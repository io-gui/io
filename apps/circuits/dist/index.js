import{IoElement,Register,ReactiveProperty,canvas,div,Storage}from"@io-gui/core";import{ioSplit,Split}from"@io-gui/layout";import{MenuOption,ioMenuTree}from"@io-gui/menus";import{ioButton}from"@io-gui/inputs";var __getOwnPropDesc$2=Object.getOwnPropertyDescriptor;let CircuitsLevels=class extends IoElement{static get Style(){return"\n      :host > .app-title {\n        margin-left: 1rem;\n        font-size: 2rem;\n        font-weight: bold;\n        letter-spacing: 2px;\n        text-transform: uppercase;\n      }\n    "}_option=new MenuOption({id:"levels",options:[]});async ready(){await this._loadLevels(),this.changed()}async _loadLevels(){const response=await fetch("./public/levels/index.json"),levelIds=await response.json();this._option=new MenuOption({id:"levels",options:levelIds.map(id=>({id:id,action:()=>this.dispatch("level-select",{level:id},!0)}))})}changed(){this.render([ioMenuTree({option:this._option})])}};CircuitsLevels=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$2(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],CircuitsLevels);const circuitsLevels=CircuitsLevels.vConstructor;class Pad{ID;pos;constructor(ID,pos){this.ID=ID,this.pos=pos}toJSON(){return{pos:this.pos,ID:this.ID}}static fromJSON(data){return new Pad(data.ID,data.pos)}}class Terminal{ID;pos;color;constructor(ID,pos,color){this.ID=ID,this.pos=pos,this.color=color}toJSON(){return{pos:this.pos,color:this.color,ID:this.ID}}static fromJSON(data){return new Terminal(data.ID,data.pos,data.color)}}class Line{ID;pos;color;readonly;constructor(ID,pos,color){this.ID=ID,this.pos=[pos],this.color=color,this.readonly=!1}addSegment(x,y){return!!this._checkErase(x,y)&&(!!this._checkDirection(x,y)&&(this.pos.push([x,y]),!0))}removeLast(){this.pos.pop()}toJSON(){return{ID:this.ID,pos:this.pos,color:this.color}}static fromJSON(data){const line=new Line(data.ID,data.pos[0],data.color);for(let j=1;j<data.pos.length;j++)line.addSegment(data.pos[j][0],data.pos[j][1]);return data.readonly&&(line.readonly=!0),line}_checkDirection(x,y){const ln=this.pos.length;if(ln>1){if(y===this.pos[ln-2][1]&&1===Math.abs(x-this.pos[ln-2][0]))return!1;if(x===this.pos[ln-2][0]&&1===Math.abs(y-this.pos[ln-2][1]))return!1}const last=this.pos[ln-1];return!(Math.abs(last[0]-x)>1)&&!(Math.abs(last[1]-y)>1)}_checkErase(x,y){const ln=this.pos.length;return ln<2||(x!==this.pos[ln-2][0]||y!==this.pos[ln-2][1]||(this.removeLast(),!1))}}class Game{width=4;height=5;pads={};terminals={};lines={};padColors={};terminalColors={};lineColors={};drawMode="line";drawColor="white";undoStack=[];redoStack=[];currentLevel="";onSave=null;onComplete=null;onInitScene=null;onRender=null;init(){this.width=4,this.height=5,this.pads={},this.terminals={},this.lines={},this.drawMode="line",this.drawColor="white",this._renderScene()}load(level,savedState){this.init(),this.redoStack=[],this.undoStack=[],this.currentLevel=level,savedState?(this.fromJSON(savedState),this.save(),this.updateUndoStack(),this.propagateColors()):this.reset(level)}clear(){this.init()}async reset(level){try{const resp=await fetch("./public/levels/"+level+".json");if(!resp.ok)throw new Error("Level not found");const text=await resp.text();this.fromJSON(text);for(const i in this.lines)this.lines[i].readonly=!0;this.save(),this.updateUndoStack(),this.propagateColors()}catch(e){console.warn("Could not load level:",level,e)}}fromJSON(jsonText){const state=JSON.parse(jsonText);this.width=state.width,this.height=state.height,this.pads={},this.terminals={};const legacyPads=state.pads;for(const p of legacyPads)"color"in p&&void 0!==p.color?"white"===p.color?this.pads[p.ID]=new Pad(p.ID,p.pos):this.terminals[p.ID]=new Terminal(p.ID,p.pos,p.color):this.pads[p.ID]=Pad.fromJSON(p);if(state.terminals)for(const t of state.terminals)this.terminals[t.ID]=Terminal.fromJSON(t);this.lines={};for(const l of state.lines)this.lines[l.ID]=Line.fromJSON(l);this.initScene()}toJSON(){return JSON.stringify({width:this.width,height:this.height,pads:this._cleanPads(),terminals:this._cleanTerminals(),lines:this._cleanLines()})}_cleanPads(){return Object.values(this.pads).map(p=>p.toJSON())}_cleanTerminals(){return Object.values(this.terminals).map(t=>t.toJSON())}_cleanLines(){return Object.values(this.lines).map(l=>l.toJSON())}save(){this.currentLevel&&this.onSave&&this.onSave(this.currentLevel,this.toJSON())}updateUndoStack(){const state=this.toJSON();state!==this.undoStack[this.undoStack.length-1]&&this.undoStack.push(state)}undo(){this.undoStack.length>1&&(this.fromJSON(this.undoStack[this.undoStack.length-2]),this.redoStack.push(this.undoStack.pop()),this.save(),this.propagateColors(),this.checkCompletion())}redo(){if(this.redoStack.length>0){const state=this.redoStack.pop();this.fromJSON(state),this.undoStack.push(state),this.save(),this.propagateColors(),this.checkCompletion()}}getPointAt(x,y){for(const i in this.pads)if(this.pads[i].pos[0]===x&&this.pads[i].pos[1]===y)return{id:this.pads[i].ID,color:this.padColors[this.pads[i].ID]??"white",isTerminal:!1};for(const i in this.terminals)if(this.terminals[i].pos[0]===x&&this.terminals[i].pos[1]===y)return{id:this.terminals[i].ID,color:this.terminalColors[this.terminals[i].ID]??this.terminals[i].color,isTerminal:!0};return!1}addPad(ID,x,y){this.getPointAt(x,y)||(this.pads[ID]=new Pad(ID,[x,y]),this._renderScene())}addTerminal(ID,x,y,color){this.getPointAt(x,y)||(this.terminals[ID]=new Terminal(ID,[x,y],color),this._renderScene())}deletePad(x,y){for(const i in this.pads)if(this.pads[i]&&this.pads[i].pos[0]===x&&this.pads[i].pos[1]===y)return delete this.pads[i],void this._renderScene()}deleteTerminal(x,y){for(const i in this.terminals)if(this.terminals[i]&&this.terminals[i].pos[0]===x&&this.terminals[i].pos[1]===y)return delete this.terminals[i],void this._renderScene()}addLine(ID,x,y,color){const point=this.getPointAt(x,y),pointColor=!!point&&point.color,lineCount=this.getLineCount(x,y),connectionLimit=point?point.isTerminal?1:2:0;if(point&&lineCount>=connectionLimit)return this._renderScene(),!1;if(!this.lines[ID])return pointColor?(this.lines[ID]=new Line(ID,[x,y],color),this.lineColors[ID]=pointColor,this._renderScene(),!1):(this._renderScene(),!1);if(!this._checkCrossing(this.lines[ID],x,y))return this._renderScene(),!1;const lineColor=this.lineColors[ID]??this.lines[ID].color;let endDrag=!1;return pointColor||lineCount&&"grey"!==color?("white"===pointColor||pointColor===lineColor||("white"===lineColor||"grey"===lineColor)&&pointColor)&&(this.lines[ID].addSegment(x,y),endDrag=!0):this.lines[ID].addSegment(x,y),this._renderScene(),endDrag}getLineColor(x,y){for(const i in this.lines)for(const pos of this.lines[i].pos)if(pos[0]===x&&pos[1]===y)return this.lines[i].color;return!1}getLineCount(x,y){let count=0;for(const i in this.lines)for(const pos of this.lines[i].pos)pos[0]===x&&pos[1]===y&&"white"===this.lines[i].color&&count++;return count}getUnderlineCount(x,y){let count=0;for(const i in this.lines)for(const pos of this.lines[i].pos)pos[0]===x&&pos[1]===y&&"grey"===this.lines[i].color&&count++;return count}checkLine(ID){if(this.lines[ID]){const first=this.lines[ID].pos[0],last=this.lines[ID].pos[this.lines[ID].pos.length-1],p1=this.getPointAt(first[0],first[1]),p2=this.getPointAt(last[0],last[1]);p1&&p2&&(first[0]!==last[0]||first[1]!==last[1])||this.undo(),this.redoStack=[]}}deleteLine(x,y){for(const i in this.lines)for(const pos of this.lines[i].pos)if(pos[0]===x&&pos[1]===y)return delete this.lines[i],void this._renderScene()}_checkCrossing(line,x,y){const last=line.pos[line.pos.length-1],mx=(x+last[0])/2,my=(y+last[1])/2;for(const id in this.lines){const other=this.lines[id];if("grey"===line.color||"grey"===other.color)continue;const pos=other.pos;for(let i=1;i<pos.length;i++)if(1===Math.abs(pos[i][0]-pos[i-1][0])&&1===Math.abs(pos[i][1]-pos[i-1][1])&&(pos[i][0]+pos[i-1][0])/2===mx&&(pos[i][1]+pos[i-1][1])/2===my)return!1}return!0}resetColors(){this.lineColors={};for(const i in this.lines)this.lineColors[this.lines[i].ID]=this.lines[i].color;this.padColors={};for(const i in this.pads)this.padColors[this.pads[i].ID]="white";this.terminalColors={};for(const i in this.terminals)this.terminalColors[this.terminals[i].ID]=this.terminals[i].color}propagateColors(){this.resetColors();for(let iter=0;iter<16;iter++)for(const i in this.lines){const line=this.lines[i],first=line.pos[0],last=line.pos[line.pos.length-1],p1=this.getPointAt(first[0],first[1]),p2=this.getPointAt(last[0],last[1]);if(!p1||!p2)continue;const c1=p1.isTerminal?this.terminalColors[p1.id]??this.terminals[p1.id].color:this.padColors[p1.id],c2=p2.isTerminal?this.terminalColors[p2.id]??this.terminals[p2.id].color:this.padColors[p2.id];"white"!==c1&&"white"!==c2?c1===c2&&(this.lineColors[line.ID]=c1):"white"!==c1?(this.lineColors[line.ID]=c1,p1.isTerminal||(this.padColors[p1.id]=c1),p2.isTerminal||(this.padColors[p2.id]=c1)):(this.lineColors[line.ID]=c2,p1.isTerminal||(this.padColors[p1.id]=c2),p2.isTerminal||(this.padColors[p2.id]=c2))}this._renderScene()}checkCompletion(){let completed=!0;for(const i in this.terminals){const term=this.terminals[i];1!==this.getLineCount(term.pos[0],term.pos[1])&&(completed=!1)}for(const i in this.pads){const pad=this.pads[i],nConn=this.getLineCount(pad.pos[0],pad.pos[1]),nUnder=this.getUnderlineCount(pad.pos[0],pad.pos[1]),pc=this.padColors[pad.ID]??"white";2!==nConn&&"white"!==pc&&(completed=!1),1!==nConn&&1!==nUnder&&"white"!==pc&&(completed=!1)}this.onComplete&&this.onComplete(this.currentLevel,completed)}finalizeMove(lineID){this.save(),this.updateUndoStack(),this.checkLine(lineID),this.propagateColors(),this.checkCompletion()}initScene(){this.onInitScene?.()}_renderScene(){this.onRender?.()}}const COLORS={white:"#ffffff",red:"#e52800",green:"#005923",blue:"#06afff",pink:"#ef47cc",yellow:"#fec41a",orange:"#ff6910",purple:"#760281",brown:"#820419",grey:"#555555",black:"#222222"};var __defProp$2=Object.defineProperty,__decorateClass$3=(decorators,target,key,kind)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);return result&&__defProp$2(target,key,result),result};class CircuitsBoard extends IoElement{static get Style(){return"\n      :host {\n        flex: 1;\n        position: relative;\n        background: rgba(0, 0, 0, 0.8);\n        border: 1px solid #99f;\n        border-radius: 12px;\n        margin: 2px;\n        overflow: hidden;\n        touch-action: none;\n      }\n      :host > canvas {\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n    "}static get Listeners(){return{pointerdown:"onPointerdown"}}_touchX=0;_touchY=0;_gridX=0;_gridY=0;_gridXOld=0;_gridYOld=0;_drag=!1;_randomID=0;constructor(args={}){super(args)}ready(){this.changed()}changed(){this.render([canvas({id:"grid",style:{zIndex:"100"}}),canvas({id:"layer0",style:{zIndex:"101"}}),canvas({id:"layer1",style:{zIndex:"102"}}),canvas({id:"top",style:{zIndex:"105"}})]),this._initScene()}onResized(){this._initScene()}_initScene(){const grid=this.querySelector("#grid"),layer0=this.querySelector("#layer0"),layer1=this.querySelector("#layer1"),top=this.querySelector("#top");if(!(grid&&layer0&&layer1&&top))return;this.scene.init({grid:grid,layer0:layer0,layer1:layer1,top:top});const rect=this.getBoundingClientRect();0!==rect.width&&0!==rect.height&&this.game&&(this._wireGameCallbacks(),this.scene.initGrid(this.game.width,this.game.height,rect.width,rect.height),this.scene.render(this.game.pads,this.game.terminals,this.game.lines,this.game.padColors,this.game.terminalColors,this.game.lineColors))}gameChanged(){this._wireGameCallbacks(),this._initScene()}_wireGameCallbacks(){this.game&&(this.game.onInitScene=()=>{const rect=this.getBoundingClientRect();0!==rect.width&&0!==rect.height&&(this.scene.initGrid(this.game.width,this.game.height,rect.width,rect.height),this.scene.render(this.game.pads,this.game.terminals,this.game.lines,this.game.padColors,this.game.terminalColors,this.game.lineColors))},this.game.onRender=()=>{this.scene.render(this.game.pads,this.game.terminals,this.game.lines,this.game.padColors,this.game.terminalColors,this.game.lineColors)})}onPointerdown(event){event.preventDefault(),this.setPointerCapture(event.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),this._randomID=Math.floor(1e5*Math.random()),this._drag=!0,this._initPosition(event),this.scene.drawMarker(this._touchX,this._touchY),this.game&&("pad"===this.game.drawMode&&this.game.addPad(this._randomID,this._gridX,this._gridY),"terminal"===this.game.drawMode&&this.game.addTerminal(this._randomID,this._gridX,this._gridY,this.game.drawColor),"line"===this.game.drawMode&&this.game.addLine(this._randomID,this._gridX,this._gridY,this.game.drawColor),"delete"===this.game.drawMode&&(this.game.deletePad(this._gridX,this._gridY),this.game.deleteTerminal(this._gridX,this._gridY),this.game.deleteLine(this._gridX,this._gridY)))}onPointermove(event){if(event.preventDefault(),this._updatePosition(event),this.scene.drawMarker(this._touchX,this._touchY),this.game&&"line"===this.game.drawMode&&this._drag&&(this._gridX!==this._gridXOld||this._gridY!==this._gridYOld)){this.game.addLine(this._randomID,this._gridX,this._gridY,this.game.drawColor)&&(this._drag=!1)}}onPointerup(event){event.preventDefault(),this.releasePointerCapture(event.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this._drag=!1,this.scene.hideMarker(),this.game&&this.game.finalizeMove(this._randomID)}_initPosition(event){const rect=this.getBoundingClientRect();this._touchX=(event.clientX-rect.left-this.scene.gridOffsetX)/this.scene.gridUnit,this._touchY=(event.clientY-rect.top-this.scene.gridOffsetY)/this.scene.gridUnit,this._gridX=Math.round(this._touchX),this._gridY=Math.round(this._touchY),this._gridXOld=this._gridX,this._gridYOld=this._gridY}_updatePosition(event){const rect=this.getBoundingClientRect();this._touchX=(event.clientX-rect.left-this.scene.gridOffsetX)/this.scene.gridUnit,this._touchY=(event.clientY-rect.top-this.scene.gridOffsetY)/this.scene.gridUnit;const distance=Math.sqrt(Math.pow(this._touchX-Math.round(this._touchX),2)+Math.pow(this._touchY-Math.round(this._touchY),2));this.game&&distance<.5&&this._touchX<=this.game.width+.5&&this._touchY<=this.game.height+.5&&this._touchX>=-.5&&this._touchY>=-.5&&(this._gridXOld=this._gridX,this._gridYOld=this._gridY,this._gridX=Math.round(this._touchX),this._gridY=Math.round(this._touchY),this._gridX>this._gridXOld&&(this._gridX=this._gridXOld+1),this._gridX<this._gridXOld&&(this._gridX=this._gridXOld-1),this._gridY>this._gridYOld&&(this._gridY=this._gridYOld+1),this._gridY<this._gridYOld&&(this._gridY=this._gridYOld-1))}}__decorateClass$3([ReactiveProperty({type:Game})],CircuitsBoard.prototype,"game"),__decorateClass$3([ReactiveProperty({type:class Scene{layers={};canvasWidth=0;canvasHeight=0;gridWidth=0;gridHeight=0;gridUnit=0;gridOffsetX=0;gridOffsetY=0;markerRadius=0;init(canvases){this.layers={};for(const name in canvases){const canvas2=canvases[name],ctx=canvas2.getContext("2d");this.layers[name]={canvas:canvas2,ctx:ctx}}}initGrid(gameWidth,gameHeight,containerWidth,containerHeight){this.canvasWidth=containerWidth,this.canvasHeight=containerHeight;const dpr=window.devicePixelRatio||1;for(const name in this.layers){const{canvas:canvas2}=this.layers[name];canvas2.width=this.canvasWidth*dpr,canvas2.height=this.canvasHeight*dpr,canvas2.style.width=this.canvasWidth+"px",canvas2.style.height=this.canvasHeight+"px",this.layers[name].ctx.setTransform(dpr,0,0,dpr,0,0)}this.gridWidth=gameWidth,this.gridHeight=gameHeight,this.canvasHeight/this.gridHeight>this.canvasWidth/this.gridWidth?this.gridUnit=this.canvasWidth/(this.gridWidth+1):this.gridUnit=this.canvasHeight/(this.gridHeight+1),this.gridOffsetX=(this.canvasWidth-this.gridUnit*this.gridWidth)/2,this.gridOffsetY=(this.canvasHeight-this.gridUnit*this.gridHeight)/2;const ctx=this.layers.grid.ctx;ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight),ctx.fillStyle="rgba(255,255,255,0.2)",ctx.fillRect(this.gridOffsetX,this.gridOffsetY,this.gridWidth*this.gridUnit,this.gridHeight*this.gridUnit),ctx.strokeStyle="rgba(255,255,255,0.5)",ctx.lineWidth=1;for(let i=0;i<=gameWidth;i++){const x=i*this.gridUnit+this.gridOffsetX;ctx.beginPath(),ctx.moveTo(x,this.gridOffsetY),ctx.lineTo(x,this.gridHeight*this.gridUnit+this.gridOffsetY),ctx.stroke()}for(let j=0;j<=gameHeight;j++){const y=j*this.gridUnit+this.gridOffsetY;ctx.beginPath(),ctx.moveTo(this.gridOffsetX,y),ctx.lineTo(this.gridWidth*this.gridUnit+this.gridOffsetX,y),ctx.stroke()}this.markerRadius=.1*this.canvasWidth}render(pads,terminals,lines,padColors={},terminalColors={},lineColors={}){const ctx0=this.layers.layer0?.ctx,ctx1=this.layers.layer1?.ctx;if(ctx0&&ctx1){ctx0.clearRect(0,0,this.canvasWidth,this.canvasHeight),ctx1.clearRect(0,0,this.canvasWidth,this.canvasHeight);for(const id in lines)this._drawLineStroke(lines[id]);for(const id in pads)this._drawPadStroke(pads[id]);for(const id in terminals)this._drawTerminalStroke(terminals[id]);for(const id in lines)this._drawLineFill(lines[id],lineColors[lines[id].ID]??lines[id].color);for(const id in pads)this._drawPadFill(pads[id],padColors[pads[id].ID]??"white");for(const id in terminals)this._drawTerminalFill(terminals[id],terminalColors[terminals[id].ID]??terminals[id].color)}}_lineParams(line){const isGrey="grey"===line.color;let radius=this.gridUnit/4,strokeW=3,strokeColor="rgba(0,0,0,1)",opacity=1;return isGrey&&(radius*=1.4,strokeW*=4,strokeColor="rgba(128,128,128,0.25)",opacity=.25),{ctx:isGrey?this.layers.layer0.ctx:this.layers.layer1.ctx,radius:radius,strokeW:strokeW,strokeColor:strokeColor,opacity:opacity}}_buildLinePath(ctx,positions){ctx.beginPath();for(let i=0;i<positions.length;i++){const x=positions[i][0]*this.gridUnit+this.gridOffsetX,y=positions[i][1]*this.gridUnit+this.gridOffsetY;0===i?ctx.moveTo(x,y):ctx.lineTo(x,y)}}_drawLineStroke(line){if(line.pos.length<2)return;const p=this._lineParams(line);p.ctx.save(),p.ctx.globalAlpha=p.opacity,p.ctx.lineCap="round",p.ctx.lineJoin="round",this._buildLinePath(p.ctx,line.pos),p.ctx.strokeStyle=p.strokeColor,p.ctx.lineWidth=p.radius+2*p.strokeW,p.ctx.stroke(),p.ctx.restore()}_drawLineFill(line,color){if(line.pos.length<2)return;const p=this._lineParams(line);p.ctx.save(),p.ctx.globalAlpha=p.opacity,p.ctx.lineCap="round",p.ctx.lineJoin="round",this._buildLinePath(p.ctx,line.pos),p.ctx.strokeStyle=COLORS[color]??"#fff",p.ctx.lineWidth=p.radius,p.ctx.stroke(),p.ctx.restore()}_drawPadStroke(pad){const ctx=this.layers.layer1.ctx,xx=pad.pos[0]*this.gridUnit+this.gridOffsetX,yy=pad.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.beginPath(),ctx.arc(xx,yy,r+3,0,2*Math.PI),ctx.fillStyle="rgba(0,0,0,1)",ctx.fill()}_drawPadFill(pad,color){const ctx=this.layers.layer1.ctx,xx=pad.pos[0]*this.gridUnit+this.gridOffsetX,yy=pad.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.beginPath(),ctx.arc(xx,yy,r,0,2*Math.PI),ctx.fillStyle=COLORS[color]??"#fff",ctx.fill()}_drawTerminalStroke(terminal){const ctx=this.layers.layer1.ctx,xx=terminal.pos[0]*this.gridUnit+this.gridOffsetX,yy=terminal.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.fillStyle="rgba(0,0,0,1)",ctx.fillRect(xx-r-3,yy-r-3,2*(r+3),2*(r+3))}_drawTerminalFill(terminal,color){const ctx=this.layers.layer1.ctx,xx=terminal.pos[0]*this.gridUnit+this.gridOffsetX,yy=terminal.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.fillStyle=COLORS[color]??"#fff",ctx.fillRect(xx-r,yy-r,2*r,2*r)}drawMarker(touchX,touchY){const ctx=this.layers.top?.ctx;if(!ctx)return;ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight);const xx=touchX*this.gridUnit+this.gridOffsetX,yy=touchY*this.gridUnit+this.gridOffsetY;ctx.beginPath(),ctx.arc(xx,yy,this.markerRadius,0,2*Math.PI),ctx.fillStyle="rgba(255,255,255,0.05)",ctx.fill()}hideMarker(){const ctx=this.layers.top?.ctx;ctx&&ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight)}},init:null})],CircuitsBoard.prototype,"scene"),Register(CircuitsBoard);var __defProp$1=Object.defineProperty,__decorateClass$2=(decorators,target,key,kind)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);return result&&__defProp$1(target,key,result),result};class CircuitsGame extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n        height: 100%;\n      }\n      :host > .game-toolbar {\n        display: flex;\n        gap: 2px;\n        padding: 2px;\n        flex-shrink: 0;\n      }\n    "}saveFn=null;completeFn=null;constructor(args){super(args)}ready(){this.game.onSave=(level,json)=>{this.saveFn&&this.saveFn(level,json)},this.game.onComplete=(level,completed)=>{this.completeFn&&this.completeFn(level,completed)},this.changed()}changed(){var arg0;this.render([div({class:"game-toolbar"},[ioButton({label:"Undo",action:this.onUndo}),ioButton({label:"Edit",action:this.onEdit}),ioButton({label:"Reset",action:this.onReset}),ioButton({label:"Redo",action:this.onRedo}),ioButton({label:"Back",action:this.onBack})]),(arg0={id:"board",game:this.game},CircuitsBoard.vConstructor(arg0))])}levelChanged(){if(!this.level)return void this.game.clear();const savedState=localStorage.getItem(this.level)||void 0;this.game.load(this.level,savedState);const board=this.querySelector("circuits-board");board&&board.gameChanged()}onUndo(){this.game.undo()}onRedo(){this.game.redo()}onReset(){this.game.reset(this.level)}onEdit(){this.changed()}onBack(){this.dispatch("back-to-levels",void 0,!0)}}__decorateClass$2([ReactiveProperty({value:"",type:String})],CircuitsGame.prototype,"level"),__decorateClass$2([ReactiveProperty({type:Game,init:null})],CircuitsGame.prototype,"game"),Register(CircuitsGame);var __getOwnPropDesc$1=Object.getOwnPropertyDescriptor;const TERMINAL_COLORS=["red","green","blue","pink","yellow","orange","purple","brown","grey","black"];let CircuitsEditor=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n        background: rgba(0, 0, 0, 0.85);\n        align-items: center;\n        justify-content: center;\n        flex: 1 1 auto;\n        gap: 4px;\n        padding: 8px;\n      }\n      :host > io-button {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: center;\n        width: 100%;\n      }\n    "}ready(){this.changed()}changed(){this.render([ioButton({label:"Pad",action:()=>this._select("pad","white")}),...TERMINAL_COLORS.map(c=>ioButton({label:c,action:()=>this._select("terminal",c)})),this._modeButton("Line W","line","white"),this._modeButton("Line G","line","grey"),this._modeButton("Delete","delete","red")])}_modeButton(label,mode,color){return ioButton({label:label,action:()=>this._select(mode,color)})}_select(mode,color){this.dispatch("editor-select",{mode:mode,color:color},!0)}};CircuitsEditor=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$1(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],CircuitsEditor);const circuitsEditor=CircuitsEditor.vConstructor;var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__decorateClass=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp(target,key,result),result};Storage.permit();const $level=Storage({key:"level",storage:"hash",value:""});let CircuitsApp=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        position: fixed;\n        inset: 0;\n        background-color: var(--io_bgColor);\n        color: var(--io_color);\n        user-select: none;\n        -webkit-user-select: none;\n        -webkit-text-size-adjust: none;\n        -webkit-touch-callout: none;\n      }\n    "}static get Listeners(){return{"level-select":"onLevelSelect","editor-select":"onEditorSelect"}}ready(){var arg0;this.render([ioSplit({split:new Split({type:"split",children:[{type:"panel",flex:"0 0 110px",tabs:[{id:"levels"}]},{type:"panel",flex:"1 1 auto",tabs:[{id:"game"}]},{type:"panel",flex:"0 0 120px",tabs:[{id:"editor"}]}]}),elements:[circuitsLevels({id:"levels"}),(arg0={id:"game",level:$level,game:this.game},CircuitsGame.vConstructor(arg0)),circuitsEditor({id:"editor"})]})])}onEditorSelect(event){event.stopPropagation();const{mode:mode,color:color}=event.detail;this.game.drawMode=mode,this.game.drawColor=color,this.changed()}onLevelSelect(event){event.stopPropagation();const{level:level}=event.detail;$level.value=level}};__decorateClass([ReactiveProperty({type:Game,init:null})],CircuitsApp.prototype,"game",2),CircuitsApp=__decorateClass([Register],CircuitsApp);
//# sourceMappingURL=index.js.map
