const bothAreNaNs=function(value,oldValue){return"number"==typeof value&&isNaN(value)&&"number"==typeof oldValue&&isNaN(oldValue)};let Binding$1=class Binding{node;property;targets=/* @__PURE__ */new Set;targetProperties=/* @__PURE__ */new WeakMap;constructor(node,property){node._isNode||node._isIoElement||console.warn("Source node is not a ReactiveNode or IoElement instance!"),node._reactiveProperties.has(property)||console.warn(`Source node does not have a reactive property "${property}"!`),this.node=node,this.property=property,this.onSourceChanged=this.onSourceChanged.bind(this),this.onTargetChanged=this.onTargetChanged.bind(this),this.node.addEventListener(`${this.property}-changed`,this.onSourceChanged)}set value(value){this.node[this.property]=value}get value(){return this.node[this.property]}addTarget(target,property){const targetProps=this.getTargetProperties(target);if(target._isNode||target._isIoElement||console.warn("Target node is not a ReactiveNode or IoElement instance!"),target._reactiveProperties.has(property)||console.warn(`Target node does not have a reactive property "${property}"!`),-1!==targetProps.indexOf(property)&&console.error(`Target property "${property}" already added!`),this.targets.has(target)||this.targets.add(target),-1===targetProps.indexOf(property)){targetProps.push(property);const targetP=target._reactiveProperties.get(property);targetP.binding&&targetP.binding!==this&&(console.warn("Improper usage detected!"),console.info("Target property is already a target of another binding. Undinding previous binding!"),targetP.binding.removeTarget(target,property)),targetP.binding=this;{const srcP=this.node._reactiveProperties.get(this.property),valueMismatch=void 0!==srcP.value&&void 0!==targetP.value&&typeof srcP.value!=typeof targetP.value,typeMismatch=void 0!==srcP.type&&void 0!==targetP.type&&(type1=srcP.type,type2=targetP.type,!(type1===type2||"function"==typeof type1&&"function"==typeof type2&&(type1.prototype instanceof type2||type2.prototype instanceof type1)));(valueMismatch||typeMismatch)&&(console.warn(`Source property "${this.property}" does not match type of target property "${property}"!`),console.info(`Source "${this.property}" value: ${srcP.value} type: ${srcP.type} typeof: ${typeof srcP.value}`),console.info(`Target "${property}" value: ${targetP.value} type: ${targetP.type} typeof: ${typeof targetP.value}`))}target.addEventListener(`${property}-changed`,this.onTargetChanged),target.setProperty(property,this.value,!0)}var type1,type2}removeTarget(target,property){const targetProperties=this.getTargetProperties(target);if(property){const i=targetProperties.indexOf(property);-1===i&&console.error("Target property not found!"),targetProperties.splice(i,1);const propertyInstance=target._reactiveProperties.get(property);propertyInstance.binding!==this&&console.error("Target property has a different binding!"),propertyInstance.binding=void 0,target.removeEventListener(`${property}-changed`,this.onTargetChanged)}else{for(let i=targetProperties.length;i--;){const prop=targetProperties[i],propertyInstance=target._reactiveProperties.get(prop);propertyInstance.binding!==this&&console.error("Target property has a different binding!"),propertyInstance.binding=void 0,target.removeEventListener(`${prop}-changed`,this.onTargetChanged)}targetProperties.length=0}0===targetProperties.length&&this.targets.delete(target)}onTargetChanged(event){this.targets.has(event.target)||console.error("onTargetChanged() should never fire if target is not accounted for!");const oldValue=this.value,value=event.detail.value;if(oldValue!==value){if(bothAreNaNs(value,oldValue))return;this.node[this.property]=value}}onSourceChanged(event){event.target!==this.node&&console.error("onSourceChanged() should always originate form source node!");const value=event.detail.value;for(const target of this.targets){const targetProperties=this.getTargetProperties(target);for(let j=targetProperties.length;j--;){const propName=targetProperties[j],oldValue=target[propName];if(oldValue!==value){if(bothAreNaNs(value,oldValue))continue;target[propName]=value}}}}getTargetProperties(target){return this.targetProperties.has(target)||this.targetProperties.set(target,[]),this.targetProperties.get(target)}toJSON(){const targetProperties=[],targetNames=[];for(const target of this.targets)targetNames.push(target.constructor.name),targetProperties.push(this.getTargetProperties(target));return{node:this.node.constructor.name,property:this.property,targets:targetNames,targetProperties:targetProperties}}dispose(){this.node.removeEventListener(`${this.property}-changed`,this.onSourceChanged);for(const target of this.targets)this.removeTarget(target);this.targets.clear(),delete this.node,delete this.property,delete this.targets,delete this.targetProperties}};class ChangeQueue{dispatchedChange=!1;dispatching=!1;constructor(node){this.changes=[],this.node=node,Object.defineProperty(this,"dispatch",{value:this.dispatch.bind(this),enumerable:!1,writable:!1,configurable:!1})}queue(property,value,oldValue){value===oldValue&&console.warn("ChangeQueue: queuing change with same value and oldValue!");const i=this.changes.findIndex(change=>change.property===property);-1===i?this.changes.push({property:property,value:value,oldValue:oldValue}):value===this.changes[i].oldValue?this.changes.splice(i,1):this.changes[i].value=value}dispatch(){if(!0===this.dispatching)return void console.error("ChangeQueue: dispatching already in progress!");this.dispatching=!0;const properties=[];let i=0;for(;i<this.changes.length;){const change=this.changes[i],property=change.property;if(change.value!==change.oldValue){this.dispatchedChange=!0;const handlerName=property+"Changed";if(this.node[handlerName])try{this.node[handlerName](change)}catch(error){console.error(`Error in ${this.node.constructor.name}.${handlerName}():`,error)}this.node.dispatch(property+"-changed",change),properties.push(property)}i++}if(this.changes.length=0,this.dispatchedChange){try{this.node.changed()}catch(error){console.error(`Error in ${this.node.constructor.name}.changed():`,error)}this.node._isNode&&this.node.dispatchMutation(this.node,properties)}this.dispatchedChange=!1,this.dispatching=!1}dispose(){this.changes.length=0,delete this.node,delete this.changes}}const hardenListenerDefinition=listenerDefinition=>Array.isArray(listenerDefinition)?listenerDefinition:[listenerDefinition],LISTENER_OPTIONS=["capture","passive"],listenerFromDefinition=(node,def)=>{const handlerDef=def[0],options=def[1];if("string"!=typeof handlerDef&&"function"!=typeof handlerDef&&console.error("listenerFromDefinition: Listener must be a function or method name"),options)if("object"!=typeof options)console.error("listenerFromDefinition: Listener options must be an object");else{const invalidOptions=Object.keys(options).filter(k=>!LISTENER_OPTIONS.includes(k));invalidOptions.length>0&&console.error(`listenerFromDefinition: Invalid listener options: ${invalidOptions.join(", ")}`)}"string"!=typeof handlerDef||handlerDef in node||console.error(`listenerFromDefinition: Method "${handlerDef}" not found on node`);const handler="string"==typeof handlerDef?node[handlerDef]:handlerDef;return options?[handler,options]:[handler]};let EventDispatcher$1=class EventDispatcher{node;nodeIsEventTarget;protoListeners={};propListeners={};addedListeners={};constructor(node){this.node=node,this.nodeIsEventTarget=node instanceof EventTarget,this.setProtoListeners(node)}setProtoListeners(node){for(const name in node._protochain?.listeners){for(let i=0;i<node._protochain.listeners[name].length;i++){const listener=listenerFromDefinition(node,node._protochain.listeners[name][i]);this.protoListeners[name]=[listener]}if(this.nodeIsEventTarget&&this.protoListeners[name]){const listener=this.protoListeners[name][0];EventTarget.prototype.addEventListener.call(this.node,name,listener[0],listener[1])}}}applyPropListeners(properties){const newPropListeners={};for(const prop in properties){if(!prop.startsWith("@"))continue;const name=prop.slice(1),definition=hardenListenerDefinition(properties[prop]),listener=listenerFromDefinition(this.node,definition);newPropListeners[name]=[listener]}const propListeners=this.propListeners;for(const name in propListeners)if(!newPropListeners[name]){if(this.nodeIsEventTarget){const listener=propListeners[name][0];EventTarget.prototype.removeEventListener.call(this.node,name,listener[0],listener[1])}delete propListeners[name]}for(const name in newPropListeners){if(this.nodeIsEventTarget){const newListener=newPropListeners[name][0];if(propListeners[name]){const oldListener=propListeners[name][0];(oldListener!==newListener||newListener[1]&&JSON.stringify(oldListener[1])!==JSON.stringify(newListener[1]))&&EventTarget.prototype.removeEventListener.call(this.node,name,oldListener[0],oldListener[1])}EventTarget.prototype.addEventListener.call(this.node,name,newListener[0],newListener[1])}propListeners[name]=newPropListeners[name]}}addEventListener(name,listener,options){if("function"!=typeof listener&&console.error("EventDispatcher.addEventListener: Invalid listener type - must be a function"),options)if("object"!=typeof options)console.error("EventDispatcher.addEventListener: Invalid listener options type - must be an object");else{const invalidOptions=Object.keys(options).filter(k=>!LISTENER_OPTIONS.includes(k));invalidOptions.length>0&&console.warn(`EventDispatcher.addEventListener: Invalid listener options: ${invalidOptions.join(", ")}`)}this.addedListeners[name]||(this.addedListeners[name]=[]);if(-1!==this.addedListeners[name].findIndex(l=>l[0]===listener))return void console.warn(`EventDispatcher.addEventListener: Listener for '${name}' event already added`,this.node);const listenerTuple=options?[listener,options]:[listener];this.addedListeners[name].push(listenerTuple),this.nodeIsEventTarget&&EventTarget.prototype.addEventListener.call(this.node,name,listener,options)}removeEventListener(name,listener,options){if(listener&&"function"!=typeof listener&&console.error("EventDispatcher.removeEventListener: Invalid listener type!"),options)if("object"!=typeof options)console.error("EventDispatcher.removeEventListener: Invalid listener options type - must be an object");else{const invalidOptions=Object.keys(options).filter(k=>!LISTENER_OPTIONS.includes(k));invalidOptions.length>0&&console.warn(`EventDispatcher.removeEventListener: Invalid listener options: ${invalidOptions.join(", ")}`)}if(this.addedListeners[name]||console.error(`EventDispatcher.removeEventListener: Listener ${name} not found!`),this.addedListeners[name]){if(listener){const index=this.addedListeners[name].findIndex(item=>item[0]===listener);-1===index&&console.error(`EventDispatcher.removeEventListener: Listener ${name} not found!`),-1!==index&&(this.addedListeners[name].splice(index,1),this.nodeIsEventTarget&&EventTarget.prototype.removeEventListener.call(this.node,name,listener,options))}else{for(let i=0;i<this.addedListeners[name].length;i++)if(this.nodeIsEventTarget){const listener2=this.addedListeners[name][i];EventTarget.prototype.removeEventListener.call(this.node,name,listener2[0],listener2[1])}this.addedListeners[name].length=0}0===this.addedListeners[name].length&&delete this.addedListeners[name]}}dispatchEvent(name,detail,bubbles=!0,node=this.node,path=[]){if(!this.node._disposed)if(path=[...path,node],node instanceof EventTarget)EventTarget.prototype.dispatchEvent.call(node,new CustomEvent(name,{detail:detail,bubbles:bubbles,composed:!0,cancelable:!0}));else{const payload={detail:detail,target:node,path:path};if(this.protoListeners[name])for(let i=0;i<this.protoListeners[name].length;i++){this.protoListeners[name][i][0].call(node,payload)}if(this.propListeners[name]){this.propListeners[name].length>1&&console.error(`EventDispatcher.dispathEvent: PropListeners[${name}] array too long!`);this.propListeners[name][0][0].call(node,payload)}if(this.addedListeners[name])for(let i=0;i<this.addedListeners[name].length;i++){this.addedListeners[name][i][0].call(node,payload)}if(bubbles)for(const parent of node._parents)!parent._isNode&&!parent._isIoElement||parent._disposed||parent._eventDispatcher.dispatchEvent(name,detail,bubbles,parent,path)}}dispose(){for(const name in this.protoListeners){if(this.nodeIsEventTarget)for(let i=0;i<this.protoListeners[name].length;i++){const listener=this.protoListeners[name][i];EventTarget.prototype.removeEventListener.call(this.node,name,listener[0],listener[1])}this.protoListeners[name].length=0,delete this.protoListeners[name]}for(const name in this.propListeners){if(this.nodeIsEventTarget){const listener=this.propListeners[name][0];EventTarget.prototype.removeEventListener.call(this.node,name,listener[0],listener[1])}this.propListeners[name].length=0,delete this.propListeners[name]}for(const name in this.addedListeners){if(this.nodeIsEventTarget)for(let i=this.addedListeners[name].length;i--;){const listener=this.addedListeners[name][i];EventTarget.prototype.removeEventListener.call(this.node,name,listener[0],listener[1])}this.addedListeners[name].length=0,delete this.addedListeners[name]}delete this.node,delete this.protoListeners,delete this.propListeners,delete this.addedListeners}};class NodeArray extends Array{constructor(node,...args){super(...args),this.node=node,this.itemMutated=this.itemMutated.bind(this),this.dispatchMutation=this.dispatchMutation.bind(this),this._observers.add(node),node._isNode||node._isIoElement||console.error("NodeArray constructor called with non-node!");const self=this,proxy=new Proxy(this,{get(target,property){if("symbol"==typeof property)return target[property];const index=Number(property);return!isNaN(index)&&index>=0?target[index]:target[property]},set(target,property,value){if("length"===property){if(!self._isInternalOperation){const oldLength=target.length,newLength=Number(value);if(newLength<oldLength)for(let i=newLength;i<oldLength;i++){const item=target[i];item._isNode&&(item.removeEventListener("io-object-mutation",self.itemMutated),item.removeParent(self.node))}else if(newLength>oldLength)return console.warn("NodeArray: cannot extend array with empty slots"),!0}return target[property]=value,self._isInternalOperation||self.dispatchMutation(),!0}const index=Number(property);if(!isNaN(index)&&index>=0){const oldValue=target[index];return void 0!==oldValue&&oldValue._isNode&&!self._isInternalOperation&&(oldValue.removeEventListener("io-object-mutation",self.itemMutated),oldValue.removeParent(self.node)),target[property]=value,value._isNode&&!self._isInternalOperation&&(value.addEventListener("io-object-mutation",self.itemMutated),value.addParent(self.node)),self._isInternalOperation||self.dispatchMutation(),!0}return target[property]=value,!0}});return Object.defineProperty(this,"proxy",{value:proxy,enumerable:!1,configurable:!1}),proxy}_isInternalOperation=!1;_observers=/* @__PURE__ */new Set;static get[Symbol.species](){return Array}withInternalOperation(operation){this._isInternalOperation=!0;try{return operation()}finally{this._isInternalOperation=!1}}splice(start,deleteCount,...items){return this.withInternalOperation(()=>{for(let i=start;i<start+deleteCount;i++){const item=this[i];item._isNode&&(item.removeEventListener("io-object-mutation",this.itemMutated),item.removeParent(this.node))}const result=super.splice(start,deleteCount,...items);for(let i=start;i<start+items.length;i++){const item=this[i];item._isNode&&(item.addEventListener("io-object-mutation",this.itemMutated),item.addParent(this.node))}return(deleteCount||items.length)&&this.dispatchMutation(),result})}push(...items){return this.withInternalOperation(()=>{const result=super.push(...items);for(const item of items)item._isNode&&(item.addEventListener("io-object-mutation",this.itemMutated),item.addParent(this.node));return items.length&&this.dispatchMutation(),result})}unshift(...items){return this.withInternalOperation(()=>{const result=super.unshift(...items);for(const item of items)item._isNode&&(item.addEventListener("io-object-mutation",this.itemMutated),item.addParent(this.node));return items.length&&this.dispatchMutation(),result})}pop(){return this.withInternalOperation(()=>{const item=super.pop();return void 0!==item&&item._isNode&&(item.removeEventListener("io-object-mutation",this.itemMutated),item.removeParent(this.node)),void 0!==item&&this.dispatchMutation(),item})}shift(){return this.withInternalOperation(()=>{const item=super.shift();return void 0!==item&&item._isNode&&(item.removeEventListener("io-object-mutation",this.itemMutated),item.removeParent(this.node)),void 0!==item&&this.dispatchMutation(),item})}reverse(){return this.withInternalOperation(()=>{const result=super.reverse();return result.length&&this.dispatchMutation(),result})}sort(compareFn){return this.withInternalOperation(()=>{const result=super.sort(compareFn);return result.length&&this.dispatchMutation(),result})}fill(value,start,end){return this.withInternalOperation(()=>{const len=this.length,relativeStart=start??0,relativeEnd=end??len,actualStart=relativeStart<0?Math.max(len+relativeStart,0):Math.min(relativeStart,len),actualEnd=relativeEnd<0?Math.max(len+relativeEnd,0):Math.min(relativeEnd,len);for(let i=actualStart;i<actualEnd;i++){const oldItem=this[i];void 0!==oldItem&&oldItem._isNode&&(oldItem.removeEventListener("io-object-mutation",this.itemMutated),oldItem.removeParent(this.node))}super.fill(value,actualStart,actualEnd);for(let i=actualStart;i<actualEnd;i++)value._isNode&&(value.addEventListener("io-object-mutation",this.itemMutated),value.addParent(this.node));return actualEnd>actualStart&&this.dispatchMutation(),this})}copyWithin(target,start,end){return this.withInternalOperation(()=>{const len=this.length,relativeTarget=target,relativeStart=start??0,relativeEnd=end??len,actualTarget=relativeTarget<0?Math.max(len+relativeTarget,0):Math.min(relativeTarget,len),actualStart=relativeStart<0?Math.max(len+relativeStart,0):Math.min(relativeStart,len),actualEnd=relativeEnd<0?Math.max(len+relativeEnd,0):Math.min(relativeEnd,len),count=Math.min(actualEnd-actualStart,len-actualTarget);if(count<=0)return this;for(let i=actualTarget;i<actualTarget+count;i++){const oldItem=this[i];void 0!==oldItem&&oldItem._isNode&&(oldItem.removeEventListener("io-object-mutation",this.itemMutated),oldItem.removeParent(this.node))}super.copyWithin(actualTarget,actualStart,actualEnd);for(let i=actualTarget;i<actualTarget+count;i++){const item=this[i];item._isNode&&(item.addEventListener("io-object-mutation",this.itemMutated),item.addParent(this.node))}return this.dispatchMutation(),this})}addObserver(node){this._observers.add(node)}removeObserver(node){this._observers.delete(node)}itemMutated(event){for(const observer of this._observers)observer.dispatch("io-object-mutation",{object:this.proxy,property:event.detail.index})}dispatchMutation(){for(const observer of this._observers)observer.dispatch("io-object-mutation",{object:this.proxy})}}class ReactiveProtoProperty{constructor(def){if(null==def)this.value=def;else if("function"==typeof def)this.type=def;else if(def instanceof Binding$1)this.value=def.value,this.binding=def;else if(def&&def.constructor===Object){const d=def;Object.hasOwn(d,"value")&&(this.value=d.value),Object.hasOwn(d,"type")&&(this.type=d.type),d.binding instanceof Binding$1&&(this.binding=d.binding,this.value=this.binding.value),Object.hasOwn(d,"reflect")&&(this.reflect=d.reflect),Object.hasOwn(d,"init")&&(this.init=d.init)}else def&&def.constructor===Object||(this.value=def)}assign(protoProp){Object.hasOwn(protoProp,"value")&&(this.value=protoProp.value),Object.hasOwn(protoProp,"type")&&(this.type=protoProp.type),Object.hasOwn(protoProp,"reflect")&&(this.reflect=protoProp.reflect),Object.hasOwn(protoProp,"init")&&(this.init=protoProp.init),Object.hasOwn(protoProp,"binding")&&(this.binding=protoProp.binding)}toJSON(){const json={value:this.value,type:this.type,reflect:this.reflect,init:this.init,binding:this.binding};return json.value&&"object"==typeof json.value&&(json.value=json.value.constructor.name),json.type&&"function"==typeof json.type&&(json.type=json.type.name),json}}function decodeInitArgument(item,node){if("this"===item)return node;if("string"!=typeof item||!item.startsWith("this."))return item;{const keys=item.split(".");let target=node;for(let i=1;i<keys.length;i++)target=target[keys[i]];if(target)return target;console.error(`ReactivePropertyInstance: Invalid path ${item}`)}}function isIoValue(value){return"object"==typeof value&&null!==value&&(value._isNode||value._isIoElement)}class Observer{type="none";observing=!1;constructor(node){Object.defineProperty(this,"node",{enumerable:!1,configurable:!1,writable:!1,value:node}),Object.defineProperty(this,"_hasSelfMutationListener",{enumerable:!1,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"_hasWindowMutationListener",{enumerable:!1,configurable:!0,writable:!0,value:!1})}start(value){this.observing||value&&"object"==typeof value&&(isIoValue(value)?(this.type="io",this.observing=!0,value.addEventListener("io-object-mutation",this.node.onPropertyMutated)):value instanceof NodeArray?(this.type="nodearray",this.observing=!0,value.addObserver(this.node),this._hasSelfMutationListener||(this._hasSelfMutationListener=!0,this.node.addEventListener("io-object-mutation",this.node.onPropertyMutated))):(this.type="object",this.observing=!0,this._hasWindowMutationListener||(this._hasWindowMutationListener=!0,window.addEventListener("io-object-mutation",this.node.onPropertyMutated))))}stop(value){isIoValue(value)&&!value._disposed?value.removeEventListener("io-object-mutation",this.node.onPropertyMutated):value instanceof NodeArray&&value.removeObserver(this.node),this.observing=!1}dispose(){this._hasSelfMutationListener&&(this.node.removeEventListener("io-object-mutation",this.node.onPropertyMutated),this._hasSelfMutationListener=!1),this._hasWindowMutationListener&&(window.removeEventListener("io-object-mutation",this.node.onPropertyMutated),this._hasWindowMutationListener=!1)}}class ReactivePropertyInstance{value;type;binding;reflect=!1;init=void 0;observer;constructor(node,propDef){if(Object.keys(propDef).forEach(key=>{-1===["value","type","reflect","init","binding"].indexOf(key)&&console.warn(`ReactiveProtoProperty: Invalid field ${key}`)}),void 0!==propDef.type&&"function"!=typeof propDef.type&&console.warn('Incorrect type for "type" field'),propDef.type===NodeArray&&"this"!==propDef.init&&console.warn('NodeArray property should be initialized with "this"'),void 0!==propDef.binding&&propDef.binding.constructor!==Binding$1&&console.warn('Incorrect type for "binding" field'),void 0!==propDef.reflect&&"boolean"!=typeof propDef.reflect&&console.error(`Invalid reflect field ${propDef.reflect}!`),this.value=propDef.value,this.type=propDef.type,this.binding=propDef.binding,"boolean"==typeof propDef.reflect&&(this.reflect=propDef.reflect),void 0!==propDef.init&&(this.init=propDef.init),this.binding instanceof Binding$1)this.value=this.binding.value;else if(void 0===this.value)if(this.type===Boolean)this.value=!1;else if(this.type===String)this.value="";else if(this.type===Number)this.value=0;else if("function"==typeof this.type&&void 0!==this.init)if(this.init instanceof Array){const args=this.init.map(item=>decodeInitArgument(item,node));this.value=new this.type(...args)}else if(this.init instanceof Object){const args={};Object.keys(this.init).forEach(key=>{args[key]=decodeInitArgument(this.init[key],node)}),this.value=new this.type(args)}else if(null===this.init)this.value=new this.type;else{const argument=decodeInitArgument(this.init,node);this.value=new this.type(argument)}this.observer=new Observer(node),this.observer.start(this.value),void 0!==this.value&&void 0!==this.init&&(-1!==[String,Number,Boolean].indexOf(this.type)?(this.type===Boolean&&"boolean"!=typeof this.value||this.type===Number&&"number"!=typeof this.value||this.type===String&&"string"!=typeof this.value)&&console.warn(`Property: Uninitialized value for type "${this.type.name}"!`):"function"!=typeof this.type||this.value instanceof this.type||console.warn(`Property: Incorrect value "${this.value}" for type "${this.type.name}"!`))}}const propertyDecorators=/* @__PURE__ */new WeakMap,reactivePropertyDecorators=/* @__PURE__ */new WeakMap;function Property(initialValue=void 0){return(target,propertyName)=>{const constructor=target.constructor,properties=propertyDecorators.get(constructor)||{};propertyDecorators.set(constructor,properties),properties[propertyName]=initialValue}}function ReactiveProperty(defLoose={}){return(target,propertyName)=>{const constructor=target.constructor,properties=reactivePropertyDecorators.get(constructor)||{};reactivePropertyDecorators.set(constructor,properties),properties[propertyName]=defLoose}}const styleDecorators=/* @__PURE__ */new WeakMap;class ProtoChain{constructors=[];properties={};reactiveProperties={};listeners={};style="";handlers=[];constructor(ioNodeConstructor){let proto=ioNodeConstructor.prototype;for(;proto&&ioNodeConstructor!==HTMLElement&&ioNodeConstructor!==Object;)this.constructors.push(ioNodeConstructor),proto=Object.getPrototypeOf(proto),ioNodeConstructor=proto.constructor;let reactivePropertyHash="",propertyHash="";for(let i=this.constructors.length;i--;)ioNodeConstructor=this.constructors[i],this.addPropertiesFromDecorators(ioNodeConstructor),propertyHash=this.addProperties(ioNodeConstructor.Properties,propertyHash),this.addReactivePropertiesFromDecorators(ioNodeConstructor),reactivePropertyHash=this.addReactiveProperties(ioNodeConstructor.ReactiveProperties,reactivePropertyHash),this.addListeners(ioNodeConstructor.Listeners),this.addStyle(ioNodeConstructor.Style),this.addStyleFromDecorators(ioNodeConstructor),this.addHandlers(ioNodeConstructor.prototype);this.validateReactiveProperties(),Object.freeze(this.constructors),Object.freeze(this.properties),Object.freeze(this.reactiveProperties),Object.freeze(this.listeners),Object.freeze(this.handlers)}init(node){if(this.constructors[0]!==node.constructor)throw new Error(`${node.constructor.name} not registered! Use @Register decorator before using ${node.constructor.name} class.`);for(let i=this.handlers.length;i--;)Object.defineProperty(node,this.handlers[i],{value:node[this.handlers[i]].bind(node),writable:!0,configurable:!0})}addPropertiesFromDecorators(ioNodeConstructor){const props=propertyDecorators.get(ioNodeConstructor);if(props)for(const name in props)this.properties[name]=props[name]}addProperties(properties={},prevHash=""){const newHash=JSON.stringify(properties);if(newHash!==prevHash){for(const name in properties)this.properties[name]=properties[name];prevHash=newHash}return prevHash}addReactivePropertiesFromDecorators(ioNodeConstructor){const props=reactivePropertyDecorators.get(ioNodeConstructor);if(props)for(const name in props){const protoProperty=new ReactiveProtoProperty(props[name]);this.reactiveProperties[name]||(this.reactiveProperties[name]=protoProperty),this.reactiveProperties[name].assign(protoProperty)}}addReactiveProperties(properties={},prevHash=""){const reativeProtoProperties={};for(const name in properties)reativeProtoProperties[name]=new ReactiveProtoProperty(properties[name]);const newHash=JSON.stringify(reativeProtoProperties);if(newHash!==prevHash){for(const name in properties)this.reactiveProperties[name]?this.reactiveProperties[name].assign(reativeProtoProperties[name]):this.reactiveProperties[name]=reativeProtoProperties[name];prevHash=newHash}return prevHash}addListeners(listenerDefs){for(const name in listenerDefs)if(listenerDefs[name]){const lsnDef=hardenListenerDefinition(listenerDefs[name]),listeners=this.listeners[name]=this.listeners[name]||[],i=listeners.findIndex(def=>def[0]===lsnDef[0]);-1!==i?listeners[i][1]?listeners[i][1]=Object.assign(listeners[i][1],lsnDef[1]):lsnDef[1]&&(listeners[i][1]=lsnDef[1]):listeners.push(lsnDef)}}addStyle(style){style&&-1===this.style.indexOf(style)&&(this.style=this.style?this.style+"\n"+style:style)}addStyleFromDecorators(ioNodeConstructor){const style=styleDecorators.get(ioNodeConstructor);style&&(this.style=this.style?this.style+"\n"+style:style)}addHandlers(proto){const names=Object.getOwnPropertyNames(proto);for(let j=0;j<names.length;j++){const fn=names[j];if(/^on[A-Z]/.test(fn)||/^_on[A-Z]/.test(fn)||fn.endsWith("Changed")||fn.endsWith("Mutated")||fn.endsWith("Debounced")||fn.endsWith("Throttled")||"changed"===fn){const propDesr=Object.getOwnPropertyDescriptor(proto,fn);if(void 0===propDesr||propDesr.get||propDesr.set)continue;"function"==typeof proto[fn]&&-1===this.handlers.indexOf(fn)&&this.handlers.push(fn)}}}validateReactiveProperties(){for(const name in this.reactiveProperties){const prop=this.reactiveProperties[name];if(-1!==[String,Number,Boolean].indexOf(prop.type))(prop.type===Boolean&&void 0!==prop.value&&"boolean"!=typeof prop.value||prop.type===Number&&void 0!==prop.value&&"number"!=typeof prop.value||prop.type===String&&void 0!==prop.value&&"string"!=typeof prop.value)&&console.warn(`Reactive property "${name}" value "${prop.value}" type for ${prop.type.name} property!`);else{const isNull=null===prop.value,isUndefined=void 0===prop.value;"function"!=typeof prop.type||prop.value instanceof prop.type||isNull||isUndefined||console.warn(`Reactive property "${name}" value "${prop.value}" type for ${prop.type.name} property!`)}}}}let currentFrame=0;const queue0=/* @__PURE__ */new Map,queue1=/* @__PURE__ */new Map;let queue=queue0;const keysByNode=/* @__PURE__ */new WeakMap,keysByFunc=/* @__PURE__ */new Map,throttleNextFrame=/* @__PURE__ */new WeakMap,throttleNextFrameGlobal=/* @__PURE__ */new Map;function getKey(func,node){if(node){let funcMap=keysByNode.get(node);funcMap||(funcMap=/* @__PURE__ */new Map,keysByNode.set(node,funcMap));let key=funcMap.get(func);return key||(key={node:node,func:func},funcMap.set(func,key)),key}{let key=keysByFunc.get(func);return key||(key={node:void 0,func:func},keysByFunc.set(func,key)),key}}function throttle(func,arg,node,delay=1){if(node?._disposed)return;const key=getKey(func,node);let nextAllowed;if(nextAllowed=node?throttleNextFrame.get(node)?.get(func)??-Infinity:throttleNextFrameGlobal.get(func)??-Infinity,currentFrame>=nextAllowed){if(node){let funcMap=throttleNextFrame.get(node);funcMap||(funcMap=/* @__PURE__ */new Map,throttleNextFrame.set(node,funcMap)),funcMap.set(func,currentFrame+delay)}else throttleNextFrameGlobal.set(func,currentFrame+delay);try{void 0!==arg?func(arg):func()}catch(e){console.error(e)}queue.set(key,{arg:arg,frame:currentFrame+delay})}else{const existing=queue.get(key);existing&&(existing.arg=arg)}}function debounce(func,arg,node,delay=1){const key=getKey(func,node);queue.set(key,{arg:arg,frame:currentFrame+delay})}requestAnimationFrame(function executeQueue(){currentFrame++;const activeQueue=queue;queue=queue===queue0?queue1:queue0;for(const[key,options]of activeQueue)if(options.frame>currentFrame)queue.has(key)||queue.set(key,options);else if(!key.node?._disposed)try{void 0!==options.arg?key.func(options.arg):key.func()}catch(e){console.error(e)}activeQueue.clear(),requestAnimationFrame(executeQueue)});const defaultPropsMap=/* @__PURE__ */new WeakMap,applyNativeElementProps=function(element,props){const defaultPropValues=defaultPropsMap.get(element)||{};defaultPropsMap.set(element,defaultPropValues);for(const _p in props){const p=_p,prop=props[p];if(prop instanceof Binding$1&&console.warn(`VDOM: Cannot set binding on "${element.localName}.${_p}"`),Object.hasOwn(defaultPropValues,p)||(defaultPropValues[p]=element[p]),"style"===p)for(const s in prop)element.style.setProperty(s,prop[s]);else"class"===p?element.className=prop:p.startsWith("data-")?void 0===prop?element.removeAttribute(p):element.setAttribute(p,prop):element[p]=void 0===prop?defaultPropValues[p]:prop;(void 0===prop||prop===defaultPropValues[p])&&element.removeAttribute(p)}for(const _p in defaultPropValues){const p=_p;Object.hasOwn(props,p)||(element[p]=defaultPropValues[p],element.removeAttribute(p))}element._eventDispatcher||Object.defineProperty(element,"_eventDispatcher",{enumerable:!1,configurable:!0,value:new EventDispatcher$1(element)}),element._eventDispatcher.applyPropListeners(props)},constructElement=function(vDOMElement){const props=vDOMElement.props||{},ConstructorClass=window.customElements?window.customElements.get(vDOMElement.tag):null;if(ConstructorClass&&ConstructorClass.prototype?._isIoElement)return new ConstructorClass(props);const element=document.createElement(vDOMElement.tag);return applyNativeElementProps(element,props),element},disposeChildren=function(element){requestAnimationFrame(()=>{const elements=Array.from(element.querySelectorAll("*")).concat([element]);for(let i=elements.length;i--;)"function"==typeof elements[i].dispose?elements[i].dispose():elements[i]._eventDispatcher&&(elements[i]._eventDispatcher.dispose(),delete elements[i]._eventDispatcher)})},vDOMAttributes=function(element){const attributes={};for(let i=0;i<element.attributes.length;i++){const name=element.attributes[i].name,value=element.getAttribute(name);null!==value&&(attributes[name]=value)}return attributes},toVDOMChildren=function(htmlCollection){const children=[];for(let i=0;i<htmlCollection.length;i++)children.push(toVDOM(htmlCollection[i]));return children},toVDOM=function(element){return{tag:element.localName,props:vDOMAttributes(element),children:element.children.length>0?toVDOMChildren(element.children):element.textContent}};function Register(ioNodeConstructor){ioNodeConstructor.prototype.Register(ioNodeConstructor)}const mixinRecord={},commentsRegex=new RegExp("(\\/\\*[\\s\\S]*?\\*\\/)","gi"),keyframeRegex=new RegExp("((@.*?keyframes [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi"),mediaQueryRegex=new RegExp("((@media [\\s\\S]*?){([\\s\\S]*?}\\s*?)})","gi"),mixinRegex=new RegExp("(( --[\\s\\S]*?): {([\\s\\S]*?)})","gi"),applyRegex=new RegExp("(@apply\\s.*?;)","gi"),cssRegex=new RegExp("((\\s*?(?:\\/\\*[\\s\\S]*?\\*\\/)?\\s*?@media[\\s\\S]*?){([\\s\\S]*?)}\\s*?})|(([\\s\\S]*?){([\\s\\S]*?)})","gi");var __defProp$S=Object.defineProperty,__getOwnPropDesc$Z=Object.getOwnPropertyDescriptor,__decorateClass$10=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$Z(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$S(target,key,result),result};const resizeObserver=new ResizeObserver(entries=>{for(const entry of entries)entry.target.onResized()});let IoElement=class extends HTMLElement{static get Style(){return"\n      :host {\n        display: block;\n        box-sizing: border-box;\n        -webkit-touch-callout: none;\n      }\n      :host[hidden] {\n        display: none;\n      }\n      --unselectable: {\n        user-select: none;\n        -webkit-user-select: none;\n        -webkit-touch-callout: none;\n        -webkit-tap-highlight-color: transparent;\n      }\n      --io_focus: {\n        border-color: var(--io_colorWhite) !important;\n        outline: var(--io_borderWidth) solid var(--io_borderColorBlue) !important;\n        z-index: 1;\n      }\n    "}static get ReactiveProperties(){return{}}static get Properties(){return{}}static get Listeners(){return{}}constructor(args={}){super(),this._protochain.init(this),Object.defineProperty(this,"_changeQueue",{enumerable:!1,configurable:!0,value:new ChangeQueue(this)}),Object.defineProperty(this,"_reactiveProperties",{enumerable:!1,configurable:!0,value:/* @__PURE__ */new Map}),Object.defineProperty(this,"_bindings",{enumerable:!1,configurable:!0,value:/* @__PURE__ */new Map}),Object.defineProperty(this,"_eventDispatcher",{enumerable:!1,configurable:!0,value:new EventDispatcher$1(this)}),Object.defineProperty(this,"_hasWindowMutationListener",{enumerable:!1,configurable:!0,writable:!0,value:!1}),Object.defineProperty(this,"_hasSelfMutationListener",{enumerable:!1,configurable:!0,writable:!0,value:!1}),this.init(),initReactiveProperties(this),initProperties(this),this.applyProperties(args,!0),this.ready(),this.dispatchQueue()}applyProperties(props,skipDispatch=!1){for(const name in props)if(this._reactiveProperties.has(name))this.setProperty(name,props[name],!0);else if("class"===name)this.className=props[name];else if("style"===name)for(const s in props[name])this.style[s]=props[name][s];else name.startsWith("data-")?void 0===props[name]?this.removeAttribute(name):this.setAttribute(name,props[name]):name.startsWith("@")||(props[name]instanceof Binding$1&&console.warn(`IoElement: Not a ReactiveProperty! Cannot set binding to "${name}" property on element "${this.localName}"`),this[name]=props[name],void 0===props[name]&&this.hasAttribute(name)&&this.removeAttribute(name));this._eventDispatcher.applyPropListeners(props),skipDispatch||this.dispatchQueue()}setProperties(props){setProperties(this,props)}setProperty(name,value,debounce2=!1){if(this._disposed)return;setProperty(this,name,value,debounce2);this._reactiveProperties.get(name).reflect&&this.setAttribute(name.toLowerCase(),value)}init(){}ready(){}changed(){}get[Symbol.toStringTag](){return this.constructor.name}queue(name,value,oldValue){this._changeQueue.queue(name,value,oldValue)}dispatchQueue(debounce2=!1){dispatchQueue(this,debounce2)}throttle(func,arg,timeout=1){throttle(func,arg,this,timeout)}debounce(func,arg,timeout=1){debounce(func,arg,this,timeout)}onPropertyMutated(event){return onPropertyMutated(this,event)}dispatchMutation(object=this,properties=[]){dispatchMutation(this,object,properties)}bind(name){return bind(this,name)}unbind(name){unbind(this,name)}addEventListener(type,listener,options){this._disposed||this._eventDispatcher.addEventListener(type,listener,options)}removeEventListener(type,listener,options){this._disposed||this._eventDispatcher.removeEventListener(type,listener,options)}dispatch(type,detail=void 0,bubbles=!1,src){this._disposed||this._eventDispatcher.dispatchEvent(type,detail,bubbles,src)}dispose(){dispose(this)}connectedCallback(){"function"==typeof this.onResized&&resizeObserver.observe(this)}disconnectedCallback(){"function"==typeof this.onResized&&resizeObserver.unobserve(this)}render(vDOMElements,host,noDispose){host=host||this;const vDOMElementsOnly=vDOMElements.filter(item=>null!==item);this.$={},this.traverse(vDOMElementsOnly,host,noDispose)}traverse(vChildren,host,noDispose){const children=host.children;for(;children.length>vChildren.length;){const child=children[children.length-1];host.removeChild(child),noDispose||disposeChildren(child)}for(let i=0;i<children.length;i++){const child=children[i];if(child.localName!==vChildren[i].tag||noDispose){const oldElement=child,element=constructElement(vChildren[i]);host.insertBefore(element,oldElement),host.removeChild(oldElement),noDispose||disposeChildren(oldElement)}else child.removeAttribute("className"),child.removeAttribute("style"),vChildren[i].props&&(child._isIoElement?child.applyProperties(vChildren[i].props):applyNativeElementProps(child,vChildren[i].props))}if(children.length<vChildren.length){const frag=document.createDocumentFragment();for(let i=children.length;i<vChildren.length;i++){const element=constructElement(vChildren[i]);frag.appendChild(element)}host.appendChild(frag)}for(let i=0;i<vChildren.length;i++){const vChild=vChildren[i],child=children[i];if(vChild.props?.id&&(void 0!==this.$[vChild.props.id]&&console.warn(`IoElement: Duplicate id in template. "${vChild.props.id}"`),this.$[vChild.props.id]=child),void 0!==vChild.children){if("string"==typeof vChild.children)this._flattenTextNode(child),child._textNode.nodeValue=String(vChild.children);else if(vChild.children instanceof Array&&!child._isIoElement){const vDOMElementsOnly=vChild.children.filter(item=>null!==item);this.traverse(vDOMElementsOnly,child,noDispose)}}else child._isIoElement||(child.textContent="")}}_flattenTextNode(element){if(0===element.childNodes.length&&element.appendChild(document.createTextNode("")),"#text"!==element.childNodes[0].nodeName&&(element.innerHTML="",element.appendChild(document.createTextNode(""))),element._textNode=element.childNodes[0],element.childNodes.length>1){const textContent=element.textContent;for(let i=element.childNodes.length;i--;)0!==i&&element.removeChild(element.childNodes[i]);element._textNode.nodeValue=textContent}}setAttribute(attr,value){!0===value?HTMLElement.prototype.setAttribute.call(this,attr,""):!1===value||""===value?this.removeAttribute(attr):"string"!=typeof value&&"number"!=typeof value||this.getAttribute(attr)!==String(value)&&HTMLElement.prototype.setAttribute.call(this,attr,String(value))}toVDOM(){return toVDOM(this)}Register(ioNodeConstructor){Object.defineProperty(ioNodeConstructor.prototype,"_protochain",{value:new ProtoChain(ioNodeConstructor)});const localName=ioNodeConstructor.name.replace(/([a-z])([A-Z,0-9])/g,"$1-$2").toLowerCase();Object.defineProperty(ioNodeConstructor.prototype,"localName",{value:localName}),Object.defineProperty(ioNodeConstructor.prototype,"_isIoElement",{enumerable:!1,value:!0,writable:!1}),Object.defineProperty(window,ioNodeConstructor.name,{value:ioNodeConstructor}),window.customElements.define(localName,ioNodeConstructor),function applyElementStyleToDocument(localName,style){let mixinsString="";const mixins=style.match(mixinRegex);if(mixins)for(let i=0;i<mixins.length;i++){const m=mixins[i].split(": {"),name=m[0].replace(" --","--"),value=m[1].replace(/}/g,"").trim().replace(/^ +/gm,"");mixinRecord[name]=value,mixinsString+=mixins[i].replace(" --",".").replace(": {"," {")}const apply=(style=style.replace(mixinRegex,"")).match(applyRegex);if(apply)for(let i=0;i<apply.length;i++){const name=apply[i].split("@apply ")[1].replace(";","");mixinRecord[name]?style=style.replace(apply[i],mixinRecord[name]):console.warn("IoElement: cound not find mixin:",name)}{let styleStripped=style;styleStripped=styleStripped.replace(commentsRegex,""),styleStripped=styleStripped.replace(keyframeRegex,""),styleStripped=styleStripped.replace(mediaQueryRegex,"");const match=styleStripped.match(cssRegex);match&&match.forEach(selector=>{(selector=selector.trim()).startsWith(":host")||(console.warn(localName+': CSS Selector not prefixed with ":host"! This will cause style leakage!'),console.warn(selector))})}style=mixinsString+style.replace(new RegExp(":host","g"),localName);const styleElement=document.createElement("style");styleElement.innerHTML=style,styleElement.setAttribute("id","io-style-"+localName.replace("io-","")),document.head.appendChild(styleElement)}(localName,ioNodeConstructor.prototype._protochain.style),Object.defineProperty(ioNodeConstructor,"vConstructor",{value:function(arg0,arg1){const vDOMElement={tag:localName};return void 0!==arg0&&("string"==typeof arg0||arg0 instanceof Array?vDOMElement.children=arg0:"object"==typeof arg0&&(vDOMElement.props=arg0),void 0!==arg1&&("string"==typeof arg1||arg1 instanceof Array)&&(vDOMElement.children=arg1)),vDOMElement}})}};__decorateClass$10([ReactiveProperty({type:String,value:"immediate"})],IoElement.prototype,"reactivity",2),__decorateClass$10([Property(Object)],IoElement.prototype,"$",2),IoElement=__decorateClass$10([Register],IoElement),IoElement.vConstructor;var __defProp$R=Object.defineProperty,__getOwnPropDesc$Y=Object.getOwnPropertyDescriptor,__decorateClass$$=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$Y(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$R(target,key,result),result};const NODES={active:/* @__PURE__ */new Set,disposed:/* @__PURE__ */new WeakSet};function hasValueAtOtherProperty(node,prop,value){let found=!1;return node._reactiveProperties.forEach(p=>{p!==prop&&p.value===value&&(found=!0)}),found}let ReactiveNode=class extends Object{static get ReactiveProperties(){return{}}static get Properties(){return{}}static get Listeners(){return{}}constructor(args){super(),this._protochain.init(this),Object.defineProperty(this,"_changeQueue",{enumerable:!1,configurable:!0,value:new ChangeQueue(this)}),Object.defineProperty(this,"_reactiveProperties",{enumerable:!1,configurable:!0,value:/* @__PURE__ */new Map}),Object.defineProperty(this,"_bindings",{enumerable:!1,configurable:!0,value:/* @__PURE__ */new Map}),Object.defineProperty(this,"_eventDispatcher",{enumerable:!1,configurable:!0,value:new EventDispatcher$1(this)}),Object.defineProperty(this,"_parents",{enumerable:!1,configurable:!0,value:[]}),this.init(),initReactiveProperties(this),initProperties(this),this.applyProperties("object"==typeof args?args:{},!0),NODES.active.add(this),this.ready(),this.dispatchQueue()}applyProperties(props,skipDispatch=!1){for(const name in props)this._reactiveProperties.has(name)?this.setProperty(name,props[name],!0):name.startsWith("@")||(this[name]=props[name],props[name]instanceof Binding$1&&console.warn(`IoElement: Not a ReactiveProperty! Cannot set binding to "${name}" property on "${this.constructor.name}"`));this._eventDispatcher.applyPropListeners(props),skipDispatch||this.dispatchQueue()}setProperties(props){setProperties(this,props)}setProperty(name,value,debounce2=!1){this._disposed||setProperty(this,name,value,debounce2)}init(){}ready(){}changed(){}get[Symbol.toStringTag](){return this.constructor.name}queue(name,value,oldValue){this._changeQueue.queue(name,value,oldValue)}dispatchQueue(debounce2=!1){dispatchQueue(this,debounce2)}throttle(func,arg,timeout=1){throttle(func,arg,this,timeout)}debounce(func,arg,timeout=1){debounce(func,arg,this,timeout)}onPropertyMutated(event){return onPropertyMutated(this,event)}dispatchMutation(object=this,properties=[]){dispatchMutation(this,object,properties)}bind(name){return bind(this,name)}unbind(name){unbind(this,name)}addEventListener(type,listener,options){this._eventDispatcher.addEventListener(type,listener,options)}removeEventListener(type,listener,options){this._eventDispatcher.removeEventListener(type,listener,options)}dispatch(type,detail=void 0,bubbles=!1,src){this._eventDispatcher.dispatchEvent(type,detail,bubbles,src)}addParent(parent){(parent._isNode||parent._isIoElement)&&this._parents.push(parent)}removeParent(parent){if(!this._disposed&&(parent._isNode||parent._isIoElement)){const index=this._parents.indexOf(parent);-1!==index?this._parents.splice(index,1):console.warn("ReactiveNode.removeParent(): Parent not found!",this,parent)}}dispose(){dispose(this),NODES.active.delete(this),NODES.disposed.add(this)}Register(ioNodeConstructor){Object.defineProperty(ioNodeConstructor.prototype,"_isNode",{enumerable:!1,value:!0,writable:!1}),Object.defineProperty(ioNodeConstructor.prototype,"_isIoElement",{enumerable:!1,value:!1,writable:!1}),Object.defineProperty(ioNodeConstructor.prototype,"_protochain",{value:new ProtoChain(ioNodeConstructor)})}};function initReactiveProperties(node){for(const name in node._protochain.reactiveProperties){Object.defineProperty(node,name,{get:function(){return node._reactiveProperties.get(name).value},set:function(value){node.setProperty(name,value)},configurable:!0,enumerable:!0});const property=new ReactivePropertyInstance(node,node._protochain.reactiveProperties[name]);node._reactiveProperties.set(name,property),property.binding&&property.binding.addTarget(node,name),property.observer.start(property.value),property.value?._isNode&&property.value.addParent(node),node instanceof IoElement&&property.reflect&&void 0!==property.value&&null!==property.value&&node.setAttribute(name,property.value)}}function initProperties(node){for(const name in node._protochain.properties){let initialValue=node._protochain.properties[name];"function"==typeof initialValue?initialValue=new initialValue:initialValue instanceof Array?initialValue=initialValue.slice():"object"==typeof initialValue&&(initialValue=Object.assign({},initialValue)),node[name]=initialValue}}function setProperties(node,props){for(const name in props)node._reactiveProperties.has(name)?node.setProperty(name,props[name],!0):console.warn(`Property "${name}" is not defined`,node);node.dispatchQueue()}function setProperty(node,name,value,debounce2=!1){const prop=node._reactiveProperties.get(name),oldValue=prop.value;if(value!==oldValue){const binding=value instanceof Binding$1?value:null;if(binding){const oldBinding=prop.binding;return binding!==oldBinding?(oldBinding&&oldBinding.removeTarget(node,name),void binding.addTarget(node,name)):void 0}if(prop.type===NodeArray&&value.constructor===Array){const nodeArray=prop.value;return value.some(item=>!item._isNode)&&console.error(`Node: Property "${name}" should be assigned as an Array of nodes!`,value),nodeArray.constructor!==NodeArray&&console.error(`Node: Property "${name}" should be initialized as a NodeArray!`,nodeArray),void nodeArray.withInternalOperation(()=>{nodeArray.length=0,nodeArray.push(...value),0===value.length&&nodeArray.dispatchMutation()})}hasValueAtOtherProperty(node,prop,oldValue)?prop.observer.observing=!1:(prop.observer.stop(oldValue),oldValue?._isNode&&!oldValue._disposed&&oldValue.removeParent(node)),prop.value=value,hasValueAtOtherProperty(node,prop,value)||(prop.observer.start(value),value?._isNode&&value.addParent(node)),prop.type===String?"string"!=typeof value&&console.warn(`Wrong type of property "${name}". Value: "${value}". Expected type: ${prop.type.name}`,node):prop.type===Number?"number"!=typeof value&&console.warn(`Wrong type of property "${name}". Value: "${value}". Expected type: ${prop.type.name}`,node):prop.type===Boolean?"boolean"!=typeof value&&console.warn(`Wrong type of property "${name}". Value: "${value}". Expected type: ${prop.type.name}`,node):prop.type===Array?value instanceof Array||console.warn(`Wrong type of property "${name}". Value: "${value}". Expected type: ${prop.type.name}`,node):prop.type===Object?value instanceof Array&&console.warn(`Wrong type of property "${name}". Value: "${value}". Expected type: ${prop.type.name}`,node):prop.type===NodeArray?(value instanceof NodeArray||console.error(`Wrong type of property "${name}". Value: "${value}". Expected type: ${prop.type.name}`,node),value.some(item=>!item._isNode)&&console.error(`Wrong type of property "${name}". NodeArray items should be nodes!`,value)):"function"==typeof prop.type&&(value instanceof prop.type||console.warn(`Wrong type of property "${name}". Value: "${value}". Expected type: ${prop.type.name}`,node)),oldValue!==value&&(node.queue(name,value,oldValue),node.dispatchQueue(debounce2))}}function dispatchQueue(node,debounce2=!1){"debounced"===node.reactivity||debounce2||node._changeQueue.dispatching?node.debounce(node._changeQueue.dispatch):"throttled"===node.reactivity?node.throttle(node._changeQueue.dispatch):"immediate"===node.reactivity&&node._changeQueue.dispatch(),-1===["immediate","throttled","debounced"].indexOf(node.reactivity)&&console.warn(`ReactiveNode.dispatchQueue(): Invalid reactivity property value: "${node.reactivity}".\n      Expected one of: "immediate", "throttled", "debounced".`)}function dispatchMutation(node,object,properties){!function isIoObject(value){return"object"==typeof value&&null!==value&&(value._isNode||value._isIoElement)}(object)?node.dispatch("io-object-mutation",{object:object,properties:properties},!1,window):node.dispatch("io-object-mutation",{object:object,properties:properties})}function onPropertyMutated(node,event){const object=event.detail.object;let hasMutated=!1;return node._reactiveProperties.forEach((prop,name)=>{if(prop.observer.observing&&prop.value===object){const handlerName=name+"Mutated";"function"==typeof node[handlerName]&&node[handlerName](event),hasMutated=!0}}),hasMutated}function bind(node,name){return node._reactiveProperties.has(name)||console.warn(`IoGUI Node: cannot bind to ${name} property. Does not exist!`),node._bindings.has(name)||node._bindings.set(name,new Binding$1(node,name)),node._bindings.get(name)}function unbind(node,name){const binding=node._bindings.get(name);binding&&(binding.dispose(),node._bindings.delete(name));const property=node._reactiveProperties.get(name);property?.binding?.removeTarget(node,name)}function dispose(node){if(node._disposed&&console.warn("ReactiveNode.dispose(): Already disposed!",node.constructor.name),!node._disposed){node._bindings.forEach((binding,name)=>{binding.dispose(),node._bindings.delete(name)}),delete node._bindings,node._changeQueue.dispose(),delete node._changeQueue,node._reactiveProperties.forEach((property,name)=>{property.binding?.removeTarget(node,name),property.observer.stop(property.value),property.observer.dispose()});for(const name in node._protochain.properties)delete node[name];delete node._protochain,node._eventDispatcher.dispose(),delete node._eventDispatcher,delete node._reactiveProperties,node._parents&&(node._parents.length=0,delete node._parents),Object.defineProperty(node,"_disposed",{value:!0})}}__decorateClass$$([ReactiveProperty({type:String,value:"immediate"})],ReactiveNode.prototype,"reactivity",2),ReactiveNode=__decorateClass$$([Register],ReactiveNode);var __defProp$Q=Object.defineProperty,__getOwnPropDesc$X=Object.getOwnPropertyDescriptor,__decorateClass$_=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$X(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$Q(target,key,result),result};const localStorage=new class EmulatedLocalStorage{constructor(){Object.defineProperty(this,"store",{value:/* @__PURE__ */new Map}),Object.defineProperty(this,"warned",{value:!1,writable:!0})}get permitted(){try{return"true"===self.localStorage.getItem("Storage:user-permitted")}catch(error){console.warn("Storage: Cannot access localStorage. Check browser privacy settings!"),console.warn(error)}return!1}set permitted(permitted){try{permitted?(console.info("Storage: localStorage permission granted."),this.store.set("Storage:user-permitted",String(permitted)),this.store.forEach((value,key)=>{self.localStorage.setItem(key,String(value)),this.store.delete(key)})):(console.info("Storage: localStorage permission revoked."),self.localStorage.setItem("Storage:user-permitted",String(permitted)),new Map(Object.entries(self.localStorage)).forEach((value,key)=>{this.store.set(key,value)}),self.localStorage.clear())}catch(error){console.warn("Storage: Cannot access localStorage. Check browser privacy settings!"),console.warn(error)}}setItem(key,value){const strValue="object"==typeof value?JSON.stringify(value):String(value);"Storage:user-permitted"!==key?this.permitted?self.localStorage.setItem(key,strValue):(this.store.set(key,strValue),this.warned||this.permitted||(console.warn("Storage: localStorage permission not set."),this.warned=!0)):this.permitted="true"===value}getItem(key){return this.permitted?self.localStorage.getItem(key):this.store.has(key)?this.store.get(key):null}removeItem(key){if(this.permitted)return self.localStorage.removeItem(key);this.store.delete(key)}clear(){if(this.permitted)return self.localStorage.clear();this.store.clear()}},nodes={local:/* @__PURE__ */new Map,hash:/* @__PURE__ */new Map,none:/* @__PURE__ */new Map};let hashValues={},StorageNode=class extends ReactiveNode{constructor(props){if("object"!=typeof props?console.warn("Ivalid Storage arguments!"):("string"==typeof props.key&&props.key||console.warn("Ivalid Storage key!"),props.storage&&-1===["hash","local","none"].indexOf(props.storage)&&console.warn(`Ivalid storage type! ${props.storage}`)),void 0===props.storage&&(props.storage="local"),nodes[props.storage].has(props.key))return nodes[props.storage].get(props.key);{let def,constructor;"object"==typeof props.value&&null!==props.value?(constructor=props.value.constructor,def=JSON.stringify(props.value)):def=props.value,props.default=def;let storedValue=null;switch(props.storage){case"hash":storedValue=function getValueFromHash(key){return hashValues=parseHash(self.location.hash),hashValues[key]||null}(props.key);break;case"local":storedValue=localStorage.getItem("Storage:"+props.key)}if(null!==storedValue)try{const value=JSON.parse(storedValue);props.value=constructor?new constructor(value):value}catch{props.value=storedValue}return super(props),this.binding=this.bind("value"),this.binding.dispose=()=>{this.clearStorage()},"__proto__"!==props.key&&nodes[props.storage].set(props.key,this),this}}dispose(){this.clearStorage(),super.dispose()}clearStorage(){switch(this.storage){case"hash":this.removeValueToHash();break;case"local":localStorage.removeItem("Storage:"+this.key)}const s=this.storage;nodes[s].delete(this.key)}valueMutated(){this.debounce(this.changed)}valueChanged(){this.changed()}changed(){switch(this.storage){case"hash":this.saveValueToHash();break;case"local":this.value===this.default||null===this.value||void 0===this.value?localStorage.removeItem("Storage:"+this.key):"object"!=typeof this.value?"string"==typeof this.value?localStorage.setItem("Storage:"+this.key,`"${this.value}"`):"number"==typeof this.value&&localStorage.setItem("Storage:"+this.key,this.value):localStorage.setItem("Storage:"+this.key,JSON.stringify(this.value))}}removeValueToHash(){hashValues=parseHash(self.location.hash),delete hashValues[this.key];let hashString="";for(const h in hashValues)hashString+=h+"="+hashValues[h]+"&";hashString?(hashString=hashString.slice(0,-1),self.location.hash=hashString):history.replaceState("",document.title,self.location.pathname+self.location.search)}saveValueToHash(){hashValues=parseHash(self.location.hash);const value=this.value;value===this.default||null==value?delete hashValues[this.key]:"string"==typeof value?isNaN(value)?hashValues[this.key]=String(value):hashValues[this.key]='"'+value+'"':"number"==typeof value||"boolean"==typeof value?hashValues[this.key]=String(value):console.warn("Storage: Cannot serialize value to hash!",value);let hashString="";for(const h in hashValues)hashString+=h+"="+hashValues[h]+"&";hashString?(hashString=hashString.slice(0,-1),self.location.hash=hashString):history.replaceState("",document.title,self.location.pathname+self.location.search)}};__decorateClass$_([ReactiveProperty({value:"",type:String})],StorageNode.prototype,"key",2),__decorateClass$_([ReactiveProperty()],StorageNode.prototype,"value",2),__decorateClass$_([ReactiveProperty({value:"local",type:String})],StorageNode.prototype,"storage",2),StorageNode=__decorateClass$_([Register],StorageNode);const Storage=Object.assign(props=>new StorageNode(props).binding,{permit(){localStorage.permitted=!0},unpermit(){localStorage.permitted=!1}});function parseHash(hash){return hash.substring(1).split("&").reduce(function(result,item){const parts=item.split("=");return parts[0]&&parts[1]&&(result[parts[0]]=parts[1].replace(/%22/g,'"').replace(/%20/g," ")),result},{})}function updateAllFromHash(){hashValues=parseHash(self.location.hash);for(const h in hashValues)if(nodes.hash.has(h)){const node=nodes.hash.get(h);try{node.value=JSON.parse(hashValues[h])}catch{node.value=hashValues[h]}}for(const[key,node]of nodes.hash.entries())void 0===hashValues[key]&&(node.value=node.default)}self.addEventListener("hashchange",updateAllFromHash,!1),updateAllFromHash();var __defProp$P=Object.defineProperty,__getOwnPropDesc$W=Object.getOwnPropertyDescriptor,__decorateClass$Z=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$W(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$P(target,key,result),result};const styleElement=document.createElement("style");styleElement.setAttribute("id","io-theme-variables-v0.11"),document.head.appendChild(styleElement);let Color$1=class Color{r;g;b;a;constructor(r,g,b,a){this.r=r,this.g=g,this.b=b,this.a=a}toCss(){const r=Math.floor(255*this.r),g=Math.floor(255*this.g),b=Math.floor(255*this.b);return void 0!==this.a&&1!==this.a?`rgba(${r}, ${g}, ${b}, ${this.a})`:`rgb(${r}, ${g}, ${b})`}};const LIGHT_THEME={spacing:2,spacing2:0,spacing3:0,spacing5:0,spacing8:0,lineHeight:20,fontSize:14,fieldHeight:0,borderRadius:2,borderWidth:1,borderColor:new Color$1(.2,.2,.2,1),borderColorLight:new Color$1(.3,.3,.3,1),borderColorStrong:new Color$1(.6,.6,.6,1),borderColorRed:new Color$1(1,.35,.15,1),borderColorGreen:new Color$1(.1,.7,.2,1),borderColorBlue:new Color$1(.2,.4,.95,1),bgColor:new Color$1(.85,.85,.85,1),bgColorStrong:new Color$1(.9,.9,.9,1),bgColorLight:new Color$1(.8,.8,.8,1),bgColorRed:new Color$1(1,.5,.3,1),bgColorGreen:new Color$1(.2,.9,.3,1),bgColorBlue:new Color$1(.2,.5,.9,1),bgColorInput:new Color$1(.95,.96,.95,1),color:new Color$1(.25,.25,.2,1),colorStrong:new Color$1(0,0,0,1),colorLight:new Color$1(.6,.6,.6,1),colorRed:new Color$1(1,.2,0,1),colorGreen:new Color$1(0,.6,.1,1),colorBlue:new Color$1(.2,.3,1,1),colorWhite:new Color$1(1,1,1,1),colorInput:new Color$1(0,.05,.02,1),gradientColorStart:new Color$1(.9,.9,.9,1),gradientColorEnd:new Color$1(.75,.75,.75,1),shadowColor:new Color$1(0,0,0,.2)},DARK_THEME={spacing:2,spacing2:0,spacing3:0,spacing5:0,spacing8:0,lineHeight:20,fontSize:14,fieldHeight:0,borderRadius:2,borderWidth:1,borderColor:new Color$1(.5,.5,.5,1),borderColorLight:new Color$1(.3,.3,.3,1),borderColorStrong:new Color$1(0,0,0,1),borderColorRed:new Color$1(1,.2,0,1),borderColorBlue:new Color$1(.4,.5,.9,1),borderColorGreen:new Color$1(0,.6,.1,1),bgColor:new Color$1(.2,.2,.2,1),bgColorStrong:new Color$1(.15,.15,.15,1),bgColorLight:new Color$1(.25,.25,.25,1),bgColorRed:new Color$1(.7,.2,.1,1),bgColorGreen:new Color$1(.1,.5,.2,1),bgColorBlue:new Color$1(.2,.4,.8,1),bgColorInput:new Color$1(.02,.02,.02,1),color:new Color$1(.6,.6,.6,1),colorStrong:new Color$1(.86,.86,.86,1),colorLight:new Color$1(.3,.3,.3,1),colorRed:new Color$1(1,.4,.4,1),colorGreen:new Color$1(.4,.95,.3,1),colorBlue:new Color$1(.6,.9,1,1),colorWhite:new Color$1(1,1,1,1),colorInput:new Color$1(.65,.7,.68,1),gradientColorStart:new Color$1(.45,.45,.45,1),gradientColorEnd:new Color$1(.2,.2,.2,1),shadowColor:new Color$1(0,0,0,.2)},$ThemeID=Storage({value:window.matchMedia("(prefers-color-scheme: dark)").matches?"dark":"light",storage:"local",key:"theme-v0.11"}),$Themes=Storage({value:{},storage:"local",key:"io-themes-v0.11"});let Theme=class extends ReactiveNode{static get ReactiveProperties(){const props={};for(const p in LIGHT_THEME){const prop=LIGHT_THEME[p];props[p]=prop instanceof Object?{value:prop,type:Color$1,init:null}:prop}return props}ready(){this.registerTheme("light",LIGHT_THEME),this.registerTheme("dark",DARK_THEME),this.themeIDChanged()}registerTheme(themeID,theme){this.themeDefaults[themeID]=theme,this.setProperty("themeDefaults",JSON.parse(JSON.stringify(this.themeDefaults)),!0),$Themes.value[themeID]=$Themes.value[themeID]||theme,$Themes.value=JSON.parse(JSON.stringify($Themes.value))}reset(){$Themes.value=JSON.parse(JSON.stringify(this.themeDefaults)),this.themeIDChanged()}themeIDChanged(){const values=$Themes.value[this.themeID];for(const p in values)values[p]instanceof Object&&'["r","g","b","a"]'===JSON.stringify(Object.keys(values[p]))&&(values[p]=new Color$1(values[p].r,values[p].g,values[p].b,values[p].a));this.setProperties(values)}onPropertyMutated(event){return!!super.onPropertyMutated(event)&&(this.changed(),this.dispatchMutation(),!0)}fontSizeChanged(){this.lineHeight=Math.max(this.fontSize,this.lineHeight)}lineHeightChanged(){this.fontSize=Math.min(this.lineHeight,this.fontSize)}changed(){this.fieldHeight=this.lineHeight+2*(this.spacing+this.borderWidth),this.spacing2=2*this.spacing,this.spacing3=3*this.spacing,this.spacing5=5*this.spacing,this.spacing8=8*this.spacing;const propertyVariables=Array.from(Object.keys(LIGHT_THEME)).reduce((result,prop)=>($Themes.value[this.themeID][prop]=this[prop],"object"==typeof this[prop]?`${result}--io_${prop}: ${this[prop].toCss()};\n    `:`${result}--io_${prop}: ${this[prop]}px;\n    `),"");styleElement.innerHTML=`body {\n  ${propertyVariables}\n}\n\n  body {\n    --io_border: var(--io_borderWidth) solid var(--io_borderColor);\n    --io_borderColorInset: var(--io_borderColorStrong) var(--io_borderColorLight) var(--io_borderColorLight) var(--io_borderColorStrong);\n    --io_borderColorOutset: var(--io_borderColorLight) var(--io_borderColorStrong) var(--io_borderColorStrong) var(--io_borderColorLight);\n    --io_gradientOutset: linear-gradient(180deg, var(--io_gradientColorStart), var(--io_gradientColorEnd) 100%);\n    --io_gradientInset: linear-gradient(0deg, var(--io_gradientColorStart), var(--io_gradientColorEnd) 150%);\n    --io_shadow: 2px 2px 6px var(--io_shadowColor), 1px 1px 1px var(--io_shadowColor);\n    --io_shadowInset: 0.75px 0.75px 2px inset var(--io_shadowColor);\n    --io_shadowOutset: 1px 1px 2px var(--io_shadowColor);\n  }\n`,this.debounce(this.onSaveTheme,void 0,60)}onSaveTheme(){$Themes.value=JSON.parse(JSON.stringify($Themes.value))}};__decorateClass$Z([ReactiveProperty({type:Object,init:null})],Theme.prototype,"themeDefaults",2),__decorateClass$Z([ReactiveProperty({type:String,binding:$ThemeID})],Theme.prototype,"themeID",2),__decorateClass$Z([ReactiveProperty("debounced")],Theme.prototype,"reactivity",2),Theme=__decorateClass$Z([Register],Theme);const ThemeSingleton=new Theme,glsl_saturate="\n  #ifndef saturate\n    #define saturate(v) clamp(v, 0., 1.)\n  #endif\n",glsl_translate="\n  vec2 translate(vec2 samplePosition, vec2 xy){\n    return samplePosition - vec2(xy.x, xy.y);\n  }\n  vec2 translate(vec2 samplePosition, float x, float y){\n    return samplePosition - vec2(x, y);\n  }\n",glsl_circle="\n  float circle(vec2 samplePosition, float radius){\n    return saturate((length(samplePosition) - radius) * uPxRatio);\n  }\n",glsl_rectangle="\n  float rectangle(vec2 samplePosition, vec2 halfSize){\n    vec2 edgeDistance = abs(samplePosition) - halfSize;\n    float outside = length(max(edgeDistance, 0.));\n    float inside = min(max(edgeDistance.x, edgeDistance.y), 0.);\n    return 1.0 - saturate((outside + inside) * 1000000.0);\n  }\n",glsl_paintDerivativeGrid2D="\n  float paintDerivativeGrid2D(vec2 samplePosition, vec2 gridWidth, float lineWidth) {\n    vec2 sp = samplePosition / gridWidth;\n    float fractx = abs(fract(sp.x - 0.5) - 0.5) * 2.0;\n    float fracty = abs(fract(sp.y - 0.5) - 0.5) * 2.0;\n\n    float sx = ((sp.x - 0.5) - 0.5) * 2.0;\n    float sy = ((sp.y - 0.5) - 0.5) * 2.0;\n    \n    float absx = abs(max(dFdx(sx), dFdy(sx)));\n    float absy = abs(max(dFdy(sy), dFdx(sy)));\n\n    float fadeX = 1.0 - dFdx(sx);\n    float fadeY = 1.0 - dFdy(sx);\n    if (fadeX <= 0.0 || fadeY <= 0.0) return 1.0;\n\n    float linex = fractx / absx - (0.5 * max(uPxRatio, 2.0) * lineWidth - 1.0) - 0.5;\n    float liney = fracty / absy - (0.5 * max(uPxRatio, 2.0) * lineWidth - 1.0) - 0.5;\n\n    return (1.0 - saturate(min(linex, liney)));\n  }\n",glsl_lineVertical="\n  float lineVertical(vec2 samplePosition, float lineWidth) {\n    return (abs(samplePosition.x) * 2.0 > lineWidth) ? 0.0 : 1.0;\n  }\n",glsl_lineHorizontal="\n  float lineHorizontal(vec2 samplePosition, float lineWidth) {\n    return (abs(samplePosition.y) * 2.0 > lineWidth) ? 0.0 : 1.0;\n  }\n",glsl_lineCross2d="\n  float lineCross2d(vec2 samplePosition, float lineWidth) {\n    return (min(abs(samplePosition.x), abs(samplePosition.y)) * 2.0 > lineWidth) ? 0.0 : 1.0;\n  }\n",glsl_checker="\n  float checker(vec2 samplePosition, float size) {\n    vec2 checkerPos = floor(samplePosition / size);\n    float checkerMask = mod(checkerPos.x + mod(checkerPos.y, 2.0), 2.0);\n    return checkerMask;\n  }\n",glsl_checkerX="\n  float checkerX(vec2 samplePosition, float size) {\n    vec2 checkerPos = floor(samplePosition / size);\n    float checkerMask = mod(checkerPos.x, 2.0);\n    return checkerMask;\n  }\n",glsl_checkerY="\n  float checkerY(vec2 samplePosition, float size) {\n    vec2 checkerPos = floor(samplePosition / size);\n    float checkerMask = mod(checkerPos.y, 2.0);\n    return checkerMask;\n  }\n",glsl_compose="\n  vec3 compose(vec3 dst, vec4 src) {\n    return mix(dst, src.rgb, src.a);\n  }\n",glsl_hue2rgb="\n  vec3 hue2rgb(float hue) {\n    hue = fract(hue);\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return saturate(vec3(R,G,B));\n  }\n",glsl_hsv2rgb="\n  vec3 hsv2rgb(vec3 hsv) {\n    vec3 rgb = hue2rgb(hsv.r);\n    return ((rgb - 1.) * hsv.g + 1.) * hsv.b;\n  }\n",glsl_hsl2rgb="\n  vec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n  }\n";var _needsResize,_canvas$1,_ctx,_vecLengths,_shader,__defProp$O=Object.defineProperty,__getOwnPropDesc$V=Object.getOwnPropertyDescriptor,__typeError$1=msg=>{throw TypeError(msg)},__decorateClass$Y=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$V(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$O(target,key,result),result},__accessCheck$1=(obj,member,msg)=>member.has(obj)||__typeError$1("Cannot "+msg),__privateGet$1=(obj,member,getter)=>(__accessCheck$1(obj,member,"read from private field"),getter?getter.call(obj):member.get(obj)),__privateAdd$1=(obj,member,value)=>member.has(obj)?__typeError$1("Cannot add the same private member more than once"):member instanceof WeakSet?member.add(obj):member.set(obj,value),__privateSet$1=(obj,member,value,setter)=>(__accessCheck$1(obj,member,"write to private field"),member.set(obj,value),value);const canvas=document.createElement("canvas"),gl=canvas.getContext("webgl",{antialias:!1,premultipliedAlpha:!1});gl.getExtension("OES_standard_derivatives"),gl.enable(gl.BLEND),gl.blendFunc(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA),gl.disable(gl.DEPTH_TEST);const positionBuff=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,positionBuff),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,1,0,-1,-1,0,1,-1,0,1,1,0]),gl.STATIC_DRAW),gl.bindBuffer(gl.ARRAY_BUFFER,null);const uvBuff=gl.createBuffer();gl.bindBuffer(gl.ARRAY_BUFFER,uvBuff),gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([0,1,0,0,1,0,1,1]),gl.STATIC_DRAW),gl.bindBuffer(gl.ARRAY_BUFFER,null);const indexBuff=gl.createBuffer();gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuff),gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array([3,2,1,3,1,0]),gl.STATIC_DRAW),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuff);const shadersCache=/* @__PURE__ */new WeakMap;let currentProgram,IoGl=class extends IoElement{constructor(args={}){super(args),__privateAdd$1(this,_needsResize,!1),__privateAdd$1(this,_canvas$1),__privateAdd$1(this,_ctx),__privateAdd$1(this,_vecLengths),__privateAdd$1(this,_shader),__privateSet$1(this,_canvas$1,document.createElement("canvas")),this.appendChild(__privateGet$1(this,_canvas$1)),__privateSet$1(this,_ctx,__privateGet$1(this,_canvas$1).getContext("2d",{alpha:!0})),__privateSet$1(this,_vecLengths,{}),this.theme._reactiveProperties.forEach((property,name)=>{property.type===Color$1&&(__privateGet$1(this,_vecLengths)["io_"+name]=4)}),this._reactiveProperties.forEach((property,name)=>{const uname="u"+name.charAt(0).toUpperCase()+name.slice(1);property.type===Array&&(__privateGet$1(this,_vecLengths)[uname]=property.value.length)}),shadersCache.has(this.constructor)?__privateSet$1(this,_shader,shadersCache.get(this.constructor)):(__privateSet$1(this,_shader,this.initShader()),shadersCache.set(this.constructor,__privateGet$1(this,_shader))),gl.linkProgram(__privateGet$1(this,_shader));const position=gl.getAttribLocation(__privateGet$1(this,_shader),"position");gl.bindBuffer(gl.ARRAY_BUFFER,positionBuff),gl.vertexAttribPointer(position,3,gl.FLOAT,!1,0,0),gl.enableVertexAttribArray(position);const uv=gl.getAttribLocation(__privateGet$1(this,_shader),"uv");gl.bindBuffer(gl.ARRAY_BUFFER,uvBuff),gl.vertexAttribPointer(uv,2,gl.FLOAT,!1,0,0),gl.enableVertexAttribArray(uv),this.updateThemeUniforms()}static get Style(){return"\n      :host {\n        position: relative;\n        overflow: hidden !important;\n        @apply --unselectable;\n      }\n      :host > canvas {\n        position: absolute;\n        pointer-events: none;\n        image-rendering: pixelated;\n      }\n      :host > span {\n        position: absolute;\n        text-shadow: 0 0 3px var(--io_bgColorStrong), 0 0 3px var(--io_bgColorStrong), 0 0 3px var(--io_bgColorStrong);\n        left: 3px;\n        pointer-events: none;\n        color: var(--io_colorStrong);\n      }\n    "}static get Vert(){return"\n      attribute vec3 position;\n      attribute vec2 uv;\n      varying vec2 vUv;\n\n      void main(void) {\n        vUv = uv;\n        gl_Position = vec4(position, 1.0);\n      }\n\n"}static get GlUtils(){return`\n      ${glsl_saturate}\n      ${glsl_translate}\n      ${glsl_circle}\n      ${glsl_rectangle}\n      ${glsl_paintDerivativeGrid2D}\n      ${glsl_lineVertical}\n      ${glsl_lineHorizontal}\n      ${glsl_lineCross2d}\n      ${glsl_checker}\n      ${glsl_checkerX}\n      ${glsl_checkerY}\n      ${glsl_compose}\n    `}static get Frag(){return"\n      void main(void) {\n        gl_FragColor = io_color;\n      }\n\n"}initPropertyUniform(name,property){switch(property.value.constructor){case Boolean:return"uniform int "+name+";\n";case Number:return"uniform float "+name+";\n";case Array:return __privateGet$1(this,_vecLengths)[name]=property.value.length,"uniform vec"+property.value.length+" "+name+";\n";case Color$1:return __privateGet$1(this,_vecLengths)[name]=4,"uniform vec4 "+name+";\n"}return""}initShader(){let frag="\n    #extension GL_OES_standard_derivatives : enable\n    precision highp float;\n";this.theme._reactiveProperties.forEach((property,name)=>{frag+=this.initPropertyUniform("io_"+name,property)}),frag+="\n",this._reactiveProperties.forEach((property,prop)=>{const name="u"+prop.charAt(0).toUpperCase()+prop.slice(1);frag+=this.initPropertyUniform(name,property)}),frag+=this.constructor.prototype._glUtils;const vertShader=gl.createShader(gl.VERTEX_SHADER);if(gl.shaderSource(vertShader,this.constructor.Vert),gl.compileShader(vertShader),!gl.getShaderParameter(vertShader,gl.COMPILE_STATUS)){const compilationLog=gl.getShaderInfoLog(vertShader);console.error("IoGl [Vertex Shader] "+this.localName+" error:"),console.warn(compilationLog)}const fragShader=gl.createShader(gl.FRAGMENT_SHADER);if(gl.shaderSource(fragShader,frag+this.constructor.Frag),gl.compileShader(fragShader),!gl.getShaderParameter(fragShader,gl.COMPILE_STATUS)){const compilationLog=gl.getShaderInfoLog(fragShader);console.error("IoGl [Frament Shader] "+this.localName+" error:"),console.warn(compilationLog)}const program=gl.createProgram();return gl.attachShader(program,vertShader),gl.attachShader(program,fragShader),program}onResized(){const pxRatio=window.devicePixelRatio,rect=this.getBoundingClientRect(),style=window.getComputedStyle(this),bw=parseInt(style.borderRightWidth)+parseInt(style.borderLeftWidth),bh=parseInt(style.borderTopWidth)+parseInt(style.borderBottomWidth),width=Math.max(0,Math.floor(rect.width-bw)),height=Math.max(0,Math.floor(rect.height-bh));(width!==this.size[0]||height!==this.size[1]||pxRatio!==this.pxRatio)&&(__privateGet$1(this,_canvas$1).style.width=Math.floor(width)+"px",__privateGet$1(this,_canvas$1).style.height=Math.floor(height)+"px",__privateSet$1(this,_needsResize,!0),this.setProperties({size:[width,height],pxRatio:pxRatio}))}get ctx(){return __privateGet$1(this,_ctx)}themeMutated(){this.updateThemeUniforms(),this.debounce(this.onRender)}changed(){this.debounce(this.onRender)}onRender(){const width=Math.floor(this.size[0]*this.pxRatio),height=Math.floor(this.size[1]*this.pxRatio);width&&height&&(this.setShaderProgram(),this._reactiveProperties.forEach((property,name)=>{const uname="u"+name.charAt(0).toUpperCase()+name.slice(1);this.updatePropertyUniform(uname,property)}),__privateGet$1(this,_needsResize)&&(__privateGet$1(this,_canvas$1).width=width,__privateGet$1(this,_canvas$1).height=height,__privateSet$1(this,_needsResize,!1)),canvas.width=width,canvas.height=height,gl.viewport(0,0,width,height),gl.clearColor(0,0,0,0),gl.clear(gl.COLOR_BUFFER_BIT),__privateGet$1(this,_ctx).clearRect(0,0,width,height),gl.drawElements(gl.TRIANGLES,6,gl.UNSIGNED_SHORT,0),__privateGet$1(this,_ctx).drawImage(canvas,0,0))}setShaderProgram(){currentProgram!==__privateGet$1(this,_shader)&&(currentProgram=__privateGet$1(this,_shader),gl.useProgram(__privateGet$1(this,_shader)))}updatePropertyUniform(name,property){this.setShaderProgram(),this.setUniform(name,property.value)}updateThemeUniforms(){this.theme._reactiveProperties.forEach((property,name)=>{this.updatePropertyUniform("io_"+name,property)})}setUniform(name,value){const uniform=gl.getUniformLocation(__privateGet$1(this,_shader),name);if(null===uniform)return;let _c,type=typeof value;switch(value instanceof Array&&(type="array"),type){case"boolean":gl.uniform1i(uniform,value?1:0);break;case"number":gl.uniform1f(uniform,value??1);break;case"object":case"array":switch(_c=[0,1,2,3],"object"==typeof value&&(void 0!==value.x?_c=["x","y","z","w"]:void 0!==value.r?_c=["r","g","b","a"]:void 0!==value.h?_c=["h","s","v","a"]:void 0!==value.c&&(_c=["c","m","y","k"])),__privateGet$1(this,_vecLengths)[name]){case 2:if(void 0===value){gl.uniform2f(uniform,0,0);break}gl.uniform2f(uniform,value[_c[0]]??1,value[_c[1]]??1);break;case 3:if(void 0===value){gl.uniform3f(uniform,0,0,0);break}gl.uniform3f(uniform,value[_c[0]]??1,value[_c[1]]??1,value[_c[2]]??1);break;case 4:if(void 0===value){gl.uniform4f(uniform,0,0,0,0);break}gl.uniform4f(uniform,value[_c[0]]??1,value[_c[1]]??1,value[_c[2]]??1,value[_c[3]]??1)}}}Register(ioNodeConstructor){super.Register(ioNodeConstructor);let _glUtils="";const constructors=ioNodeConstructor.prototype._protochain.constructors;for(let i=constructors.length;i--;){const constructor=constructors[i],glUtilsProp=Object.getOwnPropertyDescriptor(constructor,"GlUtils");glUtilsProp&&glUtilsProp.get&&(_glUtils+=constructor.GlUtils)}Object.defineProperty(ioNodeConstructor.prototype,"_glUtils",{enumerable:!1,value:_glUtils})}};_needsResize=new WeakMap,_canvas$1=new WeakMap,_ctx=new WeakMap,_vecLengths=new WeakMap,_shader=new WeakMap,__decorateClass$Y([ReactiveProperty({type:ReactiveNode,value:ThemeSingleton})],IoGl.prototype,"theme",2),__decorateClass$Y([ReactiveProperty({type:Array,init:[0,0]})],IoGl.prototype,"size",2),__decorateClass$Y([ReactiveProperty({type:Number,value:1})],IoGl.prototype,"pxRatio",2),IoGl=__decorateClass$Y([Register],IoGl);const HTML_ELEMENTS=["a","abbr","acronym","address","applet","area","article","aside","audio","b","base","basefont","bdi","bdo","big","blockquote","body","br","button","canvas","caption","center","cite","code","col","colgroup","data","datalist","dd","del","details","dfn","dialog","dir","div","dl","dt","em","embed","fieldset","figcaption","figure","font","footer","form","frame","frameset","head","header","hgroup","h1","h2","h3","h4","h5","h6","hr","html","i","iframe","img","input","ins","kbd","keygen","label","legend","li","link","main","map","mark","menu","menuitem","meta","meter","nav","noframes","noscript","object","ol","optgroup","option","output","p","param","picture","pre","progress","q","rp","rt","ruby","s","samp","script","section","select","small","source","span","strike","strong","style","sub","summary","sup","svg","table","tbody","td","template","textarea","tfoot","th","thead","time","title","tr","track","tt","u","ul","var","video","wbr"],nativeVDOMConstructors={};HTML_ELEMENTS.forEach(element=>{nativeVDOMConstructors[element]=function(arg0,arg1){const vDOMElement={tag:element};return void 0!==arg0&&("string"==typeof arg0||arg0 instanceof Array?vDOMElement.children=arg0:"object"==typeof arg0&&(vDOMElement.props=arg0),void 0!==arg1&&("string"==typeof arg1||arg1 instanceof Array)&&(vDOMElement.children=arg1)),vDOMElement}});const{div:div$1,span:span}=nativeVDOMConstructors;var __defProp$N=Object.defineProperty,__getOwnPropDesc$U=Object.getOwnPropertyDescriptor,__decorateClass$X=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$U(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$N(target,key,result),result};let focusRestoreTarget=null,IoOverlay=class extends IoElement{static get Style(){return"\n      :host {\n        display: block;\n        position: fixed;\n        top: 0;\n        left: 0;\n        bottom: 0;\n        right: 0;\n        z-index: 100000;\n        overflow: hidden;\n        pointer-events: none;\n        touch-action: none;\n        background: transparent;\n        @apply --unselectable;\n      }\n      :host[expanded] {\n        background: rgba(0, 0, 0, 0.25);\n        pointer-events: all;\n      }\n      :host > * {\n        position: absolute !important;\n        box-shadow: var(--io_shadow);\n      }\n    "}static get Listeners(){return{pointerdown:["stopPropagation",{passive:!1}],pointermove:["stopPropagation",{passive:!1}],pointerup:"onPointerup",contextmenu:"onContextmenu",mousedown:["stopPropagation",{passive:!1}],mousemove:["stopPropagation",{passive:!1}],mouseup:["stopPropagation",{passive:!1}],touchstart:["stopPropagation",{passive:!1}],touchmove:["stopPropagation",{passive:!1}],touchend:["stopPropagation",{passive:!1}],keydown:["stopPropagation",{passive:!1}],keyup:["stopPropagation",{passive:!1}],focusin:["stopPropagation",{passive:!1}],blur:["stopPropagation",{passive:!1}],scroll:"onScroll",wheel:["onScroll",{passive:!1}]}}constructor(args={}){super(args)}init(){this.expandAsChildren=this.expandAsChildren.bind(this)}stopPropagation(event){event.stopPropagation()}onPointerup(event){event.composedPath()[0]===this&&this.collapse(),event.stopPropagation()}onContextmenu(event){event.preventDefault(),event.stopPropagation()}onScroll(event){event.composedPath()[0]===this&&this.collapse()}onResized(){this.collapse()}appendChild(child){return super.appendChild(child),child.addEventListener("expanded-changed",this.onChildExpandedChanged),this.debounce(this.expandAsChildren),child}removeChild(child){return super.removeChild(child),child.removeEventListener("expanded-changed",this.onChildExpandedChanged),this.debounce(this.expandAsChildren),child}onChildExpandedChanged(){this.debounce(this.expandAsChildren)}collapse(){for(let i=this.children.length;i--;)this.expanded=!1;this.expanded=!1}expandAsChildren(){for(let i=this.children.length;i--;)if(this.children[i].expanded)return void(this.expanded=!0);this.expanded=!1}expandedChanged(){if(!this.expanded){for(let i=this.children.length;i--;)this.children[i].expanded=!1;focusRestoreTarget&&focusRestoreTarget.focus()}}};__decorateClass$X([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoOverlay.prototype,"expanded",2),IoOverlay=__decorateClass$X([Register],IoOverlay);const IoOverlaySingleton=new IoOverlay;setTimeout(()=>{document.body.appendChild(IoOverlaySingleton)},100),window.addEventListener("focusin",()=>{focusRestoreTarget=document.activeElement},{capture:!1}),window.addEventListener("blur",()=>{setTimeout(()=>{IoOverlaySingleton.expanded||document.activeElement!==document.body||(focusRestoreTarget=null)})},{capture:!0});let focusBacktrack=/* @__PURE__ */new WeakMap;const backtrackDir={ArrowLeft:"ArrowRight",ArrowRight:"ArrowLeft",ArrowDown:"ArrowUp",ArrowUp:"ArrowDown"};function setFocusBacktrack(element,dir,source){focusBacktrack.set(element,{dir:backtrackDir[dir],source:source})}function clearFocusBacktrack(){focusBacktrack=/* @__PURE__ */new WeakMap}function getRectDistance(rect1,rect2,dirBias=1){if(rect1.right>rect2.left&&rect2.right>rect1.left&&rect1.bottom>rect2.top&&rect2.bottom>rect1.top)return 0;let dx=0,dy=0;const MIN_DISTANCE=ThemeSingleton.fieldHeight/2;return rect1.right<rect2.left?dx=Math.max(MIN_DISTANCE,rect2.left-rect1.right):rect2.right<rect1.left&&(dx=Math.max(MIN_DISTANCE,rect1.left-rect2.right)),rect1.bottom<rect2.top?dy=Math.max(MIN_DISTANCE,rect2.top-rect1.bottom):rect2.bottom<rect1.top&&(dy=Math.max(MIN_DISTANCE,rect1.top-rect2.bottom)),dx*=dirBias,dy/=dirBias,(dx**2+dy**2)**.5}function getCenterDistance(rect1,rect2,dirBias=1){const c1_x=rect1.x+rect1.width/2,c1_y=rect1.y+rect1.height/2;let dx=c1_x-(rect2.x+rect2.width/2),dy=c1_y-(rect2.y+rect2.height/2);return dx*=dirBias,dy/=dirBias,(dx**2+dy**2)**.5}document.addEventListener("io-focus-to",function onIoFocusTo(event){const src=event.detail.source,srcRect=src.getBoundingClientRect(),cmd=event.detail.command,inoverlay=IoOverlaySingleton.contains(src);let closestElement=src,closestDistance=Infinity,closestCenterDistance=Infinity;const backtrack=focusBacktrack.get(src);if(backtrack&&backtrack.dir===cmd){const source=backtrack.source;let visible=!0;if(source.offsetParent&&source!==src){const sStyle=window.getComputedStyle(source);"visible"===sStyle.visibility&&"none"!==sStyle.display||(visible=!1)}else visible=!1;if(visible)return source.focus(),void setFocusBacktrack(source,cmd,src)}const root=inoverlay?IoOverlaySingleton:document;let focusableCandidates=Array.from(root.querySelectorAll(`[tabIndex="${src.tabIndex||0}"]:not([disabled]):not([inert]):not([hidden])`));const focusableSiblingCandidates=Array.from(src.parentElement.querySelectorAll(`[tabIndex="${src.tabIndex||0}"]:not([disabled]):not([inert]):not([hidden])`));if(focusableCandidates=focusableCandidates.filter(el=>null!==el.offsetParent),focusableCandidates=focusableCandidates.filter(el=>{const style=window.getComputedStyle(el);return"none"!==style.display&&"hidden"!==style.visibility&&"0"!==style.opacity}),"Tab"===cmd){const index=focusableCandidates.indexOf(src);return void(-1!==index&&focusableCandidates[(index+1)%focusableCandidates.length].focus())}if("Home"!==cmd)if("End"!==cmd)if("PageUp"!==cmd)if("PageDown"!==cmd){if(["ArrowLeft","ArrowRight","ArrowDown","ArrowUp"].includes(cmd)){for(let i=focusableCandidates.length;i--;){const candidate=focusableCandidates[i];if(!candidate.offsetParent||candidate===src)continue;const sStyle=window.getComputedStyle(candidate);if("visible"!==sStyle.visibility||"none"===sStyle.display)continue;const rect=candidate.getBoundingClientRect();if("ArrowRight"===cmd&&rect.left<srcRect.right)continue;if("ArrowLeft"===cmd&&rect.right>srcRect.left)continue;if("ArrowDown"===cmd&&rect.top<srcRect.bottom)continue;if("ArrowUp"===cmd&&rect.bottom>srcRect.top)continue;const biasMagnitude=4,dirBias="ArrowLeft"===cmd||"ArrowRight"===cmd?1/biasMagnitude:biasMagnitude,distance=getRectDistance(srcRect,rect,dirBias),centerDistance=getCenterDistance(srcRect,rect,dirBias);distance<closestDistance?(closestDistance=distance,closestCenterDistance=centerDistance,closestElement=candidate):distance===closestDistance&&centerDistance<closestCenterDistance&&(closestCenterDistance=centerDistance,closestElement=candidate)}closestElement!==src&&(closestElement.focus(),setFocusBacktrack(closestElement,cmd,src))}}else focusableSiblingCandidates[focusableSiblingCandidates.length-1].focus();else focusableSiblingCandidates[0].focus();else focusableCandidates[focusableCandidates.length-1].focus();else focusableCandidates[0].focus()});const viewport$1={get width(){return window.visualViewport?window.visualViewport.width*window.visualViewport.scale:document.documentElement.clientWidth},get height(){return window.visualViewport?window.visualViewport.height*window.visualViewport.scale:document.documentElement.clientHeight},get offsetLeft(){return window.visualViewport?window.visualViewport.offsetLeft:0},get offsetTop(){return window.visualViewport?window.visualViewport.offsetTop:0}};function nudgeUp(element,x,y,elemRect,force,doClip){x=Math.max(0,Math.min(x,viewport$1.width-elemRect.width));let clipWidth=-1,clipHeight=-1;const fitsHeight=y-elemRect.height>=0,fitsWidth=x+elemRect.width<=viewport$1.width;return!(!fitsHeight&&!force)&&(fitsHeight?y-=elemRect.height:doClip?(clipHeight=y,y=0):y=elemRect.height-y,fitsWidth||(doClip?clipWidth=viewport$1.width:x=viewport$1.width-elemRect.width),element.style.top=y+"px",element.style.left=x+"px",element.style.width=-1!==clipWidth?clipWidth+"px":"",element.style.height=-1!==clipHeight?clipHeight+"px":"",!0)}function nudgeDown(element,x,y,elemRect,force,doClip){y+=viewport$1.offsetTop,x+=viewport$1.offsetLeft,x=Math.max(0,Math.min(x,viewport$1.width-elemRect.width));let clipWidth=-1,clipHeight=-1;const fitsHeight=y+elemRect.height<=viewport$1.height,fitsWidth=x+elemRect.width<=viewport$1.width;return!(!fitsHeight&&!force)&&(fitsHeight||(doClip?clipHeight=viewport$1.height-y:y=viewport$1.height-elemRect.height),fitsWidth||(doClip?clipWidth=viewport$1.width:x=viewport$1.width-elemRect.width),element.style.top=y+"px",element.style.left=x+"px",element.style.width=-1!==clipWidth?clipWidth+"px":"",element.style.height=-1!==clipHeight?clipHeight+"px":"",!0)}function nudgeLeft(element,x,y,elemRect,force,doClip){y=Math.max(0,Math.min(y,viewport$1.height-elemRect.height));let clipWidth=-1,clipHeight=-1;const fitsWidth=x-elemRect.width>=0,fitsHeight=y+elemRect.height<=viewport$1.height;return!(!fitsWidth&&!force)&&(fitsWidth?x-=elemRect.width:doClip?(clipWidth=x,x=0):x=0,fitsHeight||(doClip?clipHeight=viewport$1.height:y=viewport$1.height-elemRect.height),element.style.top=y+"px",element.style.left=x+"px",element.style.width=-1!==clipWidth?clipWidth+"px":"",element.style.height=-1!==clipHeight?clipHeight+"px":"",!0)}function nudgeRight(element,x,y,elemRect,force,doClip){y=Math.max(0,Math.min(y,viewport$1.height-elemRect.height));let clipWidth=-1,clipHeight=-1;const fitsWidth=x+elemRect.width<=viewport$1.width,fitsHeight=y+elemRect.height<=viewport$1.height;return!(!fitsWidth&&!force)&&(fitsWidth||(doClip?clipWidth=viewport$1.width-x:x=viewport$1.width-elemRect.width),fitsHeight||(doClip?clipHeight=viewport$1.height:y=viewport$1.height-elemRect.height),element.style.top=y+"px",element.style.left=x+"px",element.style.width=-1!==clipWidth?clipWidth+"px":"",element.style.height=-1!==clipHeight?clipHeight+"px":"",!0)}function nudge(element,srcElement,direction,doClip){const elemRect=element.getBoundingClientRect(),srcRect=srcElement.getBoundingClientRect(),left=srcRect.left,top=srcRect.top,right=srcRect.right,bottom=srcRect.bottom,bottomToHeight=viewport$1.height-bottom,rightToWidth=viewport$1.width-right,x=elemRect.left,y=elemRect.top;switch(direction){case"none":nudgeRight(element,x,y,elemRect,!1,doClip)||nudgeLeft(element,x,y,elemRect,!1,doClip)||nudgeRight(element,x,y,elemRect,rightToWidth>left,doClip)||nudgeLeft(element,left,top,elemRect,rightToWidth<=left,doClip);break;case"up":nudgeUp(element,left,top,elemRect,!1,doClip)||nudgeDown(element,left,bottom,elemRect,!1,doClip)||nudgeUp(element,left,top,elemRect,top>bottomToHeight,doClip)||nudgeDown(element,left,bottom,elemRect,top<=bottomToHeight,doClip);break;case"left":nudgeLeft(element,left,top,elemRect,!1,doClip)||nudgeRight(element,right,top,elemRect,!1,doClip)||nudgeLeft(element,left,top,elemRect,left>rightToWidth,doClip)||nudgeRight(element,right,top,elemRect,left<=rightToWidth,doClip);break;case"down":nudgeDown(element,left,bottom,elemRect,!1,doClip)||nudgeUp(element,left,top,elemRect,!1,doClip)||nudgeDown(element,left,bottom,elemRect,bottomToHeight>top,doClip)||nudgeUp(element,left,top,elemRect,bottomToHeight<=top,doClip);break;case"right":nudgeRight(element,right,top,elemRect,!1,doClip)||nudgeLeft(element,left,top,elemRect,!1,doClip)||nudgeRight(element,right,top,elemRect,rightToWidth>left,doClip)||nudgeLeft(element,left,top,elemRect,rightToWidth<=left,doClip);break;default:nudgeRight(element,left,top,elemRect,!1,doClip)||nudgeLeft(element,right,top,elemRect,!1,doClip)||nudgeRight(element,left,top,elemRect,rightToWidth>left,doClip)||nudgeLeft(element,right,top,elemRect,rightToWidth<=left,doClip)}}class Pad{id;pos;_color="white";get color(){return this._color}set color(color){this._color=color}constructor(id,pos){this.id=id,this.pos=pos}toJSON(){return{pos:this.pos,id:this.id}}static fromJSON(data){return new Pad(data.id,data.pos)}}const TERMINAL_COLORS={white:"#ffffff",red:"#e52800",green:"#005923",blue:"#06afff",pink:"#ef47cc",yellow:"#fec41a",orange:"#ff6910",purple:"#760281"};class Terminal{id;pos;color;constructor(id,pos,color){this.id=id,this.pos=pos,this.color=color}toJSON(){return{id:this.id,pos:this.pos,color:this.color}}static fromJSON(data){return new Terminal(data.id,data.pos,data.color)}}let Line$1=class Line{id;pos;layer;_color="white";get color(){return this._color}set color(color){this._color=color}constructor(id,pos,layer){this.id=id,this.pos=pos,this.layer=layer}toJSON(){return{id:this.id,pos:this.pos,layer:this.layer}}static fromJSON(data){return new Line(data.id,data.pos,data.layer)}hasDiagonalSegmentAt(mx,my){const pos=this.pos;for(let i=1;i<pos.length;i++){const ax=pos[i-1][0],ay=pos[i-1][1],bx=pos[i][0],by=pos[i][1];if(1===Math.abs(bx-ax)&&1===Math.abs(by-ay)&&(ax+bx)/2===mx&&(ay+by)/2===my)return!0}return!1}plotSegment(x,y){return!!this._tryEraseLastSegment(x,y)||!!this._tryAddNewSegment(x,y)}_tryAddNewSegment(x,y){const ln=this.pos.length;if(ln>1){if(y===this.pos[ln-2][1]&&1===Math.abs(x-this.pos[ln-2][0]))return this.pos.pop(),this.pos.push([x,y]),!1;if(x===this.pos[ln-2][0]&&1===Math.abs(y-this.pos[ln-2][1]))return this.pos.pop(),this.pos.push([x,y]),!1}const last=this.pos[ln-1];return Math.abs(last[0]-x)>1||(Math.abs(last[1]-y)>1||(this.pos.push([x,y]),!1))}_tryEraseLastSegment(x,y){const ln=this.pos.length;return!(ln<2)&&(x===this.pos[ln-2][0]&&y===this.pos[ln-2][1]&&(this.pos.pop(),!0))}};var __getOwnPropDesc$T=Object.getOwnPropertyDescriptor;let Plotter=class extends ReactiveNode{width=0;height=0;pads=[];terminals=[];lines=[];connect(pads,terminals,lines,width,height){this.width=width,this.height=height,this.pads=pads,this.terminals=terminals,this.lines=lines}getPointAt(x,y){for(const pad of this.pads)if(pad.pos[0]===x&&pad.pos[1]===y)return pad;for(const term of this.terminals)if(term.pos[0]===x&&term.pos[1]===y)return term}getLinesAtPoint(x,y,filter){const lines=[];for(const line of this.lines)line.pos.some(([px,py])=>px===x&&py===y)&&(filter?.(line)??1)&&lines.push(line);return lines}getLineById(id){return this.lines.find(l=>l.id===id)}checkDiagonalCrossing(line,x,y){const last=line.pos[line.pos.length-1],mx=(x+last[0])/2,my=(y+last[1])/2;for(const other of this.lines)if(other.layer===line.layer&&other.hasDiagonalSegmentAt(mx,my))return!1;return!0}addPad(id,x,y){return!this.getPointAt(x,y)&&(this.pads.push(new Pad(id,[x,y])),this.dispatch("game-update",void 0,!0),!0)}addTerminal(id,x,y,color){return!this.getPointAt(x,y)&&(this.terminals.push(new Terminal(id,[x,y],color)),this.dispatch("game-update",void 0,!0),!0)}delete(x,y){const padIdx=this.pads.findIndex(p=>p.pos[0]===x&&p.pos[1]===y);-1!==padIdx&&this.pads.splice(padIdx,1);const termIdx=this.terminals.findIndex(t=>t.pos[0]===x&&t.pos[1]===y);-1!==termIdx&&this.terminals.splice(termIdx,1);const lineIdx=this.lines.findIndex(l=>l.pos.some(([px,py])=>px===x&&py===y));-1!==lineIdx&&this.lines.splice(lineIdx,1),this.dispatch("game-update",void 0,!0)}verifyLineLegality(id){const line=this.getLineById(id);if(line){const first=line.pos[0],last=line.pos[line.pos.length-1],p1=this.getPointAt(first[0],first[1]),p2=this.getPointAt(last[0],last[1]);if(!p1||!p2||first[0]===last[0]&&first[1]===last[1]){const idx=this.lines.findIndex(l=>l.id===id);return-1!==idx&&this.lines.splice(idx,1),!1}return!0}return!1}isInBounds(x,y){return x>=0&&x<=this.width&&y>=0&&y<=this.height}addLineSegment(id,x,y,layer){if(!this.isInBounds(x,y))return{added:!1,endDrag:!1};const point=this.getPointAt(x,y),linesAtPoint=this.getLinesAtPoint(x,y,line2=>0===line2.layer),underlineLinesAtPoint=this.getLinesAtPoint(x,y,line2=>-1===line2.layer),connectionLimit=point?point instanceof Terminal?1:2:0;let added=!1,endDrag=!1;if(point&&linesAtPoint.length+underlineLinesAtPoint.length>=connectionLimit)return{added:added,endDrag:endDrag};const line=this.getLineById(id);if(line){if(!this.checkDiagonalCrossing(line,x,y))return{added:added,endDrag:endDrag};const posCount=line.pos.length;if(line.pos.some(([px,py],i)=>px===x&&py===y&&i<posCount-2))return{added:added,endDrag:endDrag};const sameLineAtPoint=this.getLinesAtPoint(x,y,line2=>line2.id===id&&0===line2.layer)?.[0]||null;if(point||linesAtPoint.length&&!sameLineAtPoint&&-1!==layer||(added=line.plotSegment(x,y)),point){if("white"!==point.color&&"white"!==line.color&&point.color!==line.color)return{added:!1,endDrag:!1};added=line.plotSegment(x,y),endDrag=!0}}else{if(!point)return{added:!1,endDrag:!1};const newLine=new Line$1(id,[[x,y]],layer);newLine.color=point.color,this.lines.push(newLine),added=!0}return endDrag&&this.dispatch("line-end-drag",{id:id},!0),this.dispatch("game-update",void 0,!0),{added:added,endDrag:endDrag}}};Plotter=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$T(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],Plotter);var __defProp$M=Object.defineProperty,__getOwnPropDesc$S=Object.getOwnPropertyDescriptor,__decorateClass$V=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$S(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$M(target,key,result),result};let Game=class extends ReactiveNode{width=4;height=5;pads=[];terminals=[];lines=[];drawMode="line";drawColor="white";drawLayer=0;undoStack=[];redoStack=[];clear(){this.width=4,this.height=5,this.pads=[],this.terminals=[],this.lines=[],this.plotter.connect(this.pads,this.terminals,this.lines,this.width,this.height),this.drawMode="line",this.drawColor="white",this.drawLayer=0,this.redoStack=[],this.undoStack=[]}async initialize(){this.clear(),this.storedState=Storage({key:`${this.currentLevel}-level-state`,value:{},storage:"local"}),this.currentLevel&&(0===Object.keys(this.storedState.value).length?await this.load(this.currentLevel):(this.clear(),this.fromJSON(JSON.stringify(this.storedState.value)),this.propagateColors())),this.undoStack=[this.toJSON()],this.redoStack=[],this.dispatch("game-update",void 0,!0)}currentLevelChanged(){this.initialize().then(()=>{this.dispatch("game-init-scene",void 0,!0)})}reload(){this.storedState.value={},this.initialize()}async load(level){try{const resp=await fetch("./public/levels/"+level+".json");resp.ok||console.error("Level not found");const text=await resp.text();this.clear(),this.fromJSON(text),this.propagateColors(),this.save()}catch(e){console.warn("Could not load level:",level,e)}}save(){this.storedState.value={width:this.width,height:this.height,pads:this.pads.map(p=>p.toJSON()),terminals:this.terminals.map(t=>t.toJSON()),lines:this.lines.map(l=>l.toJSON())}}fromJSON(jsonText){const state=JSON.parse(jsonText);this.width=state.width,this.height=state.height,this.pads=state.pads.map(p=>Pad.fromJSON(p)),this.terminals=state.terminals.map(t=>Terminal.fromJSON(t)),this.lines=state.lines.map(l=>Line$1.fromJSON(l)),this.plotter.connect(this.pads,this.terminals,this.lines,this.width,this.height)}toJSON(){return JSON.stringify({width:this.width,height:this.height,pads:this.pads.map(p=>p.toJSON()),terminals:this.terminals.map(t=>t.toJSON()),lines:this.lines.map(l=>l.toJSON())})}updateUndoStack(){const state=this.toJSON();state!==this.undoStack[this.undoStack.length-1]&&this.undoStack.push(state)}undo(){if(this.undoStack.length>=2){const currentState=this.undoStack.pop();this.fromJSON(this.undoStack[this.undoStack.length-1]),this.redoStack.push(currentState),this.propagateColors(),this.save(),this.dispatch("game-update",void 0,!0)}}redo(){if(this.redoStack.length>0){const state=this.redoStack.pop();this.fromJSON(state),this.undoStack.push(state),this.propagateColors(),this.save(),this.dispatch("game-update",void 0,!0)}}resetColors(){for(const line of this.lines)line.color="white";for(const pad of this.pads)pad.color="white"}propagateColors(){this.resetColors();for(let iter=0;iter<16;iter++)for(const line of this.lines){const first=line.pos[0],last=line.pos[line.pos.length-1],p1=this.plotter.getPointAt(first[0],first[1]),p2=this.plotter.getPointAt(last[0],last[1]);if(!p1||!p2)continue;const c1=p1.color,c2=p2.color;"white"!==c1&&"white"!==c2?c1===c2&&(line.color=c1):"white"===c1&&"white"===c2?line.color="white":"white"!==c1?(line.color=c1,p2 instanceof Pad&&(p2.color=c1)):"white"!==c2&&(line.color=c2,p1 instanceof Pad&&(p1.color=c2))}this.dispatch("game-update",void 0,!0);let completed=!0;for(const term of this.terminals){1!==this.plotter.getLinesAtPoint(term.pos[0],term.pos[1]).length&&(completed=!1)}for(const pad of this.pads){2!==this.plotter.getLinesAtPoint(pad.pos[0],pad.pos[1]).length&&"white"!==pad.color&&(completed=!1)}console.log("game-complete",this.currentLevel,completed),this.dispatch("game-complete",{level:this.currentLevel,completed:completed},!0)}finalizeMove(lineID){this.plotter.verifyLineLegality(lineID)&&(this.updateUndoStack(),this.propagateColors(),this.save()),this.dispatch("game-update",void 0,!0)}};__decorateClass$V([ReactiveProperty({value:"",type:String})],Game.prototype,"currentLevel",2),__decorateClass$V([ReactiveProperty({type:Plotter,init:null})],Game.prototype,"plotter",2),__decorateClass$V([Property(Storage({key:"null-level-state",value:{},storage:"local"}))],Game.prototype,"storedState",2),Game=__decorateClass$V([Register],Game);
/**
 * @license
 * Copyright 2010-2026 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const MOUSE_ROTATE=0,MOUSE_DOLLY=1,MOUSE_PAN=2,TOUCH_ROTATE=0,TOUCH_PAN=1,TOUCH_DOLLY_PAN=2,TOUCH_DOLLY_ROTATE=3,FrontSide=0,BackSide=1,DoubleSide=2,AddEquation=100,SubtractEquation=101,ReverseSubtractEquation=102,ZeroFactor=200,OneFactor=201,SrcColorFactor=202,OneMinusSrcColorFactor=203,SrcAlphaFactor=204,OneMinusSrcAlphaFactor=205,DstAlphaFactor=206,OneMinusDstAlphaFactor=207,DstColorFactor=208,OneMinusDstColorFactor=209,SrcAlphaSaturateFactor=210,RepeatWrapping=1e3,ClampToEdgeWrapping=1001,MirroredRepeatWrapping=1002,NearestFilter=1003,NearestMipmapNearestFilter=1004,NearestMipmapLinearFilter=1005,LinearFilter=1006,LinearMipmapNearestFilter=1007,LinearMipmapLinearFilter=1008,HalfFloatType=1016,SRGBColorSpace="srgb",LinearSRGBColorSpace="srgb-linear",NeverCompare=512,LessCompare=513,EqualCompare=514,LessEqualCompare=515,GreaterCompare=516,NotEqualCompare=517,GreaterEqualCompare=518,AlwaysCompare=519,TimestampQuery_COMPUTE="compute",TimestampQuery_RENDER="render",Compatibility_TEXTURE_COMPARE="depthTextureCompare";function isTypedArray(array){return ArrayBuffer.isView(array)&&!(array instanceof DataView)}function createElementNS(name){return document.createElementNS("http://www.w3.org/1999/xhtml",name)}const _cache$2={};function log$1(...params){const message="THREE."+params.shift();console.log(message,...params)}function enhanceLogMessage(params){const message=params[0];if("string"==typeof message&&message.startsWith("TSL:")){const stackTrace=params[1];stackTrace&&stackTrace.isStackTrace?params[0]+=" "+stackTrace.getLocation():params[1]='Stack trace not available. Enable "THREE.Node.captureStackTrace" to capture stack traces.'}return params}function warn(...params){const message="THREE."+(params=enhanceLogMessage(params)).shift();{const stackTrace=params[0];stackTrace&&stackTrace.isStackTrace?console.warn(stackTrace.getError(message)):console.warn(message,...params)}}function error(...params){const message="THREE."+(params=enhanceLogMessage(params)).shift();{const stackTrace=params[0];stackTrace&&stackTrace.isStackTrace?console.error(stackTrace.getError(message)):console.error(message,...params)}}function warnOnce(...params){const message=params.join(" ");message in _cache$2||(_cache$2[message]=!0,warn(...params))}class EventDispatcher{addEventListener(type,listener){void 0===this._listeners&&(this._listeners={});const listeners=this._listeners;void 0===listeners[type]&&(listeners[type]=[]),-1===listeners[type].indexOf(listener)&&listeners[type].push(listener)}hasEventListener(type,listener){const listeners=this._listeners;return void 0!==listeners&&(void 0!==listeners[type]&&-1!==listeners[type].indexOf(listener))}removeEventListener(type,listener){const listeners=this._listeners;if(void 0===listeners)return;const listenerArray=listeners[type];if(void 0!==listenerArray){const index=listenerArray.indexOf(listener);-1!==index&&listenerArray.splice(index,1)}}dispatchEvent(event){const listeners=this._listeners;if(void 0===listeners)return;const listenerArray=listeners[event.type];if(void 0!==listenerArray){event.target=this;const array=listenerArray.slice(0);for(let i=0,l=array.length;i<l;i++)array[i].call(this,event);event.target=null}}}const _lut=["00","01","02","03","04","05","06","07","08","09","0a","0b","0c","0d","0e","0f","10","11","12","13","14","15","16","17","18","19","1a","1b","1c","1d","1e","1f","20","21","22","23","24","25","26","27","28","29","2a","2b","2c","2d","2e","2f","30","31","32","33","34","35","36","37","38","39","3a","3b","3c","3d","3e","3f","40","41","42","43","44","45","46","47","48","49","4a","4b","4c","4d","4e","4f","50","51","52","53","54","55","56","57","58","59","5a","5b","5c","5d","5e","5f","60","61","62","63","64","65","66","67","68","69","6a","6b","6c","6d","6e","6f","70","71","72","73","74","75","76","77","78","79","7a","7b","7c","7d","7e","7f","80","81","82","83","84","85","86","87","88","89","8a","8b","8c","8d","8e","8f","90","91","92","93","94","95","96","97","98","99","9a","9b","9c","9d","9e","9f","a0","a1","a2","a3","a4","a5","a6","a7","a8","a9","aa","ab","ac","ad","ae","af","b0","b1","b2","b3","b4","b5","b6","b7","b8","b9","ba","bb","bc","bd","be","bf","c0","c1","c2","c3","c4","c5","c6","c7","c8","c9","ca","cb","cc","cd","ce","cf","d0","d1","d2","d3","d4","d5","d6","d7","d8","d9","da","db","dc","dd","de","df","e0","e1","e2","e3","e4","e5","e6","e7","e8","e9","ea","eb","ec","ed","ee","ef","f0","f1","f2","f3","f4","f5","f6","f7","f8","f9","fa","fb","fc","fd","fe","ff"];let _seed=1234567;const DEG2RAD=Math.PI/180,RAD2DEG=180/Math.PI;function generateUUID(){const d0=4294967295*Math.random()|0,d1=4294967295*Math.random()|0,d2=4294967295*Math.random()|0,d3=4294967295*Math.random()|0;return(_lut[255&d0]+_lut[d0>>8&255]+_lut[d0>>16&255]+_lut[d0>>24&255]+"-"+_lut[255&d1]+_lut[d1>>8&255]+"-"+_lut[d1>>16&15|64]+_lut[d1>>24&255]+"-"+_lut[63&d2|128]+_lut[d2>>8&255]+"-"+_lut[d2>>16&255]+_lut[d2>>24&255]+_lut[255&d3]+_lut[d3>>8&255]+_lut[d3>>16&255]+_lut[d3>>24&255]).toLowerCase()}function clamp$3(value,min,max){return Math.max(min,Math.min(max,value))}function euclideanModulo(n,m){return(n%m+m)%m}function lerp(x,y,t){return(1-t)*x+t*y}function denormalize(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return value/4294967295;case Uint16Array:return value/65535;case Uint8Array:return value/255;case Int32Array:return Math.max(value/2147483647,-1);case Int16Array:return Math.max(value/32767,-1);case Int8Array:return Math.max(value/127,-1);default:throw new Error("Invalid component type.")}}function normalize$1(value,array){switch(array.constructor){case Float32Array:return value;case Uint32Array:return Math.round(4294967295*value);case Uint16Array:return Math.round(65535*value);case Uint8Array:return Math.round(255*value);case Int32Array:return Math.round(2147483647*value);case Int16Array:return Math.round(32767*value);case Int8Array:return Math.round(127*value);default:throw new Error("Invalid component type.")}}const MathUtils={DEG2RAD:DEG2RAD,RAD2DEG:RAD2DEG,generateUUID:generateUUID,clamp:clamp$3,euclideanModulo:euclideanModulo,mapLinear:function mapLinear(x,a1,a2,b1,b2){return b1+(x-a1)*(b2-b1)/(a2-a1)},inverseLerp:function inverseLerp(x,y,value){return x!==y?(value-x)/(y-x):0},lerp:lerp,damp:function damp(x,y,lambda,dt){return lerp(x,y,1-Math.exp(-lambda*dt))},pingpong:function pingpong(x,length=1){return length-Math.abs(euclideanModulo(x,2*length)-length)},smoothstep:function smoothstep$1(x,min,max){return x<=min?0:x>=max?1:(x=(x-min)/(max-min))*x*(3-2*x)},smootherstep:function smootherstep(x,min,max){return x<=min?0:x>=max?1:(x=(x-min)/(max-min))*x*x*(x*(6*x-15)+10)},randInt:function randInt(low,high){return low+Math.floor(Math.random()*(high-low+1))},randFloat:function randFloat(low,high){return low+Math.random()*(high-low)},randFloatSpread:function randFloatSpread(range){return range*(.5-Math.random())},seededRandom:function seededRandom(s){void 0!==s&&(_seed=s);let t=_seed+=1831565813;return t=Math.imul(t^t>>>15,1|t),t^=t+Math.imul(t^t>>>7,61|t),((t^t>>>14)>>>0)/4294967296},degToRad:function degToRad(degrees){return degrees*DEG2RAD},radToDeg:function radToDeg(radians){return radians*RAD2DEG},isPowerOfTwo:function isPowerOfTwo(value){return!(value&value-1)&&0!==value},ceilPowerOfTwo:function ceilPowerOfTwo(value){return Math.pow(2,Math.ceil(Math.log(value)/Math.LN2))},floorPowerOfTwo:function floorPowerOfTwo(value){return Math.pow(2,Math.floor(Math.log(value)/Math.LN2))},setQuaternionFromProperEuler:function setQuaternionFromProperEuler(q,a,b,c,order){const cos=Math.cos,sin=Math.sin,c2=cos(b/2),s2=sin(b/2),c13=cos((a+c)/2),s13=sin((a+c)/2),c1_3=cos((a-c)/2),s1_3=sin((a-c)/2),c3_1=cos((c-a)/2),s3_1=sin((c-a)/2);switch(order){case"XYX":q.set(c2*s13,s2*c1_3,s2*s1_3,c2*c13);break;case"YZY":q.set(s2*s1_3,c2*s13,s2*c1_3,c2*c13);break;case"ZXZ":q.set(s2*c1_3,s2*s1_3,c2*s13,c2*c13);break;case"XZX":q.set(c2*s13,s2*s3_1,s2*c3_1,c2*c13);break;case"YXY":q.set(s2*c3_1,c2*s13,s2*s3_1,c2*c13);break;case"ZYZ":q.set(s2*s3_1,s2*c3_1,c2*s13,c2*c13);break;default:warn("MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: "+order)}},normalize:normalize$1,denormalize:denormalize};class Vector2{constructor(x=0,y=0){Vector2.prototype.isVector2=!0,this.x=x,this.y=y}get width(){return this.x}set width(value){this.x=value}get height(){return this.y}set height(value){this.y=value}set(x,y){return this.x=x,this.y=y,this}setScalar(scalar){return this.x=scalar,this.y=scalar,this}setX(x){return this.x=x,this}setY(y){return this.y=y,this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;default:throw new Error("index is out of range: "+index)}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;default:throw new Error("index is out of range: "+index)}}clone(){return new this.constructor(this.x,this.y)}copy(v){return this.x=v.x,this.y=v.y,this}add(v){return this.x+=v.x,this.y+=v.y,this}addScalar(s){return this.x+=s,this.y+=s,this}addVectors(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this}addScaledVector(v,s){return this.x+=v.x*s,this.y+=v.y*s,this}sub(v){return this.x-=v.x,this.y-=v.y,this}subScalar(s){return this.x-=s,this.y-=s,this}subVectors(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this}multiply(v){return this.x*=v.x,this.y*=v.y,this}multiplyScalar(scalar){return this.x*=scalar,this.y*=scalar,this}divide(v){return this.x/=v.x,this.y/=v.y,this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}applyMatrix3(m){const x=this.x,y=this.y,e=m.elements;return this.x=e[0]*x+e[3]*y+e[6],this.y=e[1]*x+e[4]*y+e[7],this}min(v){return this.x=Math.min(this.x,v.x),this.y=Math.min(this.y,v.y),this}max(v){return this.x=Math.max(this.x,v.x),this.y=Math.max(this.y,v.y),this}clamp(min,max){return this.x=clamp$3(this.x,min.x,max.x),this.y=clamp$3(this.y,min.y,max.y),this}clampScalar(minVal,maxVal){return this.x=clamp$3(this.x,minVal,maxVal),this.y=clamp$3(this.y,minVal,maxVal),this}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$3(length,min,max))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this}negate(){return this.x=-this.x,this.y=-this.y,this}dot(v){return this.x*v.x+this.y*v.y}cross(v){return this.x*v.y-this.y*v.x}lengthSq(){return this.x*this.x+this.y*this.y}length(){return Math.sqrt(this.x*this.x+this.y*this.y)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)}normalize(){return this.divideScalar(this.length()||1)}angle(){return Math.atan2(-this.y,-this.x)+Math.PI}angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(0===denominator)return Math.PI/2;const theta=this.dot(v)/denominator;return Math.acos(clamp$3(theta,-1,1))}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y;return dx*dx+dy*dy}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v,alpha){return this.x+=(v.x-this.x)*alpha,this.y+=(v.y-this.y)*alpha,this}lerpVectors(v1,v2,alpha){return this.x=v1.x+(v2.x-v1.x)*alpha,this.y=v1.y+(v2.y-v1.y)*alpha,this}equals(v){return v.x===this.x&&v.y===this.y}fromArray(array,offset=0){return this.x=array[offset],this.y=array[offset+1],this}toArray(array=[],offset=0){return array[offset]=this.x,array[offset+1]=this.y,array}fromBufferAttribute(attribute,index){return this.x=attribute.getX(index),this.y=attribute.getY(index),this}rotateAround(center,angle){const c=Math.cos(angle),s=Math.sin(angle),x=this.x-center.x,y=this.y-center.y;return this.x=x*c-y*s+center.x,this.y=x*s+y*c+center.y,this}random(){return this.x=Math.random(),this.y=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y}}class Quaternion{constructor(x=0,y=0,z=0,w=1){this.isQuaternion=!0,this._x=x,this._y=y,this._z=z,this._w=w}static slerpFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1,t){let x0=src0[srcOffset0+0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1+0],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];if(w0!==w1||x0!==x1||y0!==y1||z0!==z1){let dot=x0*x1+y0*y1+z0*z1+w0*w1;dot<0&&(x1=-x1,y1=-y1,z1=-z1,w1=-w1,dot=-dot);let s=1-t;if(dot<.9995){const theta=Math.acos(dot),sin=Math.sin(theta);s=Math.sin(s*theta)/sin,x0=x0*s+x1*(t=Math.sin(t*theta)/sin),y0=y0*s+y1*t,z0=z0*s+z1*t,w0=w0*s+w1*t}else{x0=x0*s+x1*t,y0=y0*s+y1*t,z0=z0*s+z1*t,w0=w0*s+w1*t;const f=1/Math.sqrt(x0*x0+y0*y0+z0*z0+w0*w0);x0*=f,y0*=f,z0*=f,w0*=f}}dst[dstOffset]=x0,dst[dstOffset+1]=y0,dst[dstOffset+2]=z0,dst[dstOffset+3]=w0}static multiplyQuaternionsFlat(dst,dstOffset,src0,srcOffset0,src1,srcOffset1){const x0=src0[srcOffset0],y0=src0[srcOffset0+1],z0=src0[srcOffset0+2],w0=src0[srcOffset0+3],x1=src1[srcOffset1],y1=src1[srcOffset1+1],z1=src1[srcOffset1+2],w1=src1[srcOffset1+3];return dst[dstOffset]=x0*w1+w0*x1+y0*z1-z0*y1,dst[dstOffset+1]=y0*w1+w0*y1+z0*x1-x0*z1,dst[dstOffset+2]=z0*w1+w0*z1+x0*y1-y0*x1,dst[dstOffset+3]=w0*w1-x0*x1-y0*y1-z0*z1,dst}get x(){return this._x}set x(value){this._x=value,this._onChangeCallback()}get y(){return this._y}set y(value){this._y=value,this._onChangeCallback()}get z(){return this._z}set z(value){this._z=value,this._onChangeCallback()}get w(){return this._w}set w(value){this._w=value,this._onChangeCallback()}set(x,y,z,w){return this._x=x,this._y=y,this._z=z,this._w=w,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._w)}copy(quaternion){return this._x=quaternion.x,this._y=quaternion.y,this._z=quaternion.z,this._w=quaternion.w,this._onChangeCallback(),this}setFromEuler(euler,update=!0){const x=euler._x,y=euler._y,z=euler._z,order=euler._order,cos=Math.cos,sin=Math.sin,c1=cos(x/2),c2=cos(y/2),c3=cos(z/2),s1=sin(x/2),s2=sin(y/2),s3=sin(z/2);switch(order){case"XYZ":this._x=s1*c2*c3+c1*s2*s3,this._y=c1*s2*c3-s1*c2*s3,this._z=c1*c2*s3+s1*s2*c3,this._w=c1*c2*c3-s1*s2*s3;break;case"YXZ":this._x=s1*c2*c3+c1*s2*s3,this._y=c1*s2*c3-s1*c2*s3,this._z=c1*c2*s3-s1*s2*c3,this._w=c1*c2*c3+s1*s2*s3;break;case"ZXY":this._x=s1*c2*c3-c1*s2*s3,this._y=c1*s2*c3+s1*c2*s3,this._z=c1*c2*s3+s1*s2*c3,this._w=c1*c2*c3-s1*s2*s3;break;case"ZYX":this._x=s1*c2*c3-c1*s2*s3,this._y=c1*s2*c3+s1*c2*s3,this._z=c1*c2*s3-s1*s2*c3,this._w=c1*c2*c3+s1*s2*s3;break;case"YZX":this._x=s1*c2*c3+c1*s2*s3,this._y=c1*s2*c3+s1*c2*s3,this._z=c1*c2*s3-s1*s2*c3,this._w=c1*c2*c3-s1*s2*s3;break;case"XZY":this._x=s1*c2*c3-c1*s2*s3,this._y=c1*s2*c3-s1*c2*s3,this._z=c1*c2*s3+s1*s2*c3,this._w=c1*c2*c3+s1*s2*s3;break;default:warn("Quaternion: .setFromEuler() encountered an unknown order: "+order)}return!0===update&&this._onChangeCallback(),this}setFromAxisAngle(axis,angle){const halfAngle=angle/2,s=Math.sin(halfAngle);return this._x=axis.x*s,this._y=axis.y*s,this._z=axis.z*s,this._w=Math.cos(halfAngle),this._onChangeCallback(),this}setFromRotationMatrix(m){const te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10],trace=m11+m22+m33;if(trace>0){const s=.5/Math.sqrt(trace+1);this._w=.25/s,this._x=(m32-m23)*s,this._y=(m13-m31)*s,this._z=(m21-m12)*s}else if(m11>m22&&m11>m33){const s=2*Math.sqrt(1+m11-m22-m33);this._w=(m32-m23)/s,this._x=.25*s,this._y=(m12+m21)/s,this._z=(m13+m31)/s}else if(m22>m33){const s=2*Math.sqrt(1+m22-m11-m33);this._w=(m13-m31)/s,this._x=(m12+m21)/s,this._y=.25*s,this._z=(m23+m32)/s}else{const s=2*Math.sqrt(1+m33-m11-m22);this._w=(m21-m12)/s,this._x=(m13+m31)/s,this._y=(m23+m32)/s,this._z=.25*s}return this._onChangeCallback(),this}setFromUnitVectors(vFrom,vTo){let r=vFrom.dot(vTo)+1;return r<1e-8?(r=0,Math.abs(vFrom.x)>Math.abs(vFrom.z)?(this._x=-vFrom.y,this._y=vFrom.x,this._z=0,this._w=r):(this._x=0,this._y=-vFrom.z,this._z=vFrom.y,this._w=r)):(this._x=vFrom.y*vTo.z-vFrom.z*vTo.y,this._y=vFrom.z*vTo.x-vFrom.x*vTo.z,this._z=vFrom.x*vTo.y-vFrom.y*vTo.x,this._w=r),this.normalize()}angleTo(q){return 2*Math.acos(Math.abs(clamp$3(this.dot(q),-1,1)))}rotateTowards(q,step){const angle=this.angleTo(q);if(0===angle)return this;const t=Math.min(1,step/angle);return this.slerp(q,t),this}identity(){return this.set(0,0,0,1)}invert(){return this.conjugate()}conjugate(){return this._x*=-1,this._y*=-1,this._z*=-1,this._onChangeCallback(),this}dot(v){return this._x*v._x+this._y*v._y+this._z*v._z+this._w*v._w}lengthSq(){return this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w}length(){return Math.sqrt(this._x*this._x+this._y*this._y+this._z*this._z+this._w*this._w)}normalize(){let l=this.length();return 0===l?(this._x=0,this._y=0,this._z=0,this._w=1):(l=1/l,this._x=this._x*l,this._y=this._y*l,this._z=this._z*l,this._w=this._w*l),this._onChangeCallback(),this}multiply(q){return this.multiplyQuaternions(this,q)}premultiply(q){return this.multiplyQuaternions(q,this)}multiplyQuaternions(a,b){const qax=a._x,qay=a._y,qaz=a._z,qaw=a._w,qbx=b._x,qby=b._y,qbz=b._z,qbw=b._w;return this._x=qax*qbw+qaw*qbx+qay*qbz-qaz*qby,this._y=qay*qbw+qaw*qby+qaz*qbx-qax*qbz,this._z=qaz*qbw+qaw*qbz+qax*qby-qay*qbx,this._w=qaw*qbw-qax*qbx-qay*qby-qaz*qbz,this._onChangeCallback(),this}slerp(qb,t){let x=qb._x,y=qb._y,z=qb._z,w=qb._w,dot=this.dot(qb);dot<0&&(x=-x,y=-y,z=-z,w=-w,dot=-dot);let s=1-t;if(dot<.9995){const theta=Math.acos(dot),sin=Math.sin(theta);s=Math.sin(s*theta)/sin,t=Math.sin(t*theta)/sin,this._x=this._x*s+x*t,this._y=this._y*s+y*t,this._z=this._z*s+z*t,this._w=this._w*s+w*t,this._onChangeCallback()}else this._x=this._x*s+x*t,this._y=this._y*s+y*t,this._z=this._z*s+z*t,this._w=this._w*s+w*t,this.normalize();return this}slerpQuaternions(qa,qb,t){return this.copy(qa).slerp(qb,t)}random(){const theta1=2*Math.PI*Math.random(),theta2=2*Math.PI*Math.random(),x0=Math.random(),r1=Math.sqrt(1-x0),r2=Math.sqrt(x0);return this.set(r1*Math.sin(theta1),r1*Math.cos(theta1),r2*Math.sin(theta2),r2*Math.cos(theta2))}equals(quaternion){return quaternion._x===this._x&&quaternion._y===this._y&&quaternion._z===this._z&&quaternion._w===this._w}fromArray(array,offset=0){return this._x=array[offset],this._y=array[offset+1],this._z=array[offset+2],this._w=array[offset+3],this._onChangeCallback(),this}toArray(array=[],offset=0){return array[offset]=this._x,array[offset+1]=this._y,array[offset+2]=this._z,array[offset+3]=this._w,array}fromBufferAttribute(attribute,index){return this._x=attribute.getX(index),this._y=attribute.getY(index),this._z=attribute.getZ(index),this._w=attribute.getW(index),this._onChangeCallback(),this}toJSON(){return this.toArray()}_onChange(callback){return this._onChangeCallback=callback,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._w}}class Vector3{constructor(x=0,y=0,z=0){Vector3.prototype.isVector3=!0,this.x=x,this.y=y,this.z=z}set(x,y,z){return void 0===z&&(z=this.z),this.x=x,this.y=y,this.z=z,this}setScalar(scalar){return this.x=scalar,this.y=scalar,this.z=scalar,this}setX(x){return this.x=x,this}setY(y){return this.y=y,this}setZ(z){return this.z=z,this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;default:throw new Error("index is out of range: "+index)}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;default:throw new Error("index is out of range: "+index)}}clone(){return new this.constructor(this.x,this.y,this.z)}copy(v){return this.x=v.x,this.y=v.y,this.z=v.z,this}add(v){return this.x+=v.x,this.y+=v.y,this.z+=v.z,this}addScalar(s){return this.x+=s,this.y+=s,this.z+=s,this}addVectors(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this.z=a.z+b.z,this}addScaledVector(v,s){return this.x+=v.x*s,this.y+=v.y*s,this.z+=v.z*s,this}sub(v){return this.x-=v.x,this.y-=v.y,this.z-=v.z,this}subScalar(s){return this.x-=s,this.y-=s,this.z-=s,this}subVectors(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this.z=a.z-b.z,this}multiply(v){return this.x*=v.x,this.y*=v.y,this.z*=v.z,this}multiplyScalar(scalar){return this.x*=scalar,this.y*=scalar,this.z*=scalar,this}multiplyVectors(a,b){return this.x=a.x*b.x,this.y=a.y*b.y,this.z=a.z*b.z,this}applyEuler(euler){return this.applyQuaternion(_quaternion$5.setFromEuler(euler))}applyAxisAngle(axis,angle){return this.applyQuaternion(_quaternion$5.setFromAxisAngle(axis,angle))}applyMatrix3(m){const x=this.x,y=this.y,z=this.z,e=m.elements;return this.x=e[0]*x+e[3]*y+e[6]*z,this.y=e[1]*x+e[4]*y+e[7]*z,this.z=e[2]*x+e[5]*y+e[8]*z,this}applyNormalMatrix(m){return this.applyMatrix3(m).normalize()}applyMatrix4(m){const x=this.x,y=this.y,z=this.z,e=m.elements,w=1/(e[3]*x+e[7]*y+e[11]*z+e[15]);return this.x=(e[0]*x+e[4]*y+e[8]*z+e[12])*w,this.y=(e[1]*x+e[5]*y+e[9]*z+e[13])*w,this.z=(e[2]*x+e[6]*y+e[10]*z+e[14])*w,this}applyQuaternion(q){const vx=this.x,vy=this.y,vz=this.z,qx=q.x,qy=q.y,qz=q.z,qw=q.w,tx=2*(qy*vz-qz*vy),ty=2*(qz*vx-qx*vz),tz=2*(qx*vy-qy*vx);return this.x=vx+qw*tx+qy*tz-qz*ty,this.y=vy+qw*ty+qz*tx-qx*tz,this.z=vz+qw*tz+qx*ty-qy*tx,this}project(camera){return this.applyMatrix4(camera.matrixWorldInverse).applyMatrix4(camera.projectionMatrix)}unproject(camera){return this.applyMatrix4(camera.projectionMatrixInverse).applyMatrix4(camera.matrixWorld)}transformDirection(m){const x=this.x,y=this.y,z=this.z,e=m.elements;return this.x=e[0]*x+e[4]*y+e[8]*z,this.y=e[1]*x+e[5]*y+e[9]*z,this.z=e[2]*x+e[6]*y+e[10]*z,this.normalize()}divide(v){return this.x/=v.x,this.y/=v.y,this.z/=v.z,this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}min(v){return this.x=Math.min(this.x,v.x),this.y=Math.min(this.y,v.y),this.z=Math.min(this.z,v.z),this}max(v){return this.x=Math.max(this.x,v.x),this.y=Math.max(this.y,v.y),this.z=Math.max(this.z,v.z),this}clamp(min,max){return this.x=clamp$3(this.x,min.x,max.x),this.y=clamp$3(this.y,min.y,max.y),this.z=clamp$3(this.z,min.z,max.z),this}clampScalar(minVal,maxVal){return this.x=clamp$3(this.x,minVal,maxVal),this.y=clamp$3(this.y,minVal,maxVal),this.z=clamp$3(this.z,minVal,maxVal),this}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$3(length,min,max))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)}normalize(){return this.divideScalar(this.length()||1)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v,alpha){return this.x+=(v.x-this.x)*alpha,this.y+=(v.y-this.y)*alpha,this.z+=(v.z-this.z)*alpha,this}lerpVectors(v1,v2,alpha){return this.x=v1.x+(v2.x-v1.x)*alpha,this.y=v1.y+(v2.y-v1.y)*alpha,this.z=v1.z+(v2.z-v1.z)*alpha,this}cross(v){return this.crossVectors(this,v)}crossVectors(a,b){const ax=a.x,ay=a.y,az=a.z,bx=b.x,by=b.y,bz=b.z;return this.x=ay*bz-az*by,this.y=az*bx-ax*bz,this.z=ax*by-ay*bx,this}projectOnVector(v){const denominator=v.lengthSq();if(0===denominator)return this.set(0,0,0);const scalar=v.dot(this)/denominator;return this.copy(v).multiplyScalar(scalar)}projectOnPlane(planeNormal){return _vector$c.copy(this).projectOnVector(planeNormal),this.sub(_vector$c)}reflect(normal){return this.sub(_vector$c.copy(normal).multiplyScalar(2*this.dot(normal)))}angleTo(v){const denominator=Math.sqrt(this.lengthSq()*v.lengthSq());if(0===denominator)return Math.PI/2;const theta=this.dot(v)/denominator;return Math.acos(clamp$3(theta,-1,1))}distanceTo(v){return Math.sqrt(this.distanceToSquared(v))}distanceToSquared(v){const dx=this.x-v.x,dy=this.y-v.y,dz=this.z-v.z;return dx*dx+dy*dy+dz*dz}manhattanDistanceTo(v){return Math.abs(this.x-v.x)+Math.abs(this.y-v.y)+Math.abs(this.z-v.z)}setFromSpherical(s){return this.setFromSphericalCoords(s.radius,s.phi,s.theta)}setFromSphericalCoords(radius,phi,theta){const sinPhiRadius=Math.sin(phi)*radius;return this.x=sinPhiRadius*Math.sin(theta),this.y=Math.cos(phi)*radius,this.z=sinPhiRadius*Math.cos(theta),this}setFromCylindrical(c){return this.setFromCylindricalCoords(c.radius,c.theta,c.y)}setFromCylindricalCoords(radius,theta,y){return this.x=radius*Math.sin(theta),this.y=y,this.z=radius*Math.cos(theta),this}setFromMatrixPosition(m){const e=m.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this}setFromMatrixScale(m){const sx=this.setFromMatrixColumn(m,0).length(),sy=this.setFromMatrixColumn(m,1).length(),sz=this.setFromMatrixColumn(m,2).length();return this.x=sx,this.y=sy,this.z=sz,this}setFromMatrixColumn(m,index){return this.fromArray(m.elements,4*index)}setFromMatrix3Column(m,index){return this.fromArray(m.elements,3*index)}setFromEuler(e){return this.x=e._x,this.y=e._y,this.z=e._z,this}setFromColor(c){return this.x=c.r,this.y=c.g,this.z=c.b,this}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z}fromArray(array,offset=0){return this.x=array[offset],this.y=array[offset+1],this.z=array[offset+2],this}toArray(array=[],offset=0){return array[offset]=this.x,array[offset+1]=this.y,array[offset+2]=this.z,array}fromBufferAttribute(attribute,index){return this.x=attribute.getX(index),this.y=attribute.getY(index),this.z=attribute.getZ(index),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this}randomDirection(){const theta=Math.random()*Math.PI*2,u=2*Math.random()-1,c=Math.sqrt(1-u*u);return this.x=c*Math.cos(theta),this.y=u,this.z=c*Math.sin(theta),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z}}const _vector$c=/*@__PURE__*/new Vector3,_quaternion$5=/*@__PURE__*/new Quaternion;class Matrix3{constructor(n11,n12,n13,n21,n22,n23,n31,n32,n33){Matrix3.prototype.isMatrix3=!0,this.elements=[1,0,0,0,1,0,0,0,1],void 0!==n11&&this.set(n11,n12,n13,n21,n22,n23,n31,n32,n33)}set(n11,n12,n13,n21,n22,n23,n31,n32,n33){const te=this.elements;return te[0]=n11,te[1]=n21,te[2]=n31,te[3]=n12,te[4]=n22,te[5]=n32,te[6]=n13,te[7]=n23,te[8]=n33,this}identity(){return this.set(1,0,0,0,1,0,0,0,1),this}copy(m){const te=this.elements,me=m.elements;return te[0]=me[0],te[1]=me[1],te[2]=me[2],te[3]=me[3],te[4]=me[4],te[5]=me[5],te[6]=me[6],te[7]=me[7],te[8]=me[8],this}extractBasis(xAxis,yAxis,zAxis){return xAxis.setFromMatrix3Column(this,0),yAxis.setFromMatrix3Column(this,1),zAxis.setFromMatrix3Column(this,2),this}setFromMatrix4(m){const me=m.elements;return this.set(me[0],me[4],me[8],me[1],me[5],me[9],me[2],me[6],me[10]),this}multiply(m){return this.multiplyMatrices(this,m)}premultiply(m){return this.multiplyMatrices(m,this)}multiplyMatrices(a,b){const ae=a.elements,be=b.elements,te=this.elements,a11=ae[0],a12=ae[3],a13=ae[6],a21=ae[1],a22=ae[4],a23=ae[7],a31=ae[2],a32=ae[5],a33=ae[8],b11=be[0],b12=be[3],b13=be[6],b21=be[1],b22=be[4],b23=be[7],b31=be[2],b32=be[5],b33=be[8];return te[0]=a11*b11+a12*b21+a13*b31,te[3]=a11*b12+a12*b22+a13*b32,te[6]=a11*b13+a12*b23+a13*b33,te[1]=a21*b11+a22*b21+a23*b31,te[4]=a21*b12+a22*b22+a23*b32,te[7]=a21*b13+a22*b23+a23*b33,te[2]=a31*b11+a32*b21+a33*b31,te[5]=a31*b12+a32*b22+a33*b32,te[8]=a31*b13+a32*b23+a33*b33,this}multiplyScalar(s){const te=this.elements;return te[0]*=s,te[3]*=s,te[6]*=s,te[1]*=s,te[4]*=s,te[7]*=s,te[2]*=s,te[5]*=s,te[8]*=s,this}determinant(){const te=this.elements,a=te[0],b=te[1],c=te[2],d=te[3],e=te[4],f=te[5],g=te[6],h=te[7],i=te[8];return a*e*i-a*f*h-b*d*i+b*f*g+c*d*h-c*e*g}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n12=te[3],n22=te[4],n32=te[5],n13=te[6],n23=te[7],n33=te[8],t11=n33*n22-n32*n23,t12=n32*n13-n33*n12,t13=n23*n12-n22*n13,det=n11*t11+n21*t12+n31*t13;if(0===det)return this.set(0,0,0,0,0,0,0,0,0);const detInv=1/det;return te[0]=t11*detInv,te[1]=(n31*n23-n33*n21)*detInv,te[2]=(n32*n21-n31*n22)*detInv,te[3]=t12*detInv,te[4]=(n33*n11-n31*n13)*detInv,te[5]=(n31*n12-n32*n11)*detInv,te[6]=t13*detInv,te[7]=(n21*n13-n23*n11)*detInv,te[8]=(n22*n11-n21*n12)*detInv,this}transpose(){let tmp;const m=this.elements;return tmp=m[1],m[1]=m[3],m[3]=tmp,tmp=m[2],m[2]=m[6],m[6]=tmp,tmp=m[5],m[5]=m[7],m[7]=tmp,this}getNormalMatrix(matrix4){return this.setFromMatrix4(matrix4).invert().transpose()}transposeIntoArray(r){const m=this.elements;return r[0]=m[0],r[1]=m[3],r[2]=m[6],r[3]=m[1],r[4]=m[4],r[5]=m[7],r[6]=m[2],r[7]=m[5],r[8]=m[8],this}setUvTransform(tx,ty,sx,sy,rotation,cx,cy){const c=Math.cos(rotation),s=Math.sin(rotation);return this.set(sx*c,sx*s,-sx*(c*cx+s*cy)+cx+tx,-sy*s,sy*c,-sy*(-s*cx+c*cy)+cy+ty,0,0,1),this}scale(sx,sy){return this.premultiply(_m3.makeScale(sx,sy)),this}rotate(theta){return this.premultiply(_m3.makeRotation(-theta)),this}translate(tx,ty){return this.premultiply(_m3.makeTranslation(tx,ty)),this}makeTranslation(x,y){return x.isVector2?this.set(1,0,x.x,0,1,x.y,0,0,1):this.set(1,0,x,0,1,y,0,0,1),this}makeRotation(theta){const c=Math.cos(theta),s=Math.sin(theta);return this.set(c,-s,0,s,c,0,0,0,1),this}makeScale(x,y){return this.set(x,0,0,0,y,0,0,0,1),this}equals(matrix){const te=this.elements,me=matrix.elements;for(let i=0;i<9;i++)if(te[i]!==me[i])return!1;return!0}fromArray(array,offset=0){for(let i=0;i<9;i++)this.elements[i]=array[i+offset];return this}toArray(array=[],offset=0){const te=this.elements;return array[offset]=te[0],array[offset+1]=te[1],array[offset+2]=te[2],array[offset+3]=te[3],array[offset+4]=te[4],array[offset+5]=te[5],array[offset+6]=te[6],array[offset+7]=te[7],array[offset+8]=te[8],array}clone(){return(new this.constructor).fromArray(this.elements)}}const _m3=/*@__PURE__*/new Matrix3,LINEAR_REC709_TO_XYZ=/*@__PURE__*/(new Matrix3).set(.4123908,.3575843,.1804808,.212639,.7151687,.0721923,.0193308,.1191948,.9505322),XYZ_TO_LINEAR_REC709=/*@__PURE__*/(new Matrix3).set(3.2409699,-1.5373832,-.4986108,-.9692436,1.8759675,.0415551,.0556301,-.203977,1.0569715);function createColorManagement(){const ColorManagement={enabled:!0,workingColorSpace:"srgb-linear",spaces:{},convert:function(color,sourceColorSpace,targetColorSpace){return!1!==this.enabled&&sourceColorSpace!==targetColorSpace&&sourceColorSpace&&targetColorSpace?("srgb"===this.spaces[sourceColorSpace].transfer&&(color.r=SRGBToLinear(color.r),color.g=SRGBToLinear(color.g),color.b=SRGBToLinear(color.b)),this.spaces[sourceColorSpace].primaries!==this.spaces[targetColorSpace].primaries&&(color.applyMatrix3(this.spaces[sourceColorSpace].toXYZ),color.applyMatrix3(this.spaces[targetColorSpace].fromXYZ)),"srgb"===this.spaces[targetColorSpace].transfer&&(color.r=LinearToSRGB(color.r),color.g=LinearToSRGB(color.g),color.b=LinearToSRGB(color.b)),color):color},workingToColorSpace:function(color,targetColorSpace){return this.convert(color,this.workingColorSpace,targetColorSpace)},colorSpaceToWorking:function(color,sourceColorSpace){return this.convert(color,sourceColorSpace,this.workingColorSpace)},getPrimaries:function(colorSpace){return this.spaces[colorSpace].primaries},getTransfer:function(colorSpace){return""===colorSpace?"linear":this.spaces[colorSpace].transfer},getToneMappingMode:function(colorSpace){return this.spaces[colorSpace].outputColorSpaceConfig.toneMappingMode||"standard"},getLuminanceCoefficients:function(target,colorSpace=this.workingColorSpace){return target.fromArray(this.spaces[colorSpace].luminanceCoefficients)},define:function(colorSpaces){Object.assign(this.spaces,colorSpaces)},_getMatrix:function(targetMatrix,sourceColorSpace,targetColorSpace){return targetMatrix.copy(this.spaces[sourceColorSpace].toXYZ).multiply(this.spaces[targetColorSpace].fromXYZ)},_getDrawingBufferColorSpace:function(colorSpace){return this.spaces[colorSpace].outputColorSpaceConfig.drawingBufferColorSpace},_getUnpackColorSpace:function(colorSpace=this.workingColorSpace){return this.spaces[colorSpace].workingColorSpaceConfig.unpackColorSpace},fromWorkingColorSpace:function(color,targetColorSpace){return warnOnce("ColorManagement: .fromWorkingColorSpace() has been renamed to .workingToColorSpace()."),ColorManagement.workingToColorSpace(color,targetColorSpace)},toWorkingColorSpace:function(color,sourceColorSpace){return warnOnce("ColorManagement: .toWorkingColorSpace() has been renamed to .colorSpaceToWorking()."),ColorManagement.colorSpaceToWorking(color,sourceColorSpace)}},REC709_PRIMARIES=[.64,.33,.3,.6,.15,.06],REC709_LUMINANCE_COEFFICIENTS=[.2126,.7152,.0722],D65=[.3127,.329];return ColorManagement.define({[LinearSRGBColorSpace]:{primaries:REC709_PRIMARIES,whitePoint:D65,transfer:"linear",toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:REC709_LUMINANCE_COEFFICIENTS,workingColorSpaceConfig:{unpackColorSpace:"srgb"},outputColorSpaceConfig:{drawingBufferColorSpace:"srgb"}},[SRGBColorSpace]:{primaries:REC709_PRIMARIES,whitePoint:D65,transfer:"srgb",toXYZ:LINEAR_REC709_TO_XYZ,fromXYZ:XYZ_TO_LINEAR_REC709,luminanceCoefficients:REC709_LUMINANCE_COEFFICIENTS,outputColorSpaceConfig:{drawingBufferColorSpace:"srgb"}}}),ColorManagement}const ColorManagement=/*@__PURE__*/createColorManagement();function SRGBToLinear(c){return c<.04045?.0773993808*c:Math.pow(.9478672986*c+.0521327014,2.4)}function LinearToSRGB(c){return c<.0031308?12.92*c:1.055*Math.pow(c,.41666)-.055}let _canvas;class ImageUtils{static getDataURL(image,type="image/png"){if(/^data:/i.test(image.src))return image.src;if("undefined"==typeof HTMLCanvasElement)return image.src;let canvas;if(image instanceof HTMLCanvasElement)canvas=image;else{void 0===_canvas&&(_canvas=createElementNS("canvas")),_canvas.width=image.width,_canvas.height=image.height;const context=_canvas.getContext("2d");image instanceof ImageData?context.putImageData(image,0,0):context.drawImage(image,0,0,image.width,image.height),canvas=_canvas}return canvas.toDataURL(type)}static sRGBToLinear(image){if("undefined"!=typeof HTMLImageElement&&image instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&image instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&image instanceof ImageBitmap){const canvas=createElementNS("canvas");canvas.width=image.width,canvas.height=image.height;const context=canvas.getContext("2d");context.drawImage(image,0,0,image.width,image.height);const imageData=context.getImageData(0,0,image.width,image.height),data=imageData.data;for(let i=0;i<data.length;i++)data[i]=255*SRGBToLinear(data[i]/255);return context.putImageData(imageData,0,0),canvas}if(image.data){const data=image.data.slice(0);for(let i=0;i<data.length;i++)data instanceof Uint8Array||data instanceof Uint8ClampedArray?data[i]=Math.floor(255*SRGBToLinear(data[i]/255)):data[i]=SRGBToLinear(data[i]);return{data:data,width:image.width,height:image.height}}return warn("ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),image}}let _sourceId=0;class Source{constructor(data=null){this.isSource=!0,Object.defineProperty(this,"id",{value:_sourceId++}),this.uuid=generateUUID(),this.data=data,this.dataReady=!0,this.version=0}getSize(target){const data=this.data;return"undefined"!=typeof HTMLVideoElement&&data instanceof HTMLVideoElement?target.set(data.videoWidth,data.videoHeight,0):"undefined"!=typeof VideoFrame&&data instanceof VideoFrame?target.set(data.displayHeight,data.displayWidth,0):null!==data?target.set(data.width,data.height,data.depth||0):target.set(0,0,0),target}set needsUpdate(value){!0===value&&this.version++}toJSON(meta){const isRootObject=void 0===meta||"string"==typeof meta;if(!isRootObject&&void 0!==meta.images[this.uuid])return meta.images[this.uuid];const output={uuid:this.uuid,url:""},data=this.data;if(null!==data){let url;if(Array.isArray(data)){url=[];for(let i=0,l=data.length;i<l;i++)data[i].isDataTexture?url.push(serializeImage(data[i].image)):url.push(serializeImage(data[i]))}else url=serializeImage(data);output.url=url}return isRootObject||(meta.images[this.uuid]=output),output}}function serializeImage(image){return"undefined"!=typeof HTMLImageElement&&image instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&image instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&image instanceof ImageBitmap?ImageUtils.getDataURL(image):image.data?{data:Array.from(image.data),width:image.width,height:image.height,type:image.data.constructor.name}:(warn("Texture: Unable to serialize Texture."),{})}let _textureId=0;const _tempVec3=/*@__PURE__*/new Vector3;class Texture extends EventDispatcher{constructor(image=Texture.DEFAULT_IMAGE,mapping=Texture.DEFAULT_MAPPING,wrapS=1001,wrapT=1001,magFilter=1006,minFilter=1008,format=1023,type=1009,anisotropy=Texture.DEFAULT_ANISOTROPY,colorSpace=""){super(),this.isTexture=!0,Object.defineProperty(this,"id",{value:_textureId++}),this.uuid=generateUUID(),this.name="",this.source=new Source(image),this.mipmaps=[],this.mapping=mapping,this.channel=0,this.wrapS=wrapS,this.wrapT=wrapT,this.magFilter=magFilter,this.minFilter=minFilter,this.anisotropy=anisotropy,this.format=format,this.internalFormat=null,this.type=type,this.offset=new Vector2(0,0),this.repeat=new Vector2(1,1),this.center=new Vector2(0,0),this.rotation=0,this.matrixAutoUpdate=!0,this.matrix=new Matrix3,this.generateMipmaps=!0,this.premultiplyAlpha=!1,this.flipY=!0,this.unpackAlignment=4,this.colorSpace=colorSpace,this.userData={},this.updateRanges=[],this.version=0,this.onUpdate=null,this.renderTarget=null,this.isRenderTargetTexture=!1,this.isArrayTexture=!!(image&&image.depth&&image.depth>1),this.pmremVersion=0}get width(){return this.source.getSize(_tempVec3).x}get height(){return this.source.getSize(_tempVec3).y}get depth(){return this.source.getSize(_tempVec3).z}get image(){return this.source.data}set image(value=null){this.source.data=value}updateMatrix(){this.matrix.setUvTransform(this.offset.x,this.offset.y,this.repeat.x,this.repeat.y,this.rotation,this.center.x,this.center.y)}addUpdateRange(start,count){this.updateRanges.push({start:start,count:count})}clearUpdateRanges(){this.updateRanges.length=0}clone(){return(new this.constructor).copy(this)}copy(source){return this.name=source.name,this.source=source.source,this.mipmaps=source.mipmaps.slice(0),this.mapping=source.mapping,this.channel=source.channel,this.wrapS=source.wrapS,this.wrapT=source.wrapT,this.magFilter=source.magFilter,this.minFilter=source.minFilter,this.anisotropy=source.anisotropy,this.format=source.format,this.internalFormat=source.internalFormat,this.type=source.type,this.offset.copy(source.offset),this.repeat.copy(source.repeat),this.center.copy(source.center),this.rotation=source.rotation,this.matrixAutoUpdate=source.matrixAutoUpdate,this.matrix.copy(source.matrix),this.generateMipmaps=source.generateMipmaps,this.premultiplyAlpha=source.premultiplyAlpha,this.flipY=source.flipY,this.unpackAlignment=source.unpackAlignment,this.colorSpace=source.colorSpace,this.renderTarget=source.renderTarget,this.isRenderTargetTexture=source.isRenderTargetTexture,this.isArrayTexture=source.isArrayTexture,this.userData=JSON.parse(JSON.stringify(source.userData)),this.needsUpdate=!0,this}setValues(values){for(const key in values){const newValue=values[key];if(void 0===newValue){warn(`Texture.setValues(): parameter '${key}' has value of undefined.`);continue}const currentValue=this[key];void 0!==currentValue?currentValue&&newValue&&currentValue.isVector2&&newValue.isVector2||currentValue&&newValue&&currentValue.isVector3&&newValue.isVector3||currentValue&&newValue&&currentValue.isMatrix3&&newValue.isMatrix3?currentValue.copy(newValue):this[key]=newValue:warn(`Texture.setValues(): property '${key}' does not exist.`)}}toJSON(meta){const isRootObject=void 0===meta||"string"==typeof meta;if(!isRootObject&&void 0!==meta.textures[this.uuid])return meta.textures[this.uuid];const output={metadata:{version:4.7,type:"Texture",generator:"Texture.toJSON"},uuid:this.uuid,name:this.name,image:this.source.toJSON(meta).uuid,mapping:this.mapping,channel:this.channel,repeat:[this.repeat.x,this.repeat.y],offset:[this.offset.x,this.offset.y],center:[this.center.x,this.center.y],rotation:this.rotation,wrap:[this.wrapS,this.wrapT],format:this.format,internalFormat:this.internalFormat,type:this.type,colorSpace:this.colorSpace,minFilter:this.minFilter,magFilter:this.magFilter,anisotropy:this.anisotropy,flipY:this.flipY,generateMipmaps:this.generateMipmaps,premultiplyAlpha:this.premultiplyAlpha,unpackAlignment:this.unpackAlignment};return Object.keys(this.userData).length>0&&(output.userData=this.userData),isRootObject||(meta.textures[this.uuid]=output),output}dispose(){this.dispatchEvent({type:"dispose"})}transformUv(uv){if(300!==this.mapping)return uv;if(uv.applyMatrix3(this.matrix),uv.x<0||uv.x>1)switch(this.wrapS){case 1e3:uv.x=uv.x-Math.floor(uv.x);break;case 1001:uv.x=uv.x<0?0:1;break;case 1002:1===Math.abs(Math.floor(uv.x)%2)?uv.x=Math.ceil(uv.x)-uv.x:uv.x=uv.x-Math.floor(uv.x)}if(uv.y<0||uv.y>1)switch(this.wrapT){case 1e3:uv.y=uv.y-Math.floor(uv.y);break;case 1001:uv.y=uv.y<0?0:1;break;case 1002:1===Math.abs(Math.floor(uv.y)%2)?uv.y=Math.ceil(uv.y)-uv.y:uv.y=uv.y-Math.floor(uv.y)}return this.flipY&&(uv.y=1-uv.y),uv}set needsUpdate(value){!0===value&&(this.version++,this.source.needsUpdate=!0)}set needsPMREMUpdate(value){!0===value&&this.pmremVersion++}}Texture.DEFAULT_IMAGE=null,Texture.DEFAULT_MAPPING=300,Texture.DEFAULT_ANISOTROPY=1;class Vector4{constructor(x=0,y=0,z=0,w=1){Vector4.prototype.isVector4=!0,this.x=x,this.y=y,this.z=z,this.w=w}get width(){return this.z}set width(value){this.z=value}get height(){return this.w}set height(value){this.w=value}set(x,y,z,w){return this.x=x,this.y=y,this.z=z,this.w=w,this}setScalar(scalar){return this.x=scalar,this.y=scalar,this.z=scalar,this.w=scalar,this}setX(x){return this.x=x,this}setY(y){return this.y=y,this}setZ(z){return this.z=z,this}setW(w){return this.w=w,this}setComponent(index,value){switch(index){case 0:this.x=value;break;case 1:this.y=value;break;case 2:this.z=value;break;case 3:this.w=value;break;default:throw new Error("index is out of range: "+index)}return this}getComponent(index){switch(index){case 0:return this.x;case 1:return this.y;case 2:return this.z;case 3:return this.w;default:throw new Error("index is out of range: "+index)}}clone(){return new this.constructor(this.x,this.y,this.z,this.w)}copy(v){return this.x=v.x,this.y=v.y,this.z=v.z,this.w=void 0!==v.w?v.w:1,this}add(v){return this.x+=v.x,this.y+=v.y,this.z+=v.z,this.w+=v.w,this}addScalar(s){return this.x+=s,this.y+=s,this.z+=s,this.w+=s,this}addVectors(a,b){return this.x=a.x+b.x,this.y=a.y+b.y,this.z=a.z+b.z,this.w=a.w+b.w,this}addScaledVector(v,s){return this.x+=v.x*s,this.y+=v.y*s,this.z+=v.z*s,this.w+=v.w*s,this}sub(v){return this.x-=v.x,this.y-=v.y,this.z-=v.z,this.w-=v.w,this}subScalar(s){return this.x-=s,this.y-=s,this.z-=s,this.w-=s,this}subVectors(a,b){return this.x=a.x-b.x,this.y=a.y-b.y,this.z=a.z-b.z,this.w=a.w-b.w,this}multiply(v){return this.x*=v.x,this.y*=v.y,this.z*=v.z,this.w*=v.w,this}multiplyScalar(scalar){return this.x*=scalar,this.y*=scalar,this.z*=scalar,this.w*=scalar,this}applyMatrix4(m){const x=this.x,y=this.y,z=this.z,w=this.w,e=m.elements;return this.x=e[0]*x+e[4]*y+e[8]*z+e[12]*w,this.y=e[1]*x+e[5]*y+e[9]*z+e[13]*w,this.z=e[2]*x+e[6]*y+e[10]*z+e[14]*w,this.w=e[3]*x+e[7]*y+e[11]*z+e[15]*w,this}divide(v){return this.x/=v.x,this.y/=v.y,this.z/=v.z,this.w/=v.w,this}divideScalar(scalar){return this.multiplyScalar(1/scalar)}setAxisAngleFromQuaternion(q){this.w=2*Math.acos(q.w);const s=Math.sqrt(1-q.w*q.w);return s<1e-4?(this.x=1,this.y=0,this.z=0):(this.x=q.x/s,this.y=q.y/s,this.z=q.z/s),this}setAxisAngleFromRotationMatrix(m){let angle,x,y,z;const te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];if(Math.abs(m12-m21)<.01&&Math.abs(m13-m31)<.01&&Math.abs(m23-m32)<.01){if(Math.abs(m12+m21)<.1&&Math.abs(m13+m31)<.1&&Math.abs(m23+m32)<.1&&Math.abs(m11+m22+m33-3)<.1)return this.set(1,0,0,0),this;angle=Math.PI;const xx=(m11+1)/2,yy=(m22+1)/2,zz=(m33+1)/2,xy=(m12+m21)/4,xz=(m13+m31)/4,yz=(m23+m32)/4;return xx>yy&&xx>zz?xx<.01?(x=0,y=.707106781,z=.707106781):(x=Math.sqrt(xx),y=xy/x,z=xz/x):yy>zz?yy<.01?(x=.707106781,y=0,z=.707106781):(y=Math.sqrt(yy),x=xy/y,z=yz/y):zz<.01?(x=.707106781,y=.707106781,z=0):(z=Math.sqrt(zz),x=xz/z,y=yz/z),this.set(x,y,z,angle),this}let s=Math.sqrt((m32-m23)*(m32-m23)+(m13-m31)*(m13-m31)+(m21-m12)*(m21-m12));return Math.abs(s)<.001&&(s=1),this.x=(m32-m23)/s,this.y=(m13-m31)/s,this.z=(m21-m12)/s,this.w=Math.acos((m11+m22+m33-1)/2),this}setFromMatrixPosition(m){const e=m.elements;return this.x=e[12],this.y=e[13],this.z=e[14],this.w=e[15],this}min(v){return this.x=Math.min(this.x,v.x),this.y=Math.min(this.y,v.y),this.z=Math.min(this.z,v.z),this.w=Math.min(this.w,v.w),this}max(v){return this.x=Math.max(this.x,v.x),this.y=Math.max(this.y,v.y),this.z=Math.max(this.z,v.z),this.w=Math.max(this.w,v.w),this}clamp(min,max){return this.x=clamp$3(this.x,min.x,max.x),this.y=clamp$3(this.y,min.y,max.y),this.z=clamp$3(this.z,min.z,max.z),this.w=clamp$3(this.w,min.w,max.w),this}clampScalar(minVal,maxVal){return this.x=clamp$3(this.x,minVal,maxVal),this.y=clamp$3(this.y,minVal,maxVal),this.z=clamp$3(this.z,minVal,maxVal),this.w=clamp$3(this.w,minVal,maxVal),this}clampLength(min,max){const length=this.length();return this.divideScalar(length||1).multiplyScalar(clamp$3(length,min,max))}floor(){return this.x=Math.floor(this.x),this.y=Math.floor(this.y),this.z=Math.floor(this.z),this.w=Math.floor(this.w),this}ceil(){return this.x=Math.ceil(this.x),this.y=Math.ceil(this.y),this.z=Math.ceil(this.z),this.w=Math.ceil(this.w),this}round(){return this.x=Math.round(this.x),this.y=Math.round(this.y),this.z=Math.round(this.z),this.w=Math.round(this.w),this}roundToZero(){return this.x=Math.trunc(this.x),this.y=Math.trunc(this.y),this.z=Math.trunc(this.z),this.w=Math.trunc(this.w),this}negate(){return this.x=-this.x,this.y=-this.y,this.z=-this.z,this.w=-this.w,this}dot(v){return this.x*v.x+this.y*v.y+this.z*v.z+this.w*v.w}lengthSq(){return this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w}length(){return Math.sqrt(this.x*this.x+this.y*this.y+this.z*this.z+this.w*this.w)}manhattanLength(){return Math.abs(this.x)+Math.abs(this.y)+Math.abs(this.z)+Math.abs(this.w)}normalize(){return this.divideScalar(this.length()||1)}setLength(length){return this.normalize().multiplyScalar(length)}lerp(v,alpha){return this.x+=(v.x-this.x)*alpha,this.y+=(v.y-this.y)*alpha,this.z+=(v.z-this.z)*alpha,this.w+=(v.w-this.w)*alpha,this}lerpVectors(v1,v2,alpha){return this.x=v1.x+(v2.x-v1.x)*alpha,this.y=v1.y+(v2.y-v1.y)*alpha,this.z=v1.z+(v2.z-v1.z)*alpha,this.w=v1.w+(v2.w-v1.w)*alpha,this}equals(v){return v.x===this.x&&v.y===this.y&&v.z===this.z&&v.w===this.w}fromArray(array,offset=0){return this.x=array[offset],this.y=array[offset+1],this.z=array[offset+2],this.w=array[offset+3],this}toArray(array=[],offset=0){return array[offset]=this.x,array[offset+1]=this.y,array[offset+2]=this.z,array[offset+3]=this.w,array}fromBufferAttribute(attribute,index){return this.x=attribute.getX(index),this.y=attribute.getY(index),this.z=attribute.getZ(index),this.w=attribute.getW(index),this}random(){return this.x=Math.random(),this.y=Math.random(),this.z=Math.random(),this.w=Math.random(),this}*[Symbol.iterator](){yield this.x,yield this.y,yield this.z,yield this.w}}class RenderTarget extends EventDispatcher{constructor(width=1,height=1,options={}){super(),options=Object.assign({generateMipmaps:!1,internalFormat:null,minFilter:1006,depthBuffer:!0,stencilBuffer:!1,resolveDepthBuffer:!0,resolveStencilBuffer:!0,depthTexture:null,samples:0,count:1,depth:1,multiview:!1},options),this.isRenderTarget=!0,this.width=width,this.height=height,this.depth=options.depth,this.scissor=new Vector4(0,0,width,height),this.scissorTest=!1,this.viewport=new Vector4(0,0,width,height);const image={width:width,height:height,depth:options.depth},texture=new Texture(image);this.textures=[];const count=options.count;for(let i=0;i<count;i++)this.textures[i]=texture.clone(),this.textures[i].isRenderTargetTexture=!0,this.textures[i].renderTarget=this;this._setTextureOptions(options),this.depthBuffer=options.depthBuffer,this.stencilBuffer=options.stencilBuffer,this.resolveDepthBuffer=options.resolveDepthBuffer,this.resolveStencilBuffer=options.resolveStencilBuffer,this._depthTexture=null,this.depthTexture=options.depthTexture,this.samples=options.samples,this.multiview=options.multiview}_setTextureOptions(options={}){const values={minFilter:1006,generateMipmaps:!1,flipY:!1,internalFormat:null};void 0!==options.mapping&&(values.mapping=options.mapping),void 0!==options.wrapS&&(values.wrapS=options.wrapS),void 0!==options.wrapT&&(values.wrapT=options.wrapT),void 0!==options.wrapR&&(values.wrapR=options.wrapR),void 0!==options.magFilter&&(values.magFilter=options.magFilter),void 0!==options.minFilter&&(values.minFilter=options.minFilter),void 0!==options.format&&(values.format=options.format),void 0!==options.type&&(values.type=options.type),void 0!==options.anisotropy&&(values.anisotropy=options.anisotropy),void 0!==options.colorSpace&&(values.colorSpace=options.colorSpace),void 0!==options.flipY&&(values.flipY=options.flipY),void 0!==options.generateMipmaps&&(values.generateMipmaps=options.generateMipmaps),void 0!==options.internalFormat&&(values.internalFormat=options.internalFormat);for(let i=0;i<this.textures.length;i++){this.textures[i].setValues(values)}}get texture(){return this.textures[0]}set texture(value){this.textures[0]=value}set depthTexture(current){null!==this._depthTexture&&(this._depthTexture.renderTarget=null),null!==current&&(current.renderTarget=this),this._depthTexture=current}get depthTexture(){return this._depthTexture}setSize(width,height,depth=1){if(this.width!==width||this.height!==height||this.depth!==depth){this.width=width,this.height=height,this.depth=depth;for(let i=0,il=this.textures.length;i<il;i++)this.textures[i].image.width=width,this.textures[i].image.height=height,this.textures[i].image.depth=depth,!0!==this.textures[i].isData3DTexture&&(this.textures[i].isArrayTexture=this.textures[i].image.depth>1);this.dispose()}this.viewport.set(0,0,width,height),this.scissor.set(0,0,width,height)}clone(){return(new this.constructor).copy(this)}copy(source){this.width=source.width,this.height=source.height,this.depth=source.depth,this.scissor.copy(source.scissor),this.scissorTest=source.scissorTest,this.viewport.copy(source.viewport),this.textures.length=0;for(let i=0,il=source.textures.length;i<il;i++){this.textures[i]=source.textures[i].clone(),this.textures[i].isRenderTargetTexture=!0,this.textures[i].renderTarget=this;const image=Object.assign({},source.textures[i].image);this.textures[i].source=new Source(image)}return this.depthBuffer=source.depthBuffer,this.stencilBuffer=source.stencilBuffer,this.resolveDepthBuffer=source.resolveDepthBuffer,this.resolveStencilBuffer=source.resolveStencilBuffer,null!==source.depthTexture&&(this.depthTexture=source.depthTexture.clone()),this.samples=source.samples,this}dispose(){this.dispatchEvent({type:"dispose"})}}class DataArrayTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null),this.isDataArrayTexture=!0,this.image={data:data,width:width,height:height,depth:depth},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1,this.layerUpdates=new Set}addLayerUpdate(layerIndex){this.layerUpdates.add(layerIndex)}clearLayerUpdates(){this.layerUpdates.clear()}}class Data3DTexture extends Texture{constructor(data=null,width=1,height=1,depth=1){super(null),this.isData3DTexture=!0,this.image={data:data,width:width,height:height,depth:depth},this.magFilter=1003,this.minFilter=1003,this.wrapR=1001,this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}class Matrix4{constructor(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){Matrix4.prototype.isMatrix4=!0,this.elements=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],void 0!==n11&&this.set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44)}set(n11,n12,n13,n14,n21,n22,n23,n24,n31,n32,n33,n34,n41,n42,n43,n44){const te=this.elements;return te[0]=n11,te[4]=n12,te[8]=n13,te[12]=n14,te[1]=n21,te[5]=n22,te[9]=n23,te[13]=n24,te[2]=n31,te[6]=n32,te[10]=n33,te[14]=n34,te[3]=n41,te[7]=n42,te[11]=n43,te[15]=n44,this}identity(){return this.set(1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1),this}clone(){return(new Matrix4).fromArray(this.elements)}copy(m){const te=this.elements,me=m.elements;return te[0]=me[0],te[1]=me[1],te[2]=me[2],te[3]=me[3],te[4]=me[4],te[5]=me[5],te[6]=me[6],te[7]=me[7],te[8]=me[8],te[9]=me[9],te[10]=me[10],te[11]=me[11],te[12]=me[12],te[13]=me[13],te[14]=me[14],te[15]=me[15],this}copyPosition(m){const te=this.elements,me=m.elements;return te[12]=me[12],te[13]=me[13],te[14]=me[14],this}setFromMatrix3(m){const me=m.elements;return this.set(me[0],me[3],me[6],0,me[1],me[4],me[7],0,me[2],me[5],me[8],0,0,0,0,1),this}extractBasis(xAxis,yAxis,zAxis){return 0===this.determinant()?(xAxis.set(1,0,0),yAxis.set(0,1,0),zAxis.set(0,0,1),this):(xAxis.setFromMatrixColumn(this,0),yAxis.setFromMatrixColumn(this,1),zAxis.setFromMatrixColumn(this,2),this)}makeBasis(xAxis,yAxis,zAxis){return this.set(xAxis.x,yAxis.x,zAxis.x,0,xAxis.y,yAxis.y,zAxis.y,0,xAxis.z,yAxis.z,zAxis.z,0,0,0,0,1),this}extractRotation(m){if(0===m.determinant())return this.identity();const te=this.elements,me=m.elements,scaleX=1/_v1$7.setFromMatrixColumn(m,0).length(),scaleY=1/_v1$7.setFromMatrixColumn(m,1).length(),scaleZ=1/_v1$7.setFromMatrixColumn(m,2).length();return te[0]=me[0]*scaleX,te[1]=me[1]*scaleX,te[2]=me[2]*scaleX,te[3]=0,te[4]=me[4]*scaleY,te[5]=me[5]*scaleY,te[6]=me[6]*scaleY,te[7]=0,te[8]=me[8]*scaleZ,te[9]=me[9]*scaleZ,te[10]=me[10]*scaleZ,te[11]=0,te[12]=0,te[13]=0,te[14]=0,te[15]=1,this}makeRotationFromEuler(euler){const te=this.elements,x=euler.x,y=euler.y,z=euler.z,a=Math.cos(x),b=Math.sin(x),c=Math.cos(y),d=Math.sin(y),e=Math.cos(z),f=Math.sin(z);if("XYZ"===euler.order){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e,te[4]=-c*f,te[8]=d,te[1]=af+be*d,te[5]=ae-bf*d,te[9]=-b*c,te[2]=bf-ae*d,te[6]=be+af*d,te[10]=a*c}else if("YXZ"===euler.order){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce+df*b,te[4]=de*b-cf,te[8]=a*d,te[1]=a*f,te[5]=a*e,te[9]=-b,te[2]=cf*b-de,te[6]=df+ce*b,te[10]=a*c}else if("ZXY"===euler.order){const ce=c*e,cf=c*f,de=d*e,df=d*f;te[0]=ce-df*b,te[4]=-a*f,te[8]=de+cf*b,te[1]=cf+de*b,te[5]=a*e,te[9]=df-ce*b,te[2]=-a*d,te[6]=b,te[10]=a*c}else if("ZYX"===euler.order){const ae=a*e,af=a*f,be=b*e,bf=b*f;te[0]=c*e,te[4]=be*d-af,te[8]=ae*d+bf,te[1]=c*f,te[5]=bf*d+ae,te[9]=af*d-be,te[2]=-d,te[6]=b*c,te[10]=a*c}else if("YZX"===euler.order){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e,te[4]=bd-ac*f,te[8]=bc*f+ad,te[1]=f,te[5]=a*e,te[9]=-b*e,te[2]=-d*e,te[6]=ad*f+bc,te[10]=ac-bd*f}else if("XZY"===euler.order){const ac=a*c,ad=a*d,bc=b*c,bd=b*d;te[0]=c*e,te[4]=-f,te[8]=d*e,te[1]=ac*f+bd,te[5]=a*e,te[9]=ad*f-bc,te[2]=bc*f-ad,te[6]=b*e,te[10]=bd*f+ac}return te[3]=0,te[7]=0,te[11]=0,te[12]=0,te[13]=0,te[14]=0,te[15]=1,this}makeRotationFromQuaternion(q){return this.compose(_zero,q,_one)}lookAt(eye,target,up){const te=this.elements;return _z.subVectors(eye,target),0===_z.lengthSq()&&(_z.z=1),_z.normalize(),_x.crossVectors(up,_z),0===_x.lengthSq()&&(1===Math.abs(up.z)?_z.x+=1e-4:_z.z+=1e-4,_z.normalize(),_x.crossVectors(up,_z)),_x.normalize(),_y.crossVectors(_z,_x),te[0]=_x.x,te[4]=_y.x,te[8]=_z.x,te[1]=_x.y,te[5]=_y.y,te[9]=_z.y,te[2]=_x.z,te[6]=_y.z,te[10]=_z.z,this}multiply(m){return this.multiplyMatrices(this,m)}premultiply(m){return this.multiplyMatrices(m,this)}multiplyMatrices(a,b){const ae=a.elements,be=b.elements,te=this.elements,a11=ae[0],a12=ae[4],a13=ae[8],a14=ae[12],a21=ae[1],a22=ae[5],a23=ae[9],a24=ae[13],a31=ae[2],a32=ae[6],a33=ae[10],a34=ae[14],a41=ae[3],a42=ae[7],a43=ae[11],a44=ae[15],b11=be[0],b12=be[4],b13=be[8],b14=be[12],b21=be[1],b22=be[5],b23=be[9],b24=be[13],b31=be[2],b32=be[6],b33=be[10],b34=be[14],b41=be[3],b42=be[7],b43=be[11],b44=be[15];return te[0]=a11*b11+a12*b21+a13*b31+a14*b41,te[4]=a11*b12+a12*b22+a13*b32+a14*b42,te[8]=a11*b13+a12*b23+a13*b33+a14*b43,te[12]=a11*b14+a12*b24+a13*b34+a14*b44,te[1]=a21*b11+a22*b21+a23*b31+a24*b41,te[5]=a21*b12+a22*b22+a23*b32+a24*b42,te[9]=a21*b13+a22*b23+a23*b33+a24*b43,te[13]=a21*b14+a22*b24+a23*b34+a24*b44,te[2]=a31*b11+a32*b21+a33*b31+a34*b41,te[6]=a31*b12+a32*b22+a33*b32+a34*b42,te[10]=a31*b13+a32*b23+a33*b33+a34*b43,te[14]=a31*b14+a32*b24+a33*b34+a34*b44,te[3]=a41*b11+a42*b21+a43*b31+a44*b41,te[7]=a41*b12+a42*b22+a43*b32+a44*b42,te[11]=a41*b13+a42*b23+a43*b33+a44*b43,te[15]=a41*b14+a42*b24+a43*b34+a44*b44,this}multiplyScalar(s){const te=this.elements;return te[0]*=s,te[4]*=s,te[8]*=s,te[12]*=s,te[1]*=s,te[5]*=s,te[9]*=s,te[13]*=s,te[2]*=s,te[6]*=s,te[10]*=s,te[14]*=s,te[3]*=s,te[7]*=s,te[11]*=s,te[15]*=s,this}determinant(){const te=this.elements,n11=te[0],n12=te[4],n13=te[8],n14=te[12],n21=te[1],n22=te[5],n23=te[9],n24=te[13],n31=te[2],n32=te[6],n33=te[10],n34=te[14],n41=te[3],n42=te[7],n43=te[11],n44=te[15],t11=n23*n34-n24*n33,t12=n22*n34-n24*n32,t13=n22*n33-n23*n32,t21=n21*n34-n24*n31,t22=n21*n33-n23*n31,t23=n21*n32-n22*n31;return n11*(n42*t11-n43*t12+n44*t13)-n12*(n41*t11-n43*t21+n44*t22)+n13*(n41*t12-n42*t21+n44*t23)-n14*(n41*t13-n42*t22+n43*t23)}transpose(){const te=this.elements;let tmp;return tmp=te[1],te[1]=te[4],te[4]=tmp,tmp=te[2],te[2]=te[8],te[8]=tmp,tmp=te[6],te[6]=te[9],te[9]=tmp,tmp=te[3],te[3]=te[12],te[12]=tmp,tmp=te[7],te[7]=te[13],te[13]=tmp,tmp=te[11],te[11]=te[14],te[14]=tmp,this}setPosition(x,y,z){const te=this.elements;return x.isVector3?(te[12]=x.x,te[13]=x.y,te[14]=x.z):(te[12]=x,te[13]=y,te[14]=z),this}invert(){const te=this.elements,n11=te[0],n21=te[1],n31=te[2],n41=te[3],n12=te[4],n22=te[5],n32=te[6],n42=te[7],n13=te[8],n23=te[9],n33=te[10],n43=te[11],n14=te[12],n24=te[13],n34=te[14],n44=te[15],t1=n11*n22-n21*n12,t2=n11*n32-n31*n12,t3=n11*n42-n41*n12,t4=n21*n32-n31*n22,t5=n21*n42-n41*n22,t6=n31*n42-n41*n32,t7=n13*n24-n23*n14,t8=n13*n34-n33*n14,t9=n13*n44-n43*n14,t10=n23*n34-n33*n24,t11=n23*n44-n43*n24,t12=n33*n44-n43*n34,det=t1*t12-t2*t11+t3*t10+t4*t9-t5*t8+t6*t7;if(0===det)return this.set(0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0);const detInv=1/det;return te[0]=(n22*t12-n32*t11+n42*t10)*detInv,te[1]=(n31*t11-n21*t12-n41*t10)*detInv,te[2]=(n24*t6-n34*t5+n44*t4)*detInv,te[3]=(n33*t5-n23*t6-n43*t4)*detInv,te[4]=(n32*t9-n12*t12-n42*t8)*detInv,te[5]=(n11*t12-n31*t9+n41*t8)*detInv,te[6]=(n34*t3-n14*t6-n44*t2)*detInv,te[7]=(n13*t6-n33*t3+n43*t2)*detInv,te[8]=(n12*t11-n22*t9+n42*t7)*detInv,te[9]=(n21*t9-n11*t11-n41*t7)*detInv,te[10]=(n14*t5-n24*t3+n44*t1)*detInv,te[11]=(n23*t3-n13*t5-n43*t1)*detInv,te[12]=(n22*t8-n12*t10-n32*t7)*detInv,te[13]=(n11*t10-n21*t8+n31*t7)*detInv,te[14]=(n24*t2-n14*t4-n34*t1)*detInv,te[15]=(n13*t4-n23*t2+n33*t1)*detInv,this}scale(v){const te=this.elements,x=v.x,y=v.y,z=v.z;return te[0]*=x,te[4]*=y,te[8]*=z,te[1]*=x,te[5]*=y,te[9]*=z,te[2]*=x,te[6]*=y,te[10]*=z,te[3]*=x,te[7]*=y,te[11]*=z,this}getMaxScaleOnAxis(){const te=this.elements,scaleXSq=te[0]*te[0]+te[1]*te[1]+te[2]*te[2],scaleYSq=te[4]*te[4]+te[5]*te[5]+te[6]*te[6],scaleZSq=te[8]*te[8]+te[9]*te[9]+te[10]*te[10];return Math.sqrt(Math.max(scaleXSq,scaleYSq,scaleZSq))}makeTranslation(x,y,z){return x.isVector3?this.set(1,0,0,x.x,0,1,0,x.y,0,0,1,x.z,0,0,0,1):this.set(1,0,0,x,0,1,0,y,0,0,1,z,0,0,0,1),this}makeRotationX(theta){const c=Math.cos(theta),s=Math.sin(theta);return this.set(1,0,0,0,0,c,-s,0,0,s,c,0,0,0,0,1),this}makeRotationY(theta){const c=Math.cos(theta),s=Math.sin(theta);return this.set(c,0,s,0,0,1,0,0,-s,0,c,0,0,0,0,1),this}makeRotationZ(theta){const c=Math.cos(theta),s=Math.sin(theta);return this.set(c,-s,0,0,s,c,0,0,0,0,1,0,0,0,0,1),this}makeRotationAxis(axis,angle){const c=Math.cos(angle),s=Math.sin(angle),t=1-c,x=axis.x,y=axis.y,z=axis.z,tx=t*x,ty=t*y;return this.set(tx*x+c,tx*y-s*z,tx*z+s*y,0,tx*y+s*z,ty*y+c,ty*z-s*x,0,tx*z-s*y,ty*z+s*x,t*z*z+c,0,0,0,0,1),this}makeScale(x,y,z){return this.set(x,0,0,0,0,y,0,0,0,0,z,0,0,0,0,1),this}makeShear(xy,xz,yx,yz,zx,zy){return this.set(1,yx,zx,0,xy,1,zy,0,xz,yz,1,0,0,0,0,1),this}compose(position,quaternion,scale){const te=this.elements,x=quaternion._x,y=quaternion._y,z=quaternion._z,w=quaternion._w,x2=x+x,y2=y+y,z2=z+z,xx=x*x2,xy=x*y2,xz=x*z2,yy=y*y2,yz=y*z2,zz=z*z2,wx=w*x2,wy=w*y2,wz=w*z2,sx=scale.x,sy=scale.y,sz=scale.z;return te[0]=(1-(yy+zz))*sx,te[1]=(xy+wz)*sx,te[2]=(xz-wy)*sx,te[3]=0,te[4]=(xy-wz)*sy,te[5]=(1-(xx+zz))*sy,te[6]=(yz+wx)*sy,te[7]=0,te[8]=(xz+wy)*sz,te[9]=(yz-wx)*sz,te[10]=(1-(xx+yy))*sz,te[11]=0,te[12]=position.x,te[13]=position.y,te[14]=position.z,te[15]=1,this}decompose(position,quaternion,scale){const te=this.elements;position.x=te[12],position.y=te[13],position.z=te[14];const det=this.determinant();if(0===det)return scale.set(1,1,1),quaternion.identity(),this;let sx=_v1$7.set(te[0],te[1],te[2]).length();const sy=_v1$7.set(te[4],te[5],te[6]).length(),sz=_v1$7.set(te[8],te[9],te[10]).length();det<0&&(sx=-sx),_m1$2.copy(this);const invSX=1/sx,invSY=1/sy,invSZ=1/sz;return _m1$2.elements[0]*=invSX,_m1$2.elements[1]*=invSX,_m1$2.elements[2]*=invSX,_m1$2.elements[4]*=invSY,_m1$2.elements[5]*=invSY,_m1$2.elements[6]*=invSY,_m1$2.elements[8]*=invSZ,_m1$2.elements[9]*=invSZ,_m1$2.elements[10]*=invSZ,quaternion.setFromRotationMatrix(_m1$2),scale.x=sx,scale.y=sy,scale.z=sz,this}makePerspective(left,right,top,bottom,near,far,coordinateSystem=2e3,reversedDepth=!1){const te=this.elements,x=2*near/(right-left),y=2*near/(top-bottom),a=(right+left)/(right-left),b=(top+bottom)/(top-bottom);let c,d;if(reversedDepth)c=near/(far-near),d=far*near/(far-near);else if(2e3===coordinateSystem)c=-(far+near)/(far-near),d=-2*far*near/(far-near);else{if(2001!==coordinateSystem)throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: "+coordinateSystem);c=-far/(far-near),d=-far*near/(far-near)}return te[0]=x,te[4]=0,te[8]=a,te[12]=0,te[1]=0,te[5]=y,te[9]=b,te[13]=0,te[2]=0,te[6]=0,te[10]=c,te[14]=d,te[3]=0,te[7]=0,te[11]=-1,te[15]=0,this}makeOrthographic(left,right,top,bottom,near,far,coordinateSystem=2e3,reversedDepth=!1){const te=this.elements,x=2/(right-left),y=2/(top-bottom),a=-(right+left)/(right-left),b=-(top+bottom)/(top-bottom);let c,d;if(reversedDepth)c=1/(far-near),d=far/(far-near);else if(2e3===coordinateSystem)c=-2/(far-near),d=-(far+near)/(far-near);else{if(2001!==coordinateSystem)throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: "+coordinateSystem);c=-1/(far-near),d=-near/(far-near)}return te[0]=x,te[4]=0,te[8]=0,te[12]=a,te[1]=0,te[5]=y,te[9]=0,te[13]=b,te[2]=0,te[6]=0,te[10]=c,te[14]=d,te[3]=0,te[7]=0,te[11]=0,te[15]=1,this}equals(matrix){const te=this.elements,me=matrix.elements;for(let i=0;i<16;i++)if(te[i]!==me[i])return!1;return!0}fromArray(array,offset=0){for(let i=0;i<16;i++)this.elements[i]=array[i+offset];return this}toArray(array=[],offset=0){const te=this.elements;return array[offset]=te[0],array[offset+1]=te[1],array[offset+2]=te[2],array[offset+3]=te[3],array[offset+4]=te[4],array[offset+5]=te[5],array[offset+6]=te[6],array[offset+7]=te[7],array[offset+8]=te[8],array[offset+9]=te[9],array[offset+10]=te[10],array[offset+11]=te[11],array[offset+12]=te[12],array[offset+13]=te[13],array[offset+14]=te[14],array[offset+15]=te[15],array}}const _v1$7=/*@__PURE__*/new Vector3,_m1$2=/*@__PURE__*/new Matrix4,_zero=/*@__PURE__*/new Vector3(0,0,0),_one=/*@__PURE__*/new Vector3(1,1,1),_x=/*@__PURE__*/new Vector3,_y=/*@__PURE__*/new Vector3,_z=/*@__PURE__*/new Vector3,_matrix$2=/*@__PURE__*/new Matrix4,_quaternion$4=/*@__PURE__*/new Quaternion;class Euler{constructor(x=0,y=0,z=0,order=Euler.DEFAULT_ORDER){this.isEuler=!0,this._x=x,this._y=y,this._z=z,this._order=order}get x(){return this._x}set x(value){this._x=value,this._onChangeCallback()}get y(){return this._y}set y(value){this._y=value,this._onChangeCallback()}get z(){return this._z}set z(value){this._z=value,this._onChangeCallback()}get order(){return this._order}set order(value){this._order=value,this._onChangeCallback()}set(x,y,z,order=this._order){return this._x=x,this._y=y,this._z=z,this._order=order,this._onChangeCallback(),this}clone(){return new this.constructor(this._x,this._y,this._z,this._order)}copy(euler){return this._x=euler._x,this._y=euler._y,this._z=euler._z,this._order=euler._order,this._onChangeCallback(),this}setFromRotationMatrix(m,order=this._order,update=!0){const te=m.elements,m11=te[0],m12=te[4],m13=te[8],m21=te[1],m22=te[5],m23=te[9],m31=te[2],m32=te[6],m33=te[10];switch(order){case"XYZ":this._y=Math.asin(clamp$3(m13,-1,1)),Math.abs(m13)<.9999999?(this._x=Math.atan2(-m23,m33),this._z=Math.atan2(-m12,m11)):(this._x=Math.atan2(m32,m22),this._z=0);break;case"YXZ":this._x=Math.asin(-clamp$3(m23,-1,1)),Math.abs(m23)<.9999999?(this._y=Math.atan2(m13,m33),this._z=Math.atan2(m21,m22)):(this._y=Math.atan2(-m31,m11),this._z=0);break;case"ZXY":this._x=Math.asin(clamp$3(m32,-1,1)),Math.abs(m32)<.9999999?(this._y=Math.atan2(-m31,m33),this._z=Math.atan2(-m12,m22)):(this._y=0,this._z=Math.atan2(m21,m11));break;case"ZYX":this._y=Math.asin(-clamp$3(m31,-1,1)),Math.abs(m31)<.9999999?(this._x=Math.atan2(m32,m33),this._z=Math.atan2(m21,m11)):(this._x=0,this._z=Math.atan2(-m12,m22));break;case"YZX":this._z=Math.asin(clamp$3(m21,-1,1)),Math.abs(m21)<.9999999?(this._x=Math.atan2(-m23,m22),this._y=Math.atan2(-m31,m11)):(this._x=0,this._y=Math.atan2(m13,m33));break;case"XZY":this._z=Math.asin(-clamp$3(m12,-1,1)),Math.abs(m12)<.9999999?(this._x=Math.atan2(m32,m22),this._y=Math.atan2(m13,m11)):(this._x=Math.atan2(-m23,m33),this._y=0);break;default:warn("Euler: .setFromRotationMatrix() encountered an unknown order: "+order)}return this._order=order,!0===update&&this._onChangeCallback(),this}setFromQuaternion(q,order,update){return _matrix$2.makeRotationFromQuaternion(q),this.setFromRotationMatrix(_matrix$2,order,update)}setFromVector3(v,order=this._order){return this.set(v.x,v.y,v.z,order)}reorder(newOrder){return _quaternion$4.setFromEuler(this),this.setFromQuaternion(_quaternion$4,newOrder)}equals(euler){return euler._x===this._x&&euler._y===this._y&&euler._z===this._z&&euler._order===this._order}fromArray(array){return this._x=array[0],this._y=array[1],this._z=array[2],void 0!==array[3]&&(this._order=array[3]),this._onChangeCallback(),this}toArray(array=[],offset=0){return array[offset]=this._x,array[offset+1]=this._y,array[offset+2]=this._z,array[offset+3]=this._order,array}_onChange(callback){return this._onChangeCallback=callback,this}_onChangeCallback(){}*[Symbol.iterator](){yield this._x,yield this._y,yield this._z,yield this._order}}Euler.DEFAULT_ORDER="XYZ";class Layers{constructor(){this.mask=1}set(layer){this.mask=1<<layer>>>0}enable(layer){this.mask|=1<<layer}enableAll(){this.mask=-1}toggle(layer){this.mask^=1<<layer}disable(layer){this.mask&=~(1<<layer)}disableAll(){this.mask=0}test(layers){return 0!==(this.mask&layers.mask)}isEnabled(layer){return!!(this.mask&1<<layer)}}let _object3DId=0;const _v1$6=/*@__PURE__*/new Vector3,_q1=/*@__PURE__*/new Quaternion,_m1$1$1=/*@__PURE__*/new Matrix4,_target=/*@__PURE__*/new Vector3,_position$4=/*@__PURE__*/new Vector3,_scale$3=/*@__PURE__*/new Vector3,_quaternion$3=/*@__PURE__*/new Quaternion,_xAxis=/*@__PURE__*/new Vector3(1,0,0),_yAxis$1=/*@__PURE__*/new Vector3(0,1,0),_zAxis=/*@__PURE__*/new Vector3(0,0,1),_addedEvent={type:"added"},_removedEvent={type:"removed"},_childaddedEvent={type:"childadded",child:null},_childremovedEvent={type:"childremoved",child:null};class Object3D extends EventDispatcher{constructor(){super(),this.isObject3D=!0,Object.defineProperty(this,"id",{value:_object3DId++}),this.uuid=generateUUID(),this.name="",this.type="Object3D",this.parent=null,this.children=[],this.up=Object3D.DEFAULT_UP.clone();const position=new Vector3,rotation=new Euler,quaternion=new Quaternion,scale=new Vector3(1,1,1);rotation._onChange(function onRotationChange(){quaternion.setFromEuler(rotation,!1)}),quaternion._onChange(function onQuaternionChange(){rotation.setFromQuaternion(quaternion,void 0,!1)}),Object.defineProperties(this,{position:{configurable:!0,enumerable:!0,value:position},rotation:{configurable:!0,enumerable:!0,value:rotation},quaternion:{configurable:!0,enumerable:!0,value:quaternion},scale:{configurable:!0,enumerable:!0,value:scale},modelViewMatrix:{value:new Matrix4},normalMatrix:{value:new Matrix3}}),this.matrix=new Matrix4,this.matrixWorld=new Matrix4,this.matrixAutoUpdate=Object3D.DEFAULT_MATRIX_AUTO_UPDATE,this.matrixWorldAutoUpdate=Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,this.matrixWorldNeedsUpdate=!1,this.layers=new Layers,this.visible=!0,this.castShadow=!1,this.receiveShadow=!1,this.frustumCulled=!0,this.renderOrder=0,this.animations=[],this.customDepthMaterial=void 0,this.customDistanceMaterial=void 0,this.static=!1,this.userData={},this.pivot=null}onBeforeShadow(){}onAfterShadow(){}onBeforeRender(){}onAfterRender(){}applyMatrix4(matrix){this.matrixAutoUpdate&&this.updateMatrix(),this.matrix.premultiply(matrix),this.matrix.decompose(this.position,this.quaternion,this.scale)}applyQuaternion(q){return this.quaternion.premultiply(q),this}setRotationFromAxisAngle(axis,angle){this.quaternion.setFromAxisAngle(axis,angle)}setRotationFromEuler(euler){this.quaternion.setFromEuler(euler,!0)}setRotationFromMatrix(m){this.quaternion.setFromRotationMatrix(m)}setRotationFromQuaternion(q){this.quaternion.copy(q)}rotateOnAxis(axis,angle){return _q1.setFromAxisAngle(axis,angle),this.quaternion.multiply(_q1),this}rotateOnWorldAxis(axis,angle){return _q1.setFromAxisAngle(axis,angle),this.quaternion.premultiply(_q1),this}rotateX(angle){return this.rotateOnAxis(_xAxis,angle)}rotateY(angle){return this.rotateOnAxis(_yAxis$1,angle)}rotateZ(angle){return this.rotateOnAxis(_zAxis,angle)}translateOnAxis(axis,distance){return _v1$6.copy(axis).applyQuaternion(this.quaternion),this.position.add(_v1$6.multiplyScalar(distance)),this}translateX(distance){return this.translateOnAxis(_xAxis,distance)}translateY(distance){return this.translateOnAxis(_yAxis$1,distance)}translateZ(distance){return this.translateOnAxis(_zAxis,distance)}localToWorld(vector){return this.updateWorldMatrix(!0,!1),vector.applyMatrix4(this.matrixWorld)}worldToLocal(vector){return this.updateWorldMatrix(!0,!1),vector.applyMatrix4(_m1$1$1.copy(this.matrixWorld).invert())}lookAt(x,y,z){x.isVector3?_target.copy(x):_target.set(x,y,z);const parent=this.parent;this.updateWorldMatrix(!0,!1),_position$4.setFromMatrixPosition(this.matrixWorld),this.isCamera||this.isLight?_m1$1$1.lookAt(_position$4,_target,this.up):_m1$1$1.lookAt(_target,_position$4,this.up),this.quaternion.setFromRotationMatrix(_m1$1$1),parent&&(_m1$1$1.extractRotation(parent.matrixWorld),_q1.setFromRotationMatrix(_m1$1$1),this.quaternion.premultiply(_q1.invert()))}add(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.add(arguments[i]);return this}return object===this?(error("Object3D.add: object can't be added as a child of itself.",object),this):(object&&object.isObject3D?(object.removeFromParent(),object.parent=this,this.children.push(object),object.dispatchEvent(_addedEvent),_childaddedEvent.child=object,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null):error("Object3D.add: object not an instance of THREE.Object3D.",object),this)}remove(object){if(arguments.length>1){for(let i=0;i<arguments.length;i++)this.remove(arguments[i]);return this}const index=this.children.indexOf(object);return-1!==index&&(object.parent=null,this.children.splice(index,1),object.dispatchEvent(_removedEvent),_childremovedEvent.child=object,this.dispatchEvent(_childremovedEvent),_childremovedEvent.child=null),this}removeFromParent(){const parent=this.parent;return null!==parent&&parent.remove(this),this}clear(){return this.remove(...this.children)}attach(object){return this.updateWorldMatrix(!0,!1),_m1$1$1.copy(this.matrixWorld).invert(),null!==object.parent&&(object.parent.updateWorldMatrix(!0,!1),_m1$1$1.multiply(object.parent.matrixWorld)),object.applyMatrix4(_m1$1$1),object.removeFromParent(),object.parent=this,this.children.push(object),object.updateWorldMatrix(!1,!0),object.dispatchEvent(_addedEvent),_childaddedEvent.child=object,this.dispatchEvent(_childaddedEvent),_childaddedEvent.child=null,this}getObjectById(id){return this.getObjectByProperty("id",id)}getObjectByName(name){return this.getObjectByProperty("name",name)}getObjectByProperty(name,value){if(this[name]===value)return this;for(let i=0,l=this.children.length;i<l;i++){const object=this.children[i].getObjectByProperty(name,value);if(void 0!==object)return object}}getObjectsByProperty(name,value,result=[]){this[name]===value&&result.push(this);const children=this.children;for(let i=0,l=children.length;i<l;i++)children[i].getObjectsByProperty(name,value,result);return result}getWorldPosition(target){return this.updateWorldMatrix(!0,!1),target.setFromMatrixPosition(this.matrixWorld)}getWorldQuaternion(target){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$4,target,_scale$3),target}getWorldScale(target){return this.updateWorldMatrix(!0,!1),this.matrixWorld.decompose(_position$4,_quaternion$3,target),target}getWorldDirection(target){this.updateWorldMatrix(!0,!1);const e=this.matrixWorld.elements;return target.set(e[8],e[9],e[10]).normalize()}raycast(){}traverse(callback){callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++)children[i].traverse(callback)}traverseVisible(callback){if(!1===this.visible)return;callback(this);const children=this.children;for(let i=0,l=children.length;i<l;i++)children[i].traverseVisible(callback)}traverseAncestors(callback){const parent=this.parent;null!==parent&&(callback(parent),parent.traverseAncestors(callback))}updateMatrix(){this.matrix.compose(this.position,this.quaternion,this.scale);const pivot=this.pivot;if(null!==pivot){const px=pivot.x,py=pivot.y,pz=pivot.z,te=this.matrix.elements;te[12]+=px-te[0]*px-te[4]*py-te[8]*pz,te[13]+=py-te[1]*px-te[5]*py-te[9]*pz,te[14]+=pz-te[2]*px-te[6]*py-te[10]*pz}this.matrixWorldNeedsUpdate=!0}updateMatrixWorld(force){this.matrixAutoUpdate&&this.updateMatrix(),(this.matrixWorldNeedsUpdate||force)&&(!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),this.matrixWorldNeedsUpdate=!1,force=!0);const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].updateMatrixWorld(force)}}updateWorldMatrix(updateParents,updateChildren){const parent=this.parent;if(!0===updateParents&&null!==parent&&parent.updateWorldMatrix(!0,!1),this.matrixAutoUpdate&&this.updateMatrix(),!0===this.matrixWorldAutoUpdate&&(null===this.parent?this.matrixWorld.copy(this.matrix):this.matrixWorld.multiplyMatrices(this.parent.matrixWorld,this.matrix)),!0===updateChildren){const children=this.children;for(let i=0,l=children.length;i<l;i++){children[i].updateWorldMatrix(!1,!0)}}}toJSON(meta){const isRootObject=void 0===meta||"string"==typeof meta,output={};isRootObject&&(meta={geometries:{},materials:{},textures:{},images:{},shapes:{},skeletons:{},animations:{},nodes:{}},output.metadata={version:4.7,type:"Object",generator:"Object3D.toJSON"});const object={};function serialize(library,element){return void 0===library[element.uuid]&&(library[element.uuid]=element.toJSON(meta)),element.uuid}if(object.uuid=this.uuid,object.type=this.type,""!==this.name&&(object.name=this.name),!0===this.castShadow&&(object.castShadow=!0),!0===this.receiveShadow&&(object.receiveShadow=!0),!1===this.visible&&(object.visible=!1),!1===this.frustumCulled&&(object.frustumCulled=!1),0!==this.renderOrder&&(object.renderOrder=this.renderOrder),!1!==this.static&&(object.static=this.static),Object.keys(this.userData).length>0&&(object.userData=this.userData),object.layers=this.layers.mask,object.matrix=this.matrix.toArray(),object.up=this.up.toArray(),null!==this.pivot&&(object.pivot=this.pivot.toArray()),!1===this.matrixAutoUpdate&&(object.matrixAutoUpdate=!1),void 0!==this.morphTargetDictionary&&(object.morphTargetDictionary=Object.assign({},this.morphTargetDictionary)),void 0!==this.morphTargetInfluences&&(object.morphTargetInfluences=this.morphTargetInfluences.slice()),this.isInstancedMesh&&(object.type="InstancedMesh",object.count=this.count,object.instanceMatrix=this.instanceMatrix.toJSON(),null!==this.instanceColor&&(object.instanceColor=this.instanceColor.toJSON())),this.isBatchedMesh&&(object.type="BatchedMesh",object.perObjectFrustumCulled=this.perObjectFrustumCulled,object.sortObjects=this.sortObjects,object.drawRanges=this._drawRanges,object.reservedRanges=this._reservedRanges,object.geometryInfo=this._geometryInfo.map(info=>({...info,boundingBox:info.boundingBox?info.boundingBox.toJSON():void 0,boundingSphere:info.boundingSphere?info.boundingSphere.toJSON():void 0})),object.instanceInfo=this._instanceInfo.map(info=>({...info})),object.availableInstanceIds=this._availableInstanceIds.slice(),object.availableGeometryIds=this._availableGeometryIds.slice(),object.nextIndexStart=this._nextIndexStart,object.nextVertexStart=this._nextVertexStart,object.geometryCount=this._geometryCount,object.maxInstanceCount=this._maxInstanceCount,object.maxVertexCount=this._maxVertexCount,object.maxIndexCount=this._maxIndexCount,object.geometryInitialized=this._geometryInitialized,object.matricesTexture=this._matricesTexture.toJSON(meta),object.indirectTexture=this._indirectTexture.toJSON(meta),null!==this._colorsTexture&&(object.colorsTexture=this._colorsTexture.toJSON(meta)),null!==this.boundingSphere&&(object.boundingSphere=this.boundingSphere.toJSON()),null!==this.boundingBox&&(object.boundingBox=this.boundingBox.toJSON())),this.isScene)this.background&&(this.background.isColor?object.background=this.background.toJSON():this.background.isTexture&&(object.background=this.background.toJSON(meta).uuid)),this.environment&&this.environment.isTexture&&!0!==this.environment.isRenderTargetTexture&&(object.environment=this.environment.toJSON(meta).uuid);else if(this.isMesh||this.isLine||this.isPoints){object.geometry=serialize(meta.geometries,this.geometry);const parameters=this.geometry.parameters;if(void 0!==parameters&&void 0!==parameters.shapes){const shapes=parameters.shapes;if(Array.isArray(shapes))for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];serialize(meta.shapes,shape)}else serialize(meta.shapes,shapes)}}if(this.isSkinnedMesh&&(object.bindMode=this.bindMode,object.bindMatrix=this.bindMatrix.toArray(),void 0!==this.skeleton&&(serialize(meta.skeletons,this.skeleton),object.skeleton=this.skeleton.uuid)),void 0!==this.material)if(Array.isArray(this.material)){const uuids=[];for(let i=0,l=this.material.length;i<l;i++)uuids.push(serialize(meta.materials,this.material[i]));object.material=uuids}else object.material=serialize(meta.materials,this.material);if(this.children.length>0){object.children=[];for(let i=0;i<this.children.length;i++)object.children.push(this.children[i].toJSON(meta).object)}if(this.animations.length>0){object.animations=[];for(let i=0;i<this.animations.length;i++){const animation=this.animations[i];object.animations.push(serialize(meta.animations,animation))}}if(isRootObject){const geometries=extractFromCache(meta.geometries),materials=extractFromCache(meta.materials),textures=extractFromCache(meta.textures),images=extractFromCache(meta.images),shapes=extractFromCache(meta.shapes),skeletons=extractFromCache(meta.skeletons),animations=extractFromCache(meta.animations),nodes=extractFromCache(meta.nodes);geometries.length>0&&(output.geometries=geometries),materials.length>0&&(output.materials=materials),textures.length>0&&(output.textures=textures),images.length>0&&(output.images=images),shapes.length>0&&(output.shapes=shapes),skeletons.length>0&&(output.skeletons=skeletons),animations.length>0&&(output.animations=animations),nodes.length>0&&(output.nodes=nodes)}return output.object=object,output;function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata,values.push(data)}return values}}clone(recursive){return(new this.constructor).copy(this,recursive)}copy(source,recursive=!0){if(this.name=source.name,this.up.copy(source.up),this.position.copy(source.position),this.rotation.order=source.rotation.order,this.quaternion.copy(source.quaternion),this.scale.copy(source.scale),null!==source.pivot&&(this.pivot=source.pivot.clone()),this.matrix.copy(source.matrix),this.matrixWorld.copy(source.matrixWorld),this.matrixAutoUpdate=source.matrixAutoUpdate,this.matrixWorldAutoUpdate=source.matrixWorldAutoUpdate,this.matrixWorldNeedsUpdate=source.matrixWorldNeedsUpdate,this.layers.mask=source.layers.mask,this.visible=source.visible,this.castShadow=source.castShadow,this.receiveShadow=source.receiveShadow,this.frustumCulled=source.frustumCulled,this.renderOrder=source.renderOrder,this.static=source.static,this.animations=source.animations.slice(),this.userData=JSON.parse(JSON.stringify(source.userData)),!0===recursive)for(let i=0;i<source.children.length;i++){const child=source.children[i];this.add(child.clone())}return this}}Object3D.DEFAULT_UP=/*@__PURE__*/new Vector3(0,1,0),Object3D.DEFAULT_MATRIX_AUTO_UPDATE=!0,Object3D.DEFAULT_MATRIX_WORLD_AUTO_UPDATE=!0;class Group extends Object3D{constructor(){super(),this.isGroup=!0,this.type="Group"}}const _moveEvent={type:"move"};class WebXRController{constructor(){this._targetRay=null,this._grip=null,this._hand=null}getHandSpace(){return null===this._hand&&(this._hand=new Group,this._hand.matrixAutoUpdate=!1,this._hand.visible=!1,this._hand.joints={},this._hand.inputState={pinching:!1}),this._hand}getTargetRaySpace(){return null===this._targetRay&&(this._targetRay=new Group,this._targetRay.matrixAutoUpdate=!1,this._targetRay.visible=!1,this._targetRay.hasLinearVelocity=!1,this._targetRay.linearVelocity=new Vector3,this._targetRay.hasAngularVelocity=!1,this._targetRay.angularVelocity=new Vector3),this._targetRay}getGripSpace(){return null===this._grip&&(this._grip=new Group,this._grip.matrixAutoUpdate=!1,this._grip.visible=!1,this._grip.hasLinearVelocity=!1,this._grip.linearVelocity=new Vector3,this._grip.hasAngularVelocity=!1,this._grip.angularVelocity=new Vector3),this._grip}dispatchEvent(event){return null!==this._targetRay&&this._targetRay.dispatchEvent(event),null!==this._grip&&this._grip.dispatchEvent(event),null!==this._hand&&this._hand.dispatchEvent(event),this}connect(inputSource){if(inputSource&&inputSource.hand){const hand=this._hand;if(hand)for(const inputjoint of inputSource.hand.values())this._getHandJoint(hand,inputjoint)}return this.dispatchEvent({type:"connected",data:inputSource}),this}disconnect(inputSource){return this.dispatchEvent({type:"disconnected",data:inputSource}),null!==this._targetRay&&(this._targetRay.visible=!1),null!==this._grip&&(this._grip.visible=!1),null!==this._hand&&(this._hand.visible=!1),this}update(inputSource,frame,referenceSpace){let inputPose=null,gripPose=null,handPose=null;const targetRay=this._targetRay,grip=this._grip,hand=this._hand;if(inputSource&&"visible-blurred"!==frame.session.visibilityState){if(hand&&inputSource.hand){handPose=!0;for(const inputjoint of inputSource.hand.values()){const jointPose=frame.getJointPose(inputjoint,referenceSpace),joint=this._getHandJoint(hand,inputjoint);null!==jointPose&&(joint.matrix.fromArray(jointPose.transform.matrix),joint.matrix.decompose(joint.position,joint.rotation,joint.scale),joint.matrixWorldNeedsUpdate=!0,joint.jointRadius=jointPose.radius),joint.visible=null!==jointPose}const indexTip=hand.joints["index-finger-tip"],thumbTip=hand.joints["thumb-tip"],distance=indexTip.position.distanceTo(thumbTip.position),distanceToPinch=.02,threshold=.005;hand.inputState.pinching&&distance>distanceToPinch+threshold?(hand.inputState.pinching=!1,this.dispatchEvent({type:"pinchend",handedness:inputSource.handedness,target:this})):!hand.inputState.pinching&&distance<=distanceToPinch-threshold&&(hand.inputState.pinching=!0,this.dispatchEvent({type:"pinchstart",handedness:inputSource.handedness,target:this}))}else null!==grip&&inputSource.gripSpace&&(gripPose=frame.getPose(inputSource.gripSpace,referenceSpace),null!==gripPose&&(grip.matrix.fromArray(gripPose.transform.matrix),grip.matrix.decompose(grip.position,grip.rotation,grip.scale),grip.matrixWorldNeedsUpdate=!0,gripPose.linearVelocity?(grip.hasLinearVelocity=!0,grip.linearVelocity.copy(gripPose.linearVelocity)):grip.hasLinearVelocity=!1,gripPose.angularVelocity?(grip.hasAngularVelocity=!0,grip.angularVelocity.copy(gripPose.angularVelocity)):grip.hasAngularVelocity=!1));null!==targetRay&&(inputPose=frame.getPose(inputSource.targetRaySpace,referenceSpace),null===inputPose&&null!==gripPose&&(inputPose=gripPose),null!==inputPose&&(targetRay.matrix.fromArray(inputPose.transform.matrix),targetRay.matrix.decompose(targetRay.position,targetRay.rotation,targetRay.scale),targetRay.matrixWorldNeedsUpdate=!0,inputPose.linearVelocity?(targetRay.hasLinearVelocity=!0,targetRay.linearVelocity.copy(inputPose.linearVelocity)):targetRay.hasLinearVelocity=!1,inputPose.angularVelocity?(targetRay.hasAngularVelocity=!0,targetRay.angularVelocity.copy(inputPose.angularVelocity)):targetRay.hasAngularVelocity=!1,this.dispatchEvent(_moveEvent)))}return null!==targetRay&&(targetRay.visible=null!==inputPose),null!==grip&&(grip.visible=null!==gripPose),null!==hand&&(hand.visible=null!==handPose),this}_getHandJoint(hand,inputjoint){if(void 0===hand.joints[inputjoint.jointName]){const joint=new Group;joint.matrixAutoUpdate=!1,joint.visible=!1,hand.joints[inputjoint.jointName]=joint,hand.add(joint)}return hand.joints[inputjoint.jointName]}}const _colorKeywords={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074},_hslA={h:0,s:0,l:0},_hslB={h:0,s:0,l:0};function hue2rgb(p,q,t){return t<0&&(t+=1),t>1&&(t-=1),t<1/6?p+6*(q-p)*t:t<.5?q:t<2/3?p+6*(q-p)*(2/3-t):p}class Color{constructor(r,g,b){return this.isColor=!0,this.r=1,this.g=1,this.b=1,this.set(r,g,b)}set(r,g,b){if(void 0===g&&void 0===b){const value=r;value&&value.isColor?this.copy(value):"number"==typeof value?this.setHex(value):"string"==typeof value&&this.setStyle(value)}else this.setRGB(r,g,b);return this}setScalar(scalar){return this.r=scalar,this.g=scalar,this.b=scalar,this}setHex(hex,colorSpace="srgb"){return hex=Math.floor(hex),this.r=(hex>>16&255)/255,this.g=(hex>>8&255)/255,this.b=(255&hex)/255,ColorManagement.colorSpaceToWorking(this,colorSpace),this}setRGB(r,g,b,colorSpace=ColorManagement.workingColorSpace){return this.r=r,this.g=g,this.b=b,ColorManagement.colorSpaceToWorking(this,colorSpace),this}setHSL(h,s,l,colorSpace=ColorManagement.workingColorSpace){if(h=euclideanModulo(h,1),s=clamp$3(s,0,1),l=clamp$3(l,0,1),0===s)this.r=this.g=this.b=l;else{const p=l<=.5?l*(1+s):l+s-l*s,q=2*l-p;this.r=hue2rgb(q,p,h+1/3),this.g=hue2rgb(q,p,h),this.b=hue2rgb(q,p,h-1/3)}return ColorManagement.colorSpaceToWorking(this,colorSpace),this}setStyle(style,colorSpace="srgb"){function handleAlpha(string){void 0!==string&&parseFloat(string)<1&&warn("Color: Alpha component of "+style+" will be ignored.")}let m;if(m=/^(\w+)\(([^\)]*)\)/.exec(style)){let color;const name=m[1],components=m[2];switch(name){case"rgb":case"rgba":if(color=/^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return handleAlpha(color[4]),this.setRGB(Math.min(255,parseInt(color[1],10))/255,Math.min(255,parseInt(color[2],10))/255,Math.min(255,parseInt(color[3],10))/255,colorSpace);if(color=/^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return handleAlpha(color[4]),this.setRGB(Math.min(100,parseInt(color[1],10))/100,Math.min(100,parseInt(color[2],10))/100,Math.min(100,parseInt(color[3],10))/100,colorSpace);break;case"hsl":case"hsla":if(color=/^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(components))return handleAlpha(color[4]),this.setHSL(parseFloat(color[1])/360,parseFloat(color[2])/100,parseFloat(color[3])/100,colorSpace);break;default:warn("Color: Unknown color model "+style)}}else if(m=/^\#([A-Fa-f\d]+)$/.exec(style)){const hex=m[1],size=hex.length;if(3===size)return this.setRGB(parseInt(hex.charAt(0),16)/15,parseInt(hex.charAt(1),16)/15,parseInt(hex.charAt(2),16)/15,colorSpace);if(6===size)return this.setHex(parseInt(hex,16),colorSpace);warn("Color: Invalid hex color "+style)}else if(style&&style.length>0)return this.setColorName(style,colorSpace);return this}setColorName(style,colorSpace="srgb"){const hex=_colorKeywords[style.toLowerCase()];return void 0!==hex?this.setHex(hex,colorSpace):warn("Color: Unknown color "+style),this}clone(){return new this.constructor(this.r,this.g,this.b)}copy(color){return this.r=color.r,this.g=color.g,this.b=color.b,this}copySRGBToLinear(color){return this.r=SRGBToLinear(color.r),this.g=SRGBToLinear(color.g),this.b=SRGBToLinear(color.b),this}copyLinearToSRGB(color){return this.r=LinearToSRGB(color.r),this.g=LinearToSRGB(color.g),this.b=LinearToSRGB(color.b),this}convertSRGBToLinear(){return this.copySRGBToLinear(this),this}convertLinearToSRGB(){return this.copyLinearToSRGB(this),this}getHex(colorSpace="srgb"){return ColorManagement.workingToColorSpace(_color.copy(this),colorSpace),65536*Math.round(clamp$3(255*_color.r,0,255))+256*Math.round(clamp$3(255*_color.g,0,255))+Math.round(clamp$3(255*_color.b,0,255))}getHexString(colorSpace="srgb"){return("000000"+this.getHex(colorSpace).toString(16)).slice(-6)}getHSL(target,colorSpace=ColorManagement.workingColorSpace){ColorManagement.workingToColorSpace(_color.copy(this),colorSpace);const r=_color.r,g=_color.g,b=_color.b,max=Math.max(r,g,b),min=Math.min(r,g,b);let hue,saturation;const lightness=(min+max)/2;if(min===max)hue=0,saturation=0;else{const delta=max-min;switch(saturation=lightness<=.5?delta/(max+min):delta/(2-max-min),max){case r:hue=(g-b)/delta+(g<b?6:0);break;case g:hue=(b-r)/delta+2;break;case b:hue=(r-g)/delta+4}hue/=6}return target.h=hue,target.s=saturation,target.l=lightness,target}getRGB(target,colorSpace=ColorManagement.workingColorSpace){return ColorManagement.workingToColorSpace(_color.copy(this),colorSpace),target.r=_color.r,target.g=_color.g,target.b=_color.b,target}getStyle(colorSpace="srgb"){ColorManagement.workingToColorSpace(_color.copy(this),colorSpace);const r=_color.r,g=_color.g,b=_color.b;return"srgb"!==colorSpace?`color(${colorSpace} ${r.toFixed(3)} ${g.toFixed(3)} ${b.toFixed(3)})`:`rgb(${Math.round(255*r)},${Math.round(255*g)},${Math.round(255*b)})`}offsetHSL(h,s,l){return this.getHSL(_hslA),this.setHSL(_hslA.h+h,_hslA.s+s,_hslA.l+l)}add(color){return this.r+=color.r,this.g+=color.g,this.b+=color.b,this}addColors(color1,color2){return this.r=color1.r+color2.r,this.g=color1.g+color2.g,this.b=color1.b+color2.b,this}addScalar(s){return this.r+=s,this.g+=s,this.b+=s,this}sub(color){return this.r=Math.max(0,this.r-color.r),this.g=Math.max(0,this.g-color.g),this.b=Math.max(0,this.b-color.b),this}multiply(color){return this.r*=color.r,this.g*=color.g,this.b*=color.b,this}multiplyScalar(s){return this.r*=s,this.g*=s,this.b*=s,this}lerp(color,alpha){return this.r+=(color.r-this.r)*alpha,this.g+=(color.g-this.g)*alpha,this.b+=(color.b-this.b)*alpha,this}lerpColors(color1,color2,alpha){return this.r=color1.r+(color2.r-color1.r)*alpha,this.g=color1.g+(color2.g-color1.g)*alpha,this.b=color1.b+(color2.b-color1.b)*alpha,this}lerpHSL(color,alpha){this.getHSL(_hslA),color.getHSL(_hslB);const h=lerp(_hslA.h,_hslB.h,alpha),s=lerp(_hslA.s,_hslB.s,alpha),l=lerp(_hslA.l,_hslB.l,alpha);return this.setHSL(h,s,l),this}setFromVector3(v){return this.r=v.x,this.g=v.y,this.b=v.z,this}applyMatrix3(m){const r=this.r,g=this.g,b=this.b,e=m.elements;return this.r=e[0]*r+e[3]*g+e[6]*b,this.g=e[1]*r+e[4]*g+e[7]*b,this.b=e[2]*r+e[5]*g+e[8]*b,this}equals(c){return c.r===this.r&&c.g===this.g&&c.b===this.b}fromArray(array,offset=0){return this.r=array[offset],this.g=array[offset+1],this.b=array[offset+2],this}toArray(array=[],offset=0){return array[offset]=this.r,array[offset+1]=this.g,array[offset+2]=this.b,array}fromBufferAttribute(attribute,index){return this.r=attribute.getX(index),this.g=attribute.getY(index),this.b=attribute.getZ(index),this}toJSON(){return this.getHex()}*[Symbol.iterator](){yield this.r,yield this.g,yield this.b}}const _color=/*@__PURE__*/new Color;Color.NAMES=_colorKeywords;class FogExp2{constructor(color,density=25e-5){this.isFogExp2=!0,this.name="",this.color=new Color(color),this.density=density}clone(){return new FogExp2(this.color,this.density)}toJSON(){return{type:"FogExp2",name:this.name,color:this.color.getHex(),density:this.density}}}class Fog{constructor(color,near=1,far=1e3){this.isFog=!0,this.name="",this.color=new Color(color),this.near=near,this.far=far}clone(){return new Fog(this.color,this.near,this.far)}toJSON(){return{type:"Fog",name:this.name,color:this.color.getHex(),near:this.near,far:this.far}}}class Scene extends Object3D{constructor(){super(),this.isScene=!0,this.type="Scene",this.background=null,this.environment=null,this.fog=null,this.backgroundBlurriness=0,this.backgroundIntensity=1,this.backgroundRotation=new Euler,this.environmentIntensity=1,this.environmentRotation=new Euler,this.overrideMaterial=null,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}copy(source,recursive){return super.copy(source,recursive),null!==source.background&&(this.background=source.background.clone()),null!==source.environment&&(this.environment=source.environment.clone()),null!==source.fog&&(this.fog=source.fog.clone()),this.backgroundBlurriness=source.backgroundBlurriness,this.backgroundIntensity=source.backgroundIntensity,this.backgroundRotation.copy(source.backgroundRotation),this.environmentIntensity=source.environmentIntensity,this.environmentRotation.copy(source.environmentRotation),null!==source.overrideMaterial&&(this.overrideMaterial=source.overrideMaterial.clone()),this.matrixAutoUpdate=source.matrixAutoUpdate,this}toJSON(meta){const data=super.toJSON(meta);return null!==this.fog&&(data.object.fog=this.fog.toJSON()),this.backgroundBlurriness>0&&(data.object.backgroundBlurriness=this.backgroundBlurriness),1!==this.backgroundIntensity&&(data.object.backgroundIntensity=this.backgroundIntensity),data.object.backgroundRotation=this.backgroundRotation.toArray(),1!==this.environmentIntensity&&(data.object.environmentIntensity=this.environmentIntensity),data.object.environmentRotation=this.environmentRotation.toArray(),data}}const _v0$2=/*@__PURE__*/new Vector3,_v1$5=/*@__PURE__*/new Vector3,_v2$4=/*@__PURE__*/new Vector3,_v3$2=/*@__PURE__*/new Vector3,_vab=/*@__PURE__*/new Vector3,_vac=/*@__PURE__*/new Vector3,_vbc=/*@__PURE__*/new Vector3,_vap=/*@__PURE__*/new Vector3,_vbp=/*@__PURE__*/new Vector3,_vcp=/*@__PURE__*/new Vector3,_v40=/*@__PURE__*/new Vector4,_v41=/*@__PURE__*/new Vector4,_v42=/*@__PURE__*/new Vector4;class Triangle{constructor(a=new Vector3,b=new Vector3,c=new Vector3){this.a=a,this.b=b,this.c=c}static getNormal(a,b,c,target){target.subVectors(c,b),_v0$2.subVectors(a,b),target.cross(_v0$2);const targetLengthSq=target.lengthSq();return targetLengthSq>0?target.multiplyScalar(1/Math.sqrt(targetLengthSq)):target.set(0,0,0)}static getBarycoord(point,a,b,c,target){_v0$2.subVectors(c,a),_v1$5.subVectors(b,a),_v2$4.subVectors(point,a);const dot00=_v0$2.dot(_v0$2),dot01=_v0$2.dot(_v1$5),dot02=_v0$2.dot(_v2$4),dot11=_v1$5.dot(_v1$5),dot12=_v1$5.dot(_v2$4),denom=dot00*dot11-dot01*dot01;if(0===denom)return target.set(0,0,0),null;const invDenom=1/denom,u=(dot11*dot02-dot01*dot12)*invDenom,v=(dot00*dot12-dot01*dot02)*invDenom;return target.set(1-u-v,v,u)}static containsPoint(point,a,b,c){return null!==this.getBarycoord(point,a,b,c,_v3$2)&&(_v3$2.x>=0&&_v3$2.y>=0&&_v3$2.x+_v3$2.y<=1)}static getInterpolation(point,p1,p2,p3,v1,v2,v3,target){return null===this.getBarycoord(point,p1,p2,p3,_v3$2)?(target.x=0,target.y=0,"z"in target&&(target.z=0),"w"in target&&(target.w=0),null):(target.setScalar(0),target.addScaledVector(v1,_v3$2.x),target.addScaledVector(v2,_v3$2.y),target.addScaledVector(v3,_v3$2.z),target)}static getInterpolatedAttribute(attr,i1,i2,i3,barycoord,target){return _v40.setScalar(0),_v41.setScalar(0),_v42.setScalar(0),_v40.fromBufferAttribute(attr,i1),_v41.fromBufferAttribute(attr,i2),_v42.fromBufferAttribute(attr,i3),target.setScalar(0),target.addScaledVector(_v40,barycoord.x),target.addScaledVector(_v41,barycoord.y),target.addScaledVector(_v42,barycoord.z),target}static isFrontFacing(a,b,c,direction){return _v0$2.subVectors(c,b),_v1$5.subVectors(a,b),_v0$2.cross(_v1$5).dot(direction)<0}set(a,b,c){return this.a.copy(a),this.b.copy(b),this.c.copy(c),this}setFromPointsAndIndices(points,i0,i1,i2){return this.a.copy(points[i0]),this.b.copy(points[i1]),this.c.copy(points[i2]),this}setFromAttributeAndIndices(attribute,i0,i1,i2){return this.a.fromBufferAttribute(attribute,i0),this.b.fromBufferAttribute(attribute,i1),this.c.fromBufferAttribute(attribute,i2),this}clone(){return(new this.constructor).copy(this)}copy(triangle){return this.a.copy(triangle.a),this.b.copy(triangle.b),this.c.copy(triangle.c),this}getArea(){return _v0$2.subVectors(this.c,this.b),_v1$5.subVectors(this.a,this.b),.5*_v0$2.cross(_v1$5).length()}getMidpoint(target){return target.addVectors(this.a,this.b).add(this.c).multiplyScalar(1/3)}getNormal(target){return Triangle.getNormal(this.a,this.b,this.c,target)}getPlane(target){return target.setFromCoplanarPoints(this.a,this.b,this.c)}getBarycoord(point,target){return Triangle.getBarycoord(point,this.a,this.b,this.c,target)}getInterpolation(point,v1,v2,v3,target){return Triangle.getInterpolation(point,this.a,this.b,this.c,v1,v2,v3,target)}containsPoint(point){return Triangle.containsPoint(point,this.a,this.b,this.c)}isFrontFacing(direction){return Triangle.isFrontFacing(this.a,this.b,this.c,direction)}intersectsBox(box){return box.intersectsTriangle(this)}closestPointToPoint(p,target){const a=this.a,b=this.b,c=this.c;let v,w;_vab.subVectors(b,a),_vac.subVectors(c,a),_vap.subVectors(p,a);const d1=_vab.dot(_vap),d2=_vac.dot(_vap);if(d1<=0&&d2<=0)return target.copy(a);_vbp.subVectors(p,b);const d3=_vab.dot(_vbp),d4=_vac.dot(_vbp);if(d3>=0&&d4<=d3)return target.copy(b);const vc=d1*d4-d3*d2;if(vc<=0&&d1>=0&&d3<=0)return v=d1/(d1-d3),target.copy(a).addScaledVector(_vab,v);_vcp.subVectors(p,c);const d5=_vab.dot(_vcp),d6=_vac.dot(_vcp);if(d6>=0&&d5<=d6)return target.copy(c);const vb=d5*d2-d1*d6;if(vb<=0&&d2>=0&&d6<=0)return w=d2/(d2-d6),target.copy(a).addScaledVector(_vac,w);const va=d3*d6-d5*d4;if(va<=0&&d4-d3>=0&&d5-d6>=0)return _vbc.subVectors(c,b),w=(d4-d3)/(d4-d3+(d5-d6)),target.copy(b).addScaledVector(_vbc,w);const denom=1/(va+vb+vc);return v=vb*denom,w=vc*denom,target.copy(a).addScaledVector(_vab,v).addScaledVector(_vac,w)}equals(triangle){return triangle.a.equals(this.a)&&triangle.b.equals(this.b)&&triangle.c.equals(this.c)}}class Box3{constructor(min=new Vector3(Infinity,Infinity,Infinity),max=new Vector3(-Infinity,-Infinity,-Infinity)){this.isBox3=!0,this.min=min,this.max=max}set(min,max){return this.min.copy(min),this.max.copy(max),this}setFromArray(array){this.makeEmpty();for(let i=0,il=array.length;i<il;i+=3)this.expandByPoint(_vector$b.fromArray(array,i));return this}setFromBufferAttribute(attribute){this.makeEmpty();for(let i=0,il=attribute.count;i<il;i++)this.expandByPoint(_vector$b.fromBufferAttribute(attribute,i));return this}setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++)this.expandByPoint(points[i]);return this}setFromCenterAndSize(center,size){const halfSize=_vector$b.copy(size).multiplyScalar(.5);return this.min.copy(center).sub(halfSize),this.max.copy(center).add(halfSize),this}setFromObject(object,precise=!1){return this.makeEmpty(),this.expandByObject(object,precise)}clone(){return(new this.constructor).copy(this)}copy(box){return this.min.copy(box.min),this.max.copy(box.max),this}makeEmpty(){return this.min.x=this.min.y=this.min.z=Infinity,this.max.x=this.max.y=this.max.z=-Infinity,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y||this.max.z<this.min.z}getCenter(target){return this.isEmpty()?target.set(0,0,0):target.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(target){return this.isEmpty()?target.set(0,0,0):target.subVectors(this.max,this.min)}expandByPoint(point){return this.min.min(point),this.max.max(point),this}expandByVector(vector){return this.min.sub(vector),this.max.add(vector),this}expandByScalar(scalar){return this.min.addScalar(-scalar),this.max.addScalar(scalar),this}expandByObject(object,precise=!1){object.updateWorldMatrix(!1,!1);const geometry=object.geometry;if(void 0!==geometry){const positionAttribute=geometry.getAttribute("position");if(!0===precise&&void 0!==positionAttribute&&!0!==object.isInstancedMesh)for(let i=0,l=positionAttribute.count;i<l;i++)!0===object.isMesh?object.getVertexPosition(i,_vector$b):_vector$b.fromBufferAttribute(positionAttribute,i),_vector$b.applyMatrix4(object.matrixWorld),this.expandByPoint(_vector$b);else void 0!==object.boundingBox?(null===object.boundingBox&&object.computeBoundingBox(),_box$4.copy(object.boundingBox)):(null===geometry.boundingBox&&geometry.computeBoundingBox(),_box$4.copy(geometry.boundingBox)),_box$4.applyMatrix4(object.matrixWorld),this.union(_box$4)}const children=object.children;for(let i=0,l=children.length;i<l;i++)this.expandByObject(children[i],precise);return this}containsPoint(point){return point.x>=this.min.x&&point.x<=this.max.x&&point.y>=this.min.y&&point.y<=this.max.y&&point.z>=this.min.z&&point.z<=this.max.z}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y&&this.min.z<=box.min.z&&box.max.z<=this.max.z}getParameter(point,target){return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y),(point.z-this.min.z)/(this.max.z-this.min.z))}intersectsBox(box){return box.max.x>=this.min.x&&box.min.x<=this.max.x&&box.max.y>=this.min.y&&box.min.y<=this.max.y&&box.max.z>=this.min.z&&box.min.z<=this.max.z}intersectsSphere(sphere){return this.clampPoint(sphere.center,_vector$b),_vector$b.distanceToSquared(sphere.center)<=sphere.radius*sphere.radius}intersectsPlane(plane){let min,max;return plane.normal.x>0?(min=plane.normal.x*this.min.x,max=plane.normal.x*this.max.x):(min=plane.normal.x*this.max.x,max=plane.normal.x*this.min.x),plane.normal.y>0?(min+=plane.normal.y*this.min.y,max+=plane.normal.y*this.max.y):(min+=plane.normal.y*this.max.y,max+=plane.normal.y*this.min.y),plane.normal.z>0?(min+=plane.normal.z*this.min.z,max+=plane.normal.z*this.max.z):(min+=plane.normal.z*this.max.z,max+=plane.normal.z*this.min.z),min<=-plane.constant&&max>=-plane.constant}intersectsTriangle(triangle){if(this.isEmpty())return!1;this.getCenter(_center),_extents.subVectors(this.max,_center),_v0$1.subVectors(triangle.a,_center),_v1$4.subVectors(triangle.b,_center),_v2$3.subVectors(triangle.c,_center),_f0.subVectors(_v1$4,_v0$1),_f1.subVectors(_v2$3,_v1$4),_f2.subVectors(_v0$1,_v2$3);let axes=[0,-_f0.z,_f0.y,0,-_f1.z,_f1.y,0,-_f2.z,_f2.y,_f0.z,0,-_f0.x,_f1.z,0,-_f1.x,_f2.z,0,-_f2.x,-_f0.y,_f0.x,0,-_f1.y,_f1.x,0,-_f2.y,_f2.x,0];return!!satForAxes(axes,_v0$1,_v1$4,_v2$3,_extents)&&(axes=[1,0,0,0,1,0,0,0,1],!!satForAxes(axes,_v0$1,_v1$4,_v2$3,_extents)&&(_triangleNormal.crossVectors(_f0,_f1),axes=[_triangleNormal.x,_triangleNormal.y,_triangleNormal.z],satForAxes(axes,_v0$1,_v1$4,_v2$3,_extents)))}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max)}distanceToPoint(point){return this.clampPoint(point,_vector$b).distanceTo(point)}getBoundingSphere(target){return this.isEmpty()?target.makeEmpty():(this.getCenter(target.center),target.radius=.5*this.getSize(_vector$b).length()),target}intersect(box){return this.min.max(box.min),this.max.min(box.max),this.isEmpty()&&this.makeEmpty(),this}union(box){return this.min.min(box.min),this.max.max(box.max),this}applyMatrix4(matrix){return this.isEmpty()||(_points[0].set(this.min.x,this.min.y,this.min.z).applyMatrix4(matrix),_points[1].set(this.min.x,this.min.y,this.max.z).applyMatrix4(matrix),_points[2].set(this.min.x,this.max.y,this.min.z).applyMatrix4(matrix),_points[3].set(this.min.x,this.max.y,this.max.z).applyMatrix4(matrix),_points[4].set(this.max.x,this.min.y,this.min.z).applyMatrix4(matrix),_points[5].set(this.max.x,this.min.y,this.max.z).applyMatrix4(matrix),_points[6].set(this.max.x,this.max.y,this.min.z).applyMatrix4(matrix),_points[7].set(this.max.x,this.max.y,this.max.z).applyMatrix4(matrix),this.setFromPoints(_points)),this}translate(offset){return this.min.add(offset),this.max.add(offset),this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}toJSON(){return{min:this.min.toArray(),max:this.max.toArray()}}fromJSON(json){return this.min.fromArray(json.min),this.max.fromArray(json.max),this}}const _points=[
/*@__PURE__*/new Vector3,
/*@__PURE__*/new Vector3,
/*@__PURE__*/new Vector3,
/*@__PURE__*/new Vector3,
/*@__PURE__*/new Vector3,
/*@__PURE__*/new Vector3,
/*@__PURE__*/new Vector3,
/*@__PURE__*/new Vector3],_vector$b=/*@__PURE__*/new Vector3,_box$4=/*@__PURE__*/new Box3,_v0$1=/*@__PURE__*/new Vector3,_v1$4=/*@__PURE__*/new Vector3,_v2$3=/*@__PURE__*/new Vector3,_f0=/*@__PURE__*/new Vector3,_f1=/*@__PURE__*/new Vector3,_f2=/*@__PURE__*/new Vector3,_center=/*@__PURE__*/new Vector3,_extents=/*@__PURE__*/new Vector3,_triangleNormal=/*@__PURE__*/new Vector3,_testAxis=/*@__PURE__*/new Vector3;function satForAxes(axes,v0,v1,v2,extents){for(let i=0,j=axes.length-3;i<=j;i+=3){_testAxis.fromArray(axes,i);const r=extents.x*Math.abs(_testAxis.x)+extents.y*Math.abs(_testAxis.y)+extents.z*Math.abs(_testAxis.z),p0=v0.dot(_testAxis),p1=v1.dot(_testAxis),p2=v2.dot(_testAxis);if(Math.max(-Math.max(p0,p1,p2),Math.min(p0,p1,p2))>r)return!1}return!0}const _tables=/*@__PURE__*/_generateTables();function _generateTables(){const buffer=new ArrayBuffer(4),floatView=new Float32Array(buffer),uint32View=new Uint32Array(buffer),baseTable=new Uint32Array(512),shiftTable=new Uint32Array(512);for(let i=0;i<256;++i){const e=i-127;e<-27?(baseTable[i]=0,baseTable[256|i]=32768,shiftTable[i]=24,shiftTable[256|i]=24):e<-14?(baseTable[i]=1024>>-e-14,baseTable[256|i]=1024>>-e-14|32768,shiftTable[i]=-e-1,shiftTable[256|i]=-e-1):e<=15?(baseTable[i]=e+15<<10,baseTable[256|i]=e+15<<10|32768,shiftTable[i]=13,shiftTable[256|i]=13):e<128?(baseTable[i]=31744,baseTable[256|i]=64512,shiftTable[i]=24,shiftTable[256|i]=24):(baseTable[i]=31744,baseTable[256|i]=64512,shiftTable[i]=13,shiftTable[256|i]=13)}const mantissaTable=new Uint32Array(2048),exponentTable=new Uint32Array(64),offsetTable=new Uint32Array(64);for(let i=1;i<1024;++i){let m=i<<13,e=0;for(;!(8388608&m);)m<<=1,e-=8388608;m&=-8388609,e+=947912704,mantissaTable[i]=m|e}for(let i=1024;i<2048;++i)mantissaTable[i]=939524096+(i-1024<<13);for(let i=1;i<31;++i)exponentTable[i]=i<<23;exponentTable[31]=1199570944,exponentTable[32]=2147483648;for(let i=33;i<63;++i)exponentTable[i]=2147483648+(i-32<<23);exponentTable[63]=3347054592;for(let i=1;i<64;++i)32!==i&&(offsetTable[i]=1024);return{floatView:floatView,uint32View:uint32View,baseTable:baseTable,shiftTable:shiftTable,mantissaTable:mantissaTable,exponentTable:exponentTable,offsetTable:offsetTable}}function toHalfFloat(val){Math.abs(val)>65504&&warn("DataUtils.toHalfFloat(): Value out of range."),val=clamp$3(val,-65504,65504),_tables.floatView[0]=val;const f=_tables.uint32View[0],e=f>>23&511;return _tables.baseTable[e]+((8388607&f)>>_tables.shiftTable[e])}function fromHalfFloat(val){const m=val>>10;return _tables.uint32View[0]=_tables.mantissaTable[_tables.offsetTable[m]+(1023&val)]+_tables.exponentTable[m],_tables.floatView[0]}const _vector$a=/*@__PURE__*/new Vector3,_vector2$1=/*@__PURE__*/new Vector2;let _id$2$1=0;class BufferAttribute{constructor(array,itemSize,normalized=!1){if(Array.isArray(array))throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");this.isBufferAttribute=!0,Object.defineProperty(this,"id",{value:_id$2$1++}),this.name="",this.array=array,this.itemSize=itemSize,this.count=void 0!==array?array.length/itemSize:0,this.normalized=normalized,this.usage=35044,this.updateRanges=[],this.gpuType=1015,this.version=0}onUploadCallback(){}set needsUpdate(value){!0===value&&this.version++}setUsage(value){return this.usage=value,this}addUpdateRange(start,count){this.updateRanges.push({start:start,count:count})}clearUpdateRanges(){this.updateRanges.length=0}copy(source){return this.name=source.name,this.array=new source.array.constructor(source.array),this.itemSize=source.itemSize,this.count=source.count,this.normalized=source.normalized,this.usage=source.usage,this.gpuType=source.gpuType,this}copyAt(index1,attribute,index2){index1*=this.itemSize,index2*=attribute.itemSize;for(let i=0,l=this.itemSize;i<l;i++)this.array[index1+i]=attribute.array[index2+i];return this}copyArray(array){return this.array.set(array),this}applyMatrix3(m){if(2===this.itemSize)for(let i=0,l=this.count;i<l;i++)_vector2$1.fromBufferAttribute(this,i),_vector2$1.applyMatrix3(m),this.setXY(i,_vector2$1.x,_vector2$1.y);else if(3===this.itemSize)for(let i=0,l=this.count;i<l;i++)_vector$a.fromBufferAttribute(this,i),_vector$a.applyMatrix3(m),this.setXYZ(i,_vector$a.x,_vector$a.y,_vector$a.z);return this}applyMatrix4(m){for(let i=0,l=this.count;i<l;i++)_vector$a.fromBufferAttribute(this,i),_vector$a.applyMatrix4(m),this.setXYZ(i,_vector$a.x,_vector$a.y,_vector$a.z);return this}applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++)_vector$a.fromBufferAttribute(this,i),_vector$a.applyNormalMatrix(m),this.setXYZ(i,_vector$a.x,_vector$a.y,_vector$a.z);return this}transformDirection(m){for(let i=0,l=this.count;i<l;i++)_vector$a.fromBufferAttribute(this,i),_vector$a.transformDirection(m),this.setXYZ(i,_vector$a.x,_vector$a.y,_vector$a.z);return this}set(value,offset=0){return this.array.set(value,offset),this}getComponent(index,component){let value=this.array[index*this.itemSize+component];return this.normalized&&(value=denormalize(value,this.array)),value}setComponent(index,component,value){return this.normalized&&(value=normalize$1(value,this.array)),this.array[index*this.itemSize+component]=value,this}getX(index){let x=this.array[index*this.itemSize];return this.normalized&&(x=denormalize(x,this.array)),x}setX(index,x){return this.normalized&&(x=normalize$1(x,this.array)),this.array[index*this.itemSize]=x,this}getY(index){let y=this.array[index*this.itemSize+1];return this.normalized&&(y=denormalize(y,this.array)),y}setY(index,y){return this.normalized&&(y=normalize$1(y,this.array)),this.array[index*this.itemSize+1]=y,this}getZ(index){let z=this.array[index*this.itemSize+2];return this.normalized&&(z=denormalize(z,this.array)),z}setZ(index,z){return this.normalized&&(z=normalize$1(z,this.array)),this.array[index*this.itemSize+2]=z,this}getW(index){let w=this.array[index*this.itemSize+3];return this.normalized&&(w=denormalize(w,this.array)),w}setW(index,w){return this.normalized&&(w=normalize$1(w,this.array)),this.array[index*this.itemSize+3]=w,this}setXY(index,x,y){return index*=this.itemSize,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array)),this.array[index+0]=x,this.array[index+1]=y,this}setXYZ(index,x,y,z){return index*=this.itemSize,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array),z=normalize$1(z,this.array)),this.array[index+0]=x,this.array[index+1]=y,this.array[index+2]=z,this}setXYZW(index,x,y,z,w){return index*=this.itemSize,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array),z=normalize$1(z,this.array),w=normalize$1(w,this.array)),this.array[index+0]=x,this.array[index+1]=y,this.array[index+2]=z,this.array[index+3]=w,this}onUpload(callback){return this.onUploadCallback=callback,this}clone(){return new this.constructor(this.array,this.itemSize).copy(this)}toJSON(){const data={itemSize:this.itemSize,type:this.array.constructor.name,array:Array.from(this.array),normalized:this.normalized};return""!==this.name&&(data.name=this.name),35044!==this.usage&&(data.usage=this.usage),data}}class Uint16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized)}}class Uint32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint32Array(array),itemSize,normalized)}}class Float16BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Uint16Array(array),itemSize,normalized),this.isFloat16BufferAttribute=!0}getX(index){let x=fromHalfFloat(this.array[index*this.itemSize]);return this.normalized&&(x=denormalize(x,this.array)),x}setX(index,x){return this.normalized&&(x=normalize$1(x,this.array)),this.array[index*this.itemSize]=toHalfFloat(x),this}getY(index){let y=fromHalfFloat(this.array[index*this.itemSize+1]);return this.normalized&&(y=denormalize(y,this.array)),y}setY(index,y){return this.normalized&&(y=normalize$1(y,this.array)),this.array[index*this.itemSize+1]=toHalfFloat(y),this}getZ(index){let z=fromHalfFloat(this.array[index*this.itemSize+2]);return this.normalized&&(z=denormalize(z,this.array)),z}setZ(index,z){return this.normalized&&(z=normalize$1(z,this.array)),this.array[index*this.itemSize+2]=toHalfFloat(z),this}getW(index){let w=fromHalfFloat(this.array[index*this.itemSize+3]);return this.normalized&&(w=denormalize(w,this.array)),w}setW(index,w){return this.normalized&&(w=normalize$1(w,this.array)),this.array[index*this.itemSize+3]=toHalfFloat(w),this}setXY(index,x,y){return index*=this.itemSize,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array)),this.array[index+0]=toHalfFloat(x),this.array[index+1]=toHalfFloat(y),this}setXYZ(index,x,y,z){return index*=this.itemSize,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array),z=normalize$1(z,this.array)),this.array[index+0]=toHalfFloat(x),this.array[index+1]=toHalfFloat(y),this.array[index+2]=toHalfFloat(z),this}setXYZW(index,x,y,z,w){return index*=this.itemSize,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array),z=normalize$1(z,this.array),w=normalize$1(w,this.array)),this.array[index+0]=toHalfFloat(x),this.array[index+1]=toHalfFloat(y),this.array[index+2]=toHalfFloat(z),this.array[index+3]=toHalfFloat(w),this}}class Float32BufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized){super(new Float32Array(array),itemSize,normalized)}}const _box$3=/*@__PURE__*/new Box3,_v1$3=/*@__PURE__*/new Vector3,_v2$2=/*@__PURE__*/new Vector3;class Sphere{constructor(center=new Vector3,radius=-1){this.isSphere=!0,this.center=center,this.radius=radius}set(center,radius){return this.center.copy(center),this.radius=radius,this}setFromPoints(points,optionalCenter){const center=this.center;void 0!==optionalCenter?center.copy(optionalCenter):_box$3.setFromPoints(points).getCenter(center);let maxRadiusSq=0;for(let i=0,il=points.length;i<il;i++)maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(points[i]));return this.radius=Math.sqrt(maxRadiusSq),this}copy(sphere){return this.center.copy(sphere.center),this.radius=sphere.radius,this}isEmpty(){return this.radius<0}makeEmpty(){return this.center.set(0,0,0),this.radius=-1,this}containsPoint(point){return point.distanceToSquared(this.center)<=this.radius*this.radius}distanceToPoint(point){return point.distanceTo(this.center)-this.radius}intersectsSphere(sphere){const radiusSum=this.radius+sphere.radius;return sphere.center.distanceToSquared(this.center)<=radiusSum*radiusSum}intersectsBox(box){return box.intersectsSphere(this)}intersectsPlane(plane){return Math.abs(plane.distanceToPoint(this.center))<=this.radius}clampPoint(point,target){const deltaLengthSq=this.center.distanceToSquared(point);return target.copy(point),deltaLengthSq>this.radius*this.radius&&(target.sub(this.center).normalize(),target.multiplyScalar(this.radius).add(this.center)),target}getBoundingBox(target){return this.isEmpty()?(target.makeEmpty(),target):(target.set(this.center,this.center),target.expandByScalar(this.radius),target)}applyMatrix4(matrix){return this.center.applyMatrix4(matrix),this.radius=this.radius*matrix.getMaxScaleOnAxis(),this}translate(offset){return this.center.add(offset),this}expandByPoint(point){if(this.isEmpty())return this.center.copy(point),this.radius=0,this;_v1$3.subVectors(point,this.center);const lengthSq=_v1$3.lengthSq();if(lengthSq>this.radius*this.radius){const length=Math.sqrt(lengthSq),delta=.5*(length-this.radius);this.center.addScaledVector(_v1$3,delta/length),this.radius+=delta}return this}union(sphere){return sphere.isEmpty()?this:this.isEmpty()?(this.copy(sphere),this):(!0===this.center.equals(sphere.center)?this.radius=Math.max(this.radius,sphere.radius):(_v2$2.subVectors(sphere.center,this.center).setLength(sphere.radius),this.expandByPoint(_v1$3.copy(sphere.center).add(_v2$2)),this.expandByPoint(_v1$3.copy(sphere.center).sub(_v2$2))),this)}equals(sphere){return sphere.center.equals(this.center)&&sphere.radius===this.radius}clone(){return(new this.constructor).copy(this)}toJSON(){return{radius:this.radius,center:this.center.toArray()}}fromJSON(json){return this.radius=json.radius,this.center.fromArray(json.center),this}}let _id$1$1=0;const _m1$3=/*@__PURE__*/new Matrix4,_obj=/*@__PURE__*/new Object3D,_offset=/*@__PURE__*/new Vector3,_box$2=/*@__PURE__*/new Box3,_boxMorphTargets=/*@__PURE__*/new Box3,_vector$9=/*@__PURE__*/new Vector3;class BufferGeometry extends EventDispatcher{constructor(){super(),this.isBufferGeometry=!0,Object.defineProperty(this,"id",{value:_id$1$1++}),this.uuid=generateUUID(),this.name="",this.type="BufferGeometry",this.index=null,this.indirect=null,this.indirectOffset=0,this.attributes={},this.morphAttributes={},this.morphTargetsRelative=!1,this.groups=[],this.boundingBox=null,this.boundingSphere=null,this.drawRange={start:0,count:Infinity},this.userData={}}getIndex(){return this.index}setIndex(index){return Array.isArray(index)?this.index=new(function arrayNeedsUint32(array){for(let i=array.length-1;i>=0;--i)if(array[i]>=65535)return!0;return!1}(index)?Uint32BufferAttribute:Uint16BufferAttribute)(index,1):this.index=index,this}setIndirect(indirect,indirectOffset=0){return this.indirect=indirect,this.indirectOffset=indirectOffset,this}getIndirect(){return this.indirect}getAttribute(name){return this.attributes[name]}setAttribute(name,attribute){return this.attributes[name]=attribute,this}deleteAttribute(name){return delete this.attributes[name],this}hasAttribute(name){return void 0!==this.attributes[name]}addGroup(start,count,materialIndex=0){this.groups.push({start:start,count:count,materialIndex:materialIndex})}clearGroups(){this.groups=[]}setDrawRange(start,count){this.drawRange.start=start,this.drawRange.count=count}applyMatrix4(matrix){const position=this.attributes.position;void 0!==position&&(position.applyMatrix4(matrix),position.needsUpdate=!0);const normal=this.attributes.normal;if(void 0!==normal){const normalMatrix=(new Matrix3).getNormalMatrix(matrix);normal.applyNormalMatrix(normalMatrix),normal.needsUpdate=!0}const tangent=this.attributes.tangent;return void 0!==tangent&&(tangent.transformDirection(matrix),tangent.needsUpdate=!0),null!==this.boundingBox&&this.computeBoundingBox(),null!==this.boundingSphere&&this.computeBoundingSphere(),this}applyQuaternion(q){return _m1$3.makeRotationFromQuaternion(q),this.applyMatrix4(_m1$3),this}rotateX(angle){return _m1$3.makeRotationX(angle),this.applyMatrix4(_m1$3),this}rotateY(angle){return _m1$3.makeRotationY(angle),this.applyMatrix4(_m1$3),this}rotateZ(angle){return _m1$3.makeRotationZ(angle),this.applyMatrix4(_m1$3),this}translate(x,y,z){return _m1$3.makeTranslation(x,y,z),this.applyMatrix4(_m1$3),this}scale(x,y,z){return _m1$3.makeScale(x,y,z),this.applyMatrix4(_m1$3),this}lookAt(vector){return _obj.lookAt(vector),_obj.updateMatrix(),this.applyMatrix4(_obj.matrix),this}center(){return this.computeBoundingBox(),this.boundingBox.getCenter(_offset).negate(),this.translate(_offset.x,_offset.y,_offset.z),this}setFromPoints(points){const positionAttribute=this.getAttribute("position");if(void 0===positionAttribute){const position=[];for(let i=0,l=points.length;i<l;i++){const point=points[i];position.push(point.x,point.y,point.z||0)}this.setAttribute("position",new Float32BufferAttribute(position,3))}else{const l=Math.min(points.length,positionAttribute.count);for(let i=0;i<l;i++){const point=points[i];positionAttribute.setXYZ(i,point.x,point.y,point.z||0)}points.length>positionAttribute.count&&warn("BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."),positionAttribute.needsUpdate=!0}return this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Box3);const position=this.attributes.position,morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute)return error("BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.",this),void this.boundingBox.set(new Vector3(-Infinity,-Infinity,-Infinity),new Vector3(Infinity,Infinity,Infinity));if(void 0!==position){if(this.boundingBox.setFromBufferAttribute(position),morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_box$2.setFromBufferAttribute(morphAttribute),this.morphTargetsRelative?(_vector$9.addVectors(this.boundingBox.min,_box$2.min),this.boundingBox.expandByPoint(_vector$9),_vector$9.addVectors(this.boundingBox.max,_box$2.max),this.boundingBox.expandByPoint(_vector$9)):(this.boundingBox.expandByPoint(_box$2.min),this.boundingBox.expandByPoint(_box$2.max))}}else this.boundingBox.makeEmpty();(isNaN(this.boundingBox.min.x)||isNaN(this.boundingBox.min.y)||isNaN(this.boundingBox.min.z))&&error('BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.',this)}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const position=this.attributes.position,morphAttributesPosition=this.morphAttributes.position;if(position&&position.isGLBufferAttribute)return error("BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.",this),void this.boundingSphere.set(new Vector3,Infinity);if(position){const center=this.boundingSphere.center;if(_box$2.setFromBufferAttribute(position),morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i];_boxMorphTargets.setFromBufferAttribute(morphAttribute),this.morphTargetsRelative?(_vector$9.addVectors(_box$2.min,_boxMorphTargets.min),_box$2.expandByPoint(_vector$9),_vector$9.addVectors(_box$2.max,_boxMorphTargets.max),_box$2.expandByPoint(_vector$9)):(_box$2.expandByPoint(_boxMorphTargets.min),_box$2.expandByPoint(_boxMorphTargets.max))}_box$2.getCenter(center);let maxRadiusSq=0;for(let i=0,il=position.count;i<il;i++)_vector$9.fromBufferAttribute(position,i),maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$9));if(morphAttributesPosition)for(let i=0,il=morphAttributesPosition.length;i<il;i++){const morphAttribute=morphAttributesPosition[i],morphTargetsRelative=this.morphTargetsRelative;for(let j=0,jl=morphAttribute.count;j<jl;j++)_vector$9.fromBufferAttribute(morphAttribute,j),morphTargetsRelative&&(_offset.fromBufferAttribute(position,j),_vector$9.add(_offset)),maxRadiusSq=Math.max(maxRadiusSq,center.distanceToSquared(_vector$9))}this.boundingSphere.radius=Math.sqrt(maxRadiusSq),isNaN(this.boundingSphere.radius)&&error('BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.',this)}}computeTangents(){const index=this.index,attributes=this.attributes;if(null===index||void 0===attributes.position||void 0===attributes.normal||void 0===attributes.uv)return void error("BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");const positionAttribute=attributes.position,normalAttribute=attributes.normal,uvAttribute=attributes.uv;!1===this.hasAttribute("tangent")&&this.setAttribute("tangent",new BufferAttribute(new Float32Array(4*positionAttribute.count),4));const tangentAttribute=this.getAttribute("tangent"),tan1=[],tan2=[];for(let i=0;i<positionAttribute.count;i++)tan1[i]=new Vector3,tan2[i]=new Vector3;const vA=new Vector3,vB=new Vector3,vC=new Vector3,uvA=new Vector2,uvB=new Vector2,uvC=new Vector2,sdir=new Vector3,tdir=new Vector3;function handleTriangle(a,b,c){vA.fromBufferAttribute(positionAttribute,a),vB.fromBufferAttribute(positionAttribute,b),vC.fromBufferAttribute(positionAttribute,c),uvA.fromBufferAttribute(uvAttribute,a),uvB.fromBufferAttribute(uvAttribute,b),uvC.fromBufferAttribute(uvAttribute,c),vB.sub(vA),vC.sub(vA),uvB.sub(uvA),uvC.sub(uvA);const r=1/(uvB.x*uvC.y-uvC.x*uvB.y);isFinite(r)&&(sdir.copy(vB).multiplyScalar(uvC.y).addScaledVector(vC,-uvB.y).multiplyScalar(r),tdir.copy(vC).multiplyScalar(uvB.x).addScaledVector(vB,-uvC.x).multiplyScalar(r),tan1[a].add(sdir),tan1[b].add(sdir),tan1[c].add(sdir),tan2[a].add(tdir),tan2[b].add(tdir),tan2[c].add(tdir))}let groups=this.groups;0===groups.length&&(groups=[{start:0,count:index.count}]);for(let i=0,il=groups.length;i<il;++i){const group=groups[i],start=group.start;for(let j=start,jl=start+group.count;j<jl;j+=3)handleTriangle(index.getX(j+0),index.getX(j+1),index.getX(j+2))}const tmp=new Vector3,tmp2=new Vector3,n=new Vector3,n2=new Vector3;function handleVertex(v){n.fromBufferAttribute(normalAttribute,v),n2.copy(n);const t=tan1[v];tmp.copy(t),tmp.sub(n.multiplyScalar(n.dot(t))).normalize(),tmp2.crossVectors(n2,t);const w=tmp2.dot(tan2[v])<0?-1:1;tangentAttribute.setXYZW(v,tmp.x,tmp.y,tmp.z,w)}for(let i=0,il=groups.length;i<il;++i){const group=groups[i],start=group.start;for(let j=start,jl=start+group.count;j<jl;j+=3)handleVertex(index.getX(j+0)),handleVertex(index.getX(j+1)),handleVertex(index.getX(j+2))}}computeVertexNormals(){const index=this.index,positionAttribute=this.getAttribute("position");if(void 0!==positionAttribute){let normalAttribute=this.getAttribute("normal");if(void 0===normalAttribute)normalAttribute=new BufferAttribute(new Float32Array(3*positionAttribute.count),3),this.setAttribute("normal",normalAttribute);else for(let i=0,il=normalAttribute.count;i<il;i++)normalAttribute.setXYZ(i,0,0,0);const pA=new Vector3,pB=new Vector3,pC=new Vector3,nA=new Vector3,nB=new Vector3,nC=new Vector3,cb=new Vector3,ab=new Vector3;if(index)for(let i=0,il=index.count;i<il;i+=3){const vA=index.getX(i+0),vB=index.getX(i+1),vC=index.getX(i+2);pA.fromBufferAttribute(positionAttribute,vA),pB.fromBufferAttribute(positionAttribute,vB),pC.fromBufferAttribute(positionAttribute,vC),cb.subVectors(pC,pB),ab.subVectors(pA,pB),cb.cross(ab),nA.fromBufferAttribute(normalAttribute,vA),nB.fromBufferAttribute(normalAttribute,vB),nC.fromBufferAttribute(normalAttribute,vC),nA.add(cb),nB.add(cb),nC.add(cb),normalAttribute.setXYZ(vA,nA.x,nA.y,nA.z),normalAttribute.setXYZ(vB,nB.x,nB.y,nB.z),normalAttribute.setXYZ(vC,nC.x,nC.y,nC.z)}else for(let i=0,il=positionAttribute.count;i<il;i+=3)pA.fromBufferAttribute(positionAttribute,i+0),pB.fromBufferAttribute(positionAttribute,i+1),pC.fromBufferAttribute(positionAttribute,i+2),cb.subVectors(pC,pB),ab.subVectors(pA,pB),cb.cross(ab),normalAttribute.setXYZ(i+0,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i+1,cb.x,cb.y,cb.z),normalAttribute.setXYZ(i+2,cb.x,cb.y,cb.z);this.normalizeNormals(),normalAttribute.needsUpdate=!0}}normalizeNormals(){const normals=this.attributes.normal;for(let i=0,il=normals.count;i<il;i++)_vector$9.fromBufferAttribute(normals,i),_vector$9.normalize(),normals.setXYZ(i,_vector$9.x,_vector$9.y,_vector$9.z)}toNonIndexed(){function convertBufferAttribute(attribute,indices){const array=attribute.array,itemSize=attribute.itemSize,normalized=attribute.normalized,array2=new array.constructor(indices.length*itemSize);let index=0,index2=0;for(let i=0,l=indices.length;i<l;i++){index=attribute.isInterleavedBufferAttribute?indices[i]*attribute.data.stride+attribute.offset:indices[i]*itemSize;for(let j=0;j<itemSize;j++)array2[index2++]=array[index++]}return new BufferAttribute(array2,itemSize,normalized)}if(null===this.index)return warn("BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),this;const geometry2=new BufferGeometry,indices=this.index.array,attributes=this.attributes;for(const name in attributes){const newAttribute=convertBufferAttribute(attributes[name],indices);geometry2.setAttribute(name,newAttribute)}const morphAttributes=this.morphAttributes;for(const name in morphAttributes){const morphArray=[],morphAttribute=morphAttributes[name];for(let i=0,il=morphAttribute.length;i<il;i++){const newAttribute=convertBufferAttribute(morphAttribute[i],indices);morphArray.push(newAttribute)}geometry2.morphAttributes[name]=morphArray}geometry2.morphTargetsRelative=this.morphTargetsRelative;const groups=this.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];geometry2.addGroup(group.start,group.count,group.materialIndex)}return geometry2}toJSON(){const data={metadata:{version:4.7,type:"BufferGeometry",generator:"BufferGeometry.toJSON"}};if(data.uuid=this.uuid,data.type=this.type,""!==this.name&&(data.name=this.name),Object.keys(this.userData).length>0&&(data.userData=this.userData),void 0!==this.parameters){const parameters=this.parameters;for(const key in parameters)void 0!==parameters[key]&&(data[key]=parameters[key]);return data}data.data={attributes:{}};const index=this.index;null!==index&&(data.data.index={type:index.array.constructor.name,array:Array.prototype.slice.call(index.array)});const attributes=this.attributes;for(const key in attributes){const attribute=attributes[key];data.data.attributes[key]=attribute.toJSON(data.data)}const morphAttributes={};let hasMorphAttributes=!1;for(const key in this.morphAttributes){const attributeArray=this.morphAttributes[key],array=[];for(let i=0,il=attributeArray.length;i<il;i++){const attribute=attributeArray[i];array.push(attribute.toJSON(data.data))}array.length>0&&(morphAttributes[key]=array,hasMorphAttributes=!0)}hasMorphAttributes&&(data.data.morphAttributes=morphAttributes,data.data.morphTargetsRelative=this.morphTargetsRelative);const groups=this.groups;groups.length>0&&(data.data.groups=JSON.parse(JSON.stringify(groups)));const boundingSphere=this.boundingSphere;return null!==boundingSphere&&(data.data.boundingSphere=boundingSphere.toJSON()),data}clone(){return(new this.constructor).copy(this)}copy(source){this.index=null,this.attributes={},this.morphAttributes={},this.groups=[],this.boundingBox=null,this.boundingSphere=null;const data={};this.name=source.name;const index=source.index;null!==index&&this.setIndex(index.clone());const attributes=source.attributes;for(const name in attributes){const attribute=attributes[name];this.setAttribute(name,attribute.clone(data))}const morphAttributes=source.morphAttributes;for(const name in morphAttributes){const array=[],morphAttribute=morphAttributes[name];for(let i=0,l=morphAttribute.length;i<l;i++)array.push(morphAttribute[i].clone(data));this.morphAttributes[name]=array}this.morphTargetsRelative=source.morphTargetsRelative;const groups=source.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i];this.addGroup(group.start,group.count,group.materialIndex)}const boundingBox=source.boundingBox;null!==boundingBox&&(this.boundingBox=boundingBox.clone());const boundingSphere=source.boundingSphere;return null!==boundingSphere&&(this.boundingSphere=boundingSphere.clone()),this.drawRange.start=source.drawRange.start,this.drawRange.count=source.drawRange.count,this.userData=source.userData,this}dispose(){this.dispatchEvent({type:"dispose"})}}class InterleavedBuffer{constructor(array,stride){this.isInterleavedBuffer=!0,this.array=array,this.stride=stride,this.count=void 0!==array?array.length/stride:0,this.usage=35044,this.updateRanges=[],this.version=0,this.uuid=generateUUID()}onUploadCallback(){}set needsUpdate(value){!0===value&&this.version++}setUsage(value){return this.usage=value,this}addUpdateRange(start,count){this.updateRanges.push({start:start,count:count})}clearUpdateRanges(){this.updateRanges.length=0}copy(source){return this.array=new source.array.constructor(source.array),this.count=source.count,this.stride=source.stride,this.usage=source.usage,this}copyAt(index1,interleavedBuffer,index2){index1*=this.stride,index2*=interleavedBuffer.stride;for(let i=0,l=this.stride;i<l;i++)this.array[index1+i]=interleavedBuffer.array[index2+i];return this}set(value,offset=0){return this.array.set(value,offset),this}clone(data){void 0===data.arrayBuffers&&(data.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID()),void 0===data.arrayBuffers[this.array.buffer._uuid]&&(data.arrayBuffers[this.array.buffer._uuid]=this.array.slice(0).buffer);const array=new this.array.constructor(data.arrayBuffers[this.array.buffer._uuid]),ib=new this.constructor(array,this.stride);return ib.setUsage(this.usage),ib}onUpload(callback){return this.onUploadCallback=callback,this}toJSON(data){return void 0===data.arrayBuffers&&(data.arrayBuffers={}),void 0===this.array.buffer._uuid&&(this.array.buffer._uuid=generateUUID()),void 0===data.arrayBuffers[this.array.buffer._uuid]&&(data.arrayBuffers[this.array.buffer._uuid]=Array.from(new Uint32Array(this.array.buffer))),{uuid:this.uuid,buffer:this.array.buffer._uuid,type:this.array.constructor.name,stride:this.stride}}}const _vector$8=/*@__PURE__*/new Vector3;class InterleavedBufferAttribute{constructor(interleavedBuffer,itemSize,offset,normalized=!1){this.isInterleavedBufferAttribute=!0,this.name="",this.data=interleavedBuffer,this.itemSize=itemSize,this.offset=offset,this.normalized=normalized}get count(){return this.data.count}get array(){return this.data.array}set needsUpdate(value){this.data.needsUpdate=value}applyMatrix4(m){for(let i=0,l=this.data.count;i<l;i++)_vector$8.fromBufferAttribute(this,i),_vector$8.applyMatrix4(m),this.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z);return this}applyNormalMatrix(m){for(let i=0,l=this.count;i<l;i++)_vector$8.fromBufferAttribute(this,i),_vector$8.applyNormalMatrix(m),this.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z);return this}transformDirection(m){for(let i=0,l=this.count;i<l;i++)_vector$8.fromBufferAttribute(this,i),_vector$8.transformDirection(m),this.setXYZ(i,_vector$8.x,_vector$8.y,_vector$8.z);return this}getComponent(index,component){let value=this.array[index*this.data.stride+this.offset+component];return this.normalized&&(value=denormalize(value,this.array)),value}setComponent(index,component,value){return this.normalized&&(value=normalize$1(value,this.array)),this.data.array[index*this.data.stride+this.offset+component]=value,this}setX(index,x){return this.normalized&&(x=normalize$1(x,this.array)),this.data.array[index*this.data.stride+this.offset]=x,this}setY(index,y){return this.normalized&&(y=normalize$1(y,this.array)),this.data.array[index*this.data.stride+this.offset+1]=y,this}setZ(index,z){return this.normalized&&(z=normalize$1(z,this.array)),this.data.array[index*this.data.stride+this.offset+2]=z,this}setW(index,w){return this.normalized&&(w=normalize$1(w,this.array)),this.data.array[index*this.data.stride+this.offset+3]=w,this}getX(index){let x=this.data.array[index*this.data.stride+this.offset];return this.normalized&&(x=denormalize(x,this.array)),x}getY(index){let y=this.data.array[index*this.data.stride+this.offset+1];return this.normalized&&(y=denormalize(y,this.array)),y}getZ(index){let z=this.data.array[index*this.data.stride+this.offset+2];return this.normalized&&(z=denormalize(z,this.array)),z}getW(index){let w=this.data.array[index*this.data.stride+this.offset+3];return this.normalized&&(w=denormalize(w,this.array)),w}setXY(index,x,y){return index=index*this.data.stride+this.offset,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array)),this.data.array[index+0]=x,this.data.array[index+1]=y,this}setXYZ(index,x,y,z){return index=index*this.data.stride+this.offset,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array),z=normalize$1(z,this.array)),this.data.array[index+0]=x,this.data.array[index+1]=y,this.data.array[index+2]=z,this}setXYZW(index,x,y,z,w){return index=index*this.data.stride+this.offset,this.normalized&&(x=normalize$1(x,this.array),y=normalize$1(y,this.array),z=normalize$1(z,this.array),w=normalize$1(w,this.array)),this.data.array[index+0]=x,this.data.array[index+1]=y,this.data.array[index+2]=z,this.data.array[index+3]=w,this}clone(data){if(void 0===data){log$1("InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");const array=[];for(let i=0;i<this.count;i++){const index=i*this.data.stride+this.offset;for(let j=0;j<this.itemSize;j++)array.push(this.data.array[index+j])}return new BufferAttribute(new this.array.constructor(array),this.itemSize,this.normalized)}return void 0===data.interleavedBuffers&&(data.interleavedBuffers={}),void 0===data.interleavedBuffers[this.data.uuid]&&(data.interleavedBuffers[this.data.uuid]=this.data.clone(data)),new InterleavedBufferAttribute(data.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)}toJSON(data){if(void 0===data){log$1("InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");const array=[];for(let i=0;i<this.count;i++){const index=i*this.data.stride+this.offset;for(let j=0;j<this.itemSize;j++)array.push(this.data.array[index+j])}return{itemSize:this.itemSize,type:this.array.constructor.name,array:array,normalized:this.normalized}}return void 0===data.interleavedBuffers&&(data.interleavedBuffers={}),void 0===data.interleavedBuffers[this.data.uuid]&&(data.interleavedBuffers[this.data.uuid]=this.data.toJSON(data)),{isInterleavedBufferAttribute:!0,itemSize:this.itemSize,data:this.data.uuid,offset:this.offset,normalized:this.normalized}}}let _geometry$1,_materialId=0;class Material extends EventDispatcher{constructor(){super(),this.isMaterial=!0,Object.defineProperty(this,"id",{value:_materialId++}),this.uuid=generateUUID(),this.name="",this.type="Material",this.blending=1,this.side=0,this.vertexColors=!1,this.opacity=1,this.transparent=!1,this.alphaHash=!1,this.blendSrc=204,this.blendDst=205,this.blendEquation=100,this.blendSrcAlpha=null,this.blendDstAlpha=null,this.blendEquationAlpha=null,this.blendColor=new Color(0,0,0),this.blendAlpha=0,this.depthFunc=3,this.depthTest=!0,this.depthWrite=!0,this.stencilWriteMask=255,this.stencilFunc=519,this.stencilRef=0,this.stencilFuncMask=255,this.stencilFail=7680,this.stencilZFail=7680,this.stencilZPass=7680,this.stencilWrite=!1,this.clippingPlanes=null,this.clipIntersection=!1,this.clipShadows=!1,this.shadowSide=null,this.colorWrite=!0,this.precision=null,this.polygonOffset=!1,this.polygonOffsetFactor=0,this.polygonOffsetUnits=0,this.dithering=!1,this.alphaToCoverage=!1,this.premultipliedAlpha=!1,this.forceSinglePass=!1,this.allowOverride=!0,this.visible=!0,this.toneMapped=!0,this.userData={},this.version=0,this._alphaTest=0}get alphaTest(){return this._alphaTest}set alphaTest(value){this._alphaTest>0!=value>0&&this.version++,this._alphaTest=value}onBeforeRender(){}onBeforeCompile(){}customProgramCacheKey(){return this.onBeforeCompile.toString()}setValues(values){if(void 0!==values)for(const key in values){const newValue=values[key];if(void 0===newValue){warn(`Material: parameter '${key}' has value of undefined.`);continue}const currentValue=this[key];void 0!==currentValue?currentValue&&currentValue.isColor?currentValue.set(newValue):currentValue&&currentValue.isVector3&&newValue&&newValue.isVector3?currentValue.copy(newValue):this[key]=newValue:warn(`Material: '${key}' is not a property of THREE.${this.type}.`)}}toJSON(meta){const isRootObject=void 0===meta||"string"==typeof meta;isRootObject&&(meta={textures:{},images:{}});const data={metadata:{version:4.7,type:"Material",generator:"Material.toJSON"}};function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata,values.push(data)}return values}if(data.uuid=this.uuid,data.type=this.type,""!==this.name&&(data.name=this.name),this.color&&this.color.isColor&&(data.color=this.color.getHex()),void 0!==this.roughness&&(data.roughness=this.roughness),void 0!==this.metalness&&(data.metalness=this.metalness),void 0!==this.sheen&&(data.sheen=this.sheen),this.sheenColor&&this.sheenColor.isColor&&(data.sheenColor=this.sheenColor.getHex()),void 0!==this.sheenRoughness&&(data.sheenRoughness=this.sheenRoughness),this.emissive&&this.emissive.isColor&&(data.emissive=this.emissive.getHex()),void 0!==this.emissiveIntensity&&1!==this.emissiveIntensity&&(data.emissiveIntensity=this.emissiveIntensity),this.specular&&this.specular.isColor&&(data.specular=this.specular.getHex()),void 0!==this.specularIntensity&&(data.specularIntensity=this.specularIntensity),this.specularColor&&this.specularColor.isColor&&(data.specularColor=this.specularColor.getHex()),void 0!==this.shininess&&(data.shininess=this.shininess),void 0!==this.clearcoat&&(data.clearcoat=this.clearcoat),void 0!==this.clearcoatRoughness&&(data.clearcoatRoughness=this.clearcoatRoughness),this.clearcoatMap&&this.clearcoatMap.isTexture&&(data.clearcoatMap=this.clearcoatMap.toJSON(meta).uuid),this.clearcoatRoughnessMap&&this.clearcoatRoughnessMap.isTexture&&(data.clearcoatRoughnessMap=this.clearcoatRoughnessMap.toJSON(meta).uuid),this.clearcoatNormalMap&&this.clearcoatNormalMap.isTexture&&(data.clearcoatNormalMap=this.clearcoatNormalMap.toJSON(meta).uuid,data.clearcoatNormalScale=this.clearcoatNormalScale.toArray()),this.sheenColorMap&&this.sheenColorMap.isTexture&&(data.sheenColorMap=this.sheenColorMap.toJSON(meta).uuid),this.sheenRoughnessMap&&this.sheenRoughnessMap.isTexture&&(data.sheenRoughnessMap=this.sheenRoughnessMap.toJSON(meta).uuid),void 0!==this.dispersion&&(data.dispersion=this.dispersion),void 0!==this.iridescence&&(data.iridescence=this.iridescence),void 0!==this.iridescenceIOR&&(data.iridescenceIOR=this.iridescenceIOR),void 0!==this.iridescenceThicknessRange&&(data.iridescenceThicknessRange=this.iridescenceThicknessRange),this.iridescenceMap&&this.iridescenceMap.isTexture&&(data.iridescenceMap=this.iridescenceMap.toJSON(meta).uuid),this.iridescenceThicknessMap&&this.iridescenceThicknessMap.isTexture&&(data.iridescenceThicknessMap=this.iridescenceThicknessMap.toJSON(meta).uuid),void 0!==this.anisotropy&&(data.anisotropy=this.anisotropy),void 0!==this.anisotropyRotation&&(data.anisotropyRotation=this.anisotropyRotation),this.anisotropyMap&&this.anisotropyMap.isTexture&&(data.anisotropyMap=this.anisotropyMap.toJSON(meta).uuid),this.map&&this.map.isTexture&&(data.map=this.map.toJSON(meta).uuid),this.matcap&&this.matcap.isTexture&&(data.matcap=this.matcap.toJSON(meta).uuid),this.alphaMap&&this.alphaMap.isTexture&&(data.alphaMap=this.alphaMap.toJSON(meta).uuid),this.lightMap&&this.lightMap.isTexture&&(data.lightMap=this.lightMap.toJSON(meta).uuid,data.lightMapIntensity=this.lightMapIntensity),this.aoMap&&this.aoMap.isTexture&&(data.aoMap=this.aoMap.toJSON(meta).uuid,data.aoMapIntensity=this.aoMapIntensity),this.bumpMap&&this.bumpMap.isTexture&&(data.bumpMap=this.bumpMap.toJSON(meta).uuid,data.bumpScale=this.bumpScale),this.normalMap&&this.normalMap.isTexture&&(data.normalMap=this.normalMap.toJSON(meta).uuid,data.normalMapType=this.normalMapType,data.normalScale=this.normalScale.toArray()),this.displacementMap&&this.displacementMap.isTexture&&(data.displacementMap=this.displacementMap.toJSON(meta).uuid,data.displacementScale=this.displacementScale,data.displacementBias=this.displacementBias),this.roughnessMap&&this.roughnessMap.isTexture&&(data.roughnessMap=this.roughnessMap.toJSON(meta).uuid),this.metalnessMap&&this.metalnessMap.isTexture&&(data.metalnessMap=this.metalnessMap.toJSON(meta).uuid),this.emissiveMap&&this.emissiveMap.isTexture&&(data.emissiveMap=this.emissiveMap.toJSON(meta).uuid),this.specularMap&&this.specularMap.isTexture&&(data.specularMap=this.specularMap.toJSON(meta).uuid),this.specularIntensityMap&&this.specularIntensityMap.isTexture&&(data.specularIntensityMap=this.specularIntensityMap.toJSON(meta).uuid),this.specularColorMap&&this.specularColorMap.isTexture&&(data.specularColorMap=this.specularColorMap.toJSON(meta).uuid),this.envMap&&this.envMap.isTexture&&(data.envMap=this.envMap.toJSON(meta).uuid,void 0!==this.combine&&(data.combine=this.combine)),void 0!==this.envMapRotation&&(data.envMapRotation=this.envMapRotation.toArray()),void 0!==this.envMapIntensity&&(data.envMapIntensity=this.envMapIntensity),void 0!==this.reflectivity&&(data.reflectivity=this.reflectivity),void 0!==this.refractionRatio&&(data.refractionRatio=this.refractionRatio),this.gradientMap&&this.gradientMap.isTexture&&(data.gradientMap=this.gradientMap.toJSON(meta).uuid),void 0!==this.transmission&&(data.transmission=this.transmission),this.transmissionMap&&this.transmissionMap.isTexture&&(data.transmissionMap=this.transmissionMap.toJSON(meta).uuid),void 0!==this.thickness&&(data.thickness=this.thickness),this.thicknessMap&&this.thicknessMap.isTexture&&(data.thicknessMap=this.thicknessMap.toJSON(meta).uuid),void 0!==this.attenuationDistance&&Infinity!==this.attenuationDistance&&(data.attenuationDistance=this.attenuationDistance),void 0!==this.attenuationColor&&(data.attenuationColor=this.attenuationColor.getHex()),void 0!==this.size&&(data.size=this.size),null!==this.shadowSide&&(data.shadowSide=this.shadowSide),void 0!==this.sizeAttenuation&&(data.sizeAttenuation=this.sizeAttenuation),1!==this.blending&&(data.blending=this.blending),0!==this.side&&(data.side=this.side),!0===this.vertexColors&&(data.vertexColors=!0),this.opacity<1&&(data.opacity=this.opacity),!0===this.transparent&&(data.transparent=!0),204!==this.blendSrc&&(data.blendSrc=this.blendSrc),205!==this.blendDst&&(data.blendDst=this.blendDst),100!==this.blendEquation&&(data.blendEquation=this.blendEquation),null!==this.blendSrcAlpha&&(data.blendSrcAlpha=this.blendSrcAlpha),null!==this.blendDstAlpha&&(data.blendDstAlpha=this.blendDstAlpha),null!==this.blendEquationAlpha&&(data.blendEquationAlpha=this.blendEquationAlpha),this.blendColor&&this.blendColor.isColor&&(data.blendColor=this.blendColor.getHex()),0!==this.blendAlpha&&(data.blendAlpha=this.blendAlpha),3!==this.depthFunc&&(data.depthFunc=this.depthFunc),!1===this.depthTest&&(data.depthTest=this.depthTest),!1===this.depthWrite&&(data.depthWrite=this.depthWrite),!1===this.colorWrite&&(data.colorWrite=this.colorWrite),255!==this.stencilWriteMask&&(data.stencilWriteMask=this.stencilWriteMask),519!==this.stencilFunc&&(data.stencilFunc=this.stencilFunc),0!==this.stencilRef&&(data.stencilRef=this.stencilRef),255!==this.stencilFuncMask&&(data.stencilFuncMask=this.stencilFuncMask),7680!==this.stencilFail&&(data.stencilFail=this.stencilFail),7680!==this.stencilZFail&&(data.stencilZFail=this.stencilZFail),7680!==this.stencilZPass&&(data.stencilZPass=this.stencilZPass),!0===this.stencilWrite&&(data.stencilWrite=this.stencilWrite),void 0!==this.rotation&&0!==this.rotation&&(data.rotation=this.rotation),!0===this.polygonOffset&&(data.polygonOffset=!0),0!==this.polygonOffsetFactor&&(data.polygonOffsetFactor=this.polygonOffsetFactor),0!==this.polygonOffsetUnits&&(data.polygonOffsetUnits=this.polygonOffsetUnits),void 0!==this.linewidth&&1!==this.linewidth&&(data.linewidth=this.linewidth),void 0!==this.dashSize&&(data.dashSize=this.dashSize),void 0!==this.gapSize&&(data.gapSize=this.gapSize),void 0!==this.scale&&(data.scale=this.scale),!0===this.dithering&&(data.dithering=!0),this.alphaTest>0&&(data.alphaTest=this.alphaTest),!0===this.alphaHash&&(data.alphaHash=!0),!0===this.alphaToCoverage&&(data.alphaToCoverage=!0),!0===this.premultipliedAlpha&&(data.premultipliedAlpha=!0),!0===this.forceSinglePass&&(data.forceSinglePass=!0),!1===this.allowOverride&&(data.allowOverride=!1),!0===this.wireframe&&(data.wireframe=!0),this.wireframeLinewidth>1&&(data.wireframeLinewidth=this.wireframeLinewidth),"round"!==this.wireframeLinecap&&(data.wireframeLinecap=this.wireframeLinecap),"round"!==this.wireframeLinejoin&&(data.wireframeLinejoin=this.wireframeLinejoin),!0===this.flatShading&&(data.flatShading=!0),!1===this.visible&&(data.visible=!1),!1===this.toneMapped&&(data.toneMapped=!1),!1===this.fog&&(data.fog=!1),Object.keys(this.userData).length>0&&(data.userData=this.userData),isRootObject){const textures=extractFromCache(meta.textures),images=extractFromCache(meta.images);textures.length>0&&(data.textures=textures),images.length>0&&(data.images=images)}return data}clone(){return(new this.constructor).copy(this)}copy(source){this.name=source.name,this.blending=source.blending,this.side=source.side,this.vertexColors=source.vertexColors,this.opacity=source.opacity,this.transparent=source.transparent,this.blendSrc=source.blendSrc,this.blendDst=source.blendDst,this.blendEquation=source.blendEquation,this.blendSrcAlpha=source.blendSrcAlpha,this.blendDstAlpha=source.blendDstAlpha,this.blendEquationAlpha=source.blendEquationAlpha,this.blendColor.copy(source.blendColor),this.blendAlpha=source.blendAlpha,this.depthFunc=source.depthFunc,this.depthTest=source.depthTest,this.depthWrite=source.depthWrite,this.stencilWriteMask=source.stencilWriteMask,this.stencilFunc=source.stencilFunc,this.stencilRef=source.stencilRef,this.stencilFuncMask=source.stencilFuncMask,this.stencilFail=source.stencilFail,this.stencilZFail=source.stencilZFail,this.stencilZPass=source.stencilZPass,this.stencilWrite=source.stencilWrite;const srcPlanes=source.clippingPlanes;let dstPlanes=null;if(null!==srcPlanes){const n=srcPlanes.length;dstPlanes=new Array(n);for(let i=0;i!==n;++i)dstPlanes[i]=srcPlanes[i].clone()}return this.clippingPlanes=dstPlanes,this.clipIntersection=source.clipIntersection,this.clipShadows=source.clipShadows,this.shadowSide=source.shadowSide,this.colorWrite=source.colorWrite,this.precision=source.precision,this.polygonOffset=source.polygonOffset,this.polygonOffsetFactor=source.polygonOffsetFactor,this.polygonOffsetUnits=source.polygonOffsetUnits,this.dithering=source.dithering,this.alphaTest=source.alphaTest,this.alphaHash=source.alphaHash,this.alphaToCoverage=source.alphaToCoverage,this.premultipliedAlpha=source.premultipliedAlpha,this.forceSinglePass=source.forceSinglePass,this.allowOverride=source.allowOverride,this.visible=source.visible,this.toneMapped=source.toneMapped,this.userData=JSON.parse(JSON.stringify(source.userData)),this}dispose(){this.dispatchEvent({type:"dispose"})}set needsUpdate(value){!0===value&&this.version++}}class SpriteMaterial extends Material{constructor(parameters){super(),this.isSpriteMaterial=!0,this.type="SpriteMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.rotation=0,this.sizeAttenuation=!0,this.transparent=!0,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.alphaMap=source.alphaMap,this.rotation=source.rotation,this.sizeAttenuation=source.sizeAttenuation,this.fog=source.fog,this}}const _intersectPoint=/*@__PURE__*/new Vector3,_worldScale=/*@__PURE__*/new Vector3,_mvPosition=/*@__PURE__*/new Vector3,_alignedPosition=/*@__PURE__*/new Vector2,_rotatedPosition=/*@__PURE__*/new Vector2,_viewWorldMatrix=/*@__PURE__*/new Matrix4,_vA$1=/*@__PURE__*/new Vector3,_vB$1=/*@__PURE__*/new Vector3,_vC$1=/*@__PURE__*/new Vector3,_uvA=/*@__PURE__*/new Vector2,_uvB=/*@__PURE__*/new Vector2,_uvC=/*@__PURE__*/new Vector2;class Sprite extends Object3D{constructor(material=new SpriteMaterial){if(super(),this.isSprite=!0,this.type="Sprite",void 0===_geometry$1){_geometry$1=new BufferGeometry;const float32Array=new Float32Array([-.5,-.5,0,0,0,.5,-.5,0,1,0,.5,.5,0,1,1,-.5,.5,0,0,1]),interleavedBuffer=new InterleavedBuffer(float32Array,5);_geometry$1.setIndex([0,1,2,0,2,3]),_geometry$1.setAttribute("position",new InterleavedBufferAttribute(interleavedBuffer,3,0,!1)),_geometry$1.setAttribute("uv",new InterleavedBufferAttribute(interleavedBuffer,2,3,!1))}this.geometry=_geometry$1,this.material=material,this.center=new Vector2(.5,.5),this.count=1}raycast(raycaster,intersects){null===raycaster.camera&&error('Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'),_worldScale.setFromMatrixScale(this.matrixWorld),_viewWorldMatrix.copy(raycaster.camera.matrixWorld),this.modelViewMatrix.multiplyMatrices(raycaster.camera.matrixWorldInverse,this.matrixWorld),_mvPosition.setFromMatrixPosition(this.modelViewMatrix),raycaster.camera.isPerspectiveCamera&&!1===this.material.sizeAttenuation&&_worldScale.multiplyScalar(-_mvPosition.z);const rotation=this.material.rotation;let sin,cos;0!==rotation&&(cos=Math.cos(rotation),sin=Math.sin(rotation));const center=this.center;transformVertex(_vA$1.set(-.5,-.5,0),_mvPosition,center,_worldScale,sin,cos),transformVertex(_vB$1.set(.5,-.5,0),_mvPosition,center,_worldScale,sin,cos),transformVertex(_vC$1.set(.5,.5,0),_mvPosition,center,_worldScale,sin,cos),_uvA.set(0,0),_uvB.set(1,0),_uvC.set(1,1);let intersect=raycaster.ray.intersectTriangle(_vA$1,_vB$1,_vC$1,!1,_intersectPoint);if(null===intersect&&(transformVertex(_vB$1.set(-.5,.5,0),_mvPosition,center,_worldScale,sin,cos),_uvB.set(0,1),intersect=raycaster.ray.intersectTriangle(_vA$1,_vC$1,_vB$1,!1,_intersectPoint),null===intersect))return;const distance=raycaster.ray.origin.distanceTo(_intersectPoint);distance<raycaster.near||distance>raycaster.far||intersects.push({distance:distance,point:_intersectPoint.clone(),uv:Triangle.getInterpolation(_intersectPoint,_vA$1,_vB$1,_vC$1,_uvA,_uvB,_uvC,new Vector2),face:null,object:this})}copy(source,recursive){return super.copy(source,recursive),void 0!==source.center&&this.center.copy(source.center),this.material=source.material,this}}function transformVertex(vertexPosition,mvPosition,center,scale,sin,cos){_alignedPosition.subVectors(vertexPosition,center).addScalar(.5).multiply(scale),void 0!==sin?(_rotatedPosition.x=cos*_alignedPosition.x-sin*_alignedPosition.y,_rotatedPosition.y=sin*_alignedPosition.x+cos*_alignedPosition.y):_rotatedPosition.copy(_alignedPosition),vertexPosition.copy(mvPosition),vertexPosition.x+=_rotatedPosition.x,vertexPosition.y+=_rotatedPosition.y,vertexPosition.applyMatrix4(_viewWorldMatrix)}const _v1$2=/*@__PURE__*/new Vector3,_v2$1=/*@__PURE__*/new Vector3;const _vector$7=/*@__PURE__*/new Vector3,_segCenter=/*@__PURE__*/new Vector3,_segDir=/*@__PURE__*/new Vector3,_diff=/*@__PURE__*/new Vector3,_edge1=/*@__PURE__*/new Vector3,_edge2=/*@__PURE__*/new Vector3,_normal$1=/*@__PURE__*/new Vector3;class Ray{constructor(origin=new Vector3,direction=new Vector3(0,0,-1)){this.origin=origin,this.direction=direction}set(origin,direction){return this.origin.copy(origin),this.direction.copy(direction),this}copy(ray){return this.origin.copy(ray.origin),this.direction.copy(ray.direction),this}at(t,target){return target.copy(this.origin).addScaledVector(this.direction,t)}lookAt(v){return this.direction.copy(v).sub(this.origin).normalize(),this}recast(t){return this.origin.copy(this.at(t,_vector$7)),this}closestPointToPoint(point,target){target.subVectors(point,this.origin);const directionDistance=target.dot(this.direction);return directionDistance<0?target.copy(this.origin):target.copy(this.origin).addScaledVector(this.direction,directionDistance)}distanceToPoint(point){return Math.sqrt(this.distanceSqToPoint(point))}distanceSqToPoint(point){const directionDistance=_vector$7.subVectors(point,this.origin).dot(this.direction);return directionDistance<0?this.origin.distanceToSquared(point):(_vector$7.copy(this.origin).addScaledVector(this.direction,directionDistance),_vector$7.distanceToSquared(point))}distanceSqToSegment(v0,v1,optionalPointOnRay,optionalPointOnSegment){_segCenter.copy(v0).add(v1).multiplyScalar(.5),_segDir.copy(v1).sub(v0).normalize(),_diff.copy(this.origin).sub(_segCenter);const segExtent=.5*v0.distanceTo(v1),a01=-this.direction.dot(_segDir),b0=_diff.dot(this.direction),b1=-_diff.dot(_segDir),c=_diff.lengthSq(),det=Math.abs(1-a01*a01);let s0,s1,sqrDist,extDet;if(det>0)if(s0=a01*b1-b0,s1=a01*b0-b1,extDet=segExtent*det,s0>=0)if(s1>=-extDet)if(s1<=extDet){const invDet=1/det;s0*=invDet,s1*=invDet,sqrDist=s0*(s0+a01*s1+2*b0)+s1*(a01*s0+s1+2*b1)+c}else s1=segExtent,s0=Math.max(0,-(a01*s1+b0)),sqrDist=-s0*s0+s1*(s1+2*b1)+c;else s1=-segExtent,s0=Math.max(0,-(a01*s1+b0)),sqrDist=-s0*s0+s1*(s1+2*b1)+c;else s1<=-extDet?(s0=Math.max(0,-(-a01*segExtent+b0)),s1=s0>0?-segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),sqrDist=-s0*s0+s1*(s1+2*b1)+c):s1<=extDet?(s0=0,s1=Math.min(Math.max(-segExtent,-b1),segExtent),sqrDist=s1*(s1+2*b1)+c):(s0=Math.max(0,-(a01*segExtent+b0)),s1=s0>0?segExtent:Math.min(Math.max(-segExtent,-b1),segExtent),sqrDist=-s0*s0+s1*(s1+2*b1)+c);else s1=a01>0?-segExtent:segExtent,s0=Math.max(0,-(a01*s1+b0)),sqrDist=-s0*s0+s1*(s1+2*b1)+c;return optionalPointOnRay&&optionalPointOnRay.copy(this.origin).addScaledVector(this.direction,s0),optionalPointOnSegment&&optionalPointOnSegment.copy(_segCenter).addScaledVector(_segDir,s1),sqrDist}intersectSphere(sphere,target){_vector$7.subVectors(sphere.center,this.origin);const tca=_vector$7.dot(this.direction),d2=_vector$7.dot(_vector$7)-tca*tca,radius2=sphere.radius*sphere.radius;if(d2>radius2)return null;const thc=Math.sqrt(radius2-d2),t0=tca-thc,t1=tca+thc;return t1<0?null:t0<0?this.at(t1,target):this.at(t0,target)}intersectsSphere(sphere){return!(sphere.radius<0)&&this.distanceSqToPoint(sphere.center)<=sphere.radius*sphere.radius}distanceToPlane(plane){const denominator=plane.normal.dot(this.direction);if(0===denominator)return 0===plane.distanceToPoint(this.origin)?0:null;const t=-(this.origin.dot(plane.normal)+plane.constant)/denominator;return t>=0?t:null}intersectPlane(plane,target){const t=this.distanceToPlane(plane);return null===t?null:this.at(t,target)}intersectsPlane(plane){const distToPoint=plane.distanceToPoint(this.origin);if(0===distToPoint)return!0;return plane.normal.dot(this.direction)*distToPoint<0}intersectBox(box,target){let tmin,tmax,tymin,tymax,tzmin,tzmax;const invdirx=1/this.direction.x,invdiry=1/this.direction.y,invdirz=1/this.direction.z,origin=this.origin;return invdirx>=0?(tmin=(box.min.x-origin.x)*invdirx,tmax=(box.max.x-origin.x)*invdirx):(tmin=(box.max.x-origin.x)*invdirx,tmax=(box.min.x-origin.x)*invdirx),invdiry>=0?(tymin=(box.min.y-origin.y)*invdiry,tymax=(box.max.y-origin.y)*invdiry):(tymin=(box.max.y-origin.y)*invdiry,tymax=(box.min.y-origin.y)*invdiry),tmin>tymax||tymin>tmax?null:((tymin>tmin||isNaN(tmin))&&(tmin=tymin),(tymax<tmax||isNaN(tmax))&&(tmax=tymax),invdirz>=0?(tzmin=(box.min.z-origin.z)*invdirz,tzmax=(box.max.z-origin.z)*invdirz):(tzmin=(box.max.z-origin.z)*invdirz,tzmax=(box.min.z-origin.z)*invdirz),tmin>tzmax||tzmin>tmax?null:((tzmin>tmin||tmin!=tmin)&&(tmin=tzmin),(tzmax<tmax||tmax!=tmax)&&(tmax=tzmax),tmax<0?null:this.at(tmin>=0?tmin:tmax,target)))}intersectsBox(box){return null!==this.intersectBox(box,_vector$7)}intersectTriangle(a,b,c,backfaceCulling,target){_edge1.subVectors(b,a),_edge2.subVectors(c,a),_normal$1.crossVectors(_edge1,_edge2);let sign,DdN=this.direction.dot(_normal$1);if(DdN>0){if(backfaceCulling)return null;sign=1}else{if(!(DdN<0))return null;sign=-1,DdN=-DdN}_diff.subVectors(this.origin,a);const DdQxE2=sign*this.direction.dot(_edge2.crossVectors(_diff,_edge2));if(DdQxE2<0)return null;const DdE1xQ=sign*this.direction.dot(_edge1.cross(_diff));if(DdE1xQ<0)return null;if(DdQxE2+DdE1xQ>DdN)return null;const QdN=-sign*_diff.dot(_normal$1);return QdN<0?null:this.at(QdN/DdN,target)}applyMatrix4(matrix4){return this.origin.applyMatrix4(matrix4),this.direction.transformDirection(matrix4),this}equals(ray){return ray.origin.equals(this.origin)&&ray.direction.equals(this.direction)}clone(){return(new this.constructor).copy(this)}}class MeshBasicMaterial extends Material{constructor(parameters){super(),this.isMeshBasicMaterial=!0,this.type="MeshBasicMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=0,this.reflectivity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.specularMap=source.specularMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.envMapRotation.copy(source.envMapRotation),this.combine=source.combine,this.reflectivity=source.reflectivity,this.refractionRatio=source.refractionRatio,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.fog=source.fog,this}}const _inverseMatrix$3=/*@__PURE__*/new Matrix4,_ray$3=/*@__PURE__*/new Ray,_sphere$6=/*@__PURE__*/new Sphere,_sphereHitAt=/*@__PURE__*/new Vector3,_vA=/*@__PURE__*/new Vector3,_vB=/*@__PURE__*/new Vector3,_vC=/*@__PURE__*/new Vector3,_tempA=/*@__PURE__*/new Vector3,_morphA=/*@__PURE__*/new Vector3,_intersectionPoint=/*@__PURE__*/new Vector3,_intersectionPointWorld=/*@__PURE__*/new Vector3;class Mesh extends Object3D{constructor(geometry=new BufferGeometry,material=new MeshBasicMaterial){super(),this.isMesh=!0,this.type="Mesh",this.geometry=geometry,this.material=material,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.count=1,this.updateMorphTargets()}copy(source,recursive){return super.copy(source,recursive),void 0!==source.morphTargetInfluences&&(this.morphTargetInfluences=source.morphTargetInfluences.slice()),void 0!==source.morphTargetDictionary&&(this.morphTargetDictionary=Object.assign({},source.morphTargetDictionary)),this.material=Array.isArray(source.material)?source.material.slice():source.material,this.geometry=source.geometry,this}updateMorphTargets(){const morphAttributes=this.geometry.morphAttributes,keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(void 0!==morphAttribute){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0),this.morphTargetDictionary[name]=m}}}}getVertexPosition(index,target){const geometry=this.geometry,position=geometry.attributes.position,morphPosition=geometry.morphAttributes.position,morphTargetsRelative=geometry.morphTargetsRelative;target.fromBufferAttribute(position,index);const morphInfluences=this.morphTargetInfluences;if(morphPosition&&morphInfluences){_morphA.set(0,0,0);for(let i=0,il=morphPosition.length;i<il;i++){const influence=morphInfluences[i],morphAttribute=morphPosition[i];0!==influence&&(_tempA.fromBufferAttribute(morphAttribute,index),morphTargetsRelative?_morphA.addScaledVector(_tempA,influence):_morphA.addScaledVector(_tempA.sub(target),influence))}target.add(_morphA)}return target}raycast(raycaster,intersects){const geometry=this.geometry,material=this.material,matrixWorld=this.matrixWorld;if(void 0!==material){if(null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere$6.copy(geometry.boundingSphere),_sphere$6.applyMatrix4(matrixWorld),_ray$3.copy(raycaster.ray).recast(raycaster.near),!1===_sphere$6.containsPoint(_ray$3.origin)){if(null===_ray$3.intersectSphere(_sphere$6,_sphereHitAt))return;if(_ray$3.origin.distanceToSquared(_sphereHitAt)>(raycaster.far-raycaster.near)**2)return}_inverseMatrix$3.copy(matrixWorld).invert(),_ray$3.copy(raycaster.ray).applyMatrix4(_inverseMatrix$3),null!==geometry.boundingBox&&!1===_ray$3.intersectsBox(geometry.boundingBox)||this._computeIntersections(raycaster,intersects,_ray$3)}}_computeIntersections(raycaster,intersects,rayLocalSpace){let intersection;const geometry=this.geometry,material=this.material,index=geometry.index,position=geometry.attributes.position,uv=geometry.attributes.uv,uv1=geometry.attributes.uv1,normal=geometry.attributes.normal,groups=geometry.groups,drawRange=geometry.drawRange;if(null!==index)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){const group=groups[i],groupMaterial=material[group.materialIndex];for(let j=Math.max(group.start,drawRange.start),jl=Math.min(index.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));j<jl;j+=3){intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,index.getX(j),index.getX(j+1),index.getX(j+2)),intersection&&(intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=group.materialIndex,intersects.push(intersection))}}else{for(let i=Math.max(0,drawRange.start),il=Math.min(index.count,drawRange.start+drawRange.count);i<il;i+=3){intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,index.getX(i),index.getX(i+1),index.getX(i+2)),intersection&&(intersection.faceIndex=Math.floor(i/3),intersects.push(intersection))}}else if(void 0!==position)if(Array.isArray(material))for(let i=0,il=groups.length;i<il;i++){const group=groups[i],groupMaterial=material[group.materialIndex];for(let j=Math.max(group.start,drawRange.start),jl=Math.min(position.count,Math.min(group.start+group.count,drawRange.start+drawRange.count));j<jl;j+=3){intersection=checkGeometryIntersection(this,groupMaterial,raycaster,rayLocalSpace,uv,uv1,normal,j,j+1,j+2),intersection&&(intersection.faceIndex=Math.floor(j/3),intersection.face.materialIndex=group.materialIndex,intersects.push(intersection))}}else{for(let i=Math.max(0,drawRange.start),il=Math.min(position.count,drawRange.start+drawRange.count);i<il;i+=3){intersection=checkGeometryIntersection(this,material,raycaster,rayLocalSpace,uv,uv1,normal,i,i+1,i+2),intersection&&(intersection.faceIndex=Math.floor(i/3),intersects.push(intersection))}}}}function checkGeometryIntersection(object,material,raycaster,ray,uv,uv1,normal,a,b,c){object.getVertexPosition(a,_vA),object.getVertexPosition(b,_vB),object.getVertexPosition(c,_vC);const intersection=function checkIntersection$1(object,material,raycaster,ray,pA,pB,pC,point){let intersect;if(intersect=1===material.side?ray.intersectTriangle(pC,pB,pA,!0,point):ray.intersectTriangle(pA,pB,pC,0===material.side,point),null===intersect)return null;_intersectionPointWorld.copy(point),_intersectionPointWorld.applyMatrix4(object.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_intersectionPointWorld);return distance<raycaster.near||distance>raycaster.far?null:{distance:distance,point:_intersectionPointWorld.clone(),object:object}}(object,material,raycaster,ray,_vA,_vB,_vC,_intersectionPoint);if(intersection){const barycoord=new Vector3;Triangle.getBarycoord(_intersectionPoint,_vA,_vB,_vC,barycoord),uv&&(intersection.uv=Triangle.getInterpolatedAttribute(uv,a,b,c,barycoord,new Vector2)),uv1&&(intersection.uv1=Triangle.getInterpolatedAttribute(uv1,a,b,c,barycoord,new Vector2)),normal&&(intersection.normal=Triangle.getInterpolatedAttribute(normal,a,b,c,barycoord,new Vector3),intersection.normal.dot(ray.direction)>0&&intersection.normal.multiplyScalar(-1));const face={a:a,b:b,c:c,normal:new Vector3,materialIndex:0};Triangle.getNormal(_vA,_vB,_vC,face.normal),intersection.face=face,intersection.barycoord=barycoord}return intersection}const _basePosition=/*@__PURE__*/new Vector3,_skinIndex=/*@__PURE__*/new Vector4,_skinWeight=/*@__PURE__*/new Vector4,_vector3=/*@__PURE__*/new Vector3,_matrix4=/*@__PURE__*/new Matrix4,_vertex=/*@__PURE__*/new Vector3,_sphere$5=/*@__PURE__*/new Sphere,_inverseMatrix$2=/*@__PURE__*/new Matrix4,_ray$2=/*@__PURE__*/new Ray;class SkinnedMesh extends Mesh{constructor(geometry,material){super(geometry,material),this.isSkinnedMesh=!0,this.type="SkinnedMesh",this.bindMode="attached",this.bindMatrix=new Matrix4,this.bindMatrixInverse=new Matrix4,this.boundingBox=null,this.boundingSphere=null}computeBoundingBox(){const geometry=this.geometry;null===this.boundingBox&&(this.boundingBox=new Box3),this.boundingBox.makeEmpty();const positionAttribute=geometry.getAttribute("position");for(let i=0;i<positionAttribute.count;i++)this.getVertexPosition(i,_vertex),this.boundingBox.expandByPoint(_vertex)}computeBoundingSphere(){const geometry=this.geometry;null===this.boundingSphere&&(this.boundingSphere=new Sphere),this.boundingSphere.makeEmpty();const positionAttribute=geometry.getAttribute("position");for(let i=0;i<positionAttribute.count;i++)this.getVertexPosition(i,_vertex),this.boundingSphere.expandByPoint(_vertex)}copy(source,recursive){return super.copy(source,recursive),this.bindMode=source.bindMode,this.bindMatrix.copy(source.bindMatrix),this.bindMatrixInverse.copy(source.bindMatrixInverse),this.skeleton=source.skeleton,null!==source.boundingBox&&(this.boundingBox=source.boundingBox.clone()),null!==source.boundingSphere&&(this.boundingSphere=source.boundingSphere.clone()),this}raycast(raycaster,intersects){const material=this.material,matrixWorld=this.matrixWorld;void 0!==material&&(null===this.boundingSphere&&this.computeBoundingSphere(),_sphere$5.copy(this.boundingSphere),_sphere$5.applyMatrix4(matrixWorld),!1!==raycaster.ray.intersectsSphere(_sphere$5)&&(_inverseMatrix$2.copy(matrixWorld).invert(),_ray$2.copy(raycaster.ray).applyMatrix4(_inverseMatrix$2),null!==this.boundingBox&&!1===_ray$2.intersectsBox(this.boundingBox)||this._computeIntersections(raycaster,intersects,_ray$2)))}getVertexPosition(index,target){return super.getVertexPosition(index,target),this.applyBoneTransform(index,target),target}bind(skeleton,bindMatrix){this.skeleton=skeleton,void 0===bindMatrix&&(this.updateMatrixWorld(!0),this.skeleton.calculateInverses(),bindMatrix=this.matrixWorld),this.bindMatrix.copy(bindMatrix),this.bindMatrixInverse.copy(bindMatrix).invert()}pose(){this.skeleton.pose()}normalizeSkinWeights(){const vector=new Vector4,skinWeight=this.geometry.attributes.skinWeight;for(let i=0,l=skinWeight.count;i<l;i++){vector.fromBufferAttribute(skinWeight,i);const scale=1/vector.manhattanLength();Infinity!==scale?vector.multiplyScalar(scale):vector.set(1,0,0,0),skinWeight.setXYZW(i,vector.x,vector.y,vector.z,vector.w)}}updateMatrixWorld(force){super.updateMatrixWorld(force),"attached"===this.bindMode?this.bindMatrixInverse.copy(this.matrixWorld).invert():"detached"===this.bindMode?this.bindMatrixInverse.copy(this.bindMatrix).invert():warn("SkinnedMesh: Unrecognized bindMode: "+this.bindMode)}applyBoneTransform(index,target){const skeleton=this.skeleton,geometry=this.geometry;_skinIndex.fromBufferAttribute(geometry.attributes.skinIndex,index),_skinWeight.fromBufferAttribute(geometry.attributes.skinWeight,index),_basePosition.copy(target).applyMatrix4(this.bindMatrix),target.set(0,0,0);for(let i=0;i<4;i++){const weight=_skinWeight.getComponent(i);if(0!==weight){const boneIndex=_skinIndex.getComponent(i);_matrix4.multiplyMatrices(skeleton.bones[boneIndex].matrixWorld,skeleton.boneInverses[boneIndex]),target.addScaledVector(_vector3.copy(_basePosition).applyMatrix4(_matrix4),weight)}}return target.applyMatrix4(this.bindMatrixInverse)}}class Bone extends Object3D{constructor(){super(),this.isBone=!0,this.type="Bone"}}class DataTexture extends Texture{constructor(data=null,width=1,height=1,format,type,mapping,wrapS,wrapT,magFilter=1003,minFilter=1003,anisotropy,colorSpace){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace),this.isDataTexture=!0,this.image={data:data,width:width,height:height},this.generateMipmaps=!1,this.flipY=!1,this.unpackAlignment=1}}const _offsetMatrix=/*@__PURE__*/new Matrix4,_identityMatrix=/*@__PURE__*/new Matrix4;class Skeleton{constructor(bones=[],boneInverses=[]){this.uuid=generateUUID(),this.bones=bones.slice(0),this.boneInverses=boneInverses,this.boneMatrices=null,this.previousBoneMatrices=null,this.boneTexture=null,this.init()}init(){const bones=this.bones,boneInverses=this.boneInverses;if(this.boneMatrices=new Float32Array(16*bones.length),0===boneInverses.length)this.calculateInverses();else if(bones.length!==boneInverses.length){warn("Skeleton: Number of inverse bone matrices does not match amount of bones."),this.boneInverses=[];for(let i=0,il=this.bones.length;i<il;i++)this.boneInverses.push(new Matrix4)}}calculateInverses(){this.boneInverses.length=0;for(let i=0,il=this.bones.length;i<il;i++){const inverse=new Matrix4;this.bones[i]&&inverse.copy(this.bones[i].matrixWorld).invert(),this.boneInverses.push(inverse)}}pose(){for(let i=0,il=this.bones.length;i<il;i++){const bone=this.bones[i];bone&&bone.matrixWorld.copy(this.boneInverses[i]).invert()}for(let i=0,il=this.bones.length;i<il;i++){const bone=this.bones[i];bone&&(bone.parent&&bone.parent.isBone?(bone.matrix.copy(bone.parent.matrixWorld).invert(),bone.matrix.multiply(bone.matrixWorld)):bone.matrix.copy(bone.matrixWorld),bone.matrix.decompose(bone.position,bone.quaternion,bone.scale))}}update(){const bones=this.bones,boneInverses=this.boneInverses,boneMatrices=this.boneMatrices,boneTexture=this.boneTexture;for(let i=0,il=bones.length;i<il;i++){const matrix=bones[i]?bones[i].matrixWorld:_identityMatrix;_offsetMatrix.multiplyMatrices(matrix,boneInverses[i]),_offsetMatrix.toArray(boneMatrices,16*i)}null!==boneTexture&&(boneTexture.needsUpdate=!0)}clone(){return new Skeleton(this.bones,this.boneInverses)}computeBoneTexture(){let size=Math.sqrt(4*this.bones.length);size=4*Math.ceil(size/4),size=Math.max(size,4);const boneMatrices=new Float32Array(size*size*4);boneMatrices.set(this.boneMatrices);const boneTexture=new DataTexture(boneMatrices,size,size,1023,1015);return boneTexture.needsUpdate=!0,this.boneMatrices=boneMatrices,this.boneTexture=boneTexture,this}getBoneByName(name){for(let i=0,il=this.bones.length;i<il;i++){const bone=this.bones[i];if(bone.name===name)return bone}}dispose(){null!==this.boneTexture&&(this.boneTexture.dispose(),this.boneTexture=null)}fromJSON(json,bones){this.uuid=json.uuid;for(let i=0,l=json.bones.length;i<l;i++){const uuid=json.bones[i];let bone=bones[uuid];void 0===bone&&(warn("Skeleton: No bone found with UUID:",uuid),bone=new Bone),this.bones.push(bone),this.boneInverses.push((new Matrix4).fromArray(json.boneInverses[i]))}return this.init(),this}toJSON(){const data={metadata:{version:4.7,type:"Skeleton",generator:"Skeleton.toJSON"},bones:[],boneInverses:[]};data.uuid=this.uuid;const bones=this.bones,boneInverses=this.boneInverses;for(let i=0,l=bones.length;i<l;i++){const bone=bones[i];data.bones.push(bone.uuid);const boneInverse=boneInverses[i];data.boneInverses.push(boneInverse.toArray())}return data}}class InstancedBufferAttribute extends BufferAttribute{constructor(array,itemSize,normalized,meshPerAttribute=1){super(array,itemSize,normalized),this.isInstancedBufferAttribute=!0,this.meshPerAttribute=meshPerAttribute}copy(source){return super.copy(source),this.meshPerAttribute=source.meshPerAttribute,this}toJSON(){const data=super.toJSON();return data.meshPerAttribute=this.meshPerAttribute,data.isInstancedBufferAttribute=!0,data}}const _instanceLocalMatrix=/*@__PURE__*/new Matrix4,_instanceWorldMatrix=/*@__PURE__*/new Matrix4,_instanceIntersects=[],_box3=/*@__PURE__*/new Box3,_identity=/*@__PURE__*/new Matrix4,_mesh$1=/*@__PURE__*/new Mesh,_sphere$4=/*@__PURE__*/new Sphere;class InstancedMesh extends Mesh{constructor(geometry,material,count){super(geometry,material),this.isInstancedMesh=!0,this.instanceMatrix=new InstancedBufferAttribute(new Float32Array(16*count),16),this.previousInstanceMatrix=null,this.instanceColor=null,this.morphTexture=null,this.count=count,this.boundingBox=null,this.boundingSphere=null;for(let i=0;i<count;i++)this.setMatrixAt(i,_identity)}computeBoundingBox(){const geometry=this.geometry,count=this.count;null===this.boundingBox&&(this.boundingBox=new Box3),null===geometry.boundingBox&&geometry.computeBoundingBox(),this.boundingBox.makeEmpty();for(let i=0;i<count;i++)this.getMatrixAt(i,_instanceLocalMatrix),_box3.copy(geometry.boundingBox).applyMatrix4(_instanceLocalMatrix),this.boundingBox.union(_box3)}computeBoundingSphere(){const geometry=this.geometry,count=this.count;null===this.boundingSphere&&(this.boundingSphere=new Sphere),null===geometry.boundingSphere&&geometry.computeBoundingSphere(),this.boundingSphere.makeEmpty();for(let i=0;i<count;i++)this.getMatrixAt(i,_instanceLocalMatrix),_sphere$4.copy(geometry.boundingSphere).applyMatrix4(_instanceLocalMatrix),this.boundingSphere.union(_sphere$4)}copy(source,recursive){return super.copy(source,recursive),this.instanceMatrix.copy(source.instanceMatrix),null!==source.previousInstanceMatrix&&(this.previousInstanceMatrix=source.previousInstanceMatrix.clone()),null!==source.morphTexture&&(this.morphTexture=source.morphTexture.clone()),null!==source.instanceColor&&(this.instanceColor=source.instanceColor.clone()),this.count=source.count,null!==source.boundingBox&&(this.boundingBox=source.boundingBox.clone()),null!==source.boundingSphere&&(this.boundingSphere=source.boundingSphere.clone()),this}getColorAt(index,color){color.fromArray(this.instanceColor.array,3*index)}getMatrixAt(index,matrix){matrix.fromArray(this.instanceMatrix.array,16*index)}getMorphAt(index,object){const objectInfluences=object.morphTargetInfluences,array=this.morphTexture.source.data.data,dataIndex=index*(objectInfluences.length+1)+1;for(let i=0;i<objectInfluences.length;i++)objectInfluences[i]=array[dataIndex+i]}raycast(raycaster,intersects){const matrixWorld=this.matrixWorld,raycastTimes=this.count;if(_mesh$1.geometry=this.geometry,_mesh$1.material=this.material,void 0!==_mesh$1.material&&(null===this.boundingSphere&&this.computeBoundingSphere(),_sphere$4.copy(this.boundingSphere),_sphere$4.applyMatrix4(matrixWorld),!1!==raycaster.ray.intersectsSphere(_sphere$4)))for(let instanceId=0;instanceId<raycastTimes;instanceId++){this.getMatrixAt(instanceId,_instanceLocalMatrix),_instanceWorldMatrix.multiplyMatrices(matrixWorld,_instanceLocalMatrix),_mesh$1.matrixWorld=_instanceWorldMatrix,_mesh$1.raycast(raycaster,_instanceIntersects);for(let i=0,l=_instanceIntersects.length;i<l;i++){const intersect=_instanceIntersects[i];intersect.instanceId=instanceId,intersect.object=this,intersects.push(intersect)}_instanceIntersects.length=0}}setColorAt(index,color){null===this.instanceColor&&(this.instanceColor=new InstancedBufferAttribute(new Float32Array(3*this.instanceMatrix.count).fill(1),3)),color.toArray(this.instanceColor.array,3*index)}setMatrixAt(index,matrix){matrix.toArray(this.instanceMatrix.array,16*index)}setMorphAt(index,object){const objectInfluences=object.morphTargetInfluences,len=objectInfluences.length+1;null===this.morphTexture&&(this.morphTexture=new DataTexture(new Float32Array(len*this.count),len,this.count,1028,1015));const array=this.morphTexture.source.data.data;let morphInfluencesSum=0;for(let i=0;i<objectInfluences.length;i++)morphInfluencesSum+=objectInfluences[i];const morphBaseInfluence=this.geometry.morphTargetsRelative?1:1-morphInfluencesSum,dataIndex=len*index;array[dataIndex]=morphBaseInfluence,array.set(objectInfluences,dataIndex+1)}updateMorphTargets(){}dispose(){this.dispatchEvent({type:"dispose"}),null!==this.morphTexture&&(this.morphTexture.dispose(),this.morphTexture=null)}}const _vector1=/*@__PURE__*/new Vector3,_vector2$2=/*@__PURE__*/new Vector3,_normalMatrix=/*@__PURE__*/new Matrix3;class Plane{constructor(normal=new Vector3(1,0,0),constant=0){this.isPlane=!0,this.normal=normal,this.constant=constant}set(normal,constant){return this.normal.copy(normal),this.constant=constant,this}setComponents(x,y,z,w){return this.normal.set(x,y,z),this.constant=w,this}setFromNormalAndCoplanarPoint(normal,point){return this.normal.copy(normal),this.constant=-point.dot(this.normal),this}setFromCoplanarPoints(a,b,c){const normal=_vector1.subVectors(c,b).cross(_vector2$2.subVectors(a,b)).normalize();return this.setFromNormalAndCoplanarPoint(normal,a),this}copy(plane){return this.normal.copy(plane.normal),this.constant=plane.constant,this}normalize(){const inverseNormalLength=1/this.normal.length();return this.normal.multiplyScalar(inverseNormalLength),this.constant*=inverseNormalLength,this}negate(){return this.constant*=-1,this.normal.negate(),this}distanceToPoint(point){return this.normal.dot(point)+this.constant}distanceToSphere(sphere){return this.distanceToPoint(sphere.center)-sphere.radius}projectPoint(point,target){return target.copy(point).addScaledVector(this.normal,-this.distanceToPoint(point))}intersectLine(line,target){const direction=line.delta(_vector1),denominator=this.normal.dot(direction);if(0===denominator)return 0===this.distanceToPoint(line.start)?target.copy(line.start):null;const t=-(line.start.dot(this.normal)+this.constant)/denominator;return t<0||t>1?null:target.copy(line.start).addScaledVector(direction,t)}intersectsLine(line){const startSign=this.distanceToPoint(line.start),endSign=this.distanceToPoint(line.end);return startSign<0&&endSign>0||endSign<0&&startSign>0}intersectsBox(box){return box.intersectsPlane(this)}intersectsSphere(sphere){return sphere.intersectsPlane(this)}coplanarPoint(target){return target.copy(this.normal).multiplyScalar(-this.constant)}applyMatrix4(matrix,optionalNormalMatrix){const normalMatrix=optionalNormalMatrix||_normalMatrix.getNormalMatrix(matrix),referencePoint=this.coplanarPoint(_vector1).applyMatrix4(matrix),normal=this.normal.applyMatrix3(normalMatrix).normalize();return this.constant=-referencePoint.dot(normal),this}translate(offset){return this.constant-=offset.dot(this.normal),this}equals(plane){return plane.normal.equals(this.normal)&&plane.constant===this.constant}clone(){return(new this.constructor).copy(this)}}const _sphere$3=/*@__PURE__*/new Sphere,_defaultSpriteCenter=/*@__PURE__*/new Vector2(.5,.5),_vector$6=/*@__PURE__*/new Vector3;class Frustum{constructor(p0=new Plane,p1=new Plane,p2=new Plane,p3=new Plane,p4=new Plane,p5=new Plane){this.planes=[p0,p1,p2,p3,p4,p5]}set(p0,p1,p2,p3,p4,p5){const planes=this.planes;return planes[0].copy(p0),planes[1].copy(p1),planes[2].copy(p2),planes[3].copy(p3),planes[4].copy(p4),planes[5].copy(p5),this}copy(frustum){const planes=this.planes;for(let i=0;i<6;i++)planes[i].copy(frustum.planes[i]);return this}setFromProjectionMatrix(m,coordinateSystem=2e3,reversedDepth=!1){const planes=this.planes,me=m.elements,me0=me[0],me1=me[1],me2=me[2],me3=me[3],me4=me[4],me5=me[5],me6=me[6],me7=me[7],me8=me[8],me9=me[9],me10=me[10],me11=me[11],me12=me[12],me13=me[13],me14=me[14],me15=me[15];if(planes[0].setComponents(me3-me0,me7-me4,me11-me8,me15-me12).normalize(),planes[1].setComponents(me3+me0,me7+me4,me11+me8,me15+me12).normalize(),planes[2].setComponents(me3+me1,me7+me5,me11+me9,me15+me13).normalize(),planes[3].setComponents(me3-me1,me7-me5,me11-me9,me15-me13).normalize(),reversedDepth)planes[4].setComponents(me2,me6,me10,me14).normalize(),planes[5].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize();else if(planes[4].setComponents(me3-me2,me7-me6,me11-me10,me15-me14).normalize(),2e3===coordinateSystem)planes[5].setComponents(me3+me2,me7+me6,me11+me10,me15+me14).normalize();else{if(2001!==coordinateSystem)throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: "+coordinateSystem);planes[5].setComponents(me2,me6,me10,me14).normalize()}return this}intersectsObject(object){if(void 0!==object.boundingSphere)null===object.boundingSphere&&object.computeBoundingSphere(),_sphere$3.copy(object.boundingSphere).applyMatrix4(object.matrixWorld);else{const geometry=object.geometry;null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere$3.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld)}return this.intersectsSphere(_sphere$3)}intersectsSprite(sprite){_sphere$3.center.set(0,0,0);const offset=_defaultSpriteCenter.distanceTo(sprite.center);return _sphere$3.radius=.7071067811865476+offset,_sphere$3.applyMatrix4(sprite.matrixWorld),this.intersectsSphere(_sphere$3)}intersectsSphere(sphere){const planes=this.planes,center=sphere.center,negRadius=-sphere.radius;for(let i=0;i<6;i++){if(planes[i].distanceToPoint(center)<negRadius)return!1}return!0}intersectsBox(box){const planes=this.planes;for(let i=0;i<6;i++){const plane=planes[i];if(_vector$6.x=plane.normal.x>0?box.max.x:box.min.x,_vector$6.y=plane.normal.y>0?box.max.y:box.min.y,_vector$6.z=plane.normal.z>0?box.max.z:box.min.z,plane.distanceToPoint(_vector$6)<0)return!1}return!0}containsPoint(point){const planes=this.planes;for(let i=0;i<6;i++)if(planes[i].distanceToPoint(point)<0)return!1;return!0}clone(){return(new this.constructor).copy(this)}}const _projScreenMatrix$1$1=/*@__PURE__*/new Matrix4,_frustum$1=/*@__PURE__*/new Frustum;class FrustumArray{constructor(){this.coordinateSystem=2e3}intersectsObject(object,cameraArray){if(!cameraArray.isArrayCamera||0===cameraArray.cameras.length)return!1;for(let i=0;i<cameraArray.cameras.length;i++){const camera=cameraArray.cameras[i];if(_projScreenMatrix$1$1.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),_frustum$1.setFromProjectionMatrix(_projScreenMatrix$1$1,camera.coordinateSystem,camera.reversedDepth),_frustum$1.intersectsObject(object))return!0}return!1}intersectsSprite(sprite,cameraArray){if(!cameraArray||!cameraArray.cameras||0===cameraArray.cameras.length)return!1;for(let i=0;i<cameraArray.cameras.length;i++){const camera=cameraArray.cameras[i];if(_projScreenMatrix$1$1.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),_frustum$1.setFromProjectionMatrix(_projScreenMatrix$1$1,camera.coordinateSystem,camera.reversedDepth),_frustum$1.intersectsSprite(sprite))return!0}return!1}intersectsSphere(sphere,cameraArray){if(!cameraArray||!cameraArray.cameras||0===cameraArray.cameras.length)return!1;for(let i=0;i<cameraArray.cameras.length;i++){const camera=cameraArray.cameras[i];if(_projScreenMatrix$1$1.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),_frustum$1.setFromProjectionMatrix(_projScreenMatrix$1$1,camera.coordinateSystem,camera.reversedDepth),_frustum$1.intersectsSphere(sphere))return!0}return!1}intersectsBox(box,cameraArray){if(!cameraArray||!cameraArray.cameras||0===cameraArray.cameras.length)return!1;for(let i=0;i<cameraArray.cameras.length;i++){const camera=cameraArray.cameras[i];if(_projScreenMatrix$1$1.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),_frustum$1.setFromProjectionMatrix(_projScreenMatrix$1$1,camera.coordinateSystem,camera.reversedDepth),_frustum$1.intersectsBox(box))return!0}return!1}containsPoint(point,cameraArray){if(!cameraArray||!cameraArray.cameras||0===cameraArray.cameras.length)return!1;for(let i=0;i<cameraArray.cameras.length;i++){const camera=cameraArray.cameras[i];if(_projScreenMatrix$1$1.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),_frustum$1.setFromProjectionMatrix(_projScreenMatrix$1$1,camera.coordinateSystem,camera.reversedDepth),_frustum$1.containsPoint(point))return!0}return!1}clone(){return new FrustumArray}}function ascIdSort(a,b){return a-b}function sortOpaque(a,b){return a.z-b.z}function sortTransparent(a,b){return b.z-a.z}class MultiDrawRenderList{constructor(){this.index=0,this.pool=[],this.list=[]}push(start,count,z,index){const pool=this.pool,list=this.list;this.index>=pool.length&&pool.push({start:-1,count:-1,z:-1,index:-1});const item=pool[this.index];list.push(item),this.index++,item.start=start,item.count=count,item.z=z,item.index=index}reset(){this.list.length=0,this.index=0}}const _matrix$1=/*@__PURE__*/new Matrix4,_whiteColor=/*@__PURE__*/new Color(1,1,1),_frustum$2=/*@__PURE__*/new Frustum,_frustumArray$1=/*@__PURE__*/new FrustumArray,_box$1=/*@__PURE__*/new Box3,_sphere$2=/*@__PURE__*/new Sphere,_vector$5=/*@__PURE__*/new Vector3,_forward$1=/*@__PURE__*/new Vector3,_temp=/*@__PURE__*/new Vector3,_renderList=/*@__PURE__*/new MultiDrawRenderList,_mesh=/*@__PURE__*/new Mesh,_batchIntersects=[];function copyAttributeData(src,target,targetOffset=0){const itemSize=target.itemSize;if(src.isInterleavedBufferAttribute||src.array.constructor!==target.array.constructor){const vertexCount=src.count;for(let i=0;i<vertexCount;i++)for(let c=0;c<itemSize;c++)target.setComponent(i+targetOffset,c,src.getComponent(i,c))}else target.array.set(src.array,targetOffset*itemSize);target.needsUpdate=!0}function copyArrayContents(src,target){if(src.constructor!==target.constructor){const len=Math.min(src.length,target.length);for(let i=0;i<len;i++)target[i]=src[i]}else{const len=Math.min(src.length,target.length);target.set(new src.constructor(src.buffer,0,len))}}class LineBasicMaterial extends Material{constructor(parameters){super(),this.isLineBasicMaterial=!0,this.type="LineBasicMaterial",this.color=new Color(16777215),this.map=null,this.linewidth=1,this.linecap="round",this.linejoin="round",this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.linewidth=source.linewidth,this.linecap=source.linecap,this.linejoin=source.linejoin,this.fog=source.fog,this}}const _vStart=/*@__PURE__*/new Vector3,_vEnd=/*@__PURE__*/new Vector3,_inverseMatrix$1=/*@__PURE__*/new Matrix4,_ray$1=/*@__PURE__*/new Ray,_sphere$1=/*@__PURE__*/new Sphere,_intersectPointOnRay=/*@__PURE__*/new Vector3,_intersectPointOnSegment=/*@__PURE__*/new Vector3;class Line extends Object3D{constructor(geometry=new BufferGeometry,material=new LineBasicMaterial){super(),this.isLine=!0,this.type="Line",this.geometry=geometry,this.material=material,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(source,recursive){return super.copy(source,recursive),this.material=Array.isArray(source.material)?source.material.slice():source.material,this.geometry=source.geometry,this}computeLineDistances(){const geometry=this.geometry;if(null===geometry.index){const positionAttribute=geometry.attributes.position,lineDistances=[0];for(let i=1,l=positionAttribute.count;i<l;i++)_vStart.fromBufferAttribute(positionAttribute,i-1),_vEnd.fromBufferAttribute(positionAttribute,i),lineDistances[i]=lineDistances[i-1],lineDistances[i]+=_vStart.distanceTo(_vEnd);geometry.setAttribute("lineDistance",new Float32BufferAttribute(lineDistances,1))}else warn("Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}raycast(raycaster,intersects){const geometry=this.geometry,matrixWorld=this.matrixWorld,threshold=raycaster.params.Line.threshold,drawRange=geometry.drawRange;if(null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere$1.copy(geometry.boundingSphere),_sphere$1.applyMatrix4(matrixWorld),_sphere$1.radius+=threshold,!1===raycaster.ray.intersectsSphere(_sphere$1))return;_inverseMatrix$1.copy(matrixWorld).invert(),_ray$1.copy(raycaster.ray).applyMatrix4(_inverseMatrix$1);const localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3),localThresholdSq=localThreshold*localThreshold,step=this.isLineSegments?2:1,index=geometry.index,positionAttribute=geometry.attributes.position;if(null!==index){const start=Math.max(0,drawRange.start),end=Math.min(index.count,drawRange.start+drawRange.count);for(let i=start,l=end-1;i<l;i+=step){const a=index.getX(i),b=index.getX(i+1),intersect=checkIntersection(this,raycaster,_ray$1,localThresholdSq,a,b,i);intersect&&intersects.push(intersect)}if(this.isLineLoop){const a=index.getX(end-1),b=index.getX(start),intersect=checkIntersection(this,raycaster,_ray$1,localThresholdSq,a,b,end-1);intersect&&intersects.push(intersect)}}else{const start=Math.max(0,drawRange.start),end=Math.min(positionAttribute.count,drawRange.start+drawRange.count);for(let i=start,l=end-1;i<l;i+=step){const intersect=checkIntersection(this,raycaster,_ray$1,localThresholdSq,i,i+1,i);intersect&&intersects.push(intersect)}if(this.isLineLoop){const intersect=checkIntersection(this,raycaster,_ray$1,localThresholdSq,end-1,start,end-1);intersect&&intersects.push(intersect)}}}updateMorphTargets(){const morphAttributes=this.geometry.morphAttributes,keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(void 0!==morphAttribute){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0),this.morphTargetDictionary[name]=m}}}}}function checkIntersection(object,raycaster,ray,thresholdSq,a,b,i){const positionAttribute=object.geometry.attributes.position;_vStart.fromBufferAttribute(positionAttribute,a),_vEnd.fromBufferAttribute(positionAttribute,b);if(ray.distanceSqToSegment(_vStart,_vEnd,_intersectPointOnRay,_intersectPointOnSegment)>thresholdSq)return;_intersectPointOnRay.applyMatrix4(object.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_intersectPointOnRay);return distance<raycaster.near||distance>raycaster.far?void 0:{distance:distance,point:_intersectPointOnSegment.clone().applyMatrix4(object.matrixWorld),index:i,face:null,faceIndex:null,barycoord:null,object:object}}const _start=/*@__PURE__*/new Vector3,_end=/*@__PURE__*/new Vector3;class LineSegments extends Line{constructor(geometry,material){super(geometry,material),this.isLineSegments=!0,this.type="LineSegments"}computeLineDistances(){const geometry=this.geometry;if(null===geometry.index){const positionAttribute=geometry.attributes.position,lineDistances=[];for(let i=0,l=positionAttribute.count;i<l;i+=2)_start.fromBufferAttribute(positionAttribute,i),_end.fromBufferAttribute(positionAttribute,i+1),lineDistances[i]=0===i?0:lineDistances[i-1],lineDistances[i+1]=lineDistances[i]+_start.distanceTo(_end);geometry.setAttribute("lineDistance",new Float32BufferAttribute(lineDistances,1))}else warn("LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");return this}}class PointsMaterial extends Material{constructor(parameters){super(),this.isPointsMaterial=!0,this.type="PointsMaterial",this.color=new Color(16777215),this.map=null,this.alphaMap=null,this.size=1,this.sizeAttenuation=!0,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.alphaMap=source.alphaMap,this.size=source.size,this.sizeAttenuation=source.sizeAttenuation,this.fog=source.fog,this}}const _inverseMatrix=/*@__PURE__*/new Matrix4,_ray$4=/*@__PURE__*/new Ray,_sphere$7=/*@__PURE__*/new Sphere,_position$3=/*@__PURE__*/new Vector3;function testPoint(point,index,localThresholdSq,matrixWorld,raycaster,intersects,object){const rayPointDistanceSq=_ray$4.distanceSqToPoint(point);if(rayPointDistanceSq<localThresholdSq){const intersectPoint=new Vector3;_ray$4.closestPointToPoint(point,intersectPoint),intersectPoint.applyMatrix4(matrixWorld);const distance=raycaster.ray.origin.distanceTo(intersectPoint);if(distance<raycaster.near||distance>raycaster.far)return;intersects.push({distance:distance,distanceToRay:Math.sqrt(rayPointDistanceSq),point:intersectPoint,index:index,face:null,faceIndex:null,barycoord:null,object:object})}}class FramebufferTexture extends Texture{constructor(width,height){super({width:width,height:height}),this.isFramebufferTexture=!0,this.magFilter=1003,this.minFilter=1003,this.generateMipmaps=!1,this.needsUpdate=!0}}class CompressedTexture extends Texture{constructor(mipmaps,width,height,format,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,colorSpace){super(null,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace),this.isCompressedTexture=!0,this.image={width:width,height:height},this.mipmaps=mipmaps,this.flipY=!1,this.generateMipmaps=!1}}class CompressedArrayTexture extends CompressedTexture{constructor(mipmaps,width,height,depth,format,type){super(mipmaps,width,height,format,type),this.isCompressedArrayTexture=!0,this.image.depth=depth,this.wrapR=1001,this.layerUpdates=new Set}addLayerUpdate(layerIndex){this.layerUpdates.add(layerIndex)}clearLayerUpdates(){this.layerUpdates.clear()}}class CubeTexture extends Texture{constructor(images=[],mapping=301,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace){super(images,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy,colorSpace),this.isCubeTexture=!0,this.flipY=!1}get images(){return this.image}set images(value){this.image=value}}class DepthTexture extends Texture{constructor(width,height,type=1014,mapping,wrapS,wrapT,magFilter=1003,minFilter=1003,anisotropy,format=1026,depth=1){if(1026!==format&&1027!==format)throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");super({width:width,height:height,depth:depth},mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy),this.isDepthTexture=!0,this.flipY=!1,this.generateMipmaps=!1,this.compareFunction=null}copy(source){return super.copy(source),this.source=new Source(Object.assign({},source.image)),this.compareFunction=source.compareFunction,this}toJSON(meta){const data=super.toJSON(meta);return null!==this.compareFunction&&(data.compareFunction=this.compareFunction),data}}class CubeDepthTexture extends DepthTexture{constructor(size,type=1014,mapping=301,wrapS,wrapT,magFilter=1003,minFilter=1003,anisotropy,format=1026){const image={width:size,height:size,depth:1},images=[image,image,image,image,image,image];super(size,size,type,mapping,wrapS,wrapT,magFilter,minFilter,anisotropy,format),this.image=images,this.isCubeDepthTexture=!0,this.isCubeTexture=!0}get images(){return this.image}set images(value){this.image=value}}class BoxGeometry extends BufferGeometry{constructor(width=1,height=1,depth=1,widthSegments=1,heightSegments=1,depthSegments=1){super(),this.type="BoxGeometry",this.parameters={width:width,height:height,depth:depth,widthSegments:widthSegments,heightSegments:heightSegments,depthSegments:depthSegments};const scope=this;widthSegments=Math.floor(widthSegments),heightSegments=Math.floor(heightSegments),depthSegments=Math.floor(depthSegments);const indices=[],vertices=[],normals=[],uvs=[];let numberOfVertices=0,groupStart=0;function buildPlane(u,v,w,udir,vdir,width,height,depth,gridX,gridY,materialIndex){const segmentWidth=width/gridX,segmentHeight=height/gridY,widthHalf=width/2,heightHalf=height/2,depthHalf=depth/2,gridX1=gridX+1,gridY1=gridY+1;let vertexCounter=0,groupCount=0;const vector=new Vector3;for(let iy=0;iy<gridY1;iy++){const y=iy*segmentHeight-heightHalf;for(let ix=0;ix<gridX1;ix++){const x=ix*segmentWidth-widthHalf;vector[u]=x*udir,vector[v]=y*vdir,vector[w]=depthHalf,vertices.push(vector.x,vector.y,vector.z),vector[u]=0,vector[v]=0,vector[w]=depth>0?1:-1,normals.push(vector.x,vector.y,vector.z),uvs.push(ix/gridX),uvs.push(1-iy/gridY),vertexCounter+=1}}for(let iy=0;iy<gridY;iy++)for(let ix=0;ix<gridX;ix++){const a=numberOfVertices+ix+gridX1*iy,b=numberOfVertices+ix+gridX1*(iy+1),c=numberOfVertices+(ix+1)+gridX1*(iy+1),d=numberOfVertices+(ix+1)+gridX1*iy;indices.push(a,b,d),indices.push(b,c,d),groupCount+=6}scope.addGroup(groupStart,groupCount,materialIndex),groupStart+=groupCount,numberOfVertices+=vertexCounter}buildPlane("z","y","x",-1,-1,depth,height,width,depthSegments,heightSegments,0),buildPlane("z","y","x",1,-1,depth,height,-width,depthSegments,heightSegments,1),buildPlane("x","z","y",1,1,width,depth,height,widthSegments,depthSegments,2),buildPlane("x","z","y",1,-1,width,depth,-height,widthSegments,depthSegments,3),buildPlane("x","y","z",1,-1,width,height,depth,widthSegments,heightSegments,4),buildPlane("x","y","z",-1,-1,width,height,-depth,widthSegments,heightSegments,5),this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new BoxGeometry(data.width,data.height,data.depth,data.widthSegments,data.heightSegments,data.depthSegments)}}class CapsuleGeometry extends BufferGeometry{constructor(radius=1,height=1,capSegments=4,radialSegments=8,heightSegments=1){super(),this.type="CapsuleGeometry",this.parameters={radius:radius,height:height,capSegments:capSegments,radialSegments:radialSegments,heightSegments:heightSegments},height=Math.max(0,height),capSegments=Math.max(1,Math.floor(capSegments)),radialSegments=Math.max(3,Math.floor(radialSegments)),heightSegments=Math.max(1,Math.floor(heightSegments));const indices=[],vertices=[],normals=[],uvs=[],halfHeight=height/2,capArcLength=Math.PI/2*radius,cylinderPartLength=height,totalArcLength=2*capArcLength+cylinderPartLength,numVerticalSegments=2*capSegments+heightSegments,verticesPerRow=radialSegments+1,normal=new Vector3,vertex=new Vector3;for(let iy=0;iy<=numVerticalSegments;iy++){let currentArcLength=0,profileY=0,profileRadius=0,normalYComponent=0;if(iy<=capSegments){const segmentProgress=iy/capSegments,angle=segmentProgress*Math.PI/2;profileY=-halfHeight-radius*Math.cos(angle),profileRadius=radius*Math.sin(angle),normalYComponent=-radius*Math.cos(angle),currentArcLength=segmentProgress*capArcLength}else if(iy<=capSegments+heightSegments){const segmentProgress=(iy-capSegments)/heightSegments;profileY=segmentProgress*height-halfHeight,profileRadius=radius,normalYComponent=0,currentArcLength=capArcLength+segmentProgress*cylinderPartLength}else{const segmentProgress=(iy-capSegments-heightSegments)/capSegments,angle=segmentProgress*Math.PI/2;profileY=halfHeight+radius*Math.sin(angle),profileRadius=radius*Math.cos(angle),normalYComponent=radius*Math.sin(angle),currentArcLength=capArcLength+cylinderPartLength+segmentProgress*capArcLength}const v=Math.max(0,Math.min(1,currentArcLength/totalArcLength));let uOffset=0;0===iy?uOffset=.5/radialSegments:iy===numVerticalSegments&&(uOffset=-.5/radialSegments);for(let ix=0;ix<=radialSegments;ix++){const u=ix/radialSegments,theta=u*Math.PI*2,sinTheta=Math.sin(theta),cosTheta=Math.cos(theta);vertex.x=-profileRadius*cosTheta,vertex.y=profileY,vertex.z=profileRadius*sinTheta,vertices.push(vertex.x,vertex.y,vertex.z),normal.set(-profileRadius*cosTheta,normalYComponent,profileRadius*sinTheta),normal.normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(u+uOffset,v)}if(iy>0){const prevIndexRow=(iy-1)*verticesPerRow;for(let ix=0;ix<radialSegments;ix++){const i1=prevIndexRow+ix,i2=prevIndexRow+ix+1,i3=iy*verticesPerRow+ix,i4=iy*verticesPerRow+ix+1;indices.push(i1,i2,i3),indices.push(i2,i4,i3)}}}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new CapsuleGeometry(data.radius,data.height,data.capSegments,data.radialSegments,data.heightSegments)}}class CircleGeometry extends BufferGeometry{constructor(radius=1,segments=32,thetaStart=0,thetaLength=2*Math.PI){super(),this.type="CircleGeometry",this.parameters={radius:radius,segments:segments,thetaStart:thetaStart,thetaLength:thetaLength},segments=Math.max(3,segments);const indices=[],vertices=[],normals=[],uvs=[],vertex=new Vector3,uv=new Vector2;vertices.push(0,0,0),normals.push(0,0,1),uvs.push(.5,.5);for(let s=0,i=3;s<=segments;s++,i+=3){const segment=thetaStart+s/segments*thetaLength;vertex.x=radius*Math.cos(segment),vertex.y=radius*Math.sin(segment),vertices.push(vertex.x,vertex.y,vertex.z),normals.push(0,0,1),uv.x=(vertices[i]/radius+1)/2,uv.y=(vertices[i+1]/radius+1)/2,uvs.push(uv.x,uv.y)}for(let i=1;i<=segments;i++)indices.push(i,i+1,0);this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new CircleGeometry(data.radius,data.segments,data.thetaStart,data.thetaLength)}}class CylinderGeometry extends BufferGeometry{constructor(radiusTop=1,radiusBottom=1,height=1,radialSegments=32,heightSegments=1,openEnded=!1,thetaStart=0,thetaLength=2*Math.PI){super(),this.type="CylinderGeometry",this.parameters={radiusTop:radiusTop,radiusBottom:radiusBottom,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength};const scope=this;radialSegments=Math.floor(radialSegments),heightSegments=Math.floor(heightSegments);const indices=[],vertices=[],normals=[],uvs=[];let index=0;const indexArray=[],halfHeight=height/2;let groupStart=0;function generateCap(top){const centerIndexStart=index,uv=new Vector2,vertex=new Vector3;let groupCount=0;const radius=!0===top?radiusTop:radiusBottom,sign=!0===top?1:-1;for(let x=1;x<=radialSegments;x++)vertices.push(0,halfHeight*sign,0),normals.push(0,sign,0),uvs.push(.5,.5),index++;const centerIndexEnd=index;for(let x=0;x<=radialSegments;x++){const theta=x/radialSegments*thetaLength+thetaStart,cosTheta=Math.cos(theta),sinTheta=Math.sin(theta);vertex.x=radius*sinTheta,vertex.y=halfHeight*sign,vertex.z=radius*cosTheta,vertices.push(vertex.x,vertex.y,vertex.z),normals.push(0,sign,0),uv.x=.5*cosTheta+.5,uv.y=.5*sinTheta*sign+.5,uvs.push(uv.x,uv.y),index++}for(let x=0;x<radialSegments;x++){const c=centerIndexStart+x,i=centerIndexEnd+x;!0===top?indices.push(i,i+1,c):indices.push(i+1,i,c),groupCount+=3}scope.addGroup(groupStart,groupCount,!0===top?1:2),groupStart+=groupCount}!function generateTorso(){const normal=new Vector3,vertex=new Vector3;let groupCount=0;const slope=(radiusBottom-radiusTop)/height;for(let y=0;y<=heightSegments;y++){const indexRow=[],v=y/heightSegments,radius=v*(radiusBottom-radiusTop)+radiusTop;for(let x=0;x<=radialSegments;x++){const u=x/radialSegments,theta=u*thetaLength+thetaStart,sinTheta=Math.sin(theta),cosTheta=Math.cos(theta);vertex.x=radius*sinTheta,vertex.y=-v*height+halfHeight,vertex.z=radius*cosTheta,vertices.push(vertex.x,vertex.y,vertex.z),normal.set(sinTheta,slope,cosTheta).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(u,1-v),indexRow.push(index++)}indexArray.push(indexRow)}for(let x=0;x<radialSegments;x++)for(let y=0;y<heightSegments;y++){const a=indexArray[y][x],b=indexArray[y+1][x],c=indexArray[y+1][x+1],d=indexArray[y][x+1];(radiusTop>0||0!==y)&&(indices.push(a,b,d),groupCount+=3),(radiusBottom>0||y!==heightSegments-1)&&(indices.push(b,c,d),groupCount+=3)}scope.addGroup(groupStart,groupCount,0),groupStart+=groupCount}(),!1===openEnded&&(radiusTop>0&&generateCap(!0),radiusBottom>0&&generateCap(!1)),this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new CylinderGeometry(data.radiusTop,data.radiusBottom,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength)}}class ConeGeometry extends CylinderGeometry{constructor(radius=1,height=1,radialSegments=32,heightSegments=1,openEnded=!1,thetaStart=0,thetaLength=2*Math.PI){super(0,radius,height,radialSegments,heightSegments,openEnded,thetaStart,thetaLength),this.type="ConeGeometry",this.parameters={radius:radius,height:height,radialSegments:radialSegments,heightSegments:heightSegments,openEnded:openEnded,thetaStart:thetaStart,thetaLength:thetaLength}}static fromJSON(data){return new ConeGeometry(data.radius,data.height,data.radialSegments,data.heightSegments,data.openEnded,data.thetaStart,data.thetaLength)}}class PolyhedronGeometry extends BufferGeometry{constructor(vertices=[],indices=[],radius=1,detail=0){super(),this.type="PolyhedronGeometry",this.parameters={vertices:vertices,indices:indices,radius:radius,detail:detail};const vertexBuffer=[],uvBuffer=[];function subdivideFace(a,b,c,detail){const cols=detail+1,v=[];for(let i=0;i<=cols;i++){v[i]=[];const aj=a.clone().lerp(c,i/cols),bj=b.clone().lerp(c,i/cols),rows=cols-i;for(let j=0;j<=rows;j++)v[i][j]=0===j&&i===cols?aj:aj.clone().lerp(bj,j/rows)}for(let i=0;i<cols;i++)for(let j=0;j<2*(cols-i)-1;j++){const k=Math.floor(j/2);j%2==0?(pushVertex(v[i][k+1]),pushVertex(v[i+1][k]),pushVertex(v[i][k])):(pushVertex(v[i][k+1]),pushVertex(v[i+1][k+1]),pushVertex(v[i+1][k]))}}function pushVertex(vertex){vertexBuffer.push(vertex.x,vertex.y,vertex.z)}function getVertexByIndex(index,vertex){const stride=3*index;vertex.x=vertices[stride+0],vertex.y=vertices[stride+1],vertex.z=vertices[stride+2]}function correctUV(uv,stride,vector,azimuth){azimuth<0&&1===uv.x&&(uvBuffer[stride]=uv.x-1),0===vector.x&&0===vector.z&&(uvBuffer[stride]=azimuth/2/Math.PI+.5)}function azimuth(vector){return Math.atan2(vector.z,-vector.x)}function inclination(vector){return Math.atan2(-vector.y,Math.sqrt(vector.x*vector.x+vector.z*vector.z))}!function subdivide(detail){const a=new Vector3,b=new Vector3,c=new Vector3;for(let i=0;i<indices.length;i+=3)getVertexByIndex(indices[i+0],a),getVertexByIndex(indices[i+1],b),getVertexByIndex(indices[i+2],c),subdivideFace(a,b,c,detail)}(detail),function applyRadius(radius){const vertex=new Vector3;for(let i=0;i<vertexBuffer.length;i+=3)vertex.x=vertexBuffer[i+0],vertex.y=vertexBuffer[i+1],vertex.z=vertexBuffer[i+2],vertex.normalize().multiplyScalar(radius),vertexBuffer[i+0]=vertex.x,vertexBuffer[i+1]=vertex.y,vertexBuffer[i+2]=vertex.z}(radius),function generateUVs(){const vertex=new Vector3;for(let i=0;i<vertexBuffer.length;i+=3){vertex.x=vertexBuffer[i+0],vertex.y=vertexBuffer[i+1],vertex.z=vertexBuffer[i+2];const u=azimuth(vertex)/2/Math.PI+.5,v=inclination(vertex)/Math.PI+.5;uvBuffer.push(u,1-v)}(function correctUVs(){const a=new Vector3,b=new Vector3,c=new Vector3,centroid=new Vector3,uvA=new Vector2,uvB=new Vector2,uvC=new Vector2;for(let i=0,j=0;i<vertexBuffer.length;i+=9,j+=6){a.set(vertexBuffer[i+0],vertexBuffer[i+1],vertexBuffer[i+2]),b.set(vertexBuffer[i+3],vertexBuffer[i+4],vertexBuffer[i+5]),c.set(vertexBuffer[i+6],vertexBuffer[i+7],vertexBuffer[i+8]),uvA.set(uvBuffer[j+0],uvBuffer[j+1]),uvB.set(uvBuffer[j+2],uvBuffer[j+3]),uvC.set(uvBuffer[j+4],uvBuffer[j+5]),centroid.copy(a).add(b).add(c).divideScalar(3);const azi=azimuth(centroid);correctUV(uvA,j+0,a,azi),correctUV(uvB,j+2,b,azi),correctUV(uvC,j+4,c,azi)}})(),function correctSeam(){for(let i=0;i<uvBuffer.length;i+=6){const x0=uvBuffer[i+0],x1=uvBuffer[i+2],x2=uvBuffer[i+4],max=Math.max(x0,x1,x2),min=Math.min(x0,x1,x2);max>.9&&min<.1&&(x0<.2&&(uvBuffer[i+0]+=1),x1<.2&&(uvBuffer[i+2]+=1),x2<.2&&(uvBuffer[i+4]+=1))}}()}(),this.setAttribute("position",new Float32BufferAttribute(vertexBuffer,3)),this.setAttribute("normal",new Float32BufferAttribute(vertexBuffer.slice(),3)),this.setAttribute("uv",new Float32BufferAttribute(uvBuffer,2)),0===detail?this.computeVertexNormals():this.normalizeNormals()}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new PolyhedronGeometry(data.vertices,data.indices,data.radius,data.detail)}}class DodecahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t=(1+Math.sqrt(5))/2,r=1/t;super([-1,-1,-1,-1,-1,1,-1,1,-1,-1,1,1,1,-1,-1,1,-1,1,1,1,-1,1,1,1,0,-r,-t,0,-r,t,0,r,-t,0,r,t,-r,-t,0,-r,t,0,r,-t,0,r,t,0,-t,0,-r,t,0,-r,-t,0,r,t,0,r],[3,11,7,3,7,15,3,15,13,7,19,17,7,17,6,7,6,15,17,4,8,17,8,10,17,10,6,8,0,16,8,16,2,8,2,10,0,12,1,0,1,18,0,18,16,6,10,2,6,2,13,6,13,15,2,16,18,2,18,3,2,3,13,18,1,9,18,9,11,18,11,3,4,14,12,4,12,0,4,0,8,11,9,5,11,5,19,11,19,7,19,5,14,19,14,4,19,4,17,1,12,14,1,14,5,1,5,9],radius,detail),this.type="DodecahedronGeometry",this.parameters={radius:radius,detail:detail}}static fromJSON(data){return new DodecahedronGeometry(data.radius,data.detail)}}const _v0=/*@__PURE__*/new Vector3,_v1$1=/*@__PURE__*/new Vector3,_normal=/*@__PURE__*/new Vector3,_triangle=/*@__PURE__*/new Triangle;class EdgesGeometry extends BufferGeometry{constructor(geometry=null,thresholdAngle=1){if(super(),this.type="EdgesGeometry",this.parameters={geometry:geometry,thresholdAngle:thresholdAngle},null!==geometry){const precisionPoints=4,precision=Math.pow(10,precisionPoints),thresholdDot=Math.cos(DEG2RAD*thresholdAngle),indexAttr=geometry.getIndex(),positionAttr=geometry.getAttribute("position"),indexCount=indexAttr?indexAttr.count:positionAttr.count,indexArr=[0,0,0],vertKeys=["a","b","c"],hashes=new Array(3),edgeData={},vertices=[];for(let i=0;i<indexCount;i+=3){indexAttr?(indexArr[0]=indexAttr.getX(i),indexArr[1]=indexAttr.getX(i+1),indexArr[2]=indexAttr.getX(i+2)):(indexArr[0]=i,indexArr[1]=i+1,indexArr[2]=i+2);const{a:a,b:b,c:c}=_triangle;if(a.fromBufferAttribute(positionAttr,indexArr[0]),b.fromBufferAttribute(positionAttr,indexArr[1]),c.fromBufferAttribute(positionAttr,indexArr[2]),_triangle.getNormal(_normal),hashes[0]=`${Math.round(a.x*precision)},${Math.round(a.y*precision)},${Math.round(a.z*precision)}`,hashes[1]=`${Math.round(b.x*precision)},${Math.round(b.y*precision)},${Math.round(b.z*precision)}`,hashes[2]=`${Math.round(c.x*precision)},${Math.round(c.y*precision)},${Math.round(c.z*precision)}`,hashes[0]!==hashes[1]&&hashes[1]!==hashes[2]&&hashes[2]!==hashes[0])for(let j=0;j<3;j++){const jNext=(j+1)%3,vecHash0=hashes[j],vecHash1=hashes[jNext],v0=_triangle[vertKeys[j]],v1=_triangle[vertKeys[jNext]],hash=`${vecHash0}_${vecHash1}`,reverseHash=`${vecHash1}_${vecHash0}`;reverseHash in edgeData&&edgeData[reverseHash]?(_normal.dot(edgeData[reverseHash].normal)<=thresholdDot&&(vertices.push(v0.x,v0.y,v0.z),vertices.push(v1.x,v1.y,v1.z)),edgeData[reverseHash]=null):hash in edgeData||(edgeData[hash]={index0:indexArr[j],index1:indexArr[jNext],normal:_normal.clone()})}}for(const key in edgeData)if(edgeData[key]){const{index0:index0,index1:index1}=edgeData[key];_v0.fromBufferAttribute(positionAttr,index0),_v1$1.fromBufferAttribute(positionAttr,index1),vertices.push(_v0.x,_v0.y,_v0.z),vertices.push(_v1$1.x,_v1$1.y,_v1$1.z)}this.setAttribute("position",new Float32BufferAttribute(vertices,3))}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}}class Curve{constructor(){this.type="Curve",this.arcLengthDivisions=200,this.needsUpdate=!1,this.cacheArcLengths=null}getPoint(){warn("Curve: .getPoint() not implemented.")}getPointAt(u,optionalTarget){const t=this.getUtoTmapping(u);return this.getPoint(t,optionalTarget)}getPoints(divisions=5){const points=[];for(let d=0;d<=divisions;d++)points.push(this.getPoint(d/divisions));return points}getSpacedPoints(divisions=5){const points=[];for(let d=0;d<=divisions;d++)points.push(this.getPointAt(d/divisions));return points}getLength(){const lengths=this.getLengths();return lengths[lengths.length-1]}getLengths(divisions=this.arcLengthDivisions){if(this.cacheArcLengths&&this.cacheArcLengths.length===divisions+1&&!this.needsUpdate)return this.cacheArcLengths;this.needsUpdate=!1;const cache=[];let current,last=this.getPoint(0),sum=0;cache.push(0);for(let p=1;p<=divisions;p++)current=this.getPoint(p/divisions),sum+=current.distanceTo(last),cache.push(sum),last=current;return this.cacheArcLengths=cache,cache}updateArcLengths(){this.needsUpdate=!0,this.getLengths()}getUtoTmapping(u,distance=null){const arcLengths=this.getLengths();let i=0;const il=arcLengths.length;let targetArcLength;targetArcLength=distance||u*arcLengths[il-1];let comparison,low=0,high=il-1;for(;low<=high;)if(i=Math.floor(low+(high-low)/2),comparison=arcLengths[i]-targetArcLength,comparison<0)low=i+1;else{if(!(comparison>0)){high=i;break}high=i-1}if(i=high,arcLengths[i]===targetArcLength)return i/(il-1);const lengthBefore=arcLengths[i];return(i+(targetArcLength-lengthBefore)/(arcLengths[i+1]-lengthBefore))/(il-1)}getTangent(t,optionalTarget){let t1=t-1e-4,t2=t+1e-4;t1<0&&(t1=0),t2>1&&(t2=1);const pt1=this.getPoint(t1),pt2=this.getPoint(t2),tangent=optionalTarget||(pt1.isVector2?new Vector2:new Vector3);return tangent.copy(pt2).sub(pt1).normalize(),tangent}getTangentAt(u,optionalTarget){const t=this.getUtoTmapping(u);return this.getTangent(t,optionalTarget)}computeFrenetFrames(segments,closed=!1){const normal=new Vector3,tangents=[],normals=[],binormals=[],vec=new Vector3,mat=new Matrix4;for(let i=0;i<=segments;i++){const u=i/segments;tangents[i]=this.getTangentAt(u,new Vector3)}normals[0]=new Vector3,binormals[0]=new Vector3;let min=Number.MAX_VALUE;const tx=Math.abs(tangents[0].x),ty=Math.abs(tangents[0].y),tz=Math.abs(tangents[0].z);tx<=min&&(min=tx,normal.set(1,0,0)),ty<=min&&(min=ty,normal.set(0,1,0)),tz<=min&&normal.set(0,0,1),vec.crossVectors(tangents[0],normal).normalize(),normals[0].crossVectors(tangents[0],vec),binormals[0].crossVectors(tangents[0],normals[0]);for(let i=1;i<=segments;i++){if(normals[i]=normals[i-1].clone(),binormals[i]=binormals[i-1].clone(),vec.crossVectors(tangents[i-1],tangents[i]),vec.length()>Number.EPSILON){vec.normalize();const theta=Math.acos(clamp$3(tangents[i-1].dot(tangents[i]),-1,1));normals[i].applyMatrix4(mat.makeRotationAxis(vec,theta))}binormals[i].crossVectors(tangents[i],normals[i])}if(!0===closed){let theta=Math.acos(clamp$3(normals[0].dot(normals[segments]),-1,1));theta/=segments,tangents[0].dot(vec.crossVectors(normals[0],normals[segments]))>0&&(theta=-theta);for(let i=1;i<=segments;i++)normals[i].applyMatrix4(mat.makeRotationAxis(tangents[i],theta*i)),binormals[i].crossVectors(tangents[i],normals[i])}return{tangents:tangents,normals:normals,binormals:binormals}}clone(){return(new this.constructor).copy(this)}copy(source){return this.arcLengthDivisions=source.arcLengthDivisions,this}toJSON(){const data={metadata:{version:4.7,type:"Curve",generator:"Curve.toJSON"}};return data.arcLengthDivisions=this.arcLengthDivisions,data.type=this.type,data}fromJSON(json){return this.arcLengthDivisions=json.arcLengthDivisions,this}}class EllipseCurve extends Curve{constructor(aX=0,aY=0,xRadius=1,yRadius=1,aStartAngle=0,aEndAngle=2*Math.PI,aClockwise=!1,aRotation=0){super(),this.isEllipseCurve=!0,this.type="EllipseCurve",this.aX=aX,this.aY=aY,this.xRadius=xRadius,this.yRadius=yRadius,this.aStartAngle=aStartAngle,this.aEndAngle=aEndAngle,this.aClockwise=aClockwise,this.aRotation=aRotation}getPoint(t,optionalTarget=new Vector2){const point=optionalTarget,twoPi=2*Math.PI;let deltaAngle=this.aEndAngle-this.aStartAngle;const samePoints=Math.abs(deltaAngle)<Number.EPSILON;for(;deltaAngle<0;)deltaAngle+=twoPi;for(;deltaAngle>twoPi;)deltaAngle-=twoPi;deltaAngle<Number.EPSILON&&(deltaAngle=samePoints?0:twoPi),!0!==this.aClockwise||samePoints||(deltaAngle===twoPi?deltaAngle=-twoPi:deltaAngle-=twoPi);const angle=this.aStartAngle+t*deltaAngle;let x=this.aX+this.xRadius*Math.cos(angle),y=this.aY+this.yRadius*Math.sin(angle);if(0!==this.aRotation){const cos=Math.cos(this.aRotation),sin=Math.sin(this.aRotation),tx=x-this.aX,ty=y-this.aY;x=tx*cos-ty*sin+this.aX,y=tx*sin+ty*cos+this.aY}return point.set(x,y)}copy(source){return super.copy(source),this.aX=source.aX,this.aY=source.aY,this.xRadius=source.xRadius,this.yRadius=source.yRadius,this.aStartAngle=source.aStartAngle,this.aEndAngle=source.aEndAngle,this.aClockwise=source.aClockwise,this.aRotation=source.aRotation,this}toJSON(){const data=super.toJSON();return data.aX=this.aX,data.aY=this.aY,data.xRadius=this.xRadius,data.yRadius=this.yRadius,data.aStartAngle=this.aStartAngle,data.aEndAngle=this.aEndAngle,data.aClockwise=this.aClockwise,data.aRotation=this.aRotation,data}fromJSON(json){return super.fromJSON(json),this.aX=json.aX,this.aY=json.aY,this.xRadius=json.xRadius,this.yRadius=json.yRadius,this.aStartAngle=json.aStartAngle,this.aEndAngle=json.aEndAngle,this.aClockwise=json.aClockwise,this.aRotation=json.aRotation,this}}function CubicPoly(){let c0=0,c1=0,c2=0,c3=0;function init(x0,x1,t0,t1){c0=x0,c1=t0,c2=-3*x0+3*x1-2*t0-t1,c3=2*x0-2*x1+t0+t1}return{initCatmullRom:function(x0,x1,x2,x3,tension){init(x1,x2,tension*(x2-x0),tension*(x3-x1))},initNonuniformCatmullRom:function(x0,x1,x2,x3,dt0,dt1,dt2){let t1=(x1-x0)/dt0-(x2-x0)/(dt0+dt1)+(x2-x1)/dt1,t2=(x2-x1)/dt1-(x3-x1)/(dt1+dt2)+(x3-x2)/dt2;t1*=dt1,t2*=dt1,init(x1,x2,t1,t2)},calc:function(t){const t2=t*t;return c0+c1*t+c2*t2+c3*(t2*t)}}}const tmp=/*@__PURE__*/new Vector3,px=/*@__PURE__*/new CubicPoly,py=/*@__PURE__*/new CubicPoly,pz=/*@__PURE__*/new CubicPoly;function CatmullRom(t,p0,p1,p2,p3){const v0=.5*(p2-p0),v1=.5*(p3-p1),t2=t*t;return(2*p1-2*p2+v0+v1)*(t*t2)+(-3*p1+3*p2-2*v0-v1)*t2+v0*t+p1}function QuadraticBezier(t,p0,p1,p2){return function QuadraticBezierP0(t,p){const k=1-t;return k*k*p}(t,p0)+function QuadraticBezierP1(t,p){return 2*(1-t)*t*p}(t,p1)+function QuadraticBezierP2(t,p){return t*t*p}(t,p2)}function CubicBezier(t,p0,p1,p2,p3){return function CubicBezierP0(t,p){const k=1-t;return k*k*k*p}(t,p0)+function CubicBezierP1(t,p){const k=1-t;return 3*k*k*t*p}(t,p1)+function CubicBezierP2(t,p){return 3*(1-t)*t*t*p}(t,p2)+function CubicBezierP3(t,p){return t*t*t*p}(t,p3)}class CubicBezierCurve extends Curve{constructor(v0=new Vector2,v1=new Vector2,v2=new Vector2,v3=new Vector2){super(),this.isCubicBezierCurve=!0,this.type="CubicBezierCurve",this.v0=v0,this.v1=v1,this.v2=v2,this.v3=v3}getPoint(t,optionalTarget=new Vector2){const point=optionalTarget,v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;return point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this.v3.copy(source.v3),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data.v3=this.v3.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this.v3.fromArray(json.v3),this}}class LineCurve extends Curve{constructor(v1=new Vector2,v2=new Vector2){super(),this.isLineCurve=!0,this.type="LineCurve",this.v1=v1,this.v2=v2}getPoint(t,optionalTarget=new Vector2){const point=optionalTarget;return 1===t?point.copy(this.v2):(point.copy(this.v2).sub(this.v1),point.multiplyScalar(t).add(this.v1)),point}getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget)}getTangent(t,optionalTarget=new Vector2){return optionalTarget.subVectors(this.v2,this.v1).normalize()}getTangentAt(u,optionalTarget){return this.getTangent(u,optionalTarget)}copy(source){return super.copy(source),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}}class QuadraticBezierCurve extends Curve{constructor(v0=new Vector2,v1=new Vector2,v2=new Vector2){super(),this.isQuadraticBezierCurve=!0,this.type="QuadraticBezierCurve",this.v0=v0,this.v1=v1,this.v2=v2}getPoint(t,optionalTarget=new Vector2){const point=optionalTarget,v0=this.v0,v1=this.v1,v2=this.v2;return point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}}class QuadraticBezierCurve3 extends Curve{constructor(v0=new Vector3,v1=new Vector3,v2=new Vector3){super(),this.isQuadraticBezierCurve3=!0,this.type="QuadraticBezierCurve3",this.v0=v0,this.v1=v1,this.v2=v2}getPoint(t,optionalTarget=new Vector3){const point=optionalTarget,v0=this.v0,v1=this.v1,v2=this.v2;return point.set(QuadraticBezier(t,v0.x,v1.x,v2.x),QuadraticBezier(t,v0.y,v1.y,v2.y),QuadraticBezier(t,v0.z,v1.z,v2.z)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}}class SplineCurve extends Curve{constructor(points=[]){super(),this.isSplineCurve=!0,this.type="SplineCurve",this.points=points}getPoint(t,optionalTarget=new Vector2){const point=optionalTarget,points=this.points,p=(points.length-1)*t,intPoint=Math.floor(p),weight=p-intPoint,p0=points[0===intPoint?intPoint:intPoint-1],p1=points[intPoint],p2=points[intPoint>points.length-2?points.length-1:intPoint+1],p3=points[intPoint>points.length-3?points.length-1:intPoint+2];return point.set(CatmullRom(weight,p0.x,p1.x,p2.x,p3.x),CatmullRom(weight,p0.y,p1.y,p2.y,p3.y)),point}copy(source){super.copy(source),this.points=[];for(let i=0,l=source.points.length;i<l;i++){const point=source.points[i];this.points.push(point.clone())}return this}toJSON(){const data=super.toJSON();data.points=[];for(let i=0,l=this.points.length;i<l;i++){const point=this.points[i];data.points.push(point.toArray())}return data}fromJSON(json){super.fromJSON(json),this.points=[];for(let i=0,l=json.points.length;i<l;i++){const point=json.points[i];this.points.push((new Vector2).fromArray(point))}return this}}var Curves=/*#__PURE__*/Object.freeze({__proto__:null,ArcCurve:class ArcCurve extends EllipseCurve{constructor(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){super(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise),this.isArcCurve=!0,this.type="ArcCurve"}},CatmullRomCurve3:class CatmullRomCurve3 extends Curve{constructor(points=[],closed=!1,curveType="centripetal",tension=.5){super(),this.isCatmullRomCurve3=!0,this.type="CatmullRomCurve3",this.points=points,this.closed=closed,this.curveType=curveType,this.tension=tension}getPoint(t,optionalTarget=new Vector3){const point=optionalTarget,points=this.points,l=points.length,p=(l-(this.closed?0:1))*t;let p0,p3,intPoint=Math.floor(p),weight=p-intPoint;this.closed?intPoint+=intPoint>0?0:(Math.floor(Math.abs(intPoint)/l)+1)*l:0===weight&&intPoint===l-1&&(intPoint=l-2,weight=1),this.closed||intPoint>0?p0=points[(intPoint-1)%l]:(tmp.subVectors(points[0],points[1]).add(points[0]),p0=tmp);const p1=points[intPoint%l],p2=points[(intPoint+1)%l];if(this.closed||intPoint+2<l?p3=points[(intPoint+2)%l]:(tmp.subVectors(points[l-1],points[l-2]).add(points[l-1]),p3=tmp),"centripetal"===this.curveType||"chordal"===this.curveType){const pow="chordal"===this.curveType?.5:.25;let dt0=Math.pow(p0.distanceToSquared(p1),pow),dt1=Math.pow(p1.distanceToSquared(p2),pow),dt2=Math.pow(p2.distanceToSquared(p3),pow);dt1<1e-4&&(dt1=1),dt0<1e-4&&(dt0=dt1),dt2<1e-4&&(dt2=dt1),px.initNonuniformCatmullRom(p0.x,p1.x,p2.x,p3.x,dt0,dt1,dt2),py.initNonuniformCatmullRom(p0.y,p1.y,p2.y,p3.y,dt0,dt1,dt2),pz.initNonuniformCatmullRom(p0.z,p1.z,p2.z,p3.z,dt0,dt1,dt2)}else"catmullrom"===this.curveType&&(px.initCatmullRom(p0.x,p1.x,p2.x,p3.x,this.tension),py.initCatmullRom(p0.y,p1.y,p2.y,p3.y,this.tension),pz.initCatmullRom(p0.z,p1.z,p2.z,p3.z,this.tension));return point.set(px.calc(weight),py.calc(weight),pz.calc(weight)),point}copy(source){super.copy(source),this.points=[];for(let i=0,l=source.points.length;i<l;i++){const point=source.points[i];this.points.push(point.clone())}return this.closed=source.closed,this.curveType=source.curveType,this.tension=source.tension,this}toJSON(){const data=super.toJSON();data.points=[];for(let i=0,l=this.points.length;i<l;i++){const point=this.points[i];data.points.push(point.toArray())}return data.closed=this.closed,data.curveType=this.curveType,data.tension=this.tension,data}fromJSON(json){super.fromJSON(json),this.points=[];for(let i=0,l=json.points.length;i<l;i++){const point=json.points[i];this.points.push((new Vector3).fromArray(point))}return this.closed=json.closed,this.curveType=json.curveType,this.tension=json.tension,this}},CubicBezierCurve:CubicBezierCurve,CubicBezierCurve3:class CubicBezierCurve3 extends Curve{constructor(v0=new Vector3,v1=new Vector3,v2=new Vector3,v3=new Vector3){super(),this.isCubicBezierCurve3=!0,this.type="CubicBezierCurve3",this.v0=v0,this.v1=v1,this.v2=v2,this.v3=v3}getPoint(t,optionalTarget=new Vector3){const point=optionalTarget,v0=this.v0,v1=this.v1,v2=this.v2,v3=this.v3;return point.set(CubicBezier(t,v0.x,v1.x,v2.x,v3.x),CubicBezier(t,v0.y,v1.y,v2.y,v3.y),CubicBezier(t,v0.z,v1.z,v2.z,v3.z)),point}copy(source){return super.copy(source),this.v0.copy(source.v0),this.v1.copy(source.v1),this.v2.copy(source.v2),this.v3.copy(source.v3),this}toJSON(){const data=super.toJSON();return data.v0=this.v0.toArray(),data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data.v3=this.v3.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v0.fromArray(json.v0),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this.v3.fromArray(json.v3),this}},EllipseCurve:EllipseCurve,LineCurve:LineCurve,LineCurve3:class LineCurve3 extends Curve{constructor(v1=new Vector3,v2=new Vector3){super(),this.isLineCurve3=!0,this.type="LineCurve3",this.v1=v1,this.v2=v2}getPoint(t,optionalTarget=new Vector3){const point=optionalTarget;return 1===t?point.copy(this.v2):(point.copy(this.v2).sub(this.v1),point.multiplyScalar(t).add(this.v1)),point}getPointAt(u,optionalTarget){return this.getPoint(u,optionalTarget)}getTangent(t,optionalTarget=new Vector3){return optionalTarget.subVectors(this.v2,this.v1).normalize()}getTangentAt(u,optionalTarget){return this.getTangent(u,optionalTarget)}copy(source){return super.copy(source),this.v1.copy(source.v1),this.v2.copy(source.v2),this}toJSON(){const data=super.toJSON();return data.v1=this.v1.toArray(),data.v2=this.v2.toArray(),data}fromJSON(json){return super.fromJSON(json),this.v1.fromArray(json.v1),this.v2.fromArray(json.v2),this}},QuadraticBezierCurve:QuadraticBezierCurve,QuadraticBezierCurve3:QuadraticBezierCurve3,SplineCurve:SplineCurve});class CurvePath extends Curve{constructor(){super(),this.type="CurvePath",this.curves=[],this.autoClose=!1}add(curve){this.curves.push(curve)}closePath(){const startPoint=this.curves[0].getPoint(0),endPoint=this.curves[this.curves.length-1].getPoint(1);if(!startPoint.equals(endPoint)){const lineType=!0===startPoint.isVector2?"LineCurve":"LineCurve3";this.curves.push(new Curves[lineType](endPoint,startPoint))}return this}getPoint(t,optionalTarget){const d=t*this.getLength(),curveLengths=this.getCurveLengths();let i=0;for(;i<curveLengths.length;){if(curveLengths[i]>=d){const diff=curveLengths[i]-d,curve=this.curves[i],segmentLength=curve.getLength(),u=0===segmentLength?0:1-diff/segmentLength;return curve.getPointAt(u,optionalTarget)}i++}return null}getLength(){const lens=this.getCurveLengths();return lens[lens.length-1]}updateArcLengths(){this.needsUpdate=!0,this.cacheLengths=null,this.getCurveLengths()}getCurveLengths(){if(this.cacheLengths&&this.cacheLengths.length===this.curves.length)return this.cacheLengths;const lengths=[];let sums=0;for(let i=0,l=this.curves.length;i<l;i++)sums+=this.curves[i].getLength(),lengths.push(sums);return this.cacheLengths=lengths,lengths}getSpacedPoints(divisions=40){const points=[];for(let i=0;i<=divisions;i++)points.push(this.getPoint(i/divisions));return this.autoClose&&points.push(points[0]),points}getPoints(divisions=12){const points=[];let last;for(let i=0,curves=this.curves;i<curves.length;i++){const curve=curves[i],resolution=curve.isEllipseCurve?2*divisions:curve.isLineCurve||curve.isLineCurve3?1:curve.isSplineCurve?divisions*curve.points.length:divisions,pts=curve.getPoints(resolution);for(let j=0;j<pts.length;j++){const point=pts[j];last&&last.equals(point)||(points.push(point),last=point)}}return this.autoClose&&points.length>1&&!points[points.length-1].equals(points[0])&&points.push(points[0]),points}copy(source){super.copy(source),this.curves=[];for(let i=0,l=source.curves.length;i<l;i++){const curve=source.curves[i];this.curves.push(curve.clone())}return this.autoClose=source.autoClose,this}toJSON(){const data=super.toJSON();data.autoClose=this.autoClose,data.curves=[];for(let i=0,l=this.curves.length;i<l;i++){const curve=this.curves[i];data.curves.push(curve.toJSON())}return data}fromJSON(json){super.fromJSON(json),this.autoClose=json.autoClose,this.curves=[];for(let i=0,l=json.curves.length;i<l;i++){const curve=json.curves[i];this.curves.push((new Curves[curve.type]).fromJSON(curve))}return this}}class Path extends CurvePath{constructor(points){super(),this.type="Path",this.currentPoint=new Vector2,points&&this.setFromPoints(points)}setFromPoints(points){this.moveTo(points[0].x,points[0].y);for(let i=1,l=points.length;i<l;i++)this.lineTo(points[i].x,points[i].y);return this}moveTo(x,y){return this.currentPoint.set(x,y),this}lineTo(x,y){const curve=new LineCurve(this.currentPoint.clone(),new Vector2(x,y));return this.curves.push(curve),this.currentPoint.set(x,y),this}quadraticCurveTo(aCPx,aCPy,aX,aY){const curve=new QuadraticBezierCurve(this.currentPoint.clone(),new Vector2(aCPx,aCPy),new Vector2(aX,aY));return this.curves.push(curve),this.currentPoint.set(aX,aY),this}bezierCurveTo(aCP1x,aCP1y,aCP2x,aCP2y,aX,aY){const curve=new CubicBezierCurve(this.currentPoint.clone(),new Vector2(aCP1x,aCP1y),new Vector2(aCP2x,aCP2y),new Vector2(aX,aY));return this.curves.push(curve),this.currentPoint.set(aX,aY),this}splineThru(pts){const npts=[this.currentPoint.clone()].concat(pts),curve=new SplineCurve(npts);return this.curves.push(curve),this.currentPoint.copy(pts[pts.length-1]),this}arc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){const x0=this.currentPoint.x,y0=this.currentPoint.y;return this.absarc(aX+x0,aY+y0,aRadius,aStartAngle,aEndAngle,aClockwise),this}absarc(aX,aY,aRadius,aStartAngle,aEndAngle,aClockwise){return this.absellipse(aX,aY,aRadius,aRadius,aStartAngle,aEndAngle,aClockwise),this}ellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){const x0=this.currentPoint.x,y0=this.currentPoint.y;return this.absellipse(aX+x0,aY+y0,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation),this}absellipse(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation){const curve=new EllipseCurve(aX,aY,xRadius,yRadius,aStartAngle,aEndAngle,aClockwise,aRotation);if(this.curves.length>0){const firstPoint=curve.getPoint(0);firstPoint.equals(this.currentPoint)||this.lineTo(firstPoint.x,firstPoint.y)}this.curves.push(curve);const lastPoint=curve.getPoint(1);return this.currentPoint.copy(lastPoint),this}copy(source){return super.copy(source),this.currentPoint.copy(source.currentPoint),this}toJSON(){const data=super.toJSON();return data.currentPoint=this.currentPoint.toArray(),data}fromJSON(json){return super.fromJSON(json),this.currentPoint.fromArray(json.currentPoint),this}}class Shape extends Path{constructor(points){super(points),this.uuid=generateUUID(),this.type="Shape",this.holes=[]}getPointsHoles(divisions){const holesPts=[];for(let i=0,l=this.holes.length;i<l;i++)holesPts[i]=this.holes[i].getPoints(divisions);return holesPts}extractPoints(divisions){return{shape:this.getPoints(divisions),holes:this.getPointsHoles(divisions)}}copy(source){super.copy(source),this.holes=[];for(let i=0,l=source.holes.length;i<l;i++){const hole=source.holes[i];this.holes.push(hole.clone())}return this}toJSON(){const data=super.toJSON();data.uuid=this.uuid,data.holes=[];for(let i=0,l=this.holes.length;i<l;i++){const hole=this.holes[i];data.holes.push(hole.toJSON())}return data}fromJSON(json){super.fromJSON(json),this.uuid=json.uuid,this.holes=[];for(let i=0,l=json.holes.length;i<l;i++){const hole=json.holes[i];this.holes.push((new Path).fromJSON(hole))}return this}}function earcut(data,holeIndices,dim=2){const hasHoles=holeIndices&&holeIndices.length,outerLen=hasHoles?holeIndices[0]*dim:data.length;let outerNode=linkedList(data,0,outerLen,dim,!0);const triangles=[];if(!outerNode||outerNode.next===outerNode.prev)return triangles;let minX,minY,invSize;if(hasHoles&&(outerNode=function eliminateHoles(data,holeIndices,outerNode,dim){const queue=[];for(let i=0,len=holeIndices.length;i<len;i++){const list=linkedList(data,holeIndices[i]*dim,i<len-1?holeIndices[i+1]*dim:data.length,dim,!1);list===list.next&&(list.steiner=!0),queue.push(getLeftmost(list))}queue.sort(compareXYSlope);for(let i=0;i<queue.length;i++)outerNode=eliminateHole(queue[i],outerNode);return outerNode}(data,holeIndices,outerNode,dim)),data.length>80*dim){minX=data[0],minY=data[1];let maxX=minX,maxY=minY;for(let i=dim;i<outerLen;i+=dim){const x=data[i],y=data[i+1];x<minX&&(minX=x),y<minY&&(minY=y),x>maxX&&(maxX=x),y>maxY&&(maxY=y)}invSize=Math.max(maxX-minX,maxY-minY),invSize=0!==invSize?32767/invSize:0}return earcutLinked(outerNode,triangles,dim,minX,minY,invSize,0),triangles}function linkedList(data,start,end,dim,clockwise){let last;if(clockwise===function signedArea(data,start,end,dim){let sum=0;for(let i=start,j=end-dim;i<end;i+=dim)sum+=(data[j]-data[i])*(data[i+1]+data[j+1]),j=i;return sum}(data,start,end,dim)>0)for(let i=start;i<end;i+=dim)last=insertNode(i/dim|0,data[i],data[i+1],last);else for(let i=end-dim;i>=start;i-=dim)last=insertNode(i/dim|0,data[i],data[i+1],last);return last&&equals(last,last.next)&&(removeNode(last),last=last.next),last}function filterPoints(start,end){if(!start)return start;end||(end=start);let again,p=start;do{if(again=!1,p.steiner||!equals(p,p.next)&&0!==area(p.prev,p,p.next))p=p.next;else{if(removeNode(p),p=end=p.prev,p===p.next)break;again=!0}}while(again||p!==end);return end}function earcutLinked(ear,triangles,dim,minX,minY,invSize,pass){if(!ear)return;!pass&&invSize&&function indexCurve(start,minX,minY,invSize){let p=start;do{0===p.z&&(p.z=zOrder(p.x,p.y,minX,minY,invSize)),p.prevZ=p.prev,p.nextZ=p.next,p=p.next}while(p!==start);p.prevZ.nextZ=null,p.prevZ=null,function sortLinked(list){let numMerges,inSize=1;do{let e,p=list;list=null;let tail=null;for(numMerges=0;p;){numMerges++;let q=p,pSize=0;for(let i=0;i<inSize&&(pSize++,q=q.nextZ,q);i++);let qSize=inSize;for(;pSize>0||qSize>0&&q;)0!==pSize&&(0===qSize||!q||p.z<=q.z)?(e=p,p=p.nextZ,pSize--):(e=q,q=q.nextZ,qSize--),tail?tail.nextZ=e:list=e,e.prevZ=tail,tail=e;p=q}tail.nextZ=null,inSize*=2}while(numMerges>1);return list}(p)}(ear,minX,minY,invSize);let stop=ear;for(;ear.prev!==ear.next;){const prev=ear.prev,next=ear.next;if(invSize?isEarHashed(ear,minX,minY,invSize):isEar(ear))triangles.push(prev.i,ear.i,next.i),removeNode(ear),ear=next.next,stop=next.next;else if((ear=next)===stop){pass?1===pass?earcutLinked(ear=cureLocalIntersections(filterPoints(ear),triangles),triangles,dim,minX,minY,invSize,2):2===pass&&splitEarcut(ear,triangles,dim,minX,minY,invSize):earcutLinked(filterPoints(ear),triangles,dim,minX,minY,invSize,1);break}}}function isEar(ear){const a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return!1;const ax=a.x,bx=b.x,cx=c.x,ay=a.y,by=b.y,cy=c.y,x0=Math.min(ax,bx,cx),y0=Math.min(ay,by,cy),x1=Math.max(ax,bx,cx),y1=Math.max(ay,by,cy);let p=c.next;for(;p!==a;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&pointInTriangleExceptFirst(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.next}return!0}function isEarHashed(ear,minX,minY,invSize){const a=ear.prev,b=ear,c=ear.next;if(area(a,b,c)>=0)return!1;const ax=a.x,bx=b.x,cx=c.x,ay=a.y,by=b.y,cy=c.y,x0=Math.min(ax,bx,cx),y0=Math.min(ay,by,cy),x1=Math.max(ax,bx,cx),y1=Math.max(ay,by,cy),minZ=zOrder(x0,y0,minX,minY,invSize),maxZ=zOrder(x1,y1,minX,minY,invSize);let p=ear.prevZ,n=ear.nextZ;for(;p&&p.z>=minZ&&n&&n.z<=maxZ;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&p!==a&&p!==c&&pointInTriangleExceptFirst(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;if(p=p.prevZ,n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a&&n!==c&&pointInTriangleExceptFirst(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.nextZ}for(;p&&p.z>=minZ;){if(p.x>=x0&&p.x<=x1&&p.y>=y0&&p.y<=y1&&p!==a&&p!==c&&pointInTriangleExceptFirst(ax,ay,bx,by,cx,cy,p.x,p.y)&&area(p.prev,p,p.next)>=0)return!1;p=p.prevZ}for(;n&&n.z<=maxZ;){if(n.x>=x0&&n.x<=x1&&n.y>=y0&&n.y<=y1&&n!==a&&n!==c&&pointInTriangleExceptFirst(ax,ay,bx,by,cx,cy,n.x,n.y)&&area(n.prev,n,n.next)>=0)return!1;n=n.nextZ}return!0}function cureLocalIntersections(start,triangles){let p=start;do{const a=p.prev,b=p.next.next;!equals(a,b)&&intersects(a,p,p.next,b)&&locallyInside(a,b)&&locallyInside(b,a)&&(triangles.push(a.i,p.i,b.i),removeNode(p),removeNode(p.next),p=start=b),p=p.next}while(p!==start);return filterPoints(p)}function splitEarcut(start,triangles,dim,minX,minY,invSize){let a=start;do{let b=a.next.next;for(;b!==a.prev;){if(a.i!==b.i&&isValidDiagonal(a,b)){let c=splitPolygon(a,b);return a=filterPoints(a,a.next),c=filterPoints(c,c.next),earcutLinked(a,triangles,dim,minX,minY,invSize,0),void earcutLinked(c,triangles,dim,minX,minY,invSize,0)}b=b.next}a=a.next}while(a!==start)}function compareXYSlope(a,b){let result=a.x-b.x;if(0===result&&(result=a.y-b.y,0===result)){result=(a.next.y-a.y)/(a.next.x-a.x)-(b.next.y-b.y)/(b.next.x-b.x)}return result}function eliminateHole(hole,outerNode){const bridge=function findHoleBridge(hole,outerNode){let p=outerNode;const hx=hole.x,hy=hole.y;let m,qx=-Infinity;if(equals(hole,p))return p;do{if(equals(hole,p.next))return p.next;if(hy<=p.y&&hy>=p.next.y&&p.next.y!==p.y){const x=p.x+(hy-p.y)*(p.next.x-p.x)/(p.next.y-p.y);if(x<=hx&&x>qx&&(qx=x,m=p.x<p.next.x?p:p.next,x===hx))return m}p=p.next}while(p!==outerNode);if(!m)return null;const stop=m,mx=m.x,my=m.y;let tanMin=Infinity;p=m;do{if(hx>=p.x&&p.x>=mx&&hx!==p.x&&pointInTriangle(hy<my?hx:qx,hy,mx,my,hy<my?qx:hx,hy,p.x,p.y)){const tan=Math.abs(hy-p.y)/(hx-p.x);locallyInside(p,hole)&&(tan<tanMin||tan===tanMin&&(p.x>m.x||p.x===m.x&&sectorContainsSector(m,p)))&&(m=p,tanMin=tan)}p=p.next}while(p!==stop);return m}(hole,outerNode);if(!bridge)return outerNode;const bridgeReverse=splitPolygon(bridge,hole);return filterPoints(bridgeReverse,bridgeReverse.next),filterPoints(bridge,bridge.next)}function sectorContainsSector(m,p){return area(m.prev,m,p.prev)<0&&area(p.next,m,m.next)<0}function zOrder(x,y,minX,minY,invSize){return(x=1431655765&((x=858993459&((x=252645135&((x=16711935&((x=(x-minX)*invSize|0)|x<<8))|x<<4))|x<<2))|x<<1))|(y=1431655765&((y=858993459&((y=252645135&((y=16711935&((y=(y-minY)*invSize|0)|y<<8))|y<<4))|y<<2))|y<<1))<<1}function getLeftmost(start){let p=start,leftmost=start;do{(p.x<leftmost.x||p.x===leftmost.x&&p.y<leftmost.y)&&(leftmost=p),p=p.next}while(p!==start);return leftmost}function pointInTriangle(ax,ay,bx,by,cx,cy,px,py){return(cx-px)*(ay-py)>=(ax-px)*(cy-py)&&(ax-px)*(by-py)>=(bx-px)*(ay-py)&&(bx-px)*(cy-py)>=(cx-px)*(by-py)}function pointInTriangleExceptFirst(ax,ay,bx,by,cx,cy,px,py){return!(ax===px&&ay===py)&&pointInTriangle(ax,ay,bx,by,cx,cy,px,py)}function isValidDiagonal(a,b){return a.next.i!==b.i&&a.prev.i!==b.i&&!function intersectsPolygon(a,b){let p=a;do{if(p.i!==a.i&&p.next.i!==a.i&&p.i!==b.i&&p.next.i!==b.i&&intersects(p,p.next,a,b))return!0;p=p.next}while(p!==a);return!1}(a,b)&&(locallyInside(a,b)&&locallyInside(b,a)&&function middleInside(a,b){let p=a,inside=!1;const px=(a.x+b.x)/2,py=(a.y+b.y)/2;do{p.y>py!=p.next.y>py&&p.next.y!==p.y&&px<(p.next.x-p.x)*(py-p.y)/(p.next.y-p.y)+p.x&&(inside=!inside),p=p.next}while(p!==a);return inside}(a,b)&&(area(a.prev,a,b.prev)||area(a,b.prev,b))||equals(a,b)&&area(a.prev,a,a.next)>0&&area(b.prev,b,b.next)>0)}function area(p,q,r){return(q.y-p.y)*(r.x-q.x)-(q.x-p.x)*(r.y-q.y)}function equals(p1,p2){return p1.x===p2.x&&p1.y===p2.y}function intersects(p1,q1,p2,q2){const o1=sign$1(area(p1,q1,p2)),o2=sign$1(area(p1,q1,q2)),o3=sign$1(area(p2,q2,p1)),o4=sign$1(area(p2,q2,q1));return o1!==o2&&o3!==o4||(!(0!==o1||!onSegment(p1,p2,q1))||(!(0!==o2||!onSegment(p1,q2,q1))||(!(0!==o3||!onSegment(p2,p1,q2))||!(0!==o4||!onSegment(p2,q1,q2)))))}function onSegment(p,q,r){return q.x<=Math.max(p.x,r.x)&&q.x>=Math.min(p.x,r.x)&&q.y<=Math.max(p.y,r.y)&&q.y>=Math.min(p.y,r.y)}function sign$1(num){return num>0?1:num<0?-1:0}function locallyInside(a,b){return area(a.prev,a,a.next)<0?area(a,b,a.next)>=0&&area(a,a.prev,b)>=0:area(a,b,a.prev)<0||area(a,a.next,b)<0}function splitPolygon(a,b){const a2=createNode(a.i,a.x,a.y),b2=createNode(b.i,b.x,b.y),an=a.next,bp=b.prev;return a.next=b,b.prev=a,a2.next=an,an.prev=a2,b2.next=a2,a2.prev=b2,bp.next=b2,b2.prev=bp,b2}function insertNode(i,x,y,last){const p=createNode(i,x,y);return last?(p.next=last.next,p.prev=last,last.next.prev=p,last.next=p):(p.prev=p,p.next=p),p}function removeNode(p){p.next.prev=p.prev,p.prev.next=p.next,p.prevZ&&(p.prevZ.nextZ=p.nextZ),p.nextZ&&(p.nextZ.prevZ=p.prevZ)}function createNode(i,x,y){return{i:i,x:x,y:y,prev:null,next:null,z:0,prevZ:null,nextZ:null,steiner:!1}}class Earcut{static triangulate(data,holeIndices,dim=2){return earcut(data,holeIndices,dim)}}class ShapeUtils{static area(contour){const n=contour.length;let a=0;for(let p=n-1,q=0;q<n;p=q++)a+=contour[p].x*contour[q].y-contour[q].x*contour[p].y;return.5*a}static isClockWise(pts){return ShapeUtils.area(pts)<0}static triangulateShape(contour,holes){const vertices=[],holeIndices=[],faces=[];removeDupEndPts(contour),addContour(vertices,contour);let holeIndex=contour.length;holes.forEach(removeDupEndPts);for(let i=0;i<holes.length;i++)holeIndices.push(holeIndex),holeIndex+=holes[i].length,addContour(vertices,holes[i]);const triangles=Earcut.triangulate(vertices,holeIndices);for(let i=0;i<triangles.length;i+=3)faces.push(triangles.slice(i,i+3));return faces}}function removeDupEndPts(points){const l=points.length;l>2&&points[l-1].equals(points[0])&&points.pop()}function addContour(vertices,contour){for(let i=0;i<contour.length;i++)vertices.push(contour[i].x),vertices.push(contour[i].y)}class ExtrudeGeometry extends BufferGeometry{constructor(shapes=new Shape([new Vector2(.5,.5),new Vector2(-.5,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),options={}){super(),this.type="ExtrudeGeometry",this.parameters={shapes:shapes,options:options},shapes=Array.isArray(shapes)?shapes:[shapes];const scope=this,verticesArray=[],uvArray=[];for(let i=0,l=shapes.length;i<l;i++){addShape(shapes[i])}function addShape(shape){const placeholder=[],curveSegments=void 0!==options.curveSegments?options.curveSegments:12,steps=void 0!==options.steps?options.steps:1,depth=void 0!==options.depth?options.depth:1;let bevelEnabled=void 0===options.bevelEnabled||options.bevelEnabled,bevelThickness=void 0!==options.bevelThickness?options.bevelThickness:.2,bevelSize=void 0!==options.bevelSize?options.bevelSize:bevelThickness-.1,bevelOffset=void 0!==options.bevelOffset?options.bevelOffset:0,bevelSegments=void 0!==options.bevelSegments?options.bevelSegments:3;const extrudePath=options.extrudePath,uvgen=void 0!==options.UVGenerator?options.UVGenerator:WorldUVGenerator;let extrudePts,splineTube,binormal,normal,position2,extrudeByPath=!1;if(extrudePath){extrudePts=extrudePath.getSpacedPoints(steps),extrudeByPath=!0,bevelEnabled=!1;const isClosed=!!extrudePath.isCatmullRomCurve3&&extrudePath.closed;splineTube=extrudePath.computeFrenetFrames(steps,isClosed),binormal=new Vector3,normal=new Vector3,position2=new Vector3}bevelEnabled||(bevelSegments=0,bevelThickness=0,bevelSize=0,bevelOffset=0);const shapePoints=shape.extractPoints(curveSegments);let vertices=shapePoints.shape;const holes=shapePoints.holes;if(!ShapeUtils.isClockWise(vertices)){vertices=vertices.reverse();for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];ShapeUtils.isClockWise(ahole)&&(holes[h]=ahole.reverse())}}function mergeOverlappingPoints(points){let prevPos=points[0];for(let i=1;i<=points.length;i++){const currentIndex=i%points.length,currentPos=points[currentIndex],dx=currentPos.x-prevPos.x,dy=currentPos.y-prevPos.y,distSq=dx*dx+dy*dy,scalingFactorSqrt=Math.max(Math.abs(currentPos.x),Math.abs(currentPos.y),Math.abs(prevPos.x),Math.abs(prevPos.y));distSq<=1.0000000000000001e-20*scalingFactorSqrt*scalingFactorSqrt?(points.splice(currentIndex,1),i--):prevPos=currentPos}}mergeOverlappingPoints(vertices),holes.forEach(mergeOverlappingPoints);const numHoles=holes.length,contour=vertices;for(let h=0;h<numHoles;h++){const ahole=holes[h];vertices=vertices.concat(ahole)}function scalePt2(pt,vec,size){return vec||error("ExtrudeGeometry: vec does not exist"),pt.clone().addScaledVector(vec,size)}const vlen=vertices.length;function getBevelVec(inPt,inPrev,inNext){let v_trans_x,v_trans_y,shrink_by;const v_prev_x=inPt.x-inPrev.x,v_prev_y=inPt.y-inPrev.y,v_next_x=inNext.x-inPt.x,v_next_y=inNext.y-inPt.y,v_prev_lensq=v_prev_x*v_prev_x+v_prev_y*v_prev_y,collinear0=v_prev_x*v_next_y-v_prev_y*v_next_x;if(Math.abs(collinear0)>Number.EPSILON){const v_prev_len=Math.sqrt(v_prev_lensq),v_next_len=Math.sqrt(v_next_x*v_next_x+v_next_y*v_next_y),ptPrevShift_x=inPrev.x-v_prev_y/v_prev_len,ptPrevShift_y=inPrev.y+v_prev_x/v_prev_len,sf=((inNext.x-v_next_y/v_next_len-ptPrevShift_x)*v_next_y-(inNext.y+v_next_x/v_next_len-ptPrevShift_y)*v_next_x)/(v_prev_x*v_next_y-v_prev_y*v_next_x);v_trans_x=ptPrevShift_x+v_prev_x*sf-inPt.x,v_trans_y=ptPrevShift_y+v_prev_y*sf-inPt.y;const v_trans_lensq=v_trans_x*v_trans_x+v_trans_y*v_trans_y;if(v_trans_lensq<=2)return new Vector2(v_trans_x,v_trans_y);shrink_by=Math.sqrt(v_trans_lensq/2)}else{let direction_eq=!1;v_prev_x>Number.EPSILON?v_next_x>Number.EPSILON&&(direction_eq=!0):v_prev_x<-Number.EPSILON?v_next_x<-Number.EPSILON&&(direction_eq=!0):Math.sign(v_prev_y)===Math.sign(v_next_y)&&(direction_eq=!0),direction_eq?(v_trans_x=-v_prev_y,v_trans_y=v_prev_x,shrink_by=Math.sqrt(v_prev_lensq)):(v_trans_x=v_prev_x,v_trans_y=v_prev_y,shrink_by=Math.sqrt(v_prev_lensq/2))}return new Vector2(v_trans_x/shrink_by,v_trans_y/shrink_by)}const contourMovements=[];for(let i=0,il=contour.length,j=il-1,k=i+1;i<il;i++,j++,k++)j===il&&(j=0),k===il&&(k=0),contourMovements[i]=getBevelVec(contour[i],contour[j],contour[k]);const holesMovements=[];let oneHoleMovements,faces,verticesMovements=contourMovements.concat();for(let h=0,hl=numHoles;h<hl;h++){const ahole=holes[h];oneHoleMovements=[];for(let i=0,il=ahole.length,j=il-1,k=i+1;i<il;i++,j++,k++)j===il&&(j=0),k===il&&(k=0),oneHoleMovements[i]=getBevelVec(ahole[i],ahole[j],ahole[k]);holesMovements.push(oneHoleMovements),verticesMovements=verticesMovements.concat(oneHoleMovements)}if(0===bevelSegments)faces=ShapeUtils.triangulateShape(contour,holes);else{const contractedContourVertices=[],expandedHoleVertices=[];for(let b=0;b<bevelSegments;b++){const t=b/bevelSegments,z=bevelThickness*Math.cos(t*Math.PI/2),bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;for(let i=0,il=contour.length;i<il;i++){const vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,-z),0===t&&contractedContourVertices.push(vert)}for(let h=0,hl=numHoles;h<hl;h++){const ahole=holes[h];oneHoleMovements=holesMovements[h];const oneHoleVertices=[];for(let i=0,il=ahole.length;i<il;i++){const vert=scalePt2(ahole[i],oneHoleMovements[i],bs);v(vert.x,vert.y,-z),0===t&&oneHoleVertices.push(vert)}0===t&&expandedHoleVertices.push(oneHoleVertices)}}faces=ShapeUtils.triangulateShape(contractedContourVertices,expandedHoleVertices)}const flen=faces.length,bs=bevelSize+bevelOffset;for(let i=0;i<vlen;i++){const vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];extrudeByPath?(normal.copy(splineTube.normals[0]).multiplyScalar(vert.x),binormal.copy(splineTube.binormals[0]).multiplyScalar(vert.y),position2.copy(extrudePts[0]).add(normal).add(binormal),v(position2.x,position2.y,position2.z)):v(vert.x,vert.y,0)}for(let s=1;s<=steps;s++)for(let i=0;i<vlen;i++){const vert=bevelEnabled?scalePt2(vertices[i],verticesMovements[i],bs):vertices[i];extrudeByPath?(normal.copy(splineTube.normals[s]).multiplyScalar(vert.x),binormal.copy(splineTube.binormals[s]).multiplyScalar(vert.y),position2.copy(extrudePts[s]).add(normal).add(binormal),v(position2.x,position2.y,position2.z)):v(vert.x,vert.y,depth/steps*s)}for(let b=bevelSegments-1;b>=0;b--){const t=b/bevelSegments,z=bevelThickness*Math.cos(t*Math.PI/2),bs=bevelSize*Math.sin(t*Math.PI/2)+bevelOffset;for(let i=0,il=contour.length;i<il;i++){const vert=scalePt2(contour[i],contourMovements[i],bs);v(vert.x,vert.y,depth+z)}for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];oneHoleMovements=holesMovements[h];for(let i=0,il=ahole.length;i<il;i++){const vert=scalePt2(ahole[i],oneHoleMovements[i],bs);extrudeByPath?v(vert.x,vert.y+extrudePts[steps-1].y,extrudePts[steps-1].x+z):v(vert.x,vert.y,depth+z)}}}function sidewalls(contour,layeroffset){let i=contour.length;for(;--i>=0;){const j=i;let k=i-1;k<0&&(k=contour.length-1);for(let s=0,sl=steps+2*bevelSegments;s<sl;s++){const slen1=vlen*s,slen2=vlen*(s+1);f4(layeroffset+j+slen1,layeroffset+k+slen1,layeroffset+k+slen2,layeroffset+j+slen2)}}}function v(x,y,z){placeholder.push(x),placeholder.push(y),placeholder.push(z)}function f3(a,b,c){addVertex(a),addVertex(b),addVertex(c);const nextIndex=verticesArray.length/3,uvs=uvgen.generateTopUV(scope,verticesArray,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]),addUV(uvs[1]),addUV(uvs[2])}function f4(a,b,c,d){addVertex(a),addVertex(b),addVertex(d),addVertex(b),addVertex(c),addVertex(d);const nextIndex=verticesArray.length/3,uvs=uvgen.generateSideWallUV(scope,verticesArray,nextIndex-6,nextIndex-3,nextIndex-2,nextIndex-1);addUV(uvs[0]),addUV(uvs[1]),addUV(uvs[3]),addUV(uvs[1]),addUV(uvs[2]),addUV(uvs[3])}function addVertex(index){verticesArray.push(placeholder[3*index+0]),verticesArray.push(placeholder[3*index+1]),verticesArray.push(placeholder[3*index+2])}function addUV(vector2){uvArray.push(vector2.x),uvArray.push(vector2.y)}!function buildLidFaces(){const start=verticesArray.length/3;if(bevelEnabled){let layer=0,offset=vlen*layer;for(let i=0;i<flen;i++){const face=faces[i];f3(face[2]+offset,face[1]+offset,face[0]+offset)}layer=steps+2*bevelSegments,offset=vlen*layer;for(let i=0;i<flen;i++){const face=faces[i];f3(face[0]+offset,face[1]+offset,face[2]+offset)}}else{for(let i=0;i<flen;i++){const face=faces[i];f3(face[2],face[1],face[0])}for(let i=0;i<flen;i++){const face=faces[i];f3(face[0]+vlen*steps,face[1]+vlen*steps,face[2]+vlen*steps)}}scope.addGroup(start,verticesArray.length/3-start,0)}(),function buildSideFaces(){const start=verticesArray.length/3;let layeroffset=0;sidewalls(contour,layeroffset),layeroffset+=contour.length;for(let h=0,hl=holes.length;h<hl;h++){const ahole=holes[h];sidewalls(ahole,layeroffset),layeroffset+=ahole.length}scope.addGroup(start,verticesArray.length/3-start,1)}()}this.setAttribute("position",new Float32BufferAttribute(verticesArray,3)),this.setAttribute("uv",new Float32BufferAttribute(uvArray,2)),this.computeVertexNormals()}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}toJSON(){const data=super.toJSON();return function toJSON$1(shapes,options,data){if(data.shapes=[],Array.isArray(shapes))for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];data.shapes.push(shape.uuid)}else data.shapes.push(shapes.uuid);data.options=Object.assign({},options),void 0!==options.extrudePath&&(data.options.extrudePath=options.extrudePath.toJSON());return data}(this.parameters.shapes,this.parameters.options,data)}static fromJSON(data,shapes){const geometryShapes=[];for(let j=0,jl=data.shapes.length;j<jl;j++){const shape=shapes[data.shapes[j]];geometryShapes.push(shape)}const extrudePath=data.options.extrudePath;return void 0!==extrudePath&&(data.options.extrudePath=(new Curves[extrudePath.type]).fromJSON(extrudePath)),new ExtrudeGeometry(geometryShapes,data.options)}}const WorldUVGenerator={generateTopUV:function(geometry,vertices,indexA,indexB,indexC){const a_x=vertices[3*indexA],a_y=vertices[3*indexA+1],b_x=vertices[3*indexB],b_y=vertices[3*indexB+1],c_x=vertices[3*indexC],c_y=vertices[3*indexC+1];return[new Vector2(a_x,a_y),new Vector2(b_x,b_y),new Vector2(c_x,c_y)]},generateSideWallUV:function(geometry,vertices,indexA,indexB,indexC,indexD){const a_x=vertices[3*indexA],a_y=vertices[3*indexA+1],a_z=vertices[3*indexA+2],b_x=vertices[3*indexB],b_y=vertices[3*indexB+1],b_z=vertices[3*indexB+2],c_x=vertices[3*indexC],c_y=vertices[3*indexC+1],c_z=vertices[3*indexC+2],d_x=vertices[3*indexD],d_y=vertices[3*indexD+1],d_z=vertices[3*indexD+2];return Math.abs(a_y-b_y)<Math.abs(a_x-b_x)?[new Vector2(a_x,1-a_z),new Vector2(b_x,1-b_z),new Vector2(c_x,1-c_z),new Vector2(d_x,1-d_z)]:[new Vector2(a_y,1-a_z),new Vector2(b_y,1-b_z),new Vector2(c_y,1-c_z),new Vector2(d_y,1-d_z)]}};class IcosahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){const t=(1+Math.sqrt(5))/2;super([-1,t,0,1,t,0,-1,-t,0,1,-t,0,0,-1,t,0,1,t,0,-1,-t,0,1,-t,t,0,-1,t,0,1,-t,0,-1,-t,0,1],[0,11,5,0,5,1,0,1,7,0,7,10,0,10,11,1,5,9,5,11,4,11,10,2,10,7,6,7,1,8,3,9,4,3,4,2,3,2,6,3,6,8,3,8,9,4,9,5,2,4,11,6,2,10,8,6,7,9,8,1],radius,detail),this.type="IcosahedronGeometry",this.parameters={radius:radius,detail:detail}}static fromJSON(data){return new IcosahedronGeometry(data.radius,data.detail)}}class LatheGeometry extends BufferGeometry{constructor(points=[new Vector2(0,-.5),new Vector2(.5,0),new Vector2(0,.5)],segments=12,phiStart=0,phiLength=2*Math.PI){super(),this.type="LatheGeometry",this.parameters={points:points,segments:segments,phiStart:phiStart,phiLength:phiLength},segments=Math.floor(segments),phiLength=clamp$3(phiLength,0,2*Math.PI);const indices=[],vertices=[],uvs=[],initNormals=[],normals=[],inverseSegments=1/segments,vertex=new Vector3,uv=new Vector2,normal=new Vector3,curNormal=new Vector3,prevNormal=new Vector3;let dx=0,dy=0;for(let j=0;j<=points.length-1;j++)switch(j){case 0:dx=points[j+1].x-points[j].x,dy=points[j+1].y-points[j].y,normal.x=1*dy,normal.y=-dx,normal.z=0*dy,prevNormal.copy(normal),normal.normalize(),initNormals.push(normal.x,normal.y,normal.z);break;case points.length-1:initNormals.push(prevNormal.x,prevNormal.y,prevNormal.z);break;default:dx=points[j+1].x-points[j].x,dy=points[j+1].y-points[j].y,normal.x=1*dy,normal.y=-dx,normal.z=0*dy,curNormal.copy(normal),normal.x+=prevNormal.x,normal.y+=prevNormal.y,normal.z+=prevNormal.z,normal.normalize(),initNormals.push(normal.x,normal.y,normal.z),prevNormal.copy(curNormal)}for(let i=0;i<=segments;i++){const phi=phiStart+i*inverseSegments*phiLength,sin=Math.sin(phi),cos=Math.cos(phi);for(let j=0;j<=points.length-1;j++){vertex.x=points[j].x*sin,vertex.y=points[j].y,vertex.z=points[j].x*cos,vertices.push(vertex.x,vertex.y,vertex.z),uv.x=i/segments,uv.y=j/(points.length-1),uvs.push(uv.x,uv.y);const x=initNormals[3*j+0]*sin,y=initNormals[3*j+1],z=initNormals[3*j+0]*cos;normals.push(x,y,z)}}for(let i=0;i<segments;i++)for(let j=0;j<points.length-1;j++){const base=j+i*points.length,a=base,b=base+points.length,c=base+points.length+1,d=base+1;indices.push(a,b,d),indices.push(c,d,b)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2)),this.setAttribute("normal",new Float32BufferAttribute(normals,3))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new LatheGeometry(data.points,data.segments,data.phiStart,data.phiLength)}}class OctahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){super([1,0,0,-1,0,0,0,1,0,0,-1,0,0,0,1,0,0,-1],[0,2,4,0,4,3,0,3,5,0,5,2,1,2,5,1,5,3,1,3,4,1,4,2],radius,detail),this.type="OctahedronGeometry",this.parameters={radius:radius,detail:detail}}static fromJSON(data){return new OctahedronGeometry(data.radius,data.detail)}}class PlaneGeometry extends BufferGeometry{constructor(width=1,height=1,widthSegments=1,heightSegments=1){super(),this.type="PlaneGeometry",this.parameters={width:width,height:height,widthSegments:widthSegments,heightSegments:heightSegments};const width_half=width/2,height_half=height/2,gridX=Math.floor(widthSegments),gridY=Math.floor(heightSegments),gridX1=gridX+1,gridY1=gridY+1,segment_width=width/gridX,segment_height=height/gridY,indices=[],vertices=[],normals=[],uvs=[];for(let iy=0;iy<gridY1;iy++){const y=iy*segment_height-height_half;for(let ix=0;ix<gridX1;ix++){const x=ix*segment_width-width_half;vertices.push(x,-y,0),normals.push(0,0,1),uvs.push(ix/gridX),uvs.push(1-iy/gridY)}}for(let iy=0;iy<gridY;iy++)for(let ix=0;ix<gridX;ix++){const a=ix+gridX1*iy,b=ix+gridX1*(iy+1),c=ix+1+gridX1*(iy+1),d=ix+1+gridX1*iy;indices.push(a,b,d),indices.push(b,c,d)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new PlaneGeometry(data.width,data.height,data.widthSegments,data.heightSegments)}}class RingGeometry extends BufferGeometry{constructor(innerRadius=.5,outerRadius=1,thetaSegments=32,phiSegments=1,thetaStart=0,thetaLength=2*Math.PI){super(),this.type="RingGeometry",this.parameters={innerRadius:innerRadius,outerRadius:outerRadius,thetaSegments:thetaSegments,phiSegments:phiSegments,thetaStart:thetaStart,thetaLength:thetaLength},thetaSegments=Math.max(3,thetaSegments);const indices=[],vertices=[],normals=[],uvs=[];let radius=innerRadius;const radiusStep=(outerRadius-innerRadius)/(phiSegments=Math.max(1,phiSegments)),vertex=new Vector3,uv=new Vector2;for(let j=0;j<=phiSegments;j++){for(let i=0;i<=thetaSegments;i++){const segment=thetaStart+i/thetaSegments*thetaLength;vertex.x=radius*Math.cos(segment),vertex.y=radius*Math.sin(segment),vertices.push(vertex.x,vertex.y,vertex.z),normals.push(0,0,1),uv.x=(vertex.x/outerRadius+1)/2,uv.y=(vertex.y/outerRadius+1)/2,uvs.push(uv.x,uv.y)}radius+=radiusStep}for(let j=0;j<phiSegments;j++){const thetaSegmentLevel=j*(thetaSegments+1);for(let i=0;i<thetaSegments;i++){const segment=i+thetaSegmentLevel,a=segment,b=segment+thetaSegments+1,c=segment+thetaSegments+2,d=segment+1;indices.push(a,b,d),indices.push(b,c,d)}}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new RingGeometry(data.innerRadius,data.outerRadius,data.thetaSegments,data.phiSegments,data.thetaStart,data.thetaLength)}}class ShapeGeometry extends BufferGeometry{constructor(shapes=new Shape([new Vector2(0,.5),new Vector2(-.5,-.5),new Vector2(.5,-.5)]),curveSegments=12){super(),this.type="ShapeGeometry",this.parameters={shapes:shapes,curveSegments:curveSegments};const indices=[],vertices=[],normals=[],uvs=[];let groupStart=0,groupCount=0;if(!1===Array.isArray(shapes))addShape(shapes);else for(let i=0;i<shapes.length;i++)addShape(shapes[i]),this.addGroup(groupStart,groupCount,i),groupStart+=groupCount,groupCount=0;function addShape(shape){const indexOffset=vertices.length/3,points=shape.extractPoints(curveSegments);let shapeVertices=points.shape;const shapeHoles=points.holes;!1===ShapeUtils.isClockWise(shapeVertices)&&(shapeVertices=shapeVertices.reverse());for(let i=0,l=shapeHoles.length;i<l;i++){const shapeHole=shapeHoles[i];!0===ShapeUtils.isClockWise(shapeHole)&&(shapeHoles[i]=shapeHole.reverse())}const faces=ShapeUtils.triangulateShape(shapeVertices,shapeHoles);for(let i=0,l=shapeHoles.length;i<l;i++){const shapeHole=shapeHoles[i];shapeVertices=shapeVertices.concat(shapeHole)}for(let i=0,l=shapeVertices.length;i<l;i++){const vertex=shapeVertices[i];vertices.push(vertex.x,vertex.y,0),normals.push(0,0,1),uvs.push(vertex.x,vertex.y)}for(let i=0,l=faces.length;i<l;i++){const face=faces[i],a=face[0]+indexOffset,b=face[1]+indexOffset,c=face[2]+indexOffset;indices.push(a,b,c),groupCount+=3}}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}toJSON(){const data=super.toJSON();return function toJSON(shapes,data){if(data.shapes=[],Array.isArray(shapes))for(let i=0,l=shapes.length;i<l;i++){const shape=shapes[i];data.shapes.push(shape.uuid)}else data.shapes.push(shapes.uuid);return data}(this.parameters.shapes,data)}static fromJSON(data,shapes){const geometryShapes=[];for(let j=0,jl=data.shapes.length;j<jl;j++){const shape=shapes[data.shapes[j]];geometryShapes.push(shape)}return new ShapeGeometry(geometryShapes,data.curveSegments)}}class SphereGeometry extends BufferGeometry{constructor(radius=1,widthSegments=32,heightSegments=16,phiStart=0,phiLength=2*Math.PI,thetaStart=0,thetaLength=Math.PI){super(),this.type="SphereGeometry",this.parameters={radius:radius,widthSegments:widthSegments,heightSegments:heightSegments,phiStart:phiStart,phiLength:phiLength,thetaStart:thetaStart,thetaLength:thetaLength},widthSegments=Math.max(3,Math.floor(widthSegments)),heightSegments=Math.max(2,Math.floor(heightSegments));const thetaEnd=Math.min(thetaStart+thetaLength,Math.PI);let index=0;const grid=[],vertex=new Vector3,normal=new Vector3,indices=[],vertices=[],normals=[],uvs=[];for(let iy=0;iy<=heightSegments;iy++){const verticesRow=[],v=iy/heightSegments;let uOffset=0;0===iy&&0===thetaStart?uOffset=.5/widthSegments:iy===heightSegments&&thetaEnd===Math.PI&&(uOffset=-.5/widthSegments);for(let ix=0;ix<=widthSegments;ix++){const u=ix/widthSegments;vertex.x=-radius*Math.cos(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength),vertex.y=radius*Math.cos(thetaStart+v*thetaLength),vertex.z=radius*Math.sin(phiStart+u*phiLength)*Math.sin(thetaStart+v*thetaLength),vertices.push(vertex.x,vertex.y,vertex.z),normal.copy(vertex).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(u+uOffset,1-v),verticesRow.push(index++)}grid.push(verticesRow)}for(let iy=0;iy<heightSegments;iy++)for(let ix=0;ix<widthSegments;ix++){const a=grid[iy][ix+1],b=grid[iy][ix],c=grid[iy+1][ix],d=grid[iy+1][ix+1];(0!==iy||thetaStart>0)&&indices.push(a,b,d),(iy!==heightSegments-1||thetaEnd<Math.PI)&&indices.push(b,c,d)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new SphereGeometry(data.radius,data.widthSegments,data.heightSegments,data.phiStart,data.phiLength,data.thetaStart,data.thetaLength)}}class TetrahedronGeometry extends PolyhedronGeometry{constructor(radius=1,detail=0){super([1,1,1,-1,-1,1,-1,1,-1,1,-1,-1],[2,1,0,0,3,2,1,3,0,2,3,1],radius,detail),this.type="TetrahedronGeometry",this.parameters={radius:radius,detail:detail}}static fromJSON(data){return new TetrahedronGeometry(data.radius,data.detail)}}class TorusGeometry extends BufferGeometry{constructor(radius=1,tube=.4,radialSegments=12,tubularSegments=48,arc=2*Math.PI,thetaStart=0,thetaLength=2*Math.PI){super(),this.type="TorusGeometry",this.parameters={radius:radius,tube:tube,radialSegments:radialSegments,tubularSegments:tubularSegments,arc:arc,thetaStart:thetaStart,thetaLength:thetaLength},radialSegments=Math.floor(radialSegments),tubularSegments=Math.floor(tubularSegments);const indices=[],vertices=[],normals=[],uvs=[],center=new Vector3,vertex=new Vector3,normal=new Vector3;for(let j=0;j<=radialSegments;j++){const v=thetaStart+j/radialSegments*thetaLength;for(let i=0;i<=tubularSegments;i++){const u=i/tubularSegments*arc;vertex.x=(radius+tube*Math.cos(v))*Math.cos(u),vertex.y=(radius+tube*Math.cos(v))*Math.sin(u),vertex.z=tube*Math.sin(v),vertices.push(vertex.x,vertex.y,vertex.z),center.x=radius*Math.cos(u),center.y=radius*Math.sin(u),normal.subVectors(vertex,center).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(i/tubularSegments),uvs.push(j/radialSegments)}}for(let j=1;j<=radialSegments;j++)for(let i=1;i<=tubularSegments;i++){const a=(tubularSegments+1)*j+i-1,b=(tubularSegments+1)*(j-1)+i-1,c=(tubularSegments+1)*(j-1)+i,d=(tubularSegments+1)*j+i;indices.push(a,b,d),indices.push(b,c,d)}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new TorusGeometry(data.radius,data.tube,data.radialSegments,data.tubularSegments,data.arc)}}class TorusKnotGeometry extends BufferGeometry{constructor(radius=1,tube=.4,tubularSegments=64,radialSegments=8,p=2,q=3){super(),this.type="TorusKnotGeometry",this.parameters={radius:radius,tube:tube,tubularSegments:tubularSegments,radialSegments:radialSegments,p:p,q:q},tubularSegments=Math.floor(tubularSegments),radialSegments=Math.floor(radialSegments);const indices=[],vertices=[],normals=[],uvs=[],vertex=new Vector3,normal=new Vector3,P1=new Vector3,P2=new Vector3,B=new Vector3,T=new Vector3,N=new Vector3;for(let i=0;i<=tubularSegments;++i){const u=i/tubularSegments*p*Math.PI*2;calculatePositionOnCurve(u,p,q,radius,P1),calculatePositionOnCurve(u+.01,p,q,radius,P2),T.subVectors(P2,P1),N.addVectors(P2,P1),B.crossVectors(T,N),N.crossVectors(B,T),B.normalize(),N.normalize();for(let j=0;j<=radialSegments;++j){const v=j/radialSegments*Math.PI*2,cx=-tube*Math.cos(v),cy=tube*Math.sin(v);vertex.x=P1.x+(cx*N.x+cy*B.x),vertex.y=P1.y+(cx*N.y+cy*B.y),vertex.z=P1.z+(cx*N.z+cy*B.z),vertices.push(vertex.x,vertex.y,vertex.z),normal.subVectors(vertex,P1).normalize(),normals.push(normal.x,normal.y,normal.z),uvs.push(i/tubularSegments),uvs.push(j/radialSegments)}}for(let j=1;j<=tubularSegments;j++)for(let i=1;i<=radialSegments;i++){const a=(radialSegments+1)*(j-1)+(i-1),b=(radialSegments+1)*j+(i-1),c=(radialSegments+1)*j+i,d=(radialSegments+1)*(j-1)+i;indices.push(a,b,d),indices.push(b,c,d)}function calculatePositionOnCurve(u,p,q,radius,position){const cu=Math.cos(u),su=Math.sin(u),quOverP=q/p*u,cs=Math.cos(quOverP);position.x=radius*(2+cs)*.5*cu,position.y=radius*(2+cs)*su*.5,position.z=radius*Math.sin(quOverP)*.5}this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}static fromJSON(data){return new TorusKnotGeometry(data.radius,data.tube,data.tubularSegments,data.radialSegments,data.p,data.q)}}class TubeGeometry extends BufferGeometry{constructor(path=new QuadraticBezierCurve3(new Vector3(-1,-1,0),new Vector3(-1,1,0),new Vector3(1,1,0)),tubularSegments=64,radius=1,radialSegments=8,closed=!1){super(),this.type="TubeGeometry",this.parameters={path:path,tubularSegments:tubularSegments,radius:radius,radialSegments:radialSegments,closed:closed};const frames=path.computeFrenetFrames(tubularSegments,closed);this.tangents=frames.tangents,this.normals=frames.normals,this.binormals=frames.binormals;const vertex=new Vector3,normal=new Vector3,uv=new Vector2;let P=new Vector3;const vertices=[],normals=[],uvs=[],indices=[];function generateSegment(i){P=path.getPointAt(i/tubularSegments,P);const N=frames.normals[i],B=frames.binormals[i];for(let j=0;j<=radialSegments;j++){const v=j/radialSegments*Math.PI*2,sin=Math.sin(v),cos=-Math.cos(v);normal.x=cos*N.x+sin*B.x,normal.y=cos*N.y+sin*B.y,normal.z=cos*N.z+sin*B.z,normal.normalize(),normals.push(normal.x,normal.y,normal.z),vertex.x=P.x+radius*normal.x,vertex.y=P.y+radius*normal.y,vertex.z=P.z+radius*normal.z,vertices.push(vertex.x,vertex.y,vertex.z)}}!function generateBufferData(){for(let i=0;i<tubularSegments;i++)generateSegment(i);generateSegment(!1===closed?tubularSegments:0),function generateUVs(){for(let i=0;i<=tubularSegments;i++)for(let j=0;j<=radialSegments;j++)uv.x=i/tubularSegments,uv.y=j/radialSegments,uvs.push(uv.x,uv.y)}(),function generateIndices(){for(let j=1;j<=tubularSegments;j++)for(let i=1;i<=radialSegments;i++){const a=(radialSegments+1)*(j-1)+(i-1),b=(radialSegments+1)*j+(i-1),c=(radialSegments+1)*j+i,d=(radialSegments+1)*(j-1)+i;indices.push(a,b,d),indices.push(b,c,d)}}()}(),this.setIndex(indices),this.setAttribute("position",new Float32BufferAttribute(vertices,3)),this.setAttribute("normal",new Float32BufferAttribute(normals,3)),this.setAttribute("uv",new Float32BufferAttribute(uvs,2))}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}toJSON(){const data=super.toJSON();return data.path=this.parameters.path.toJSON(),data}static fromJSON(data){return new TubeGeometry((new Curves[data.path.type]).fromJSON(data.path),data.tubularSegments,data.radius,data.radialSegments,data.closed)}}class WireframeGeometry extends BufferGeometry{constructor(geometry=null){if(super(),this.type="WireframeGeometry",this.parameters={geometry:geometry},null!==geometry){const vertices=[],edges=new Set,start=new Vector3,end=new Vector3;if(null!==geometry.index){const position=geometry.attributes.position,indices=geometry.index;let groups=geometry.groups;0===groups.length&&(groups=[{start:0,count:indices.count,materialIndex:0}]);for(let o=0,ol=groups.length;o<ol;++o){const group=groups[o],groupStart=group.start;for(let i=groupStart,l=groupStart+group.count;i<l;i+=3)for(let j=0;j<3;j++){const index1=indices.getX(i+j),index2=indices.getX(i+(j+1)%3);start.fromBufferAttribute(position,index1),end.fromBufferAttribute(position,index2),!0===isUniqueEdge(start,end,edges)&&(vertices.push(start.x,start.y,start.z),vertices.push(end.x,end.y,end.z))}}}else{const position=geometry.attributes.position;for(let i=0,l=position.count/3;i<l;i++)for(let j=0;j<3;j++){const index1=3*i+j,index2=3*i+(j+1)%3;start.fromBufferAttribute(position,index1),end.fromBufferAttribute(position,index2),!0===isUniqueEdge(start,end,edges)&&(vertices.push(start.x,start.y,start.z),vertices.push(end.x,end.y,end.z))}}this.setAttribute("position",new Float32BufferAttribute(vertices,3))}}copy(source){return super.copy(source),this.parameters=Object.assign({},source.parameters),this}}function isUniqueEdge(start,end,edges){const hash1=`${start.x},${start.y},${start.z}-${end.x},${end.y},${end.z}`,hash2=`${end.x},${end.y},${end.z}-${start.x},${start.y},${start.z}`;return!0!==edges.has(hash1)&&!0!==edges.has(hash2)&&(edges.add(hash1),edges.add(hash2),!0)}class ShadowMaterial extends Material{constructor(parameters){super(),this.isShadowMaterial=!0,this.type="ShadowMaterial",this.color=new Color(0),this.transparent=!0,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.fog=source.fog,this}}class MeshStandardMaterial extends Material{constructor(parameters){super(),this.isMeshStandardMaterial=!0,this.type="MeshStandardMaterial",this.defines={STANDARD:""},this.color=new Color(16777215),this.roughness=1,this.metalness=0,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.roughnessMap=null,this.metalnessMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.envMapIntensity=1,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.defines={STANDARD:""},this.color.copy(source.color),this.roughness=source.roughness,this.metalness=source.metalness,this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.roughnessMap=source.roughnessMap,this.metalnessMap=source.metalnessMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.envMapRotation.copy(source.envMapRotation),this.envMapIntensity=source.envMapIntensity,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.flatShading=source.flatShading,this.fog=source.fog,this}}class MeshPhysicalMaterial extends MeshStandardMaterial{constructor(parameters){super(),this.isMeshPhysicalMaterial=!0,this.defines={STANDARD:"",PHYSICAL:""},this.type="MeshPhysicalMaterial",this.anisotropyRotation=0,this.anisotropyMap=null,this.clearcoatMap=null,this.clearcoatRoughness=0,this.clearcoatRoughnessMap=null,this.clearcoatNormalScale=new Vector2(1,1),this.clearcoatNormalMap=null,this.ior=1.5,Object.defineProperty(this,"reflectivity",{get:function(){return clamp$3(2.5*(this.ior-1)/(this.ior+1),0,1)},set:function(reflectivity){this.ior=(1+.4*reflectivity)/(1-.4*reflectivity)}}),this.iridescenceMap=null,this.iridescenceIOR=1.3,this.iridescenceThicknessRange=[100,400],this.iridescenceThicknessMap=null,this.sheenColor=new Color(0),this.sheenColorMap=null,this.sheenRoughness=1,this.sheenRoughnessMap=null,this.transmissionMap=null,this.thickness=0,this.thicknessMap=null,this.attenuationDistance=Infinity,this.attenuationColor=new Color(1,1,1),this.specularIntensity=1,this.specularIntensityMap=null,this.specularColor=new Color(1,1,1),this.specularColorMap=null,this._anisotropy=0,this._clearcoat=0,this._dispersion=0,this._iridescence=0,this._sheen=0,this._transmission=0,this.setValues(parameters)}get anisotropy(){return this._anisotropy}set anisotropy(value){this._anisotropy>0!=value>0&&this.version++,this._anisotropy=value}get clearcoat(){return this._clearcoat}set clearcoat(value){this._clearcoat>0!=value>0&&this.version++,this._clearcoat=value}get iridescence(){return this._iridescence}set iridescence(value){this._iridescence>0!=value>0&&this.version++,this._iridescence=value}get dispersion(){return this._dispersion}set dispersion(value){this._dispersion>0!=value>0&&this.version++,this._dispersion=value}get sheen(){return this._sheen}set sheen(value){this._sheen>0!=value>0&&this.version++,this._sheen=value}get transmission(){return this._transmission}set transmission(value){this._transmission>0!=value>0&&this.version++,this._transmission=value}copy(source){return super.copy(source),this.defines={STANDARD:"",PHYSICAL:""},this.anisotropy=source.anisotropy,this.anisotropyRotation=source.anisotropyRotation,this.anisotropyMap=source.anisotropyMap,this.clearcoat=source.clearcoat,this.clearcoatMap=source.clearcoatMap,this.clearcoatRoughness=source.clearcoatRoughness,this.clearcoatRoughnessMap=source.clearcoatRoughnessMap,this.clearcoatNormalMap=source.clearcoatNormalMap,this.clearcoatNormalScale.copy(source.clearcoatNormalScale),this.dispersion=source.dispersion,this.ior=source.ior,this.iridescence=source.iridescence,this.iridescenceMap=source.iridescenceMap,this.iridescenceIOR=source.iridescenceIOR,this.iridescenceThicknessRange=[...source.iridescenceThicknessRange],this.iridescenceThicknessMap=source.iridescenceThicknessMap,this.sheen=source.sheen,this.sheenColor.copy(source.sheenColor),this.sheenColorMap=source.sheenColorMap,this.sheenRoughness=source.sheenRoughness,this.sheenRoughnessMap=source.sheenRoughnessMap,this.transmission=source.transmission,this.transmissionMap=source.transmissionMap,this.thickness=source.thickness,this.thicknessMap=source.thicknessMap,this.attenuationDistance=source.attenuationDistance,this.attenuationColor.copy(source.attenuationColor),this.specularIntensity=source.specularIntensity,this.specularIntensityMap=source.specularIntensityMap,this.specularColor.copy(source.specularColor),this.specularColorMap=source.specularColorMap,this}}class MeshPhongMaterial extends Material{constructor(parameters){super(),this.isMeshPhongMaterial=!0,this.type="MeshPhongMaterial",this.color=new Color(16777215),this.specular=new Color(1118481),this.shininess=30,this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=0,this.reflectivity=1,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.specular.copy(source.specular),this.shininess=source.shininess,this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.specularMap=source.specularMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.envMapRotation.copy(source.envMapRotation),this.combine=source.combine,this.reflectivity=source.reflectivity,this.envMapIntensity=source.envMapIntensity,this.refractionRatio=source.refractionRatio,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.flatShading=source.flatShading,this.fog=source.fog,this}}class MeshToonMaterial extends Material{constructor(parameters){super(),this.isMeshToonMaterial=!0,this.defines={TOON:""},this.type="MeshToonMaterial",this.color=new Color(16777215),this.map=null,this.gradientMap=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.gradientMap=source.gradientMap,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.alphaMap=source.alphaMap,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.fog=source.fog,this}}class MeshNormalMaterial extends Material{constructor(parameters){super(),this.isMeshNormalMaterial=!0,this.type="MeshNormalMaterial",this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.setValues(parameters)}copy(source){return super.copy(source),this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.flatShading=source.flatShading,this}}class MeshLambertMaterial extends Material{constructor(parameters){super(),this.isMeshLambertMaterial=!0,this.type="MeshLambertMaterial",this.color=new Color(16777215),this.map=null,this.lightMap=null,this.lightMapIntensity=1,this.aoMap=null,this.aoMapIntensity=1,this.emissive=new Color(0),this.emissiveIntensity=1,this.emissiveMap=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.specularMap=null,this.alphaMap=null,this.envMap=null,this.envMapRotation=new Euler,this.combine=0,this.reflectivity=1,this.envMapIntensity=1,this.refractionRatio=.98,this.wireframe=!1,this.wireframeLinewidth=1,this.wireframeLinecap="round",this.wireframeLinejoin="round",this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.color.copy(source.color),this.map=source.map,this.lightMap=source.lightMap,this.lightMapIntensity=source.lightMapIntensity,this.aoMap=source.aoMap,this.aoMapIntensity=source.aoMapIntensity,this.emissive.copy(source.emissive),this.emissiveMap=source.emissiveMap,this.emissiveIntensity=source.emissiveIntensity,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.specularMap=source.specularMap,this.alphaMap=source.alphaMap,this.envMap=source.envMap,this.envMapRotation.copy(source.envMapRotation),this.combine=source.combine,this.reflectivity=source.reflectivity,this.envMapIntensity=source.envMapIntensity,this.refractionRatio=source.refractionRatio,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.wireframeLinecap=source.wireframeLinecap,this.wireframeLinejoin=source.wireframeLinejoin,this.flatShading=source.flatShading,this.fog=source.fog,this}}class MeshMatcapMaterial extends Material{constructor(parameters){super(),this.isMeshMatcapMaterial=!0,this.defines={MATCAP:""},this.type="MeshMatcapMaterial",this.color=new Color(16777215),this.matcap=null,this.map=null,this.bumpMap=null,this.bumpScale=1,this.normalMap=null,this.normalMapType=0,this.normalScale=new Vector2(1,1),this.displacementMap=null,this.displacementScale=1,this.displacementBias=0,this.alphaMap=null,this.wireframe=!1,this.wireframeLinewidth=1,this.flatShading=!1,this.fog=!0,this.setValues(parameters)}copy(source){return super.copy(source),this.defines={MATCAP:""},this.color.copy(source.color),this.matcap=source.matcap,this.map=source.map,this.bumpMap=source.bumpMap,this.bumpScale=source.bumpScale,this.normalMap=source.normalMap,this.normalMapType=source.normalMapType,this.normalScale.copy(source.normalScale),this.displacementMap=source.displacementMap,this.displacementScale=source.displacementScale,this.displacementBias=source.displacementBias,this.alphaMap=source.alphaMap,this.wireframe=source.wireframe,this.wireframeLinewidth=source.wireframeLinewidth,this.flatShading=source.flatShading,this.fog=source.fog,this}}class LineDashedMaterial extends LineBasicMaterial{constructor(parameters){super(),this.isLineDashedMaterial=!0,this.type="LineDashedMaterial",this.scale=1,this.dashSize=3,this.gapSize=1,this.setValues(parameters)}copy(source){return super.copy(source),this.scale=source.scale,this.dashSize=source.dashSize,this.gapSize=source.gapSize,this}}function convertArray(array,type){return array&&array.constructor!==type?"number"==typeof type.BYTES_PER_ELEMENT?new type(array):Array.prototype.slice.call(array):array}function getKeyframeOrder(times){const n=times.length,result=new Array(n);for(let i=0;i!==n;++i)result[i]=i;return result.sort(function compareTime(i,j){return times[i]-times[j]}),result}function sortedArray(values,stride,order){const nValues=values.length,result=new values.constructor(nValues);for(let i=0,dstOffset=0;dstOffset!==nValues;++i){const srcOffset=order[i]*stride;for(let j=0;j!==stride;++j)result[dstOffset++]=values[srcOffset+j]}return result}function flattenJSON(jsonKeys,times,values,valuePropertyName){let i=1,key=jsonKeys[0];for(;void 0!==key&&void 0===key[valuePropertyName];)key=jsonKeys[i++];if(void 0===key)return;let value=key[valuePropertyName];if(void 0!==value)if(Array.isArray(value))do{value=key[valuePropertyName],void 0!==value&&(times.push(key.time),values.push(...value)),key=jsonKeys[i++]}while(void 0!==key);else if(void 0!==value.toArray)do{value=key[valuePropertyName],void 0!==value&&(times.push(key.time),value.toArray(values,values.length)),key=jsonKeys[i++]}while(void 0!==key);else do{value=key[valuePropertyName],void 0!==value&&(times.push(key.time),values.push(value)),key=jsonKeys[i++]}while(void 0!==key)}class Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){this.parameterPositions=parameterPositions,this._cachedIndex=0,this.resultBuffer=void 0!==resultBuffer?resultBuffer:new sampleValues.constructor(sampleSize),this.sampleValues=sampleValues,this.valueSize=sampleSize,this.settings=null,this.DefaultSettings_={}}evaluate(t){const pp=this.parameterPositions;let i1=this._cachedIndex,t1=pp[i1],t0=pp[i1-1];validate_interval:{seek:{let right;linear_scan:{forward_scan:if(!(t<t1)){for(let giveUpAt=i1+2;;){if(void 0===t1){if(t<t0)break forward_scan;return i1=pp.length,this._cachedIndex=i1,this.copySampleValue_(i1-1)}if(i1===giveUpAt)break;if(t0=t1,t1=pp[++i1],t<t1)break seek}right=pp.length;break linear_scan}if(!(t>=t0)){const t1global=pp[1];t<t1global&&(i1=2,t0=t1global);for(let giveUpAt=i1-2;;){if(void 0===t0)return this._cachedIndex=0,this.copySampleValue_(0);if(i1===giveUpAt)break;if(t1=t0,t0=pp[--i1-1],t>=t0)break seek}right=i1,i1=0;break linear_scan}break validate_interval}for(;i1<right;){const mid=i1+right>>>1;t<pp[mid]?right=mid:i1=mid+1}if(t1=pp[i1],t0=pp[i1-1],void 0===t0)return this._cachedIndex=0,this.copySampleValue_(0);if(void 0===t1)return i1=pp.length,this._cachedIndex=i1,this.copySampleValue_(i1-1)}this._cachedIndex=i1,this.intervalChanged_(i1,t0,t1)}return this.interpolate_(i1,t0,t,t1)}getSettings_(){return this.settings||this.DefaultSettings_}copySampleValue_(index){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset=index*stride;for(let i=0;i!==stride;++i)result[i]=values[offset+i];return result}interpolate_(){throw new Error("call to abstract method")}intervalChanged_(){}}class CubicInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer),this._weightPrev=-0,this._offsetPrev=-0,this._weightNext=-0,this._offsetNext=-0,this.DefaultSettings_={endingStart:2400,endingEnd:2400}}intervalChanged_(i1,t0,t1){const pp=this.parameterPositions;let iPrev=i1-2,iNext=i1+1,tPrev=pp[iPrev],tNext=pp[iNext];if(void 0===tPrev)switch(this.getSettings_().endingStart){case 2401:iPrev=i1,tPrev=2*t0-t1;break;case 2402:iPrev=pp.length-2,tPrev=t0+pp[iPrev]-pp[iPrev+1];break;default:iPrev=i1,tPrev=t1}if(void 0===tNext)switch(this.getSettings_().endingEnd){case 2401:iNext=i1,tNext=2*t1-t0;break;case 2402:iNext=1,tNext=t1+pp[1]-pp[0];break;default:iNext=i1-1,tNext=t0}const halfDt=.5*(t1-t0),stride=this.valueSize;this._weightPrev=halfDt/(t0-tPrev),this._weightNext=halfDt/(tNext-t1),this._offsetPrev=iPrev*stride,this._offsetNext=iNext*stride}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,o1=i1*stride,o0=o1-stride,oP=this._offsetPrev,oN=this._offsetNext,wP=this._weightPrev,wN=this._weightNext,p=(t-t0)/(t1-t0),pp=p*p,ppp=pp*p,sP=-wP*ppp+2*wP*pp-wP*p,s0=(1+wP)*ppp+(-1.5-2*wP)*pp+(-.5+wP)*p+1,s1=(-1-wN)*ppp+(1.5+wN)*pp+.5*p,sN=wN*ppp-wN*pp;for(let i=0;i!==stride;++i)result[i]=sP*values[oP+i]+s0*values[o0+i]+s1*values[o1+i]+sN*values[oN+i];return result}}class LinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(let i=0;i!==stride;++i)result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;return result}}class DiscreteInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1){return this.copySampleValue_(i1-1)}}class BezierInterpolant extends Interpolant{interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,offset1=i1*stride,offset0=offset1-stride,settings=this.settings||this.DefaultSettings_,inTangents=settings.inTangents,outTangents=settings.outTangents;if(!inTangents||!outTangents){const weight1=(t-t0)/(t1-t0),weight0=1-weight1;for(let i=0;i!==stride;++i)result[i]=values[offset0+i]*weight0+values[offset1+i]*weight1;return result}const tangentStride=2*stride,i0=i1-1;for(let i=0;i!==stride;++i){const v0=values[offset0+i],v1=values[offset1+i],outTangentOffset=i0*tangentStride+2*i,c0x=outTangents[outTangentOffset],c0y=outTangents[outTangentOffset+1],inTangentOffset=i1*tangentStride+2*i,c1x=inTangents[inTangentOffset],c1y=inTangents[inTangentOffset+1];let s2,s3,oneMinusS,oneMinusS2,oneMinusS3,s=(t-t0)/(t1-t0);for(let iter=0;iter<8;iter++){s2=s*s,s3=s2*s,oneMinusS=1-s,oneMinusS2=oneMinusS*oneMinusS,oneMinusS3=oneMinusS2*oneMinusS;const error=oneMinusS3*t0+3*oneMinusS2*s*c0x+3*oneMinusS*s2*c1x+s3*t1-t;if(Math.abs(error)<1e-10)break;const dbx=3*oneMinusS2*(c0x-t0)+6*oneMinusS*s*(c1x-c0x)+3*s2*(t1-c1x);if(Math.abs(dbx)<1e-10)break;s-=error/dbx,s=Math.max(0,Math.min(1,s))}result[i]=oneMinusS3*v0+3*oneMinusS2*s*c0y+3*oneMinusS*s2*c1y+s3*v1}return result}}class KeyframeTrack{constructor(name,times,values,interpolation){if(void 0===name)throw new Error("THREE.KeyframeTrack: track name is undefined");if(void 0===times||0===times.length)throw new Error("THREE.KeyframeTrack: no keyframes in track named "+name);this.name=name,this.times=convertArray(times,this.TimeBufferType),this.values=convertArray(values,this.ValueBufferType),this.setInterpolation(interpolation||this.DefaultInterpolation)}static toJSON(track){const trackType=track.constructor;let json;if(trackType.toJSON!==this.toJSON)json=trackType.toJSON(track);else{json={name:track.name,times:convertArray(track.times,Array),values:convertArray(track.values,Array)};const interpolation=track.getInterpolation();interpolation!==track.DefaultInterpolation&&(json.interpolation=interpolation)}return json.type=track.ValueTypeName,json}InterpolantFactoryMethodDiscrete(result){return new DiscreteInterpolant(this.times,this.values,this.getValueSize(),result)}InterpolantFactoryMethodLinear(result){return new LinearInterpolant(this.times,this.values,this.getValueSize(),result)}InterpolantFactoryMethodSmooth(result){return new CubicInterpolant(this.times,this.values,this.getValueSize(),result)}InterpolantFactoryMethodBezier(result){const interpolant=new BezierInterpolant(this.times,this.values,this.getValueSize(),result);return this.settings&&(interpolant.settings=this.settings),interpolant}setInterpolation(interpolation){let factoryMethod;switch(interpolation){case 2300:factoryMethod=this.InterpolantFactoryMethodDiscrete;break;case 2301:factoryMethod=this.InterpolantFactoryMethodLinear;break;case 2302:factoryMethod=this.InterpolantFactoryMethodSmooth;break;case 2303:factoryMethod=this.InterpolantFactoryMethodBezier}if(void 0===factoryMethod){const message="unsupported interpolation for "+this.ValueTypeName+" keyframe track named "+this.name;if(void 0===this.createInterpolant){if(interpolation===this.DefaultInterpolation)throw new Error(message);this.setInterpolation(this.DefaultInterpolation)}return warn("KeyframeTrack:",message),this}return this.createInterpolant=factoryMethod,this}getInterpolation(){switch(this.createInterpolant){case this.InterpolantFactoryMethodDiscrete:return 2300;case this.InterpolantFactoryMethodLinear:return 2301;case this.InterpolantFactoryMethodSmooth:return 2302;case this.InterpolantFactoryMethodBezier:return 2303}}getValueSize(){return this.values.length/this.times.length}shift(timeOffset){if(0!==timeOffset){const times=this.times;for(let i=0,n=times.length;i!==n;++i)times[i]+=timeOffset}return this}scale(timeScale){if(1!==timeScale){const times=this.times;for(let i=0,n=times.length;i!==n;++i)times[i]*=timeScale}return this}trim(startTime,endTime){const times=this.times,nKeys=times.length;let from=0,to=nKeys-1;for(;from!==nKeys&&times[from]<startTime;)++from;for(;-1!==to&&times[to]>endTime;)--to;if(++to,0!==from||to!==nKeys){from>=to&&(to=Math.max(to,1),from=to-1);const stride=this.getValueSize();this.times=times.slice(from,to),this.values=this.values.slice(from*stride,to*stride)}return this}validate(){let valid=!0;const valueSize=this.getValueSize();valueSize-Math.floor(valueSize)!==0&&(error("KeyframeTrack: Invalid value size in track.",this),valid=!1);const times=this.times,values=this.values,nKeys=times.length;0===nKeys&&(error("KeyframeTrack: Track is empty.",this),valid=!1);let prevTime=null;for(let i=0;i!==nKeys;i++){const currTime=times[i];if("number"==typeof currTime&&isNaN(currTime)){error("KeyframeTrack: Time is not a valid number.",this,i,currTime),valid=!1;break}if(null!==prevTime&&prevTime>currTime){error("KeyframeTrack: Out of order keys.",this,i,currTime,prevTime),valid=!1;break}prevTime=currTime}if(void 0!==values&&isTypedArray(values))for(let i=0,n=values.length;i!==n;++i){const value=values[i];if(isNaN(value)){error("KeyframeTrack: Value is not a valid number.",this,i,value),valid=!1;break}}return valid}optimize(){const times=this.times.slice(),values=this.values.slice(),stride=this.getValueSize(),smoothInterpolation=2302===this.getInterpolation(),lastIndex=times.length-1;let writeIndex=1;for(let i=1;i<lastIndex;++i){let keep=!1;const time=times[i];if(time!==times[i+1]&&(1!==i||time!==times[0]))if(smoothInterpolation)keep=!0;else{const offset=i*stride,offsetP=offset-stride,offsetN=offset+stride;for(let j=0;j!==stride;++j){const value=values[offset+j];if(value!==values[offsetP+j]||value!==values[offsetN+j]){keep=!0;break}}}if(keep){if(i!==writeIndex){times[writeIndex]=times[i];const readOffset=i*stride,writeOffset=writeIndex*stride;for(let j=0;j!==stride;++j)values[writeOffset+j]=values[readOffset+j]}++writeIndex}}if(lastIndex>0){times[writeIndex]=times[lastIndex];for(let readOffset=lastIndex*stride,writeOffset=writeIndex*stride,j=0;j!==stride;++j)values[writeOffset+j]=values[readOffset+j];++writeIndex}return writeIndex!==times.length?(this.times=times.slice(0,writeIndex),this.values=values.slice(0,writeIndex*stride)):(this.times=times,this.values=values),this}clone(){const times=this.times.slice(),values=this.values.slice(),track=new(0,this.constructor)(this.name,times,values);return track.createInterpolant=this.createInterpolant,track}}KeyframeTrack.prototype.ValueTypeName="",KeyframeTrack.prototype.TimeBufferType=Float32Array,KeyframeTrack.prototype.ValueBufferType=Float32Array,KeyframeTrack.prototype.DefaultInterpolation=2301;class BooleanKeyframeTrack extends KeyframeTrack{constructor(name,times,values){super(name,times,values)}}BooleanKeyframeTrack.prototype.ValueTypeName="bool",BooleanKeyframeTrack.prototype.ValueBufferType=Array,BooleanKeyframeTrack.prototype.DefaultInterpolation=2300,BooleanKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0,BooleanKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class ColorKeyframeTrack extends KeyframeTrack{constructor(name,times,values,interpolation){super(name,times,values,interpolation)}}ColorKeyframeTrack.prototype.ValueTypeName="color";class NumberKeyframeTrack extends KeyframeTrack{constructor(name,times,values,interpolation){super(name,times,values,interpolation)}}NumberKeyframeTrack.prototype.ValueTypeName="number";class QuaternionLinearInterpolant extends Interpolant{constructor(parameterPositions,sampleValues,sampleSize,resultBuffer){super(parameterPositions,sampleValues,sampleSize,resultBuffer)}interpolate_(i1,t0,t,t1){const result=this.resultBuffer,values=this.sampleValues,stride=this.valueSize,alpha=(t-t0)/(t1-t0);let offset=i1*stride;for(let end=offset+stride;offset!==end;offset+=4)Quaternion.slerpFlat(result,0,values,offset-stride,values,offset,alpha);return result}}class QuaternionKeyframeTrack extends KeyframeTrack{constructor(name,times,values,interpolation){super(name,times,values,interpolation)}InterpolantFactoryMethodLinear(result){return new QuaternionLinearInterpolant(this.times,this.values,this.getValueSize(),result)}}QuaternionKeyframeTrack.prototype.ValueTypeName="quaternion",QuaternionKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class StringKeyframeTrack extends KeyframeTrack{constructor(name,times,values){super(name,times,values)}}StringKeyframeTrack.prototype.ValueTypeName="string",StringKeyframeTrack.prototype.ValueBufferType=Array,StringKeyframeTrack.prototype.DefaultInterpolation=2300,StringKeyframeTrack.prototype.InterpolantFactoryMethodLinear=void 0,StringKeyframeTrack.prototype.InterpolantFactoryMethodSmooth=void 0;class VectorKeyframeTrack extends KeyframeTrack{constructor(name,times,values,interpolation){super(name,times,values,interpolation)}}VectorKeyframeTrack.prototype.ValueTypeName="vector";class AnimationClip{constructor(name="",duration=-1,tracks=[],blendMode=2500){this.name=name,this.tracks=tracks,this.duration=duration,this.blendMode=blendMode,this.uuid=generateUUID(),this.userData={},this.duration<0&&this.resetDuration()}static parse(json){const tracks=[],jsonTracks=json.tracks,frameTime=1/(json.fps||1);for(let i=0,n=jsonTracks.length;i!==n;++i)tracks.push(parseKeyframeTrack(jsonTracks[i]).scale(frameTime));const clip=new this(json.name,json.duration,tracks,json.blendMode);return clip.uuid=json.uuid,clip.userData=JSON.parse(json.userData||"{}"),clip}static toJSON(clip){const tracks=[],clipTracks=clip.tracks,json={name:clip.name,duration:clip.duration,tracks:tracks,uuid:clip.uuid,blendMode:clip.blendMode,userData:JSON.stringify(clip.userData)};for(let i=0,n=clipTracks.length;i!==n;++i)tracks.push(KeyframeTrack.toJSON(clipTracks[i]));return json}static CreateFromMorphTargetSequence(name,morphTargetSequence,fps,noLoop){const numMorphTargets=morphTargetSequence.length,tracks=[];for(let i=0;i<numMorphTargets;i++){let times=[],values=[];times.push((i+numMorphTargets-1)%numMorphTargets,i,(i+1)%numMorphTargets),values.push(0,1,0);const order=getKeyframeOrder(times);times=sortedArray(times,1,order),values=sortedArray(values,1,order),noLoop||0!==times[0]||(times.push(numMorphTargets),values.push(values[0])),tracks.push(new NumberKeyframeTrack(".morphTargetInfluences["+morphTargetSequence[i].name+"]",times,values).scale(1/fps))}return new this(name,-1,tracks)}static findByName(objectOrClipArray,name){let clipArray=objectOrClipArray;if(!Array.isArray(objectOrClipArray)){const o=objectOrClipArray;clipArray=o.geometry&&o.geometry.animations||o.animations}for(let i=0;i<clipArray.length;i++)if(clipArray[i].name===name)return clipArray[i];return null}static CreateClipsFromMorphTargetSequences(morphTargets,fps,noLoop){const animationToMorphTargets={},pattern=/^([\w-]*?)([\d]+)$/;for(let i=0,il=morphTargets.length;i<il;i++){const morphTarget=morphTargets[i],parts=morphTarget.name.match(pattern);if(parts&&parts.length>1){const name=parts[1];let animationMorphTargets=animationToMorphTargets[name];animationMorphTargets||(animationToMorphTargets[name]=animationMorphTargets=[]),animationMorphTargets.push(morphTarget)}}const clips=[];for(const name in animationToMorphTargets)clips.push(this.CreateFromMorphTargetSequence(name,animationToMorphTargets[name],fps,noLoop));return clips}static parseAnimation(animation,bones){if(warn("AnimationClip: parseAnimation() is deprecated and will be removed with r185"),!animation)return error("AnimationClip: No animation in JSONLoader data."),null;const addNonemptyTrack=function(trackType,trackName,animationKeys,propertyName,destTracks){if(0!==animationKeys.length){const times=[],values=[];flattenJSON(animationKeys,times,values,propertyName),0!==times.length&&destTracks.push(new trackType(trackName,times,values))}},tracks=[],clipName=animation.name||"default",fps=animation.fps||30,blendMode=animation.blendMode;let duration=animation.length||-1;const hierarchyTracks=animation.hierarchy||[];for(let h=0;h<hierarchyTracks.length;h++){const animationKeys=hierarchyTracks[h].keys;if(animationKeys&&0!==animationKeys.length)if(animationKeys[0].morphTargets){const morphTargetNames={};let k;for(k=0;k<animationKeys.length;k++)if(animationKeys[k].morphTargets)for(let m=0;m<animationKeys[k].morphTargets.length;m++)morphTargetNames[animationKeys[k].morphTargets[m]]=-1;for(const morphTargetName in morphTargetNames){const times=[],values=[];for(let m=0;m!==animationKeys[k].morphTargets.length;++m){const animationKey=animationKeys[k];times.push(animationKey.time),values.push(animationKey.morphTarget===morphTargetName?1:0)}tracks.push(new NumberKeyframeTrack(".morphTargetInfluence["+morphTargetName+"]",times,values))}duration=morphTargetNames.length*fps}else{const boneName=".bones["+bones[h].name+"]";addNonemptyTrack(VectorKeyframeTrack,boneName+".position",animationKeys,"pos",tracks),addNonemptyTrack(QuaternionKeyframeTrack,boneName+".quaternion",animationKeys,"rot",tracks),addNonemptyTrack(VectorKeyframeTrack,boneName+".scale",animationKeys,"scl",tracks)}}if(0===tracks.length)return null;return new this(clipName,duration,tracks,blendMode)}resetDuration(){let duration=0;for(let i=0,n=this.tracks.length;i!==n;++i){const track=this.tracks[i];duration=Math.max(duration,track.times[track.times.length-1])}return this.duration=duration,this}trim(){for(let i=0;i<this.tracks.length;i++)this.tracks[i].trim(0,this.duration);return this}validate(){let valid=!0;for(let i=0;i<this.tracks.length;i++)valid=valid&&this.tracks[i].validate();return valid}optimize(){for(let i=0;i<this.tracks.length;i++)this.tracks[i].optimize();return this}clone(){const tracks=[];for(let i=0;i<this.tracks.length;i++)tracks.push(this.tracks[i].clone());const clip=new this.constructor(this.name,this.duration,tracks,this.blendMode);return clip.userData=JSON.parse(JSON.stringify(this.userData)),clip}toJSON(){return this.constructor.toJSON(this)}}function parseKeyframeTrack(json){if(void 0===json.type)throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");const trackType=function getTrackTypeForValueTypeName(typeName){switch(typeName.toLowerCase()){case"scalar":case"double":case"float":case"number":case"integer":return NumberKeyframeTrack;case"vector":case"vector2":case"vector3":case"vector4":return VectorKeyframeTrack;case"color":return ColorKeyframeTrack;case"quaternion":return QuaternionKeyframeTrack;case"bool":case"boolean":return BooleanKeyframeTrack;case"string":return StringKeyframeTrack}throw new Error("THREE.KeyframeTrack: Unsupported typeName: "+typeName)}(json.type);if(void 0===json.times){const times=[],values=[];flattenJSON(json.keys,times,values,"value"),json.times=times,json.values=values}return void 0!==trackType.parse?trackType.parse(json):new trackType(json.name,json.times,json.values,json.interpolation)}class Light extends Object3D{constructor(color,intensity=1){super(),this.isLight=!0,this.type="Light",this.color=new Color(color),this.intensity=intensity}dispose(){this.dispatchEvent({type:"dispose"})}copy(source,recursive){return super.copy(source,recursive),this.color.copy(source.color),this.intensity=source.intensity,this}toJSON(meta){const data=super.toJSON(meta);return data.object.color=this.color.getHex(),data.object.intensity=this.intensity,data}}class HemisphereLight extends Light{constructor(skyColor,groundColor,intensity){super(skyColor,intensity),this.isHemisphereLight=!0,this.type="HemisphereLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.groundColor=new Color(groundColor)}copy(source,recursive){return super.copy(source,recursive),this.groundColor.copy(source.groundColor),this}toJSON(meta){const data=super.toJSON(meta);return data.object.groundColor=this.groundColor.getHex(),data}}const _projScreenMatrix$2=/*@__PURE__*/new Matrix4,_lightPositionWorld$1=/*@__PURE__*/new Vector3,_lookTarget$1=/*@__PURE__*/new Vector3;class LightShadow{constructor(camera){this.camera=camera,this.intensity=1,this.bias=0,this.biasNode=null,this.normalBias=0,this.radius=1,this.blurSamples=8,this.mapSize=new Vector2(512,512),this.mapType=1009,this.map=null,this.mapPass=null,this.matrix=new Matrix4,this.autoUpdate=!0,this.needsUpdate=!1,this._frustum=new Frustum,this._frameExtents=new Vector2(1,1),this._viewportCount=1,this._viewports=[new Vector4(0,0,1,1)]}getViewportCount(){return this._viewportCount}getFrustum(){return this._frustum}updateMatrices(light){const shadowCamera=this.camera,shadowMatrix=this.matrix;_lightPositionWorld$1.setFromMatrixPosition(light.matrixWorld),shadowCamera.position.copy(_lightPositionWorld$1),_lookTarget$1.setFromMatrixPosition(light.target.matrixWorld),shadowCamera.lookAt(_lookTarget$1),shadowCamera.updateMatrixWorld(),_projScreenMatrix$2.multiplyMatrices(shadowCamera.projectionMatrix,shadowCamera.matrixWorldInverse),this._frustum.setFromProjectionMatrix(_projScreenMatrix$2,shadowCamera.coordinateSystem,shadowCamera.reversedDepth),shadowCamera.reversedDepth?shadowMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,1,0,0,0,0,1):shadowMatrix.set(.5,0,0,.5,0,.5,0,.5,0,0,.5,.5,0,0,0,1),shadowMatrix.multiply(_projScreenMatrix$2)}getViewport(viewportIndex){return this._viewports[viewportIndex]}getFrameExtents(){return this._frameExtents}dispose(){this.map&&this.map.dispose(),this.mapPass&&this.mapPass.dispose()}copy(source){return this.camera=source.camera.clone(),this.intensity=source.intensity,this.bias=source.bias,this.radius=source.radius,this.autoUpdate=source.autoUpdate,this.needsUpdate=source.needsUpdate,this.normalBias=source.normalBias,this.blurSamples=source.blurSamples,this.mapSize.copy(source.mapSize),this.biasNode=source.biasNode,this}clone(){return(new this.constructor).copy(this)}toJSON(){const object={};return 1!==this.intensity&&(object.intensity=this.intensity),0!==this.bias&&(object.bias=this.bias),0!==this.normalBias&&(object.normalBias=this.normalBias),1!==this.radius&&(object.radius=this.radius),512===this.mapSize.x&&512===this.mapSize.y||(object.mapSize=this.mapSize.toArray()),object.camera=this.camera.toJSON(!1).object,delete object.camera.matrix,object}}const _position$2=/*@__PURE__*/new Vector3,_quaternion$2=/*@__PURE__*/new Quaternion,_scale$2=/*@__PURE__*/new Vector3;class Camera extends Object3D{constructor(){super(),this.isCamera=!0,this.type="Camera",this.matrixWorldInverse=new Matrix4,this.projectionMatrix=new Matrix4,this.projectionMatrixInverse=new Matrix4,this.coordinateSystem=2e3,this._reversedDepth=!1}get reversedDepth(){return this._reversedDepth}copy(source,recursive){return super.copy(source,recursive),this.matrixWorldInverse.copy(source.matrixWorldInverse),this.projectionMatrix.copy(source.projectionMatrix),this.projectionMatrixInverse.copy(source.projectionMatrixInverse),this.coordinateSystem=source.coordinateSystem,this}getWorldDirection(target){return super.getWorldDirection(target).negate()}updateMatrixWorld(force){super.updateMatrixWorld(force),this.matrixWorld.decompose(_position$2,_quaternion$2,_scale$2),1===_scale$2.x&&1===_scale$2.y&&1===_scale$2.z?this.matrixWorldInverse.copy(this.matrixWorld).invert():this.matrixWorldInverse.compose(_position$2,_quaternion$2,_scale$2.set(1,1,1)).invert()}updateWorldMatrix(updateParents,updateChildren){super.updateWorldMatrix(updateParents,updateChildren),this.matrixWorld.decompose(_position$2,_quaternion$2,_scale$2),1===_scale$2.x&&1===_scale$2.y&&1===_scale$2.z?this.matrixWorldInverse.copy(this.matrixWorld).invert():this.matrixWorldInverse.compose(_position$2,_quaternion$2,_scale$2.set(1,1,1)).invert()}clone(){return(new this.constructor).copy(this)}}const _v3$1=/*@__PURE__*/new Vector3,_minTarget=/*@__PURE__*/new Vector2,_maxTarget=/*@__PURE__*/new Vector2;class PerspectiveCamera extends Camera{constructor(fov=50,aspect=1,near=.1,far=2e3){super(),this.isPerspectiveCamera=!0,this.type="PerspectiveCamera",this.fov=fov,this.zoom=1,this.near=near,this.far=far,this.focus=10,this.aspect=aspect,this.view=null,this.filmGauge=35,this.filmOffset=0,this.updateProjectionMatrix()}copy(source,recursive){return super.copy(source,recursive),this.fov=source.fov,this.zoom=source.zoom,this.near=source.near,this.far=source.far,this.focus=source.focus,this.aspect=source.aspect,this.view=null===source.view?null:Object.assign({},source.view),this.filmGauge=source.filmGauge,this.filmOffset=source.filmOffset,this}setFocalLength(focalLength){const vExtentSlope=.5*this.getFilmHeight()/focalLength;this.fov=2*RAD2DEG*Math.atan(vExtentSlope),this.updateProjectionMatrix()}getFocalLength(){const vExtentSlope=Math.tan(.5*DEG2RAD*this.fov);return.5*this.getFilmHeight()/vExtentSlope}getEffectiveFOV(){return 2*RAD2DEG*Math.atan(Math.tan(.5*DEG2RAD*this.fov)/this.zoom)}getFilmWidth(){return this.filmGauge*Math.min(this.aspect,1)}getFilmHeight(){return this.filmGauge/Math.max(this.aspect,1)}getViewBounds(distance,minTarget,maxTarget){_v3$1.set(-1,-1,.5).applyMatrix4(this.projectionMatrixInverse),minTarget.set(_v3$1.x,_v3$1.y).multiplyScalar(-distance/_v3$1.z),_v3$1.set(1,1,.5).applyMatrix4(this.projectionMatrixInverse),maxTarget.set(_v3$1.x,_v3$1.y).multiplyScalar(-distance/_v3$1.z)}getViewSize(distance,target){return this.getViewBounds(distance,_minTarget,_maxTarget),target.subVectors(_maxTarget,_minTarget)}setViewOffset(fullWidth,fullHeight,x,y,width,height){this.aspect=fullWidth/fullHeight,null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=fullWidth,this.view.fullHeight=fullHeight,this.view.offsetX=x,this.view.offsetY=y,this.view.width=width,this.view.height=height,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const near=this.near;let top=near*Math.tan(.5*DEG2RAD*this.fov)/this.zoom,height=2*top,width=this.aspect*height,left=-.5*width;const view=this.view;if(null!==this.view&&this.view.enabled){const fullWidth=view.fullWidth,fullHeight=view.fullHeight;left+=view.offsetX*width/fullWidth,top-=view.offsetY*height/fullHeight,width*=view.width/fullWidth,height*=view.height/fullHeight}const skew=this.filmOffset;0!==skew&&(left+=near*skew/this.getFilmWidth()),this.projectionMatrix.makePerspective(left,left+width,top,top-height,near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(meta){const data=super.toJSON(meta);return data.object.fov=this.fov,data.object.zoom=this.zoom,data.object.near=this.near,data.object.far=this.far,data.object.focus=this.focus,data.object.aspect=this.aspect,null!==this.view&&(data.object.view=Object.assign({},this.view)),data.object.filmGauge=this.filmGauge,data.object.filmOffset=this.filmOffset,data}}class SpotLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(50,1,.5,500)),this.isSpotLightShadow=!0,this.focus=1,this.aspect=1}updateMatrices(light){const camera=this.camera,fov=2*RAD2DEG*light.angle*this.focus,aspect=this.mapSize.width/this.mapSize.height*this.aspect,far=light.distance||camera.far;fov===camera.fov&&aspect===camera.aspect&&far===camera.far||(camera.fov=fov,camera.aspect=aspect,camera.far=far,camera.updateProjectionMatrix()),super.updateMatrices(light)}copy(source){return super.copy(source),this.focus=source.focus,this}}class SpotLight extends Light{constructor(color,intensity,distance=0,angle=Math.PI/3,penumbra=0,decay=2){super(color,intensity),this.isSpotLight=!0,this.type="SpotLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.distance=distance,this.angle=angle,this.penumbra=penumbra,this.decay=decay,this.map=null,this.shadow=new SpotLightShadow}get power(){return this.intensity*Math.PI}set power(power){this.intensity=power/Math.PI}dispose(){super.dispose(),this.shadow.dispose()}copy(source,recursive){return super.copy(source,recursive),this.distance=source.distance,this.angle=source.angle,this.penumbra=source.penumbra,this.decay=source.decay,this.target=source.target.clone(),this.map=source.map,this.shadow=source.shadow.clone(),this}toJSON(meta){const data=super.toJSON(meta);return data.object.distance=this.distance,data.object.angle=this.angle,data.object.decay=this.decay,data.object.penumbra=this.penumbra,data.object.target=this.target.uuid,this.map&&this.map.isTexture&&(data.object.map=this.map.toJSON(meta).uuid),data.object.shadow=this.shadow.toJSON(),data}}class PointLightShadow extends LightShadow{constructor(){super(new PerspectiveCamera(90,1,.5,500)),this.isPointLightShadow=!0}}class PointLight extends Light{constructor(color,intensity,distance=0,decay=2){super(color,intensity),this.isPointLight=!0,this.type="PointLight",this.distance=distance,this.decay=decay,this.shadow=new PointLightShadow}get power(){return 4*this.intensity*Math.PI}set power(power){this.intensity=power/(4*Math.PI)}dispose(){super.dispose(),this.shadow.dispose()}copy(source,recursive){return super.copy(source,recursive),this.distance=source.distance,this.decay=source.decay,this.shadow=source.shadow.clone(),this}toJSON(meta){const data=super.toJSON(meta);return data.object.distance=this.distance,data.object.decay=this.decay,data.object.shadow=this.shadow.toJSON(),data}}class OrthographicCamera extends Camera{constructor(left=-1,right=1,top=1,bottom=-1,near=.1,far=2e3){super(),this.isOrthographicCamera=!0,this.type="OrthographicCamera",this.zoom=1,this.view=null,this.left=left,this.right=right,this.top=top,this.bottom=bottom,this.near=near,this.far=far,this.updateProjectionMatrix()}copy(source,recursive){return super.copy(source,recursive),this.left=source.left,this.right=source.right,this.top=source.top,this.bottom=source.bottom,this.near=source.near,this.far=source.far,this.zoom=source.zoom,this.view=null===source.view?null:Object.assign({},source.view),this}setViewOffset(fullWidth,fullHeight,x,y,width,height){null===this.view&&(this.view={enabled:!0,fullWidth:1,fullHeight:1,offsetX:0,offsetY:0,width:1,height:1}),this.view.enabled=!0,this.view.fullWidth=fullWidth,this.view.fullHeight=fullHeight,this.view.offsetX=x,this.view.offsetY=y,this.view.width=width,this.view.height=height,this.updateProjectionMatrix()}clearViewOffset(){null!==this.view&&(this.view.enabled=!1),this.updateProjectionMatrix()}updateProjectionMatrix(){const dx=(this.right-this.left)/(2*this.zoom),dy=(this.top-this.bottom)/(2*this.zoom),cx=(this.right+this.left)/2,cy=(this.top+this.bottom)/2;let left=cx-dx,right=cx+dx,top=cy+dy,bottom=cy-dy;if(null!==this.view&&this.view.enabled){const scaleW=(this.right-this.left)/this.view.fullWidth/this.zoom,scaleH=(this.top-this.bottom)/this.view.fullHeight/this.zoom;left+=scaleW*this.view.offsetX,right=left+scaleW*this.view.width,top-=scaleH*this.view.offsetY,bottom=top-scaleH*this.view.height}this.projectionMatrix.makeOrthographic(left,right,top,bottom,this.near,this.far,this.coordinateSystem,this.reversedDepth),this.projectionMatrixInverse.copy(this.projectionMatrix).invert()}toJSON(meta){const data=super.toJSON(meta);return data.object.zoom=this.zoom,data.object.left=this.left,data.object.right=this.right,data.object.top=this.top,data.object.bottom=this.bottom,data.object.near=this.near,data.object.far=this.far,null!==this.view&&(data.object.view=Object.assign({},this.view)),data}}class DirectionalLightShadow extends LightShadow{constructor(){super(new OrthographicCamera(-5,5,5,-5,.5,500)),this.isDirectionalLightShadow=!0}}class DirectionalLight extends Light{constructor(color,intensity){super(color,intensity),this.isDirectionalLight=!0,this.type="DirectionalLight",this.position.copy(Object3D.DEFAULT_UP),this.updateMatrix(),this.target=new Object3D,this.shadow=new DirectionalLightShadow}dispose(){super.dispose(),this.shadow.dispose()}copy(source){return super.copy(source),this.target=source.target.clone(),this.shadow=source.shadow.clone(),this}toJSON(meta){const data=super.toJSON(meta);return data.object.shadow=this.shadow.toJSON(),data.object.target=this.target.uuid,data}}class AmbientLight extends Light{constructor(color,intensity){super(color,intensity),this.isAmbientLight=!0,this.type="AmbientLight"}}class RectAreaLight extends Light{constructor(color,intensity,width=10,height=10){super(color,intensity),this.isRectAreaLight=!0,this.type="RectAreaLight",this.width=width,this.height=height}get power(){return this.intensity*this.width*this.height*Math.PI}set power(power){this.intensity=power/(this.width*this.height*Math.PI)}copy(source){return super.copy(source),this.width=source.width,this.height=source.height,this}toJSON(meta){const data=super.toJSON(meta);return data.object.width=this.width,data.object.height=this.height,data}}class SphericalHarmonics3{constructor(){this.isSphericalHarmonics3=!0,this.coefficients=[];for(let i=0;i<9;i++)this.coefficients.push(new Vector3)}set(coefficients){for(let i=0;i<9;i++)this.coefficients[i].copy(coefficients[i]);return this}zero(){for(let i=0;i<9;i++)this.coefficients[i].set(0,0,0);return this}getAt(normal,target){const x=normal.x,y=normal.y,z=normal.z,coeff=this.coefficients;return target.copy(coeff[0]).multiplyScalar(.282095),target.addScaledVector(coeff[1],.488603*y),target.addScaledVector(coeff[2],.488603*z),target.addScaledVector(coeff[3],.488603*x),target.addScaledVector(coeff[4],x*y*1.092548),target.addScaledVector(coeff[5],y*z*1.092548),target.addScaledVector(coeff[6],.315392*(3*z*z-1)),target.addScaledVector(coeff[7],x*z*1.092548),target.addScaledVector(coeff[8],.546274*(x*x-y*y)),target}getIrradianceAt(normal,target){const x=normal.x,y=normal.y,z=normal.z,coeff=this.coefficients;return target.copy(coeff[0]).multiplyScalar(.886227),target.addScaledVector(coeff[1],1.023328*y),target.addScaledVector(coeff[2],1.023328*z),target.addScaledVector(coeff[3],1.023328*x),target.addScaledVector(coeff[4],.858086*x*y),target.addScaledVector(coeff[5],.858086*y*z),target.addScaledVector(coeff[6],.743125*z*z-.247708),target.addScaledVector(coeff[7],.858086*x*z),target.addScaledVector(coeff[8],.429043*(x*x-y*y)),target}add(sh){for(let i=0;i<9;i++)this.coefficients[i].add(sh.coefficients[i]);return this}addScaledSH(sh,s){for(let i=0;i<9;i++)this.coefficients[i].addScaledVector(sh.coefficients[i],s);return this}scale(s){for(let i=0;i<9;i++)this.coefficients[i].multiplyScalar(s);return this}lerp(sh,alpha){for(let i=0;i<9;i++)this.coefficients[i].lerp(sh.coefficients[i],alpha);return this}equals(sh){for(let i=0;i<9;i++)if(!this.coefficients[i].equals(sh.coefficients[i]))return!1;return!0}copy(sh){return this.set(sh.coefficients)}clone(){return(new this.constructor).copy(this)}fromArray(array,offset=0){const coefficients=this.coefficients;for(let i=0;i<9;i++)coefficients[i].fromArray(array,offset+3*i);return this}toArray(array=[],offset=0){const coefficients=this.coefficients;for(let i=0;i<9;i++)coefficients[i].toArray(array,offset+3*i);return array}static getBasisAt(normal,shBasis){const x=normal.x,y=normal.y,z=normal.z;shBasis[0]=.282095,shBasis[1]=.488603*y,shBasis[2]=.488603*z,shBasis[3]=.488603*x,shBasis[4]=1.092548*x*y,shBasis[5]=1.092548*y*z,shBasis[6]=.315392*(3*z*z-1),shBasis[7]=1.092548*x*z,shBasis[8]=.546274*(x*x-y*y)}}class LightProbe extends Light{constructor(sh=new SphericalHarmonics3,intensity=1){super(void 0,intensity),this.isLightProbe=!0,this.sh=sh}copy(source){return super.copy(source),this.sh.copy(source.sh),this}toJSON(meta){const data=super.toJSON(meta);return data.object.sh=this.sh.toArray(),data}}class InstancedBufferGeometry extends BufferGeometry{constructor(){super(),this.isInstancedBufferGeometry=!0,this.type="InstancedBufferGeometry",this.instanceCount=Infinity}copy(source){return super.copy(source),this.instanceCount=source.instanceCount,this}toJSON(){const data=super.toJSON();return data.instanceCount=this.instanceCount,data.isInstancedBufferGeometry=!0,data}}let _context;class AudioContext{static getContext(){return void 0===_context&&(_context=new(window.AudioContext||window.webkitAudioContext)),_context}static setContext(value){_context=value}}const _eyeRight=/*@__PURE__*/new Matrix4,_eyeLeft=/*@__PURE__*/new Matrix4,_projectionMatrix=/*@__PURE__*/new Matrix4;class StereoCamera{constructor(){this.type="StereoCamera",this.aspect=1,this.eyeSep=.064,this.cameraL=new PerspectiveCamera,this.cameraL.layers.enable(1),this.cameraL.matrixAutoUpdate=!1,this.cameraR=new PerspectiveCamera,this.cameraR.layers.enable(2),this.cameraR.matrixAutoUpdate=!1,this._cache={focus:null,fov:null,aspect:null,near:null,far:null,zoom:null,eyeSep:null}}update(camera){const cache=this._cache;if(cache.focus!==camera.focus||cache.fov!==camera.fov||cache.aspect!==camera.aspect*this.aspect||cache.near!==camera.near||cache.far!==camera.far||cache.zoom!==camera.zoom||cache.eyeSep!==this.eyeSep){cache.focus=camera.focus,cache.fov=camera.fov,cache.aspect=camera.aspect*this.aspect,cache.near=camera.near,cache.far=camera.far,cache.zoom=camera.zoom,cache.eyeSep=this.eyeSep,_projectionMatrix.copy(camera.projectionMatrix);const eyeSepHalf=cache.eyeSep/2,eyeSepOnProjection=eyeSepHalf*cache.near/cache.focus,ymax=cache.near*Math.tan(DEG2RAD*cache.fov*.5)/cache.zoom;let xmin,xmax;_eyeLeft.elements[12]=-eyeSepHalf,_eyeRight.elements[12]=eyeSepHalf,xmin=-ymax*cache.aspect+eyeSepOnProjection,xmax=ymax*cache.aspect+eyeSepOnProjection,_projectionMatrix.elements[0]=2*cache.near/(xmax-xmin),_projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin),this.cameraL.projectionMatrix.copy(_projectionMatrix),xmin=-ymax*cache.aspect-eyeSepOnProjection,xmax=ymax*cache.aspect-eyeSepOnProjection,_projectionMatrix.elements[0]=2*cache.near/(xmax-xmin),_projectionMatrix.elements[8]=(xmax+xmin)/(xmax-xmin),this.cameraR.projectionMatrix.copy(_projectionMatrix)}this.cameraL.matrixWorld.copy(camera.matrixWorld).multiply(_eyeLeft),this.cameraR.matrixWorld.copy(camera.matrixWorld).multiply(_eyeRight)}}class CubeCamera extends Object3D{constructor(near,far,renderTarget){super(),this.type="CubeCamera",this.renderTarget=renderTarget,this.coordinateSystem=null,this.activeMipmapLevel=0;const cameraPX=new PerspectiveCamera(-90,1,near,far);cameraPX.layers=this.layers,this.add(cameraPX);const cameraNX=new PerspectiveCamera(-90,1,near,far);cameraNX.layers=this.layers,this.add(cameraNX);const cameraPY=new PerspectiveCamera(-90,1,near,far);cameraPY.layers=this.layers,this.add(cameraPY);const cameraNY=new PerspectiveCamera(-90,1,near,far);cameraNY.layers=this.layers,this.add(cameraNY);const cameraPZ=new PerspectiveCamera(-90,1,near,far);cameraPZ.layers=this.layers,this.add(cameraPZ);const cameraNZ=new PerspectiveCamera(-90,1,near,far);cameraNZ.layers=this.layers,this.add(cameraNZ)}updateCoordinateSystem(){const coordinateSystem=this.coordinateSystem,cameras=this.children.concat(),[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=cameras;for(const camera of cameras)this.remove(camera);if(2e3===coordinateSystem)cameraPX.up.set(0,1,0),cameraPX.lookAt(1,0,0),cameraNX.up.set(0,1,0),cameraNX.lookAt(-1,0,0),cameraPY.up.set(0,0,-1),cameraPY.lookAt(0,1,0),cameraNY.up.set(0,0,1),cameraNY.lookAt(0,-1,0),cameraPZ.up.set(0,1,0),cameraPZ.lookAt(0,0,1),cameraNZ.up.set(0,1,0),cameraNZ.lookAt(0,0,-1);else{if(2001!==coordinateSystem)throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: "+coordinateSystem);cameraPX.up.set(0,-1,0),cameraPX.lookAt(-1,0,0),cameraNX.up.set(0,-1,0),cameraNX.lookAt(1,0,0),cameraPY.up.set(0,0,1),cameraPY.lookAt(0,1,0),cameraNY.up.set(0,0,-1),cameraNY.lookAt(0,-1,0),cameraPZ.up.set(0,-1,0),cameraPZ.lookAt(0,0,1),cameraNZ.up.set(0,-1,0),cameraNZ.lookAt(0,0,-1)}for(const camera of cameras)this.add(camera),camera.updateMatrixWorld()}update(renderer,scene){null===this.parent&&this.updateMatrixWorld();const{renderTarget:renderTarget,activeMipmapLevel:activeMipmapLevel}=this;this.coordinateSystem!==renderer.coordinateSystem&&(this.coordinateSystem=renderer.coordinateSystem,this.updateCoordinateSystem());const[cameraPX,cameraNX,cameraPY,cameraNY,cameraPZ,cameraNZ]=this.children,currentRenderTarget=renderer.getRenderTarget(),currentActiveCubeFace=renderer.getActiveCubeFace(),currentActiveMipmapLevel=renderer.getActiveMipmapLevel(),currentXrEnabled=renderer.xr.enabled;renderer.xr.enabled=!1;const generateMipmaps=renderTarget.texture.generateMipmaps;renderTarget.texture.generateMipmaps=!1;const reversedDepthBuffer=!(!renderer.isWebGLRenderer||!renderer.state.buffers.depth.getReversed());renderer.setRenderTarget(renderTarget,0,activeMipmapLevel),reversedDepthBuffer&&!1===renderer.autoClear&&renderer.clearDepth(),renderer.render(scene,cameraPX),renderer.setRenderTarget(renderTarget,1,activeMipmapLevel),reversedDepthBuffer&&!1===renderer.autoClear&&renderer.clearDepth(),renderer.render(scene,cameraNX),renderer.setRenderTarget(renderTarget,2,activeMipmapLevel),reversedDepthBuffer&&!1===renderer.autoClear&&renderer.clearDepth(),renderer.render(scene,cameraPY),renderer.setRenderTarget(renderTarget,3,activeMipmapLevel),reversedDepthBuffer&&!1===renderer.autoClear&&renderer.clearDepth(),renderer.render(scene,cameraNY),renderer.setRenderTarget(renderTarget,4,activeMipmapLevel),reversedDepthBuffer&&!1===renderer.autoClear&&renderer.clearDepth(),renderer.render(scene,cameraPZ),renderTarget.texture.generateMipmaps=generateMipmaps,renderer.setRenderTarget(renderTarget,5,activeMipmapLevel),reversedDepthBuffer&&!1===renderer.autoClear&&renderer.clearDepth(),renderer.render(scene,cameraNZ),renderer.setRenderTarget(currentRenderTarget,currentActiveCubeFace,currentActiveMipmapLevel),renderer.xr.enabled=currentXrEnabled,renderTarget.texture.needsPMREMUpdate=!0}}class ArrayCamera extends PerspectiveCamera{constructor(array=[]){super(),this.isArrayCamera=!0,this.isMultiViewCamera=!1,this.cameras=array}}class Clock{constructor(autoStart=!0){this.autoStart=autoStart,this.startTime=0,this.oldTime=0,this.elapsedTime=0,this.running=!1,warn("THREE.Clock: This module has been deprecated. Please use THREE.Timer instead.")}start(){this.startTime=performance.now(),this.oldTime=this.startTime,this.elapsedTime=0,this.running=!0}stop(){this.getElapsedTime(),this.running=!1,this.autoStart=!1}getElapsedTime(){return this.getDelta(),this.elapsedTime}getDelta(){let diff=0;if(this.autoStart&&!this.running)return this.start(),0;if(this.running){const newTime=performance.now();diff=(newTime-this.oldTime)/1e3,this.oldTime=newTime,this.elapsedTime+=diff}return diff}}const _position$1=/*@__PURE__*/new Vector3,_quaternion$1=/*@__PURE__*/new Quaternion,_scale$1=/*@__PURE__*/new Vector3,_forward=/*@__PURE__*/new Vector3,_up=/*@__PURE__*/new Vector3;class AudioListener extends Object3D{constructor(){super(),this.type="AudioListener",this.context=AudioContext.getContext(),this.gain=this.context.createGain(),this.gain.connect(this.context.destination),this.filter=null,this.timeDelta=0,this._clock=new Clock}getInput(){return this.gain}removeFilter(){return null!==this.filter&&(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination),this.gain.connect(this.context.destination),this.filter=null),this}getFilter(){return this.filter}setFilter(value){return null!==this.filter?(this.gain.disconnect(this.filter),this.filter.disconnect(this.context.destination)):this.gain.disconnect(this.context.destination),this.filter=value,this.gain.connect(this.filter),this.filter.connect(this.context.destination),this}getMasterVolume(){return this.gain.gain.value}setMasterVolume(value){return this.gain.gain.setTargetAtTime(value,this.context.currentTime,.01),this}updateMatrixWorld(force){super.updateMatrixWorld(force);const listener=this.context.listener;if(this.timeDelta=this._clock.getDelta(),this.matrixWorld.decompose(_position$1,_quaternion$1,_scale$1),_forward.set(0,0,-1).applyQuaternion(_quaternion$1),_up.set(0,1,0).applyQuaternion(_quaternion$1),listener.positionX){const endTime=this.context.currentTime+this.timeDelta;listener.positionX.linearRampToValueAtTime(_position$1.x,endTime),listener.positionY.linearRampToValueAtTime(_position$1.y,endTime),listener.positionZ.linearRampToValueAtTime(_position$1.z,endTime),listener.forwardX.linearRampToValueAtTime(_forward.x,endTime),listener.forwardY.linearRampToValueAtTime(_forward.y,endTime),listener.forwardZ.linearRampToValueAtTime(_forward.z,endTime),listener.upX.linearRampToValueAtTime(_up.x,endTime),listener.upY.linearRampToValueAtTime(_up.y,endTime),listener.upZ.linearRampToValueAtTime(_up.z,endTime)}else listener.setPosition(_position$1.x,_position$1.y,_position$1.z),listener.setOrientation(_forward.x,_forward.y,_forward.z,_up.x,_up.y,_up.z)}}class Audio extends Object3D{constructor(listener){super(),this.type="Audio",this.listener=listener,this.context=listener.context,this.gain=this.context.createGain(),this.gain.connect(listener.getInput()),this.autoplay=!1,this.buffer=null,this.detune=0,this.loop=!1,this.loopStart=0,this.loopEnd=0,this.offset=0,this.duration=void 0,this.playbackRate=1,this.isPlaying=!1,this.hasPlaybackControl=!0,this.source=null,this.sourceType="empty",this._startedAt=0,this._progress=0,this._connected=!1,this.filters=[]}getOutput(){return this.gain}setNodeSource(audioNode){return this.hasPlaybackControl=!1,this.sourceType="audioNode",this.source=audioNode,this.connect(),this}setMediaElementSource(mediaElement){return this.hasPlaybackControl=!1,this.sourceType="mediaNode",this.source=this.context.createMediaElementSource(mediaElement),this.connect(),this}setMediaStreamSource(mediaStream){return this.hasPlaybackControl=!1,this.sourceType="mediaStreamNode",this.source=this.context.createMediaStreamSource(mediaStream),this.connect(),this}setBuffer(audioBuffer){return this.buffer=audioBuffer,this.sourceType="buffer",this.autoplay&&this.play(),this}play(delay=0){if(!0===this.isPlaying)return void warn("Audio: Audio is already playing.");if(!1===this.hasPlaybackControl)return void warn("Audio: this Audio has no playback control.");this._startedAt=this.context.currentTime+delay;const source=this.context.createBufferSource();return source.buffer=this.buffer,source.loop=this.loop,source.loopStart=this.loopStart,source.loopEnd=this.loopEnd,source.onended=this.onEnded.bind(this),source.start(this._startedAt,this._progress+this.offset,this.duration),this.isPlaying=!0,this.source=source,this.setDetune(this.detune),this.setPlaybackRate(this.playbackRate),this.connect()}pause(){if(!1!==this.hasPlaybackControl)return!0===this.isPlaying&&(this._progress+=Math.max(this.context.currentTime-this._startedAt,0)*this.playbackRate,!0===this.loop&&(this._progress=this._progress%(this.duration||this.buffer.duration)),this.source.stop(),this.source.onended=null,this.isPlaying=!1),this;warn("Audio: this Audio has no playback control.")}stop(delay=0){if(!1!==this.hasPlaybackControl)return this._progress=0,null!==this.source&&(this.source.stop(this.context.currentTime+delay),this.source.onended=null),this.isPlaying=!1,this;warn("Audio: this Audio has no playback control.")}connect(){if(this.filters.length>0){this.source.connect(this.filters[0]);for(let i=1,l=this.filters.length;i<l;i++)this.filters[i-1].connect(this.filters[i]);this.filters[this.filters.length-1].connect(this.getOutput())}else this.source.connect(this.getOutput());return this._connected=!0,this}disconnect(){if(!1!==this._connected){if(this.filters.length>0){this.source.disconnect(this.filters[0]);for(let i=1,l=this.filters.length;i<l;i++)this.filters[i-1].disconnect(this.filters[i]);this.filters[this.filters.length-1].disconnect(this.getOutput())}else this.source.disconnect(this.getOutput());return this._connected=!1,this}}getFilters(){return this.filters}setFilters(value){return value||(value=[]),!0===this._connected?(this.disconnect(),this.filters=value.slice(),this.connect()):this.filters=value.slice(),this}setDetune(value){return this.detune=value,!0===this.isPlaying&&void 0!==this.source.detune&&this.source.detune.setTargetAtTime(this.detune,this.context.currentTime,.01),this}getDetune(){return this.detune}getFilter(){return this.getFilters()[0]}setFilter(filter){return this.setFilters(filter?[filter]:[])}setPlaybackRate(value){if(!1!==this.hasPlaybackControl)return this.playbackRate=value,!0===this.isPlaying&&this.source.playbackRate.setTargetAtTime(this.playbackRate,this.context.currentTime,.01),this;warn("Audio: this Audio has no playback control.")}getPlaybackRate(){return this.playbackRate}onEnded(){this.isPlaying=!1,this._progress=0}getLoop(){return!1===this.hasPlaybackControl?(warn("Audio: this Audio has no playback control."),!1):this.loop}setLoop(value){if(!1!==this.hasPlaybackControl)return this.loop=value,!0===this.isPlaying&&(this.source.loop=this.loop),this;warn("Audio: this Audio has no playback control.")}setLoopStart(value){return this.loopStart=value,this}setLoopEnd(value){return this.loopEnd=value,this}getVolume(){return this.gain.gain.value}setVolume(value){return this.gain.gain.setTargetAtTime(value,this.context.currentTime,.01),this}copy(source,recursive){return super.copy(source,recursive),"buffer"!==source.sourceType?(warn("Audio: Audio source type cannot be copied."),this):(this.autoplay=source.autoplay,this.buffer=source.buffer,this.detune=source.detune,this.loop=source.loop,this.loopStart=source.loopStart,this.loopEnd=source.loopEnd,this.offset=source.offset,this.duration=source.duration,this.playbackRate=source.playbackRate,this.hasPlaybackControl=source.hasPlaybackControl,this.sourceType=source.sourceType,this.filters=source.filters.slice(),this)}clone(recursive){return new this.constructor(this.listener).copy(this,recursive)}}const _position=/*@__PURE__*/new Vector3,_quaternion=/*@__PURE__*/new Quaternion,_scale=/*@__PURE__*/new Vector3,_orientation=/*@__PURE__*/new Vector3;class PositionalAudio extends Audio{constructor(listener){super(listener),this.panner=this.context.createPanner(),this.panner.panningModel="HRTF",this.panner.connect(this.gain)}connect(){return super.connect(),this.panner.connect(this.gain),this}disconnect(){return super.disconnect(),this.panner.disconnect(this.gain),this}getOutput(){return this.panner}getRefDistance(){return this.panner.refDistance}setRefDistance(value){return this.panner.refDistance=value,this}getRolloffFactor(){return this.panner.rolloffFactor}setRolloffFactor(value){return this.panner.rolloffFactor=value,this}getDistanceModel(){return this.panner.distanceModel}setDistanceModel(value){return this.panner.distanceModel=value,this}getMaxDistance(){return this.panner.maxDistance}setMaxDistance(value){return this.panner.maxDistance=value,this}setDirectionalCone(coneInnerAngle,coneOuterAngle,coneOuterGain){return this.panner.coneInnerAngle=coneInnerAngle,this.panner.coneOuterAngle=coneOuterAngle,this.panner.coneOuterGain=coneOuterGain,this}updateMatrixWorld(force){if(super.updateMatrixWorld(force),!0===this.hasPlaybackControl&&!1===this.isPlaying)return;this.matrixWorld.decompose(_position,_quaternion,_scale),_orientation.set(0,0,1).applyQuaternion(_quaternion);const panner=this.panner;if(panner.positionX){const endTime=this.context.currentTime+this.listener.timeDelta;panner.positionX.linearRampToValueAtTime(_position.x,endTime),panner.positionY.linearRampToValueAtTime(_position.y,endTime),panner.positionZ.linearRampToValueAtTime(_position.z,endTime),panner.orientationX.linearRampToValueAtTime(_orientation.x,endTime),panner.orientationY.linearRampToValueAtTime(_orientation.y,endTime),panner.orientationZ.linearRampToValueAtTime(_orientation.z,endTime)}else panner.setPosition(_position.x,_position.y,_position.z),panner.setOrientation(_orientation.x,_orientation.y,_orientation.z)}}class AudioAnalyser{constructor(audio,fftSize=2048){this.analyser=audio.context.createAnalyser(),this.analyser.fftSize=fftSize,this.data=new Uint8Array(this.analyser.frequencyBinCount),audio.getOutput().connect(this.analyser)}getFrequencyData(){return this.analyser.getByteFrequencyData(this.data),this.data}getAverageFrequency(){let value=0;const data=this.getFrequencyData();for(let i=0;i<data.length;i++)value+=data[i];return value/data.length}}class PropertyMixer{constructor(binding,typeName,valueSize){let mixFunction,mixFunctionAdditive,setIdentity;switch(this.binding=binding,this.valueSize=valueSize,typeName){case"quaternion":mixFunction=this._slerp,mixFunctionAdditive=this._slerpAdditive,setIdentity=this._setAdditiveIdentityQuaternion,this.buffer=new Float64Array(6*valueSize),this._workIndex=5;break;case"string":case"bool":mixFunction=this._select,mixFunctionAdditive=this._select,setIdentity=this._setAdditiveIdentityOther,this.buffer=new Array(5*valueSize);break;default:mixFunction=this._lerp,mixFunctionAdditive=this._lerpAdditive,setIdentity=this._setAdditiveIdentityNumeric,this.buffer=new Float64Array(5*valueSize)}this._mixBufferRegion=mixFunction,this._mixBufferRegionAdditive=mixFunctionAdditive,this._setIdentity=setIdentity,this._origIndex=3,this._addIndex=4,this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,this.useCount=0,this.referenceCount=0}accumulate(accuIndex,weight){const buffer=this.buffer,stride=this.valueSize,offset=accuIndex*stride+stride;let currentWeight=this.cumulativeWeight;if(0===currentWeight){for(let i=0;i!==stride;++i)buffer[offset+i]=buffer[i];currentWeight=weight}else{currentWeight+=weight;const mix=weight/currentWeight;this._mixBufferRegion(buffer,offset,0,mix,stride)}this.cumulativeWeight=currentWeight}accumulateAdditive(weight){const buffer=this.buffer,stride=this.valueSize,offset=stride*this._addIndex;0===this.cumulativeWeightAdditive&&this._setIdentity(),this._mixBufferRegionAdditive(buffer,offset,0,weight,stride),this.cumulativeWeightAdditive+=weight}apply(accuIndex){const stride=this.valueSize,buffer=this.buffer,offset=accuIndex*stride+stride,weight=this.cumulativeWeight,weightAdditive=this.cumulativeWeightAdditive,binding=this.binding;if(this.cumulativeWeight=0,this.cumulativeWeightAdditive=0,weight<1){const originalValueOffset=stride*this._origIndex;this._mixBufferRegion(buffer,offset,originalValueOffset,1-weight,stride)}weightAdditive>0&&this._mixBufferRegionAdditive(buffer,offset,this._addIndex*stride,1,stride);for(let i=stride,e=stride+stride;i!==e;++i)if(buffer[i]!==buffer[i+stride]){binding.setValue(buffer,offset);break}}saveOriginalState(){const binding=this.binding,buffer=this.buffer,stride=this.valueSize,originalValueOffset=stride*this._origIndex;binding.getValue(buffer,originalValueOffset);for(let i=stride,e=originalValueOffset;i!==e;++i)buffer[i]=buffer[originalValueOffset+i%stride];this._setIdentity(),this.cumulativeWeight=0,this.cumulativeWeightAdditive=0}restoreOriginalState(){const originalValueOffset=3*this.valueSize;this.binding.setValue(this.buffer,originalValueOffset)}_setAdditiveIdentityNumeric(){const startIndex=this._addIndex*this.valueSize,endIndex=startIndex+this.valueSize;for(let i=startIndex;i<endIndex;i++)this.buffer[i]=0}_setAdditiveIdentityQuaternion(){this._setAdditiveIdentityNumeric(),this.buffer[this._addIndex*this.valueSize+3]=1}_setAdditiveIdentityOther(){const startIndex=this._origIndex*this.valueSize,targetIndex=this._addIndex*this.valueSize;for(let i=0;i<this.valueSize;i++)this.buffer[targetIndex+i]=this.buffer[startIndex+i]}_select(buffer,dstOffset,srcOffset,t,stride){if(t>=.5)for(let i=0;i!==stride;++i)buffer[dstOffset+i]=buffer[srcOffset+i]}_slerp(buffer,dstOffset,srcOffset,t){Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,srcOffset,t)}_slerpAdditive(buffer,dstOffset,srcOffset,t,stride){const workOffset=this._workIndex*stride;Quaternion.multiplyQuaternionsFlat(buffer,workOffset,buffer,dstOffset,buffer,srcOffset),Quaternion.slerpFlat(buffer,dstOffset,buffer,dstOffset,buffer,workOffset,t)}_lerp(buffer,dstOffset,srcOffset,t,stride){const s=1-t;for(let i=0;i!==stride;++i){const j=dstOffset+i;buffer[j]=buffer[j]*s+buffer[srcOffset+i]*t}}_lerpAdditive(buffer,dstOffset,srcOffset,t,stride){for(let i=0;i!==stride;++i){const j=dstOffset+i;buffer[j]=buffer[j]+buffer[srcOffset+i]*t}}}const _reservedRe=new RegExp("[\\[\\]\\.:\\/]","g"),_wordCharOrDot="[^"+"\\[\\]\\.:\\/".replace("\\.","")+"]",_trackRe=new RegExp("^"+/*@__PURE__*/ /((?:WC+[\/:])*)/.source.replace("WC","[^\\[\\]\\.:\\/]")+/*@__PURE__*/ /(WCOD+)?/.source.replace("WCOD",_wordCharOrDot)+/*@__PURE__*/ /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC","[^\\[\\]\\.:\\/]")+/*@__PURE__*/ /\.(WC+)(?:\[(.+)\])?/.source.replace("WC","[^\\[\\]\\.:\\/]")+"$"),_supportedObjectNames=["material","materials","bones","map"];class PropertyBinding{constructor(rootNode,path,parsedPath){this.path=path,this.parsedPath=parsedPath||PropertyBinding.parseTrackName(path),this.node=PropertyBinding.findNode(rootNode,this.parsedPath.nodeName),this.rootNode=rootNode,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}static create(root,path,parsedPath){return root&&root.isAnimationObjectGroup?new PropertyBinding.Composite(root,path,parsedPath):new PropertyBinding(root,path,parsedPath)}static sanitizeNodeName(name){return name.replace(/\s/g,"_").replace(_reservedRe,"")}static parseTrackName(trackName){const matches=_trackRe.exec(trackName);if(null===matches)throw new Error("PropertyBinding: Cannot parse trackName: "+trackName);const results={nodeName:matches[2],objectName:matches[3],objectIndex:matches[4],propertyName:matches[5],propertyIndex:matches[6]},lastDot=results.nodeName&&results.nodeName.lastIndexOf(".");if(void 0!==lastDot&&-1!==lastDot){const objectName=results.nodeName.substring(lastDot+1);-1!==_supportedObjectNames.indexOf(objectName)&&(results.nodeName=results.nodeName.substring(0,lastDot),results.objectName=objectName)}if(null===results.propertyName||0===results.propertyName.length)throw new Error("PropertyBinding: can not parse propertyName from trackName: "+trackName);return results}static findNode(root,nodeName){if(void 0===nodeName||""===nodeName||"."===nodeName||-1===nodeName||nodeName===root.name||nodeName===root.uuid)return root;if(root.skeleton){const bone=root.skeleton.getBoneByName(nodeName);if(void 0!==bone)return bone}if(root.children){const searchNodeSubtree=function(children){for(let i=0;i<children.length;i++){const childNode=children[i];if(childNode.name===nodeName||childNode.uuid===nodeName)return childNode;const result=searchNodeSubtree(childNode.children);if(result)return result}return null},subTreeNode=searchNodeSubtree(root.children);if(subTreeNode)return subTreeNode}return null}_getValue_unavailable(){}_setValue_unavailable(){}_getValue_direct(buffer,offset){buffer[offset]=this.targetObject[this.propertyName]}_getValue_array(buffer,offset){const source=this.resolvedProperty;for(let i=0,n=source.length;i!==n;++i)buffer[offset++]=source[i]}_getValue_arrayElement(buffer,offset){buffer[offset]=this.resolvedProperty[this.propertyIndex]}_getValue_toArray(buffer,offset){this.resolvedProperty.toArray(buffer,offset)}_setValue_direct(buffer,offset){this.targetObject[this.propertyName]=buffer[offset]}_setValue_direct_setNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset],this.targetObject.needsUpdate=!0}_setValue_direct_setMatrixWorldNeedsUpdate(buffer,offset){this.targetObject[this.propertyName]=buffer[offset],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_array(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i)dest[i]=buffer[offset++]}_setValue_array_setNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i)dest[i]=buffer[offset++];this.targetObject.needsUpdate=!0}_setValue_array_setMatrixWorldNeedsUpdate(buffer,offset){const dest=this.resolvedProperty;for(let i=0,n=dest.length;i!==n;++i)dest[i]=buffer[offset++];this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_arrayElement(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset]}_setValue_arrayElement_setNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset],this.targetObject.needsUpdate=!0}_setValue_arrayElement_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty[this.propertyIndex]=buffer[offset],this.targetObject.matrixWorldNeedsUpdate=!0}_setValue_fromArray(buffer,offset){this.resolvedProperty.fromArray(buffer,offset)}_setValue_fromArray_setNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset),this.targetObject.needsUpdate=!0}_setValue_fromArray_setMatrixWorldNeedsUpdate(buffer,offset){this.resolvedProperty.fromArray(buffer,offset),this.targetObject.matrixWorldNeedsUpdate=!0}_getValue_unbound(targetArray,offset){this.bind(),this.getValue(targetArray,offset)}_setValue_unbound(sourceArray,offset){this.bind(),this.setValue(sourceArray,offset)}bind(){let targetObject=this.node;const parsedPath=this.parsedPath,objectName=parsedPath.objectName,propertyName=parsedPath.propertyName;let propertyIndex=parsedPath.propertyIndex;if(targetObject||(targetObject=PropertyBinding.findNode(this.rootNode,parsedPath.nodeName),this.node=targetObject),this.getValue=this._getValue_unavailable,this.setValue=this._setValue_unavailable,!targetObject)return void warn("PropertyBinding: No target node found for track: "+this.path+".");if(objectName){let objectIndex=parsedPath.objectIndex;switch(objectName){case"materials":if(!targetObject.material)return void error("PropertyBinding: Can not bind to material as node does not have a material.",this);if(!targetObject.material.materials)return void error("PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.",this);targetObject=targetObject.material.materials;break;case"bones":if(!targetObject.skeleton)return void error("PropertyBinding: Can not bind to bones as node does not have a skeleton.",this);targetObject=targetObject.skeleton.bones;for(let i=0;i<targetObject.length;i++)if(targetObject[i].name===objectIndex){objectIndex=i;break}break;case"map":if("map"in targetObject){targetObject=targetObject.map;break}if(!targetObject.material)return void error("PropertyBinding: Can not bind to material as node does not have a material.",this);if(!targetObject.material.map)return void error("PropertyBinding: Can not bind to material.map as node.material does not have a map.",this);targetObject=targetObject.material.map;break;default:if(void 0===targetObject[objectName])return void error("PropertyBinding: Can not bind to objectName of node undefined.",this);targetObject=targetObject[objectName]}if(void 0!==objectIndex){if(void 0===targetObject[objectIndex])return void error("PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.",this,targetObject);targetObject=targetObject[objectIndex]}}const nodeProperty=targetObject[propertyName];if(void 0===nodeProperty){return void error("PropertyBinding: Trying to update property for track: "+parsedPath.nodeName+"."+propertyName+" but it wasn't found.",targetObject)}let versioning=this.Versioning.None;this.targetObject=targetObject,!0===targetObject.isMaterial?versioning=this.Versioning.NeedsUpdate:!0===targetObject.isObject3D&&(versioning=this.Versioning.MatrixWorldNeedsUpdate);let bindingType=this.BindingType.Direct;if(void 0!==propertyIndex){if("morphTargetInfluences"===propertyName){if(!targetObject.geometry)return void error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.",this);if(!targetObject.geometry.morphAttributes)return void error("PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.",this);void 0!==targetObject.morphTargetDictionary[propertyIndex]&&(propertyIndex=targetObject.morphTargetDictionary[propertyIndex])}bindingType=this.BindingType.ArrayElement,this.resolvedProperty=nodeProperty,this.propertyIndex=propertyIndex}else void 0!==nodeProperty.fromArray&&void 0!==nodeProperty.toArray?(bindingType=this.BindingType.HasFromToArray,this.resolvedProperty=nodeProperty):Array.isArray(nodeProperty)?(bindingType=this.BindingType.EntireArray,this.resolvedProperty=nodeProperty):this.propertyName=propertyName;this.getValue=this.GetterByBindingType[bindingType],this.setValue=this.SetterByBindingTypeAndVersioning[bindingType][versioning]}unbind(){this.node=null,this.getValue=this._getValue_unbound,this.setValue=this._setValue_unbound}}PropertyBinding.Composite=class Composite{constructor(targetGroup,path,optionalParsedPath){const parsedPath=optionalParsedPath||PropertyBinding.parseTrackName(path);this._targetGroup=targetGroup,this._bindings=targetGroup.subscribe_(path,parsedPath)}getValue(array,offset){this.bind();const firstValidIndex=this._targetGroup.nCachedObjects_,binding=this._bindings[firstValidIndex];void 0!==binding&&binding.getValue(array,offset)}setValue(array,offset){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i)bindings[i].setValue(array,offset)}bind(){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i)bindings[i].bind()}unbind(){const bindings=this._bindings;for(let i=this._targetGroup.nCachedObjects_,n=bindings.length;i!==n;++i)bindings[i].unbind()}},PropertyBinding.prototype.BindingType={Direct:0,EntireArray:1,ArrayElement:2,HasFromToArray:3},PropertyBinding.prototype.Versioning={None:0,NeedsUpdate:1,MatrixWorldNeedsUpdate:2},PropertyBinding.prototype.GetterByBindingType=[PropertyBinding.prototype._getValue_direct,PropertyBinding.prototype._getValue_array,PropertyBinding.prototype._getValue_arrayElement,PropertyBinding.prototype._getValue_toArray],PropertyBinding.prototype.SetterByBindingTypeAndVersioning=[[PropertyBinding.prototype._setValue_direct,PropertyBinding.prototype._setValue_direct_setNeedsUpdate,PropertyBinding.prototype._setValue_direct_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_array,PropertyBinding.prototype._setValue_array_setNeedsUpdate,PropertyBinding.prototype._setValue_array_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_arrayElement,PropertyBinding.prototype._setValue_arrayElement_setNeedsUpdate,PropertyBinding.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],[PropertyBinding.prototype._setValue_fromArray,PropertyBinding.prototype._setValue_fromArray_setNeedsUpdate,PropertyBinding.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];class AnimationObjectGroup{constructor(){this.isAnimationObjectGroup=!0,this.uuid=generateUUID(),this._objects=Array.prototype.slice.call(arguments),this.nCachedObjects_=0;const indices={};this._indicesByUUID=indices;for(let i=0,n=arguments.length;i!==n;++i)indices[arguments[i].uuid]=i;this._paths=[],this._parsedPaths=[],this._bindings=[],this._bindingsIndicesByPath={};const scope=this;this.stats={objects:{get total(){return scope._objects.length},get inUse(){return this.total-scope.nCachedObjects_}},get bindingsPerObject(){return scope._bindings.length}}}add(){const objects=this._objects,indicesByUUID=this._indicesByUUID,paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,nBindings=bindings.length;let knownObject,nObjects=objects.length,nCachedObjects=this.nCachedObjects_;for(let i=0,n=arguments.length;i!==n;++i){const object=arguments[i],uuid=object.uuid;let index=indicesByUUID[uuid];if(void 0===index){index=nObjects++,indicesByUUID[uuid]=index,objects.push(object);for(let j=0,m=nBindings;j!==m;++j)bindings[j].push(new PropertyBinding(object,paths[j],parsedPaths[j]))}else if(index<nCachedObjects){knownObject=objects[index];const firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex];indicesByUUID[lastCachedObject.uuid]=index,objects[index]=lastCachedObject,indicesByUUID[uuid]=firstActiveIndex,objects[firstActiveIndex]=object;for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex];let binding=bindingsForPath[index];bindingsForPath[index]=lastCached,void 0===binding&&(binding=new PropertyBinding(object,paths[j],parsedPaths[j])),bindingsForPath[firstActiveIndex]=binding}}else objects[index]!==knownObject&&error("AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")}this.nCachedObjects_=nCachedObjects}remove(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=this.nCachedObjects_;for(let i=0,n=arguments.length;i!==n;++i){const object=arguments[i],uuid=object.uuid,index=indicesByUUID[uuid];if(void 0!==index&&index>=nCachedObjects){const lastCachedIndex=nCachedObjects++,firstActiveObject=objects[lastCachedIndex];indicesByUUID[firstActiveObject.uuid]=index,objects[index]=firstActiveObject,indicesByUUID[uuid]=lastCachedIndex,objects[lastCachedIndex]=object;for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j],firstActive=bindingsForPath[lastCachedIndex],binding=bindingsForPath[index];bindingsForPath[index]=firstActive,bindingsForPath[lastCachedIndex]=binding}}}this.nCachedObjects_=nCachedObjects}uncache(){const objects=this._objects,indicesByUUID=this._indicesByUUID,bindings=this._bindings,nBindings=bindings.length;let nCachedObjects=this.nCachedObjects_,nObjects=objects.length;for(let i=0,n=arguments.length;i!==n;++i){const uuid=arguments[i].uuid,index=indicesByUUID[uuid];if(void 0!==index)if(delete indicesByUUID[uuid],index<nCachedObjects){const firstActiveIndex=--nCachedObjects,lastCachedObject=objects[firstActiveIndex],lastIndex=--nObjects,lastObject=objects[lastIndex];indicesByUUID[lastCachedObject.uuid]=index,objects[index]=lastCachedObject,indicesByUUID[lastObject.uuid]=firstActiveIndex,objects[firstActiveIndex]=lastObject,objects.pop();for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j],lastCached=bindingsForPath[firstActiveIndex],last=bindingsForPath[lastIndex];bindingsForPath[index]=lastCached,bindingsForPath[firstActiveIndex]=last,bindingsForPath.pop()}}else{const lastIndex=--nObjects,lastObject=objects[lastIndex];lastIndex>0&&(indicesByUUID[lastObject.uuid]=index),objects[index]=lastObject,objects.pop();for(let j=0,m=nBindings;j!==m;++j){const bindingsForPath=bindings[j];bindingsForPath[index]=bindingsForPath[lastIndex],bindingsForPath.pop()}}}this.nCachedObjects_=nCachedObjects}subscribe_(path,parsedPath){const indicesByPath=this._bindingsIndicesByPath;let index=indicesByPath[path];const bindings=this._bindings;if(void 0!==index)return bindings[index];const paths=this._paths,parsedPaths=this._parsedPaths,objects=this._objects,nObjects=objects.length,nCachedObjects=this.nCachedObjects_,bindingsForPath=new Array(nObjects);index=bindings.length,indicesByPath[path]=index,paths.push(path),parsedPaths.push(parsedPath),bindings.push(bindingsForPath);for(let i=nCachedObjects,n=objects.length;i!==n;++i){const object=objects[i];bindingsForPath[i]=new PropertyBinding(object,path,parsedPath)}return bindingsForPath}unsubscribe_(path){const indicesByPath=this._bindingsIndicesByPath,index=indicesByPath[path];if(void 0!==index){const paths=this._paths,parsedPaths=this._parsedPaths,bindings=this._bindings,lastBindingsIndex=bindings.length-1,lastBindings=bindings[lastBindingsIndex];indicesByPath[path[lastBindingsIndex]]=index,bindings[index]=lastBindings,bindings.pop(),parsedPaths[index]=parsedPaths[lastBindingsIndex],parsedPaths.pop(),paths[index]=paths[lastBindingsIndex],paths.pop()}}}class AnimationAction{constructor(mixer,clip,localRoot=null,blendMode=clip.blendMode){this._mixer=mixer,this._clip=clip,this._localRoot=localRoot,this.blendMode=blendMode;const tracks=clip.tracks,nTracks=tracks.length,interpolants=new Array(nTracks),interpolantSettings={endingStart:2400,endingEnd:2400};for(let i=0;i!==nTracks;++i){const interpolant=tracks[i].createInterpolant(null);interpolants[i]=interpolant,interpolant.settings=interpolantSettings}this._interpolantSettings=interpolantSettings,this._interpolants=interpolants,this._propertyBindings=new Array(nTracks),this._cacheIndex=null,this._byClipCacheIndex=null,this._timeScaleInterpolant=null,this._weightInterpolant=null,this.loop=2201,this._loopCount=-1,this._startTime=null,this.time=0,this.timeScale=1,this._effectiveTimeScale=1,this.weight=1,this._effectiveWeight=1,this.repetitions=Infinity,this.paused=!1,this.enabled=!0,this.clampWhenFinished=!1,this.zeroSlopeAtStart=!0,this.zeroSlopeAtEnd=!0}play(){return this._mixer._activateAction(this),this}stop(){return this._mixer._deactivateAction(this),this.reset()}reset(){return this.paused=!1,this.enabled=!0,this.time=0,this._loopCount=-1,this._startTime=null,this.stopFading().stopWarping()}isRunning(){return this.enabled&&!this.paused&&0!==this.timeScale&&null===this._startTime&&this._mixer._isActiveAction(this)}isScheduled(){return this._mixer._isActiveAction(this)}startAt(time){return this._startTime=time,this}setLoop(mode,repetitions){return this.loop=mode,this.repetitions=repetitions,this}setEffectiveWeight(weight){return this.weight=weight,this._effectiveWeight=this.enabled?weight:0,this.stopFading()}getEffectiveWeight(){return this._effectiveWeight}fadeIn(duration){return this._scheduleFading(duration,0,1)}fadeOut(duration){return this._scheduleFading(duration,1,0)}crossFadeFrom(fadeOutAction,duration,warp=!1){if(fadeOutAction.fadeOut(duration),this.fadeIn(duration),!0===warp){const fadeInDuration=this._clip.duration,fadeOutDuration=fadeOutAction._clip.duration,startEndRatio=fadeOutDuration/fadeInDuration,endStartRatio=fadeInDuration/fadeOutDuration;fadeOutAction.warp(1,startEndRatio,duration),this.warp(endStartRatio,1,duration)}return this}crossFadeTo(fadeInAction,duration,warp=!1){return fadeInAction.crossFadeFrom(this,duration,warp)}stopFading(){const weightInterpolant=this._weightInterpolant;return null!==weightInterpolant&&(this._weightInterpolant=null,this._mixer._takeBackControlInterpolant(weightInterpolant)),this}setEffectiveTimeScale(timeScale){return this.timeScale=timeScale,this._effectiveTimeScale=this.paused?0:timeScale,this.stopWarping()}getEffectiveTimeScale(){return this._effectiveTimeScale}setDuration(duration){return this.timeScale=this._clip.duration/duration,this.stopWarping()}syncWith(action){return this.time=action.time,this.timeScale=action.timeScale,this.stopWarping()}halt(duration){return this.warp(this._effectiveTimeScale,0,duration)}warp(startTimeScale,endTimeScale,duration){const mixer=this._mixer,now=mixer.time,timeScale=this.timeScale;let interpolant=this._timeScaleInterpolant;null===interpolant&&(interpolant=mixer._lendControlInterpolant(),this._timeScaleInterpolant=interpolant);const times=interpolant.parameterPositions,values=interpolant.sampleValues;return times[0]=now,times[1]=now+duration,values[0]=startTimeScale/timeScale,values[1]=endTimeScale/timeScale,this}stopWarping(){const timeScaleInterpolant=this._timeScaleInterpolant;return null!==timeScaleInterpolant&&(this._timeScaleInterpolant=null,this._mixer._takeBackControlInterpolant(timeScaleInterpolant)),this}getMixer(){return this._mixer}getClip(){return this._clip}getRoot(){return this._localRoot||this._mixer._root}_update(time,deltaTime,timeDirection,accuIndex){if(!this.enabled)return void this._updateWeight(time);const startTime=this._startTime;if(null!==startTime){const timeRunning=(time-startTime)*timeDirection;timeRunning<0||0===timeDirection?deltaTime=0:(this._startTime=null,deltaTime=timeDirection*timeRunning)}deltaTime*=this._updateTimeScale(time);const clipTime=this._updateTime(deltaTime),weight=this._updateWeight(time);if(weight>0){const interpolants=this._interpolants,propertyMixers=this._propertyBindings;if(2501===this.blendMode)for(let j=0,m=interpolants.length;j!==m;++j)interpolants[j].evaluate(clipTime),propertyMixers[j].accumulateAdditive(weight);else for(let j=0,m=interpolants.length;j!==m;++j)interpolants[j].evaluate(clipTime),propertyMixers[j].accumulate(accuIndex,weight)}}_updateWeight(time){let weight=0;if(this.enabled){weight=this.weight;const interpolant=this._weightInterpolant;if(null!==interpolant){const interpolantValue=interpolant.evaluate(time)[0];weight*=interpolantValue,time>interpolant.parameterPositions[1]&&(this.stopFading(),0===interpolantValue&&(this.enabled=!1))}}return this._effectiveWeight=weight,weight}_updateTimeScale(time){let timeScale=0;if(!this.paused){timeScale=this.timeScale;const interpolant=this._timeScaleInterpolant;if(null!==interpolant){timeScale*=interpolant.evaluate(time)[0],time>interpolant.parameterPositions[1]&&(this.stopWarping(),0===timeScale?this.paused=!0:this.timeScale=timeScale)}}return this._effectiveTimeScale=timeScale,timeScale}_updateTime(deltaTime){const duration=this._clip.duration,loop=this.loop;let time=this.time+deltaTime,loopCount=this._loopCount;const pingPong=2202===loop;if(0===deltaTime)return-1===loopCount||!pingPong||1&~loopCount?time:duration-time;if(2200===loop){-1===loopCount&&(this._loopCount=0,this._setEndings(!0,!0,!1));handle_stop:{if(time>=duration)time=duration;else{if(!(time<0)){this.time=time;break handle_stop}time=0}this.clampWhenFinished?this.paused=!0:this.enabled=!1,this.time=time,this._mixer.dispatchEvent({type:"finished",action:this,direction:deltaTime<0?-1:1})}}else{if(-1===loopCount&&(deltaTime>=0?(loopCount=0,this._setEndings(!0,0===this.repetitions,pingPong)):this._setEndings(0===this.repetitions,!0,pingPong)),time>=duration||time<0){const loopDelta=Math.floor(time/duration);time-=duration*loopDelta,loopCount+=Math.abs(loopDelta);const pending=this.repetitions-loopCount;if(pending<=0)this.clampWhenFinished?this.paused=!0:this.enabled=!1,time=deltaTime>0?duration:0,this.time=time,this._mixer.dispatchEvent({type:"finished",action:this,direction:deltaTime>0?1:-1});else{if(1===pending){const atStart=deltaTime<0;this._setEndings(atStart,!atStart,pingPong)}else this._setEndings(!1,!1,pingPong);this._loopCount=loopCount,this.time=time,this._mixer.dispatchEvent({type:"loop",action:this,loopDelta:loopDelta})}}else this.time=time;if(pingPong&&!(1&~loopCount))return duration-time}return time}_setEndings(atStart,atEnd,pingPong){const settings=this._interpolantSettings;pingPong?(settings.endingStart=2401,settings.endingEnd=2401):(settings.endingStart=atStart?this.zeroSlopeAtStart?2401:2400:2402,settings.endingEnd=atEnd?this.zeroSlopeAtEnd?2401:2400:2402)}_scheduleFading(duration,weightNow,weightThen){const mixer=this._mixer,now=mixer.time;let interpolant=this._weightInterpolant;null===interpolant&&(interpolant=mixer._lendControlInterpolant(),this._weightInterpolant=interpolant);const times=interpolant.parameterPositions,values=interpolant.sampleValues;return times[0]=now,values[0]=weightNow,times[1]=now+duration,values[1]=weightThen,this}}const _controlInterpolantsResultBuffer=new Float32Array(1);class AnimationMixer extends EventDispatcher{constructor(root){super(),this._root=root,this._initMemoryManager(),this._accuIndex=0,this.time=0,this.timeScale=1,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}_bindAction(action,prototypeAction){const root=action._localRoot||this._root,tracks=action._clip.tracks,nTracks=tracks.length,bindings=action._propertyBindings,interpolants=action._interpolants,rootUuid=root.uuid,bindingsByRoot=this._bindingsByRootAndName;let bindingsByName=bindingsByRoot[rootUuid];void 0===bindingsByName&&(bindingsByName={},bindingsByRoot[rootUuid]=bindingsByName);for(let i=0;i!==nTracks;++i){const track=tracks[i],trackName=track.name;let binding=bindingsByName[trackName];if(void 0!==binding)++binding.referenceCount,bindings[i]=binding;else{if(binding=bindings[i],void 0!==binding){null===binding._cacheIndex&&(++binding.referenceCount,this._addInactiveBinding(binding,rootUuid,trackName));continue}const path=prototypeAction&&prototypeAction._propertyBindings[i].binding.parsedPath;binding=new PropertyMixer(PropertyBinding.create(root,trackName,path),track.ValueTypeName,track.getValueSize()),++binding.referenceCount,this._addInactiveBinding(binding,rootUuid,trackName),bindings[i]=binding}interpolants[i].resultBuffer=binding.buffer}}_activateAction(action){if(!this._isActiveAction(action)){if(null===action._cacheIndex){const rootUuid=(action._localRoot||this._root).uuid,clipUuid=action._clip.uuid,actionsForClip=this._actionsByClip[clipUuid];this._bindAction(action,actionsForClip&&actionsForClip.knownActions[0]),this._addInactiveAction(action,clipUuid,rootUuid)}const bindings=action._propertyBindings;for(let i=0,n=bindings.length;i!==n;++i){const binding=bindings[i];0===binding.useCount++&&(this._lendBinding(binding),binding.saveOriginalState())}this._lendAction(action)}}_deactivateAction(action){if(this._isActiveAction(action)){const bindings=action._propertyBindings;for(let i=0,n=bindings.length;i!==n;++i){const binding=bindings[i];0===--binding.useCount&&(binding.restoreOriginalState(),this._takeBackBinding(binding))}this._takeBackAction(action)}}_initMemoryManager(){this._actions=[],this._nActiveActions=0,this._actionsByClip={},this._bindings=[],this._nActiveBindings=0,this._bindingsByRootAndName={},this._controlInterpolants=[],this._nActiveControlInterpolants=0;const scope=this;this.stats={actions:{get total(){return scope._actions.length},get inUse(){return scope._nActiveActions}},bindings:{get total(){return scope._bindings.length},get inUse(){return scope._nActiveBindings}},controlInterpolants:{get total(){return scope._controlInterpolants.length},get inUse(){return scope._nActiveControlInterpolants}}}}_isActiveAction(action){const index=action._cacheIndex;return null!==index&&index<this._nActiveActions}_addInactiveAction(action,clipUuid,rootUuid){const actions=this._actions,actionsByClip=this._actionsByClip;let actionsForClip=actionsByClip[clipUuid];if(void 0===actionsForClip)actionsForClip={knownActions:[action],actionByRoot:{}},action._byClipCacheIndex=0,actionsByClip[clipUuid]=actionsForClip;else{const knownActions=actionsForClip.knownActions;action._byClipCacheIndex=knownActions.length,knownActions.push(action)}action._cacheIndex=actions.length,actions.push(action),actionsForClip.actionByRoot[rootUuid]=action}_removeInactiveAction(action){const actions=this._actions,lastInactiveAction=actions[actions.length-1],cacheIndex=action._cacheIndex;lastInactiveAction._cacheIndex=cacheIndex,actions[cacheIndex]=lastInactiveAction,actions.pop(),action._cacheIndex=null;const clipUuid=action._clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid],knownActionsForClip=actionsForClip.knownActions,lastKnownAction=knownActionsForClip[knownActionsForClip.length-1],byClipCacheIndex=action._byClipCacheIndex;lastKnownAction._byClipCacheIndex=byClipCacheIndex,knownActionsForClip[byClipCacheIndex]=lastKnownAction,knownActionsForClip.pop(),action._byClipCacheIndex=null;delete actionsForClip.actionByRoot[(action._localRoot||this._root).uuid],0===knownActionsForClip.length&&delete actionsByClip[clipUuid],this._removeInactiveBindingsForAction(action)}_removeInactiveBindingsForAction(action){const bindings=action._propertyBindings;for(let i=0,n=bindings.length;i!==n;++i){const binding=bindings[i];0===--binding.referenceCount&&this._removeInactiveBinding(binding)}}_lendAction(action){const actions=this._actions,prevIndex=action._cacheIndex,lastActiveIndex=this._nActiveActions++,firstInactiveAction=actions[lastActiveIndex];action._cacheIndex=lastActiveIndex,actions[lastActiveIndex]=action,firstInactiveAction._cacheIndex=prevIndex,actions[prevIndex]=firstInactiveAction}_takeBackAction(action){const actions=this._actions,prevIndex=action._cacheIndex,firstInactiveIndex=--this._nActiveActions,lastActiveAction=actions[firstInactiveIndex];action._cacheIndex=firstInactiveIndex,actions[firstInactiveIndex]=action,lastActiveAction._cacheIndex=prevIndex,actions[prevIndex]=lastActiveAction}_addInactiveBinding(binding,rootUuid,trackName){const bindingsByRoot=this._bindingsByRootAndName,bindings=this._bindings;let bindingByName=bindingsByRoot[rootUuid];void 0===bindingByName&&(bindingByName={},bindingsByRoot[rootUuid]=bindingByName),bindingByName[trackName]=binding,binding._cacheIndex=bindings.length,bindings.push(binding)}_removeInactiveBinding(binding){const bindings=this._bindings,propBinding=binding.binding,rootUuid=propBinding.rootNode.uuid,trackName=propBinding.path,bindingsByRoot=this._bindingsByRootAndName,bindingByName=bindingsByRoot[rootUuid],lastInactiveBinding=bindings[bindings.length-1],cacheIndex=binding._cacheIndex;lastInactiveBinding._cacheIndex=cacheIndex,bindings[cacheIndex]=lastInactiveBinding,bindings.pop(),delete bindingByName[trackName],0===Object.keys(bindingByName).length&&delete bindingsByRoot[rootUuid]}_lendBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,lastActiveIndex=this._nActiveBindings++,firstInactiveBinding=bindings[lastActiveIndex];binding._cacheIndex=lastActiveIndex,bindings[lastActiveIndex]=binding,firstInactiveBinding._cacheIndex=prevIndex,bindings[prevIndex]=firstInactiveBinding}_takeBackBinding(binding){const bindings=this._bindings,prevIndex=binding._cacheIndex,firstInactiveIndex=--this._nActiveBindings,lastActiveBinding=bindings[firstInactiveIndex];binding._cacheIndex=firstInactiveIndex,bindings[firstInactiveIndex]=binding,lastActiveBinding._cacheIndex=prevIndex,bindings[prevIndex]=lastActiveBinding}_lendControlInterpolant(){const interpolants=this._controlInterpolants,lastActiveIndex=this._nActiveControlInterpolants++;let interpolant=interpolants[lastActiveIndex];return void 0===interpolant&&(interpolant=new LinearInterpolant(new Float32Array(2),new Float32Array(2),1,_controlInterpolantsResultBuffer),interpolant.__cacheIndex=lastActiveIndex,interpolants[lastActiveIndex]=interpolant),interpolant}_takeBackControlInterpolant(interpolant){const interpolants=this._controlInterpolants,prevIndex=interpolant.__cacheIndex,firstInactiveIndex=--this._nActiveControlInterpolants,lastActiveInterpolant=interpolants[firstInactiveIndex];interpolant.__cacheIndex=firstInactiveIndex,interpolants[firstInactiveIndex]=interpolant,lastActiveInterpolant.__cacheIndex=prevIndex,interpolants[prevIndex]=lastActiveInterpolant}clipAction(clip,optionalRoot,blendMode){const root=optionalRoot||this._root,rootUuid=root.uuid;let clipObject="string"==typeof clip?AnimationClip.findByName(root,clip):clip;const clipUuid=null!==clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];let prototypeAction=null;if(void 0===blendMode&&(blendMode=null!==clipObject?clipObject.blendMode:2500),void 0!==actionsForClip){const existingAction=actionsForClip.actionByRoot[rootUuid];if(void 0!==existingAction&&existingAction.blendMode===blendMode)return existingAction;prototypeAction=actionsForClip.knownActions[0],null===clipObject&&(clipObject=prototypeAction._clip)}if(null===clipObject)return null;const newAction=new AnimationAction(this,clipObject,optionalRoot,blendMode);return this._bindAction(newAction,prototypeAction),this._addInactiveAction(newAction,clipUuid,rootUuid),newAction}existingAction(clip,optionalRoot){const root=optionalRoot||this._root,rootUuid=root.uuid,clipObject="string"==typeof clip?AnimationClip.findByName(root,clip):clip,clipUuid=clipObject?clipObject.uuid:clip,actionsForClip=this._actionsByClip[clipUuid];return void 0!==actionsForClip&&actionsForClip.actionByRoot[rootUuid]||null}stopAllAction(){const actions=this._actions;for(let i=this._nActiveActions-1;i>=0;--i)actions[i].stop();return this}update(deltaTime){deltaTime*=this.timeScale;const actions=this._actions,nActions=this._nActiveActions,time=this.time+=deltaTime,timeDirection=Math.sign(deltaTime),accuIndex=this._accuIndex^=1;for(let i=0;i!==nActions;++i){actions[i]._update(time,deltaTime,timeDirection,accuIndex)}const bindings=this._bindings,nBindings=this._nActiveBindings;for(let i=0;i!==nBindings;++i)bindings[i].apply(accuIndex);return this}setTime(time){this.time=0;for(let i=0;i<this._actions.length;i++)this._actions[i].time=0;return this.update(time)}getRoot(){return this._root}uncacheClip(clip){const actions=this._actions,clipUuid=clip.uuid,actionsByClip=this._actionsByClip,actionsForClip=actionsByClip[clipUuid];if(void 0!==actionsForClip){const actionsToRemove=actionsForClip.knownActions;for(let i=0,n=actionsToRemove.length;i!==n;++i){const action=actionsToRemove[i];this._deactivateAction(action);const cacheIndex=action._cacheIndex,lastInactiveAction=actions[actions.length-1];action._cacheIndex=null,action._byClipCacheIndex=null,lastInactiveAction._cacheIndex=cacheIndex,actions[cacheIndex]=lastInactiveAction,actions.pop(),this._removeInactiveBindingsForAction(action)}delete actionsByClip[clipUuid]}}uncacheRoot(root){const rootUuid=root.uuid,actionsByClip=this._actionsByClip;for(const clipUuid in actionsByClip){const action=actionsByClip[clipUuid].actionByRoot[rootUuid];void 0!==action&&(this._deactivateAction(action),this._removeInactiveAction(action))}const bindingByName=this._bindingsByRootAndName[rootUuid];if(void 0!==bindingByName)for(const trackName in bindingByName){const binding=bindingByName[trackName];binding.restoreOriginalState(),this._removeInactiveBinding(binding)}}uncacheAction(clip,optionalRoot){const action=this.existingAction(clip,optionalRoot);null!==action&&(this._deactivateAction(action),this._removeInactiveAction(action))}}let _id$b=0,UniformsGroup$1=class UniformsGroup extends EventDispatcher{constructor(){super(),this.isUniformsGroup=!0,Object.defineProperty(this,"id",{value:_id$b++}),this.name="",this.usage=35044,this.uniforms=[]}add(uniform){return this.uniforms.push(uniform),this}remove(uniform){const index=this.uniforms.indexOf(uniform);return-1!==index&&this.uniforms.splice(index,1),this}setName(name){return this.name=name,this}setUsage(value){return this.usage=value,this}dispose(){this.dispatchEvent({type:"dispose"})}copy(source){this.name=source.name,this.usage=source.usage;const uniformsSource=source.uniforms;this.uniforms.length=0;for(let i=0,l=uniformsSource.length;i<l;i++){const uniforms=Array.isArray(uniformsSource[i])?uniformsSource[i]:[uniformsSource[i]];for(let j=0;j<uniforms.length;j++)this.uniforms.push(uniforms[j].clone())}return this}clone(){return(new this.constructor).copy(this)}};class InstancedInterleavedBuffer extends InterleavedBuffer{constructor(array,stride,meshPerAttribute=1){super(array,stride),this.isInstancedInterleavedBuffer=!0,this.meshPerAttribute=meshPerAttribute}copy(source){return super.copy(source),this.meshPerAttribute=source.meshPerAttribute,this}clone(data){const ib=super.clone(data);return ib.meshPerAttribute=this.meshPerAttribute,ib}toJSON(data){const json=super.toJSON(data);return json.isInstancedInterleavedBuffer=!0,json.meshPerAttribute=this.meshPerAttribute,json}}const _matrix=/*@__PURE__*/new Matrix4;class Raycaster{constructor(origin,direction,near=0,far=Infinity){this.ray=new Ray(origin,direction),this.near=near,this.far=far,this.camera=null,this.layers=new Layers,this.params={Mesh:{},Line:{threshold:1},LOD:{},Points:{threshold:1},Sprite:{}}}set(origin,direction){this.ray.set(origin,direction)}setFromCamera(coords,camera){camera.isPerspectiveCamera?(this.ray.origin.setFromMatrixPosition(camera.matrixWorld),this.ray.direction.set(coords.x,coords.y,.5).unproject(camera).sub(this.ray.origin).normalize(),this.camera=camera):camera.isOrthographicCamera?(this.ray.origin.set(coords.x,coords.y,(camera.near+camera.far)/(camera.near-camera.far)).unproject(camera),this.ray.direction.set(0,0,-1).transformDirection(camera.matrixWorld),this.camera=camera):error("Raycaster: Unsupported camera type: "+camera.type)}setFromXRController(controller){return _matrix.identity().extractRotation(controller.matrixWorld),this.ray.origin.setFromMatrixPosition(controller.matrixWorld),this.ray.direction.set(0,0,-1).applyMatrix4(_matrix),this}intersectObject(object,recursive=!0,intersects=[]){return intersect(object,this,intersects,recursive),intersects.sort(ascSort),intersects}intersectObjects(objects,recursive=!0,intersects=[]){for(let i=0,l=objects.length;i<l;i++)intersect(objects[i],this,intersects,recursive);return intersects.sort(ascSort),intersects}}function ascSort(a,b){return a.distance-b.distance}function intersect(object,raycaster,intersects,recursive){let propagate=!0;if(object.layers.test(raycaster.layers)){!1===object.raycast(raycaster,intersects)&&(propagate=!1)}if(!0===propagate&&!0===recursive){const children=object.children;for(let i=0,l=children.length;i<l;i++)intersect(children[i],raycaster,intersects,!0)}}class Timer{constructor(){this._previousTime=0,this._currentTime=0,this._startTime=performance.now(),this._delta=0,this._elapsed=0,this._timescale=1,this._document=null,this._pageVisibilityHandler=null}connect(document){this._document=document,void 0!==document.hidden&&(this._pageVisibilityHandler=handleVisibilityChange.bind(this),document.addEventListener("visibilitychange",this._pageVisibilityHandler,!1))}disconnect(){null!==this._pageVisibilityHandler&&(this._document.removeEventListener("visibilitychange",this._pageVisibilityHandler),this._pageVisibilityHandler=null),this._document=null}getDelta(){return this._delta/1e3}getElapsed(){return this._elapsed/1e3}getTimescale(){return this._timescale}setTimescale(timescale){return this._timescale=timescale,this}reset(){return this._currentTime=performance.now()-this._startTime,this}dispose(){this.disconnect()}update(timestamp){return null!==this._pageVisibilityHandler&&!0===this._document.hidden?this._delta=0:(this._previousTime=this._currentTime,this._currentTime=(void 0!==timestamp?timestamp:performance.now())-this._startTime,this._delta=(this._currentTime-this._previousTime)*this._timescale,this._elapsed+=this._delta),this}}function handleVisibilityChange(){!1===this._document.hidden&&this.reset()}class Spherical{constructor(radius=1,phi=0,theta=0){this.radius=radius,this.phi=phi,this.theta=theta}set(radius,phi,theta){return this.radius=radius,this.phi=phi,this.theta=theta,this}copy(other){return this.radius=other.radius,this.phi=other.phi,this.theta=other.theta,this}makeSafe(){return this.phi=clamp$3(this.phi,1e-6,Math.PI-1e-6),this}setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z)}setFromCartesianCoords(x,y,z){return this.radius=Math.sqrt(x*x+y*y+z*z),0===this.radius?(this.theta=0,this.phi=0):(this.theta=Math.atan2(x,z),this.phi=Math.acos(clamp$3(y/this.radius,-1,1))),this}clone(){return(new this.constructor).copy(this)}}class Matrix2{constructor(n11,n12,n21,n22){Matrix2.prototype.isMatrix2=!0,this.elements=[1,0,0,1],void 0!==n11&&this.set(n11,n12,n21,n22)}identity(){return this.set(1,0,0,1),this}fromArray(array,offset=0){for(let i=0;i<4;i++)this.elements[i]=array[i+offset];return this}set(n11,n12,n21,n22){const te=this.elements;return te[0]=n11,te[2]=n12,te[1]=n21,te[3]=n22,this}}const _vector$4=/*@__PURE__*/new Vector2;const _startP=/*@__PURE__*/new Vector3,_startEnd=/*@__PURE__*/new Vector3,_d1=/*@__PURE__*/new Vector3,_d2=/*@__PURE__*/new Vector3,_r=/*@__PURE__*/new Vector3,_c1=/*@__PURE__*/new Vector3,_c2=/*@__PURE__*/new Vector3;class Controls extends EventDispatcher{constructor(object,domElement=null){super(),this.object=object,this.domElement=domElement,this.enabled=!0,this.state=-1,this.keys={},this.mouseButtons={LEFT:null,MIDDLE:null,RIGHT:null},this.touches={ONE:null,TWO:null}}connect(element){void 0!==element?(null!==this.domElement&&this.disconnect(),this.domElement=element):warn("Controls: connect() now requires an element.")}disconnect(){}dispose(){}update(){}}function getByteLength(width,height,format,type){const typeByteLength=function getTextureTypeByteLength(type){switch(type){case 1009:case 1010:return{byteLength:1,components:1};case 1012:case 1011:case HalfFloatType:return{byteLength:2,components:1};case 1017:case 1018:return{byteLength:2,components:4};case 1014:case 1013:case 1015:return{byteLength:4,components:1};case 35902:case 35899:return{byteLength:4,components:3}}throw new Error(`Unknown texture type ${type}.`)}(type);switch(format){case 1021:return width*height;case 1028:case 1029:return width*height/typeByteLength.components*typeByteLength.byteLength;case 1030:case 1031:return width*height*2/typeByteLength.components*typeByteLength.byteLength;case 1022:return width*height*3/typeByteLength.components*typeByteLength.byteLength;case 1023:case 1033:return width*height*4/typeByteLength.components*typeByteLength.byteLength;case 33776:case 33777:case 36196:case 37492:case 37488:case 37489:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*8;case 33778:case 33779:case 37496:case 37490:case 37491:case 37808:return Math.floor((width+3)/4)*Math.floor((height+3)/4)*16;case 35841:case 35843:return Math.max(width,16)*Math.max(height,8)/4;case 35840:case 35842:return Math.max(width,8)*Math.max(height,8)/2;case 37809:return Math.floor((width+4)/5)*Math.floor((height+3)/4)*16;case 37810:return Math.floor((width+4)/5)*Math.floor((height+4)/5)*16;case 37811:return Math.floor((width+5)/6)*Math.floor((height+4)/5)*16;case 37812:return Math.floor((width+5)/6)*Math.floor((height+5)/6)*16;case 37813:return Math.floor((width+7)/8)*Math.floor((height+4)/5)*16;case 37814:return Math.floor((width+7)/8)*Math.floor((height+5)/6)*16;case 37815:return Math.floor((width+7)/8)*Math.floor((height+7)/8)*16;case 37816:return Math.floor((width+9)/10)*Math.floor((height+4)/5)*16;case 37817:return Math.floor((width+9)/10)*Math.floor((height+5)/6)*16;case 37818:return Math.floor((width+9)/10)*Math.floor((height+7)/8)*16;case 37819:return Math.floor((width+9)/10)*Math.floor((height+9)/10)*16;case 37820:return Math.floor((width+11)/12)*Math.floor((height+9)/10)*16;case 37821:return Math.floor((width+11)/12)*Math.floor((height+11)/12)*16;case 36492:case 36494:case 36495:case 36285:case 36286:return Math.ceil(width/4)*Math.ceil(height/4)*16;case 36283:case 36284:return Math.ceil(width/4)*Math.ceil(height/4)*8}throw new Error(`Unable to determine texture byte length for ${format} format.`)}"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{detail:{revision:"183dev"}})),"undefined"!=typeof window&&(window.__THREE__?warn("WARNING: Multiple instances of Three.js being imported."):window.__THREE__="183dev")
/**
 * @license
 * Copyright 2010-2026 Three.js Authors
 * SPDX-License-Identifier: MIT
 */;const refreshUniforms=["alphaMap","alphaTest","anisotropy","anisotropyMap","anisotropyRotation","aoMap","aoMapIntensity","attenuationColor","attenuationDistance","bumpMap","clearcoat","clearcoatMap","clearcoatNormalMap","clearcoatNormalScale","clearcoatRoughness","color","dispersion","displacementMap","emissive","emissiveIntensity","emissiveMap","envMap","envMapIntensity","gradientMap","ior","iridescence","iridescenceIOR","iridescenceMap","iridescenceThicknessMap","lightMap","lightMapIntensity","map","matcap","metalness","metalnessMap","normalMap","normalScale","opacity","roughness","roughnessMap","sheen","sheenColor","sheenColorMap","sheenRoughnessMap","shininess","specular","specularColor","specularColorMap","specularIntensity","specularIntensityMap","specularMap","thickness","transmission","transmissionMap"],_lightsCache=new WeakMap;class NodeMaterialObserver{constructor(builder){this.renderObjects=new WeakMap,this.hasNode=this.containsNode(builder),this.hasAnimation=!0===builder.object.isSkinnedMesh,this.refreshUniforms=refreshUniforms,this.renderId=0}firstInitialization(renderObject){return!1===this.renderObjects.has(renderObject)&&(this.getRenderObjectData(renderObject),!0)}needsVelocity(renderer){const mrt=renderer.getMRT();return null!==mrt&&mrt.has("velocity")}getRenderObjectData(renderObject){let data=this.renderObjects.get(renderObject);if(void 0===data){const{geometry:geometry,material:material,object:object}=renderObject;if(data={material:this.getMaterialData(material),geometry:{id:geometry.id,attributes:this.getAttributesData(geometry.attributes),indexId:geometry.index?geometry.index.id:null,indexVersion:geometry.index?geometry.index.version:null,drawRange:{start:geometry.drawRange.start,count:geometry.drawRange.count}},worldMatrix:object.matrixWorld.clone()},object.center&&(data.center=object.center.clone()),object.morphTargetInfluences&&(data.morphTargetInfluences=object.morphTargetInfluences.slice()),null!==renderObject.bundle&&(data.version=renderObject.bundle.version),data.material.transmission>0){const{width:width,height:height}=renderObject.context;data.bufferWidth=width,data.bufferHeight=height}data.lights=this.getLightsData(renderObject.lightsNode.getLights()),this.renderObjects.set(renderObject,data)}return data}getAttributesData(attributes){const attributesData={};for(const name in attributes){const attribute=attributes[name];attributesData[name]={id:attribute.id,version:attribute.version}}return attributesData}containsNode(builder){const material=builder.material;for(const property in material)if(material[property]&&material[property].isNode)return!0;return!!(builder.context.modelViewMatrix||builder.context.modelNormalViewMatrix||builder.context.getAO||builder.context.getShadow)}getMaterialData(material){const data={};for(const property of this.refreshUniforms){const value=material[property];null!=value&&("object"==typeof value&&void 0!==value.clone?!0===value.isTexture?data[property]={id:value.id,version:value.version}:data[property]=value.clone():data[property]=value)}return data}equals(renderObject,lightsData){const{object:object,material:material,geometry:geometry}=renderObject,renderObjectData=this.getRenderObjectData(renderObject);if(!0!==renderObjectData.worldMatrix.equals(object.matrixWorld))return renderObjectData.worldMatrix.copy(object.matrixWorld),!1;const materialData=renderObjectData.material;for(const property in materialData){const value=materialData[property],mtlValue=material[property];if(void 0!==value.equals){if(!1===value.equals(mtlValue))return value.copy(mtlValue),!1}else if(!0===mtlValue.isTexture){if(value.id!==mtlValue.id||value.version!==mtlValue.version)return value.id=mtlValue.id,value.version=mtlValue.version,!1}else if(value!==mtlValue)return materialData[property]=mtlValue,!1}if(materialData.transmission>0){const{width:width,height:height}=renderObject.context;if(renderObjectData.bufferWidth!==width||renderObjectData.bufferHeight!==height)return renderObjectData.bufferWidth=width,renderObjectData.bufferHeight=height,!1}const storedGeometryData=renderObjectData.geometry,attributes=geometry.attributes,storedAttributes=storedGeometryData.attributes,storedAttributeNames=Object.keys(storedAttributes),currentAttributeNames=Object.keys(attributes);if(storedGeometryData.id!==geometry.id)return storedGeometryData.id=geometry.id,!1;if(storedAttributeNames.length!==currentAttributeNames.length)return renderObjectData.geometry.attributes=this.getAttributesData(attributes),!1;for(const name of storedAttributeNames){const storedAttributeData=storedAttributes[name],attribute=attributes[name];if(void 0===attribute)return delete storedAttributes[name],!1;if(storedAttributeData.id!==attribute.id||storedAttributeData.version!==attribute.version)return storedAttributeData.id=attribute.id,storedAttributeData.version=attribute.version,!1}const index=geometry.index,storedIndexId=storedGeometryData.id,storedIndexVersion=storedGeometryData.indexVersion,currentIndexId=index?index.id:null,currentIndexVersion=index?index.version:null;if(storedIndexId!==currentIndexId||storedIndexVersion!==currentIndexVersion)return storedGeometryData.id=currentIndexId,storedGeometryData.indexVersion=currentIndexVersion,!1;if(storedGeometryData.drawRange.start!==geometry.drawRange.start||storedGeometryData.drawRange.count!==geometry.drawRange.count)return storedGeometryData.drawRange.start=geometry.drawRange.start,storedGeometryData.drawRange.count=geometry.drawRange.count,!1;if(renderObjectData.morphTargetInfluences){let morphChanged=!1;for(let i=0;i<renderObjectData.morphTargetInfluences.length;i++)renderObjectData.morphTargetInfluences[i]!==object.morphTargetInfluences[i]&&(renderObjectData.morphTargetInfluences[i]=object.morphTargetInfluences[i],morphChanged=!0);if(morphChanged)return!1}if(renderObjectData.lights)for(let i=0;i<lightsData.length;i++)if(renderObjectData.lights[i].map!==lightsData[i].map)return!1;return renderObjectData.center&&!1===renderObjectData.center.equals(object.center)?(renderObjectData.center.copy(object.center),!0):(null!==renderObject.bundle&&(renderObjectData.version=renderObject.bundle.version),!0)}getLightsData(materialLights){const lights=[];for(const light of materialLights)!0===light.isSpotLight&&null!==light.map&&lights.push({map:light.map.version});return lights}getLights(lightsNode,renderId){if(_lightsCache.has(lightsNode)){const cached=_lightsCache.get(lightsNode);if(cached.renderId===renderId)return cached.lightsData}const lightsData=this.getLightsData(lightsNode.getLights());return _lightsCache.set(lightsNode,{renderId:renderId,lightsData:lightsData}),lightsData}needsRefresh(renderObject,nodeFrame){if(this.hasNode||this.hasAnimation||this.firstInitialization(renderObject)||this.needsVelocity(nodeFrame.renderer))return!0;const{renderId:renderId}=nodeFrame;if(this.renderId!==renderId)return this.renderId=renderId,!0;const isStatic=!0===renderObject.object.static,isBundle=null!==renderObject.bundle&&!0===renderObject.bundle.static&&this.getRenderObjectData(renderObject).version===renderObject.bundle.version;if(isStatic||isBundle)return!1;const lightsData=this.getLights(renderObject.lightsNode,renderId);return!0!==this.equals(renderObject,lightsData)}}const IGNORED_FILES=[/^StackTrace\.js$/,/^TSLCore\.js$/,/^.*Node\.js$/,/^three\.webgpu.*\.js$/];class StackTrace{constructor(stackMessage=null){this.isStackTrace=!0,this.stack=function getFilteredStack(stack){const regex=/(?:at\s+(.+?)\s+\()?(?:(.+?)@)?([^@\s()]+):(\d+):(\d+)/;return stack.split("\n").map(line=>{const match=line.match(regex);if(!match)return null;const fn=match[1]||match[2]||"",file=match[3].split("?")[0],lineNum=parseInt(match[4],10),column=parseInt(match[5],10);return{fn:fn,file:file.split("/").pop(),line:lineNum,column:column}}).filter(frame=>frame&&!IGNORED_FILES.some(regex=>regex.test(frame.file)))}(stackMessage||(new Error).stack)}getLocation(){if(0===this.stack.length)return"[Unknown location]";const mainStack=this.stack[0],fn=mainStack.fn;return`${fn?`"${fn}()" at `:""}"${mainStack.file}:${mainStack.line}"`}getError(message){if(0===this.stack.length)return message;return`${message}\n${this.stack.map(frame=>{const location=`${frame.file}:${frame.line}:${frame.column}`;return frame.fn?`    at ${frame.fn} (${location})`:`    at ${location}`}).join("\n")}`}}function cyrb53(value,seed=0){let h1=3735928559^seed,h2=1103547991^seed;if(value instanceof Array)for(let val,i=0;i<value.length;i++)val=value[i],h1=Math.imul(h1^val,2654435761),h2=Math.imul(h2^val,1597334677);else for(let ch,i=0;i<value.length;i++)ch=value.charCodeAt(i),h1=Math.imul(h1^ch,2654435761),h2=Math.imul(h2^ch,1597334677);return h1=Math.imul(h1^h1>>>16,2246822507),h1^=Math.imul(h2^h2>>>13,3266489909),h2=Math.imul(h2^h2>>>16,2246822507),h2^=Math.imul(h1^h1>>>13,3266489909),4294967296*(2097151&h2)+(h1>>>0)}const hashString=str=>cyrb53(str),hashArray=array=>cyrb53(array),hash$1=(...params)=>cyrb53(params),typeFromLength=/*@__PURE__*/new Map([[1,"float"],[2,"vec2"],[3,"vec3"],[4,"vec4"],[9,"mat3"],[16,"mat4"]]),dataFromObject=/*@__PURE__*/new WeakMap;function getTypeFromLength(length){return typeFromLength.get(length)}function getValueType(value){if(null==value)return null;const typeOf=typeof value;return!0===value.isNode?"node":"number"===typeOf?"float":"boolean"===typeOf?"bool":"string"===typeOf?"string":"function"===typeOf?"shader":!0===value.isVector2?"vec2":!0===value.isVector3?"vec3":!0===value.isVector4?"vec4":!0===value.isMatrix2?"mat2":!0===value.isMatrix3?"mat3":!0===value.isMatrix4?"mat4":!0===value.isColor?"color":value instanceof ArrayBuffer?"ArrayBuffer":null}function getValueFromType(type,...params){const last4=type?type.slice(-4):void 0;return 1===params.length&&("vec2"===last4?params=[params[0],params[0]]:"vec3"===last4?params=[params[0],params[0],params[0]]:"vec4"===last4&&(params=[params[0],params[0],params[0],params[0]])),"color"===type?new Color(...params):"vec2"===last4?new Vector2(...params):"vec3"===last4?new Vector3(...params):"vec4"===last4?new Vector4(...params):"mat2"===last4?new Matrix2(...params):"mat3"===last4?new Matrix3(...params):"mat4"===last4?new Matrix4(...params):"bool"===type?params[0]||!1:"float"===type||"int"===type||"uint"===type?params[0]||0:"string"===type?params[0]||"":"ArrayBuffer"===type?function base64ToArrayBuffer(base64){return Uint8Array.from(atob(base64),c=>c.charCodeAt(0)).buffer}(params[0]):null}function getDataFromObject(object){let data=dataFromObject.get(object);return void 0===data&&(data={},dataFromObject.set(object,data)),data}const NodeShaderStage_VERTEX="vertex",NodeUpdateType_NONE="none",NodeUpdateType_FRAME="frame",NodeUpdateType_RENDER="render",NodeUpdateType_OBJECT="object",NodeAccess_READ_ONLY="readOnly",NodeAccess_WRITE_ONLY="writeOnly",NodeAccess_READ_WRITE="readWrite",defaultBuildStages=["setup","analyze","generate"],shaderStages=["fragment","vertex","compute"],vectorComponents=["x","y","z","w"],_parentBuildStage={analyze:"setup",generate:"analyze"};let _nodeId=0,Node$1=class Node extends EventDispatcher{static get type(){return"Node"}constructor(nodeType=null){super(),this.nodeType=nodeType,this.updateType=NodeUpdateType_NONE,this.updateBeforeType=NodeUpdateType_NONE,this.updateAfterType=NodeUpdateType_NONE,this.uuid=MathUtils.generateUUID(),this.version=0,this.name="",this.global=!1,this.parents=!1,this.isNode=!0,this._beforeNodes=null,this._cacheKey=null,this._cacheKeyVersion=0,Object.defineProperty(this,"id",{value:_nodeId++}),this.stackTrace=null,!0===Node.captureStackTrace&&(this.stackTrace=new StackTrace)}set needsUpdate(value){!0===value&&this.version++}get type(){return this.constructor.type}onUpdate(callback,updateType){return this.updateType=updateType,this.update=callback.bind(this),this}onFrameUpdate(callback){return this.onUpdate(callback,NodeUpdateType_FRAME)}onRenderUpdate(callback){return this.onUpdate(callback,NodeUpdateType_RENDER)}onObjectUpdate(callback){return this.onUpdate(callback,NodeUpdateType_OBJECT)}onReference(callback){return this.updateReference=callback.bind(this),this}updateReference(){return this}isGlobal(){return this.global}*getChildren(){for(const{childNode:childNode}of this._getChildren())yield childNode}dispose(){this.dispatchEvent({type:"dispose"})}traverse(callback){callback(this);for(const childNode of this.getChildren())childNode.traverse(callback)}_getChildren(ignores=new Set){const children=[];ignores.add(this);for(const property of Object.getOwnPropertyNames(this)){const object=this[property];if(!0!==property.startsWith("_")&&!ignores.has(object))if(!0===Array.isArray(object))for(let i=0;i<object.length;i++){const child=object[i];child&&!0===child.isNode&&children.push({property:property,index:i,childNode:child})}else if(object&&!0===object.isNode)children.push({property:property,childNode:object});else if(object&&Object.getPrototypeOf(object)===Object.prototype)for(const subProperty in object){if(!0===subProperty.startsWith("_"))continue;const child=object[subProperty];child&&!0===child.isNode&&children.push({property:property,index:subProperty,childNode:child})}}return children}getCacheKey(force=!1,ignores=null){if(!0===(force=force||this.version!==this._cacheKeyVersion)||null===this._cacheKey){null===ignores&&(ignores=new Set);const values=[];for(const{property:property,childNode:childNode}of this._getChildren(ignores))values.push(hashString(property.slice(0,-4)),childNode.getCacheKey(force,ignores));this._cacheKey=hash$1(hashArray(values),this.customCacheKey()),this._cacheKeyVersion=this.version}return this._cacheKey}customCacheKey(){return this.id}getScope(){return this}getHash(){return this.uuid}getUpdateType(){return this.updateType}getUpdateBeforeType(){return this.updateBeforeType}getUpdateAfterType(){return this.updateAfterType}getElementType(builder){const type=this.getNodeType(builder);return builder.getElementType(type)}getMemberType(){return"void"}getNodeType(builder){const nodeProperties=builder.getNodeProperties(this);return nodeProperties.outputNode?nodeProperties.outputNode.getNodeType(builder):this.nodeType}getShared(builder){const hash=this.getHash(builder);return builder.getNodeFromHash(hash)||this}getArrayCount(){return null}setup(builder){const nodeProperties=builder.getNodeProperties(this);let index=0;for(const childNode of this.getChildren())nodeProperties["node"+index++]=childNode;return nodeProperties.outputNode||null}analyze(builder,output=null){const usageCount=builder.increaseUsage(this);if(!0===this.parents){const nodeData=builder.getDataFromNode(this,"any");nodeData.stages=nodeData.stages||{},nodeData.stages[builder.shaderStage]=nodeData.stages[builder.shaderStage]||[],nodeData.stages[builder.shaderStage].push(output)}if(1===usageCount){const nodeProperties=builder.getNodeProperties(this);for(const childNode of Object.values(nodeProperties))childNode&&!0===childNode.isNode&&childNode.build(builder,this)}}generate(builder,output){const{outputNode:outputNode}=builder.getNodeProperties(this);if(outputNode&&!0===outputNode.isNode)return outputNode.build(builder,output)}updateBefore(){warn("Abstract function.")}updateAfter(){warn("Abstract function.")}update(){warn("Abstract function.")}before(node){return null===this._beforeNodes&&(this._beforeNodes=[]),this._beforeNodes.push(node),this}build(builder,output=null){const refNode=this.getShared(builder);if(this!==refNode)return refNode.build(builder,output);if(null!==this._beforeNodes){const currentBeforeNodes=this._beforeNodes;this._beforeNodes=null;for(const beforeNode of currentBeforeNodes)beforeNode.build(builder,output);this._beforeNodes=currentBeforeNodes}const nodeData=builder.getDataFromNode(this);nodeData.buildStages=nodeData.buildStages||{},nodeData.buildStages[builder.buildStage]=!0;const parentBuildStage=_parentBuildStage[builder.buildStage];if(parentBuildStage&&!0!==nodeData.buildStages[parentBuildStage]){const previousBuildStage=builder.getBuildStage();builder.setBuildStage(parentBuildStage),this.build(builder),builder.setBuildStage(previousBuildStage)}builder.addNode(this),builder.addChain(this);let result=null;const buildStage=builder.getBuildStage();if("setup"===buildStage){this.updateReference(builder);const properties=builder.getNodeProperties(this);if(!0!==properties.initialized){properties.initialized=!0,properties.outputNode=this.setup(builder)||properties.outputNode||null;for(const childNode of Object.values(properties))if(childNode&&!0===childNode.isNode){if(!0===childNode.parents){const childProperties=builder.getNodeProperties(childNode);childProperties.parents=childProperties.parents||[],childProperties.parents.push(this)}childNode.build(builder)}}result=properties.outputNode}else if("analyze"===buildStage)this.analyze(builder,output);else if("generate"===buildStage){if(this.generate.length<2){const type=this.getNodeType(builder),nodeData=builder.getDataFromNode(this);result=nodeData.snippet,void 0===result?void 0===nodeData.generated?(nodeData.generated=!0,result=this.generate(builder)||"",nodeData.snippet=result):(warn("Node: Recursion detected.",this),result="/* Recursion detected. */"):void 0!==nodeData.flowCodes&&void 0!==builder.context.nodeBlock&&builder.addFlowCodeHierarchy(this,builder.context.nodeBlock),result=builder.format(result,type,output)}else result=this.generate(builder,output)||"";""===result&&null!==output&&"void"!==output&&"OutputType"!==output&&(error(`TSL: Invalid generated code, expected a "${output}".`),result=builder.generateConst(output))}return builder.removeChain(this),builder.addSequentialNode(this),result}getSerializeChildren(){return this._getChildren()}serialize(json){const nodeChildren=this.getSerializeChildren(),inputNodes={};for(const{property:property,index:index,childNode:childNode}of nodeChildren)void 0!==index?(void 0===inputNodes[property]&&(inputNodes[property]=Number.isInteger(index)?[]:{}),inputNodes[property][index]=childNode.toJSON(json.meta).uuid):inputNodes[property]=childNode.toJSON(json.meta).uuid;Object.keys(inputNodes).length>0&&(json.inputNodes=inputNodes)}deserialize(json){if(void 0!==json.inputNodes){const nodes=json.meta.nodes;for(const property in json.inputNodes)if(Array.isArray(json.inputNodes[property])){const inputArray=[];for(const uuid of json.inputNodes[property])inputArray.push(nodes[uuid]);this[property]=inputArray}else if("object"==typeof json.inputNodes[property]){const inputObject={};for(const subProperty in json.inputNodes[property]){const uuid=json.inputNodes[property][subProperty];inputObject[subProperty]=nodes[uuid]}this[property]=inputObject}else{const uuid=json.inputNodes[property];this[property]=nodes[uuid]}}}toJSON(meta){const{uuid:uuid,type:type}=this,isRoot=void 0===meta||"string"==typeof meta;isRoot&&(meta={textures:{},images:{},nodes:{}});let data=meta.nodes[uuid];function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata,values.push(data)}return values}if(void 0===data&&(data={uuid:uuid,type:type,meta:meta,metadata:{version:4.7,type:"Node",generator:"Node.toJSON"}},!0!==isRoot&&(meta.nodes[data.uuid]=data),this.serialize(data),delete data.meta),isRoot){const textures=extractFromCache(meta.textures),images=extractFromCache(meta.images),nodes=extractFromCache(meta.nodes);textures.length>0&&(data.textures=textures),images.length>0&&(data.images=images),nodes.length>0&&(data.nodes=nodes)}return data}};Node$1.captureStackTrace=!1;class ArrayElementNode extends Node$1{static get type(){return"ArrayElementNode"}constructor(node,indexNode){super(),this.node=node,this.indexNode=indexNode,this.isArrayElementNode=!0}getNodeType(builder){return this.node.getElementType(builder)}getMemberType(builder,name){return this.node.getMemberType(builder,name)}generate(builder){const indexType=this.indexNode.getNodeType(builder);return`${this.node.build(builder)}[ ${this.indexNode.build(builder,!builder.isVector(indexType)&&builder.isInteger(indexType)?indexType:"uint")} ]`}}class ConvertNode extends Node$1{static get type(){return"ConvertNode"}constructor(node,convertTo){super(),this.node=node,this.convertTo=convertTo}getNodeType(builder){const requestType=this.node.getNodeType(builder);let convertTo=null;for(const overloadingType of this.convertTo.split("|"))null!==convertTo&&builder.getTypeLength(requestType)!==builder.getTypeLength(overloadingType)||(convertTo=overloadingType);return convertTo}serialize(data){super.serialize(data),data.convertTo=this.convertTo}deserialize(data){super.deserialize(data),this.convertTo=data.convertTo}generate(builder,output){const node=this.node,type=this.getNodeType(builder),snippet=node.build(builder,type);return builder.format(snippet,type,output)}}class TempNode extends Node$1{static get type(){return"TempNode"}constructor(nodeType=null){super(nodeType),this.isTempNode=!0}hasDependencies(builder){return builder.getDataFromNode(this).usageCount>1}build(builder,output){if("generate"===builder.getBuildStage()){const type=builder.getVectorType(this.getNodeType(builder,output)),nodeData=builder.getDataFromNode(this);if(void 0!==nodeData.propertyName)return builder.format(nodeData.propertyName,type,output);if("void"!==type&&"void"!==output&&this.hasDependencies(builder)){const snippet=super.build(builder,type),nodeVar=builder.getVarFromNode(this,null,type),propertyName=builder.getPropertyName(nodeVar);return builder.addLineFlowCode(`${propertyName} = ${snippet}`,this),nodeData.snippet=snippet,nodeData.propertyName=propertyName,builder.format(nodeData.propertyName,type,output)}}return super.build(builder,output)}}class JoinNode extends TempNode{static get type(){return"JoinNode"}constructor(nodes=[],nodeType=null){super(nodeType),this.nodes=nodes}getNodeType(builder){return null!==this.nodeType?builder.getVectorType(this.nodeType):builder.getTypeFromLength(this.nodes.reduce((count,cur)=>count+builder.getTypeLength(cur.getNodeType(builder)),0))}generate(builder,output){const type=this.getNodeType(builder),maxLength=builder.getTypeLength(type),nodes=this.nodes,primitiveType=builder.getComponentType(type),snippetValues=[];let length=0;for(const input of nodes){if(length>=maxLength){error(`TSL: Length of parameters exceeds maximum length of function '${type}()' type.`,this.stackTrace);break}let inputSnippet,inputType=input.getNodeType(builder),inputTypeLength=builder.getTypeLength(inputType);length+inputTypeLength>maxLength&&(error(`TSL: Length of '${type}()' data exceeds maximum length of output type.`,this.stackTrace),inputTypeLength=maxLength-length,inputType=builder.getTypeFromLength(inputTypeLength)),length+=inputTypeLength,inputSnippet=input.build(builder,inputType);if(builder.getComponentType(inputType)!==primitiveType){const targetType=builder.getTypeFromLength(inputTypeLength,primitiveType);inputSnippet=builder.format(inputSnippet,inputType,targetType)}snippetValues.push(inputSnippet)}const snippet=`${builder.getType(type)}( ${snippetValues.join(", ")} )`;return builder.format(snippet,type,output)}}const _stringVectorComponents=vectorComponents.join("");class SplitNode extends Node$1{static get type(){return"SplitNode"}constructor(node,components="x"){super(),this.node=node,this.components=components,this.isSplitNode=!0}getVectorLength(){let vectorLength=this.components.length;for(const c of this.components)vectorLength=Math.max(vectorComponents.indexOf(c)+1,vectorLength);return vectorLength}getComponentType(builder){return builder.getComponentType(this.node.getNodeType(builder))}getNodeType(builder){return builder.getTypeFromLength(this.components.length,this.getComponentType(builder))}getScope(){return this.node.getScope()}generate(builder,output){const node=this.node,nodeTypeLength=builder.getTypeLength(node.getNodeType(builder));let snippet=null;if(nodeTypeLength>1){let type=null;this.getVectorLength()>=nodeTypeLength&&(type=builder.getTypeFromLength(this.getVectorLength(),this.getComponentType(builder)));const nodeSnippet=node.build(builder,type);snippet=this.components.length===nodeTypeLength&&this.components===_stringVectorComponents.slice(0,this.components.length)?builder.format(nodeSnippet,type,output):builder.format(`${nodeSnippet}.${this.components}`,this.getNodeType(builder),output)}else snippet=node.build(builder,output);return snippet}serialize(data){super.serialize(data),data.components=this.components}deserialize(data){super.deserialize(data),this.components=data.components}}class SetNode extends TempNode{static get type(){return"SetNode"}constructor(sourceNode,components,targetNode){super(),this.sourceNode=sourceNode,this.components=components,this.targetNode=targetNode}getNodeType(builder){return this.sourceNode.getNodeType(builder)}generate(builder){const{sourceNode:sourceNode,components:components,targetNode:targetNode}=this,sourceType=this.getNodeType(builder),componentType=builder.getComponentType(targetNode.getNodeType(builder)),targetType=builder.getTypeFromLength(components.length,componentType),targetSnippet=targetNode.build(builder,targetType),sourceSnippet=sourceNode.build(builder,sourceType),length=builder.getTypeLength(sourceType),snippetValues=[];for(let i=0;i<length;i++){const component=vectorComponents[i];component===components[0]?(snippetValues.push(targetSnippet),i+=components.length-1):snippetValues.push(sourceSnippet+"."+component)}return`${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`}}class FlipNode extends TempNode{static get type(){return"FlipNode"}constructor(sourceNode,components){super(),this.sourceNode=sourceNode,this.components=components}getNodeType(builder){return this.sourceNode.getNodeType(builder)}generate(builder){const{components:components,sourceNode:sourceNode}=this,sourceType=this.getNodeType(builder),sourceSnippet=sourceNode.build(builder),sourceCache=builder.getVarFromNode(this),sourceProperty=builder.getPropertyName(sourceCache);builder.addLineFlowCode(sourceProperty+" = "+sourceSnippet,this);const length=builder.getTypeLength(sourceType),snippetValues=[];let componentIndex=0;for(let i=0;i<length;i++){const component=vectorComponents[i];component===components[componentIndex]?(snippetValues.push("1.0 - "+sourceProperty+"."+component),componentIndex++):snippetValues.push(sourceProperty+"."+component)}return`${builder.getType(sourceType)}( ${snippetValues.join(", ")} )`}}class InputNode extends Node$1{static get type(){return"InputNode"}constructor(value,nodeType=null){super(nodeType),this.isInputNode=!0,this.value=value,this.precision=null}getNodeType(){return null===this.nodeType?getValueType(this.value):this.nodeType}getInputType(builder){return this.getNodeType(builder)}setPrecision(precision){return this.precision=precision,this}serialize(data){super.serialize(data),data.value=this.value,this.value&&this.value.toArray&&(data.value=this.value.toArray()),data.valueType=getValueType(this.value),data.nodeType=this.nodeType,"ArrayBuffer"===data.valueType&&(data.value=function arrayBufferToBase64(arrayBuffer){let chars="";const array=new Uint8Array(arrayBuffer);for(let i=0;i<array.length;i++)chars+=String.fromCharCode(array[i]);return btoa(chars)}(data.value)),data.precision=this.precision}deserialize(data){super.deserialize(data),this.nodeType=data.nodeType,this.value=Array.isArray(data.value)?getValueFromType(data.valueType,...data.value):data.value,this.precision=data.precision||null,this.value&&this.value.fromArray&&(this.value=this.value.fromArray(data.value))}generate(){warn("Abstract function.")}}const _regNum=/float|u?int/;class ConstNode extends InputNode{static get type(){return"ConstNode"}constructor(value,nodeType=null){super(value,nodeType),this.isConstNode=!0}generateConst(builder){return builder.generateConst(this.getNodeType(builder),this.value)}generate(builder,output){const type=this.getNodeType(builder);return _regNum.test(type)&&_regNum.test(output)?builder.generateConst(output,this.value):builder.format(this.generateConst(builder),type,output)}}class MemberNode extends Node$1{static get type(){return"MemberNode"}constructor(structNode,property){super(),this.structNode=structNode,this.property=property,this.isMemberNode=!0}hasMember(builder){return(!this.structNode.isMemberNode||!1!==this.structNode.hasMember(builder))&&"void"!==this.structNode.getMemberType(builder,this.property)}getNodeType(builder){return!1===this.hasMember(builder)?"float":this.structNode.getMemberType(builder,this.property)}getMemberType(builder,name){if(!1===this.hasMember(builder))return"float";const type=this.getNodeType(builder);return builder.getStructTypeNode(type).getMemberType(builder,name)}generate(builder){if(!1===this.hasMember(builder)){warn(`TSL: Member "${this.property}" does not exist in struct.`,this.stackTrace);const type=this.getNodeType(builder);return builder.generateConst(type)}return this.structNode.build(builder)+"."+this.property}}let currentStack=null;const NodeElements=new Map;function addMethodChaining(name,nodeElement){if(NodeElements.has(name))warn(`TSL: Redefinition of method chaining '${name}'.`);else{if("function"!=typeof nodeElement)throw new Error(`THREE.TSL: Node element ${name} is not a function`);NodeElements.set(name,nodeElement),"assign"!==name&&(Node$1.prototype[name]=function(...params){return this.isStackNode?this.addToStack(nodeElement(...params)):nodeElement(this,...params)},Node$1.prototype[name+"Assign"]=function(...params){return this.isStackNode?this.assign(params[0],nodeElement(...params)):this.assign(nodeElement(this,...params))})}}const parseSwizzleAndSort=props=>(props=>props.replace(/r|s/g,"x").replace(/g|t/g,"y").replace(/b|p/g,"z").replace(/a|q/g,"w"))(props).split("").sort().join("");Node$1.prototype.assign=function(...params){if(!0!==this.isStackNode)return null!==currentStack?currentStack.assign(this,...params):error("TSL: No stack defined for assign operation. Make sure the assign is inside a Fn().",new StackTrace),this;{const nodeElement=NodeElements.get("assign");return this.addToStack(nodeElement(...params))}},Node$1.prototype.toVarIntent=function(){return this},Node$1.prototype.get=function(value){return new MemberNode(this,value)};const proto={};function setProtoSwizzle(property,altA,altB){proto[property]=proto[altA]=proto[altB]={get(){this._cache=this._cache||{};let split=this._cache[property];return void 0===split&&(split=new SplitNode(this,property),this._cache[property]=split),split},set(value){this[property].assign(nodeObject(value))}};const propUpper=property.toUpperCase(),altAUpper=altA.toUpperCase(),altBUpper=altB.toUpperCase();Node$1.prototype["set"+propUpper]=Node$1.prototype["set"+altAUpper]=Node$1.prototype["set"+altBUpper]=function(value){const swizzle=parseSwizzleAndSort(property);return new SetNode(this,swizzle,nodeObject(value))},Node$1.prototype["flip"+propUpper]=Node$1.prototype["flip"+altAUpper]=Node$1.prototype["flip"+altBUpper]=function(){const swizzle=parseSwizzleAndSort(property);return new FlipNode(this,swizzle)}}const swizzleA=["x","y","z","w"],swizzleB=["r","g","b","a"],swizzleC=["s","t","p","q"];for(let a=0;a<4;a++){let prop=swizzleA[a],altA=swizzleB[a],altB=swizzleC[a];setProtoSwizzle(prop,altA,altB);for(let b=0;b<4;b++){prop=swizzleA[a]+swizzleA[b],altA=swizzleB[a]+swizzleB[b],altB=swizzleC[a]+swizzleC[b],setProtoSwizzle(prop,altA,altB);for(let c=0;c<4;c++){prop=swizzleA[a]+swizzleA[b]+swizzleA[c],altA=swizzleB[a]+swizzleB[b]+swizzleB[c],altB=swizzleC[a]+swizzleC[b]+swizzleC[c],setProtoSwizzle(prop,altA,altB);for(let d=0;d<4;d++)prop=swizzleA[a]+swizzleA[b]+swizzleA[c]+swizzleA[d],altA=swizzleB[a]+swizzleB[b]+swizzleB[c]+swizzleB[d],altB=swizzleC[a]+swizzleC[b]+swizzleC[c]+swizzleC[d],setProtoSwizzle(prop,altA,altB)}}}for(let i=0;i<32;i++)proto[i]={get(){this._cache=this._cache||{};let element=this._cache[i];return void 0===element&&(element=new ArrayElementNode(this,new ConstNode(i,"uint")),this._cache[i]=element),element},set(value){this[i].assign(nodeObject(value))}};Object.defineProperties(Node$1.prototype,proto);const nodeBuilderFunctionsCacheMap=new WeakMap,ShaderNodeObjects=function(objects,altType=null){for(const name in objects)objects[name]=nodeObject(objects[name],altType);return objects},ShaderNodeArray=function(array,altType=null){const len=array.length;for(let i=0;i<len;i++)array[i]=nodeObject(array[i],altType);return array},ShaderNodeProxy=function(NodeClass,scope=null,factor=null,settings=null){function assignNode(node){return null!==settings?(node=nodeObject(Object.assign(node,settings)),!0===settings.intent&&(node=node.toVarIntent())):node=nodeObject(node),node}let fn,minParams,maxParams,name=scope;function verifyParamsLimit(params){let tslName;return tslName=name?/[a-z]/i.test(name)?name+"()":name:NodeClass.type,void 0!==minParams&&params.length<minParams?(error(`TSL: "${tslName}" parameter length is less than minimum required.`,new StackTrace),params.concat(new Array(minParams-params.length).fill(0))):void 0!==maxParams&&params.length>maxParams?(error(`TSL: "${tslName}" parameter length exceeds limit.`,new StackTrace),params.slice(0,maxParams)):params}return null===scope?fn=(...params)=>assignNode(new NodeClass(...nodeArray(verifyParamsLimit(params)))):null!==factor?(factor=nodeObject(factor),fn=(...params)=>assignNode(new NodeClass(scope,...nodeArray(verifyParamsLimit(params)),factor))):fn=(...params)=>assignNode(new NodeClass(scope,...nodeArray(verifyParamsLimit(params)))),fn.setParameterLength=(...params)=>(1===params.length?minParams=maxParams=params[0]:2===params.length&&([minParams,maxParams]=params),fn),fn.setName=value=>(name=value,fn),fn},ShaderNodeImmutable=function(NodeClass,...params){return new NodeClass(...nodeArray(params))};class ShaderCallNodeInternal extends Node$1{constructor(shaderNode,rawInputs){super(),this.shaderNode=shaderNode,this.rawInputs=rawInputs,this.isShaderCallNodeInternal=!0}getNodeType(builder){return this.shaderNode.nodeType||this.getOutputNode(builder).getNodeType(builder)}getElementType(builder){return this.getOutputNode(builder).getElementType(builder)}getMemberType(builder,name){return this.getOutputNode(builder).getMemberType(builder,name)}call(builder){const{shaderNode:shaderNode,rawInputs:rawInputs}=this,properties=builder.getNodeProperties(shaderNode),subBuild=builder.getClosestSubBuild(shaderNode.subBuilds)||"",subBuildProperty=subBuild||"default";if(properties[subBuildProperty])return properties[subBuildProperty];const previousSubBuildFn=builder.subBuildFn,previousFnCall=builder.fnCall;builder.subBuildFn=subBuild,builder.fnCall=this;let result=null;if(shaderNode.layout){let functionNodesCacheMap=nodeBuilderFunctionsCacheMap.get(builder.constructor);void 0===functionNodesCacheMap&&(functionNodesCacheMap=new WeakMap,nodeBuilderFunctionsCacheMap.set(builder.constructor,functionNodesCacheMap));let functionNode=functionNodesCacheMap.get(shaderNode);void 0===functionNode&&(functionNode=nodeObject(builder.buildFunctionNode(shaderNode)),functionNodesCacheMap.set(shaderNode,functionNode)),builder.addInclude(functionNode);const inputs=rawInputs?function getLayoutParameters(params){let output;nodeObjects(params);output=params[0]&&(params[0].isNode||Object.getPrototypeOf(params[0])!==Object.prototype)?[...params]:params[0];return output}(rawInputs):null;result=nodeObject(functionNode.call(inputs))}else{const secureNodeBuilder=new Proxy(builder,{get:(target,property,receiver)=>{let value;return value=Symbol.iterator===property?function*(){yield}:Reflect.get(target,property,receiver),value}}),inputs=rawInputs?function getProxyParameters(params){let index=0;return nodeObjects(params),new Proxy(params,{get:(target,property,receiver)=>{let value;if("length"===property)return value=params.length,value;if(Symbol.iterator===property)value=function*(){for(const inputNode of params)yield nodeObject(inputNode)};else{if(params.length>0)if(Object.getPrototypeOf(params[0])===Object.prototype){const objectTarget=params[0];value=void 0===objectTarget[property]?objectTarget[index++]:Reflect.get(objectTarget,property,receiver)}else params[0]instanceof Node$1&&(value=void 0===params[property]?params[index++]:Reflect.get(params,property,receiver));else value=Reflect.get(target,property,receiver);value=nodeObject(value)}return value}})}(rawInputs):null,hasParameters=Array.isArray(rawInputs)?rawInputs.length>0:null!==rawInputs,jsFunc=shaderNode.jsFunc,outputNode=hasParameters||jsFunc.length>1?jsFunc(inputs,secureNodeBuilder):jsFunc(secureNodeBuilder);result=nodeObject(outputNode)}return builder.subBuildFn=previousSubBuildFn,builder.fnCall=previousFnCall,shaderNode.once&&(properties[subBuildProperty]=result),result}setupOutput(builder){return builder.addStack(),builder.stack.outputNode=this.call(builder),builder.removeStack()}getOutputNode(builder){const properties=builder.getNodeProperties(this),subBuildOutput=builder.getSubBuildOutput(this);return properties[subBuildOutput]=properties[subBuildOutput]||this.setupOutput(builder),properties[subBuildOutput].subBuild=builder.getClosestSubBuild(this),properties[subBuildOutput]}build(builder,output=null){let result=null;const buildStage=builder.getBuildStage(),properties=builder.getNodeProperties(this),subBuildOutput=builder.getSubBuildOutput(this),outputNode=this.getOutputNode(builder),previousFnCall=builder.fnCall;if(builder.fnCall=this,"setup"===buildStage){const subBuildInitialized=builder.getSubBuildProperty("initialized",this);if(!0!==properties[subBuildInitialized]&&(properties[subBuildInitialized]=!0,properties[subBuildOutput]=this.getOutputNode(builder),properties[subBuildOutput].build(builder),this.shaderNode.subBuilds))for(const node of builder.chaining){const nodeData=builder.getDataFromNode(node,"any");nodeData.subBuilds=nodeData.subBuilds||new Set;for(const subBuild of this.shaderNode.subBuilds)nodeData.subBuilds.add(subBuild)}result=properties[subBuildOutput]}else"analyze"===buildStage?outputNode.build(builder,output):"generate"===buildStage&&(result=outputNode.build(builder,output)||"");return builder.fnCall=previousFnCall,result}}class ShaderNodeInternal extends Node$1{constructor(jsFunc,nodeType){super(nodeType),this.jsFunc=jsFunc,this.layout=null,this.global=!0,this.once=!1}setLayout(layout){return this.layout=layout,this}getLayout(){return this.layout}call(rawInputs=null){return new ShaderCallNodeInternal(this,rawInputs)}setup(){return this.call()}}const bools=[!1,!0],uints=[0,1,2,3],ints=[-1,-2],floats=[.5,1.5,1/3,1e-6,1e6,Math.PI,2*Math.PI,1/Math.PI,2/Math.PI,1/(2*Math.PI),Math.PI/2],boolsCacheMap=new Map;for(const bool of bools)boolsCacheMap.set(bool,new ConstNode(bool));const uintsCacheMap=new Map;for(const uint of uints)uintsCacheMap.set(uint,new ConstNode(uint,"uint"));const intsCacheMap=new Map([...uintsCacheMap].map(el=>new ConstNode(el.value,"int")));for(const int of ints)intsCacheMap.set(int,new ConstNode(int,"int"));const floatsCacheMap=new Map([...intsCacheMap].map(el=>new ConstNode(el.value)));for(const float of floats)floatsCacheMap.set(float,new ConstNode(float));for(const float of floats)floatsCacheMap.set(-float,new ConstNode(-float));const cacheMaps={bool:boolsCacheMap,uint:uintsCacheMap,ints:intsCacheMap,float:floatsCacheMap},constNodesCacheMap=new Map([...boolsCacheMap,...floatsCacheMap]),getConstNode=(value,type)=>constNodesCacheMap.has(value)?constNodesCacheMap.get(value):!0===value.isNode?value:new ConstNode(value,type),ConvertType=function(type,cacheMap=null){return(...params)=>{for(const param of params)if(void 0===param)return error(`TSL: Invalid parameter for the type "${type}".`,new StackTrace),new ConstNode(0,type);if((0===params.length||!["bool","float","int","uint"].includes(type)&&params.every(param=>{const paramType=typeof param;return"object"!==paramType&&"function"!==paramType}))&&(params=[getValueFromType(type,...params)]),1===params.length&&null!==cacheMap&&cacheMap.has(params[0]))return nodeObjectIntent(cacheMap.get(params[0]));if(1===params.length){const node=getConstNode(params[0],type);return node.nodeType===type?nodeObjectIntent(node):nodeObjectIntent(new ConvertNode(node,type))}const nodes=params.map(param=>getConstNode(param));return nodeObjectIntent(new JoinNode(nodes,type))}},defined=v=>"object"==typeof v&&null!==v?v.value:v;function ShaderNode(jsFunc,nodeType){return new ShaderNodeInternal(jsFunc,nodeType)}const nodeObject=(val,altType=null)=>function(obj,altType=null){const type=getValueType(obj);return"node"===type?obj:null===altType&&("float"===type||"boolean"===type)||type&&"shader"!==type&&"string"!==type?nodeObject(getConstNode(obj,altType)):"shader"===type?obj.isFn?obj:Fn(obj):obj}(val,altType),nodeObjectIntent=(val,altType=null)=>nodeObject(val,altType).toVarIntent(),nodeObjects=(val,altType=null)=>new ShaderNodeObjects(val,altType),nodeArray=(val,altType=null)=>new ShaderNodeArray(val,altType),nodeProxy=(NodeClass,scope=null,factor=null,settings=null)=>new ShaderNodeProxy(NodeClass,scope,factor,settings),nodeImmutable=(NodeClass,...params)=>new ShaderNodeImmutable(NodeClass,...params),nodeProxyIntent=(NodeClass,scope=null,factor=null,settings={})=>new ShaderNodeProxy(NodeClass,scope,factor,{...settings,intent:!0});let fnId=0;class FnNode extends Node$1{constructor(jsFunc,layout=null){super();let nodeType=null;null!==layout&&("object"==typeof layout?nodeType=layout.return:("string"==typeof layout?nodeType=layout:error("TSL: Invalid layout type.",new StackTrace),layout=null)),this.shaderNode=new ShaderNode(jsFunc,nodeType),null!==layout&&this.setLayout(layout),this.isFn=!0}setLayout(layout){const nodeType=this.shaderNode.nodeType;if("object"!=typeof layout.inputs){const fullLayout={name:"fn"+fnId++,type:nodeType,inputs:[]};for(const name in layout)"return"!==name&&fullLayout.inputs.push({name:name,type:layout[name]});layout=fullLayout}return this.shaderNode.setLayout(layout),this}getNodeType(builder){return this.shaderNode.getNodeType(builder)||"float"}call(...params){const fnCall=this.shaderNode.call(params);return"void"===this.shaderNode.nodeType&&fnCall.toStack(),fnCall.toVarIntent()}once(subBuilds=null){return this.shaderNode.once=!0,this.shaderNode.subBuilds=subBuilds,this}generate(builder){const type=this.getNodeType(builder);return error('TSL: "Fn()" was declared but not invoked. Try calling it like "Fn()( ...params )".',this.stackTrace),builder.generateConst(type)}}function Fn(jsFunc,layout=null){const instance=new FnNode(jsFunc,layout);return new Proxy(()=>{},{apply:(target,thisArg,params)=>instance.call(...params),get:(target,prop,receiver)=>Reflect.get(instance,prop,receiver),set:(target,prop,value,receiver)=>Reflect.set(instance,prop,value,receiver)})}const setCurrentStack=stack=>{currentStack=stack},getCurrentStack=()=>currentStack,If=(...params)=>currentStack.If(...params);function Stack(node){return currentStack&&currentStack.addToStack(node),node}addMethodChaining("toStack",Stack);const color=new ConvertType("color"),float=new ConvertType("float",cacheMaps.float),int=new ConvertType("int",cacheMaps.ints),uint=new ConvertType("uint",cacheMaps.uint),bool=new ConvertType("bool",cacheMaps.bool),vec2=new ConvertType("vec2"),ivec2=new ConvertType("ivec2"),uvec2=new ConvertType("uvec2"),bvec2=new ConvertType("bvec2"),vec3=new ConvertType("vec3"),ivec3=new ConvertType("ivec3"),uvec3=new ConvertType("uvec3"),bvec3=new ConvertType("bvec3"),vec4=new ConvertType("vec4"),ivec4=new ConvertType("ivec4"),uvec4=new ConvertType("uvec4"),bvec4=new ConvertType("bvec4"),mat2=new ConvertType("mat2"),mat3=new ConvertType("mat3"),mat4=new ConvertType("mat4");addMethodChaining("toColor",color),addMethodChaining("toFloat",float),addMethodChaining("toInt",int),addMethodChaining("toUint",uint),addMethodChaining("toBool",bool),addMethodChaining("toVec2",vec2),addMethodChaining("toIVec2",ivec2),addMethodChaining("toUVec2",uvec2),addMethodChaining("toBVec2",bvec2),addMethodChaining("toVec3",vec3),addMethodChaining("toIVec3",ivec3),addMethodChaining("toUVec3",uvec3),addMethodChaining("toBVec3",bvec3),addMethodChaining("toVec4",vec4),addMethodChaining("toIVec4",ivec4),addMethodChaining("toUVec4",uvec4),addMethodChaining("toBVec4",bvec4),addMethodChaining("toMat2",mat2),addMethodChaining("toMat3",mat3),addMethodChaining("toMat4",mat4);addMethodChaining("element",/*@__PURE__*/nodeProxy(ArrayElementNode).setParameterLength(2)),addMethodChaining("convert",(node,types)=>nodeObject(new ConvertNode(nodeObject(node),types))),addMethodChaining("append",node=>(warn("TSL: .append() has been renamed to .toStack().",new StackTrace),Stack(node)));class PropertyNode extends Node$1{static get type(){return"PropertyNode"}constructor(nodeType,name=null,varying=!1){super(nodeType),this.name=name,this.varying=varying,this.isPropertyNode=!0,this.global=!0}customCacheKey(){return hashString(this.type+":"+(this.name||"")+":"+(this.varying?"1":"0"))}getHash(builder){return this.name||super.getHash(builder)}generate(builder){let nodeVar;return!0===this.varying?(nodeVar=builder.getVaryingFromNode(this,this.name),nodeVar.needsInterpolation=!0):nodeVar=builder.getVarFromNode(this,this.name),builder.getPropertyName(nodeVar)}}const property=(type,name)=>new PropertyNode(type,name),varyingProperty=(type,name)=>new PropertyNode(type,name,!0),diffuseColor=/*@__PURE__*/nodeImmutable(PropertyNode,"vec4","DiffuseColor"),diffuseContribution=/*@__PURE__*/nodeImmutable(PropertyNode,"vec3","DiffuseContribution"),emissive=/*@__PURE__*/nodeImmutable(PropertyNode,"vec3","EmissiveColor"),roughness=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Roughness"),metalness=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Metalness"),clearcoat=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Clearcoat"),clearcoatRoughness=/*@__PURE__*/nodeImmutable(PropertyNode,"float","ClearcoatRoughness"),sheen=/*@__PURE__*/nodeImmutable(PropertyNode,"vec3","Sheen"),sheenRoughness=/*@__PURE__*/nodeImmutable(PropertyNode,"float","SheenRoughness"),iridescence=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Iridescence"),iridescenceIOR=/*@__PURE__*/nodeImmutable(PropertyNode,"float","IridescenceIOR"),iridescenceThickness=/*@__PURE__*/nodeImmutable(PropertyNode,"float","IridescenceThickness"),alphaT=/*@__PURE__*/nodeImmutable(PropertyNode,"float","AlphaT"),anisotropy=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Anisotropy"),anisotropyT=/*@__PURE__*/nodeImmutable(PropertyNode,"vec3","AnisotropyT"),anisotropyB=/*@__PURE__*/nodeImmutable(PropertyNode,"vec3","AnisotropyB"),specularColor=/*@__PURE__*/nodeImmutable(PropertyNode,"color","SpecularColor"),specularColorBlended=/*@__PURE__*/nodeImmutable(PropertyNode,"color","SpecularColorBlended"),specularF90=/*@__PURE__*/nodeImmutable(PropertyNode,"float","SpecularF90"),shininess=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Shininess"),output=/*@__PURE__*/nodeImmutable(PropertyNode,"vec4","Output"),dashSize=/*@__PURE__*/nodeImmutable(PropertyNode,"float","dashSize"),gapSize=/*@__PURE__*/nodeImmutable(PropertyNode,"float","gapSize"),ior=/*@__PURE__*/nodeImmutable(PropertyNode,"float","IOR"),transmission=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Transmission"),thickness=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Thickness"),attenuationDistance=/*@__PURE__*/nodeImmutable(PropertyNode,"float","AttenuationDistance"),attenuationColor=/*@__PURE__*/nodeImmutable(PropertyNode,"color","AttenuationColor"),dispersion=/*@__PURE__*/nodeImmutable(PropertyNode,"float","Dispersion");class UniformGroupNode extends Node$1{static get type(){return"UniformGroupNode"}constructor(name,shared=!1,order=1){super("string"),this.name=name,this.shared=shared,this.order=order,this.isUniformGroup=!0}serialize(data){super.serialize(data),data.name=this.name,data.version=this.version,data.shared=this.shared}deserialize(data){super.deserialize(data),this.name=data.name,this.version=data.version,this.shared=data.shared}}const uniformGroup=name=>new UniformGroupNode(name),sharedUniformGroup=(name,order=0)=>new UniformGroupNode(name,!0,order),frameGroup=/*@__PURE__*/sharedUniformGroup("frame"),renderGroup=/*@__PURE__*/sharedUniformGroup("render"),objectGroup=/*@__PURE__*/uniformGroup("object");class UniformNode extends InputNode{static get type(){return"UniformNode"}constructor(value,nodeType=null){super(value,nodeType),this.isUniformNode=!0,this.name="",this.groupNode=objectGroup}setName(name){return this.name=name,this}label(name){return warn('TSL: "label()" has been deprecated. Use "setName()" instead.',new StackTrace),this.setName(name)}setGroup(group){return this.groupNode=group,this}getGroup(){return this.groupNode}getUniformHash(builder){return this.getHash(builder)}onUpdate(callback,updateType){return callback=callback.bind(this),super.onUpdate(frame=>{const value=callback(frame,this);void 0!==value&&(this.value=value)},updateType)}getInputType(builder){let type=super.getInputType(builder);return"bool"===type&&(type="uint"),type}generate(builder,output){const type=this.getNodeType(builder),hash=this.getUniformHash(builder);let sharedNode=builder.getNodeFromHash(hash);void 0===sharedNode&&(builder.setHashNode(this,hash),sharedNode=this);const sharedNodeType=sharedNode.getInputType(builder),nodeUniform=builder.getUniformFromNode(sharedNode,sharedNodeType,builder.shaderStage,this.name||builder.context.nodeName),uniformName=builder.getPropertyName(nodeUniform);void 0!==builder.context.nodeName&&delete builder.context.nodeName;let snippet=uniformName;if("bool"===type){const nodeData=builder.getDataFromNode(this);let propertyName=nodeData.propertyName;if(void 0===propertyName){const nodeVar=builder.getVarFromNode(this,null,"bool");propertyName=builder.getPropertyName(nodeVar),nodeData.propertyName=propertyName,snippet=builder.format(uniformName,sharedNodeType,type),builder.addLineFlowCode(`${propertyName} = ${snippet}`,this)}snippet=propertyName}return builder.format(snippet,type,output)}}const uniform=(value,type)=>{const nodeType=(value=>null!=value?value.nodeType||value.convertTo||("string"==typeof value?value:null):null)(type||value);if(nodeType===value&&(value=getValueFromType(nodeType)),value&&!0===value.isNode){let v=value.value;value.traverse(n=>{!0===n.isConstNode&&(v=n.value)}),value=v}return new UniformNode(value,nodeType)};class ArrayNode extends TempNode{static get type(){return"ArrayNode"}constructor(nodeType,count,values=null){super(nodeType),this.count=count,this.values=values,this.isArrayNode=!0}getArrayCount(){return this.count}getNodeType(builder){return null===this.nodeType?this.values[0].getNodeType(builder):this.nodeType}getElementType(builder){return this.getNodeType(builder)}getMemberType(builder,name){return null===this.nodeType?this.values[0].getMemberType(builder,name):super.getMemberType(builder,name)}generate(builder){const type=this.getNodeType(builder);return builder.generateArray(type,this.count,this.values)}}addMethodChaining("toArray",(node,count)=>((...params)=>{let node;if(1===params.length){const values=params[0];node=new ArrayNode(null,values.length,values)}else{const nodeType=params[0],count=params[1];node=new ArrayNode(nodeType,count)}return nodeObject(node)})(Array(count).fill(node)));class AssignNode extends TempNode{static get type(){return"AssignNode"}constructor(targetNode,sourceNode){super(),this.targetNode=targetNode,this.sourceNode=sourceNode,this.isAssignNode=!0}hasDependencies(){return!1}getNodeType(builder,output){return"void"!==output?this.targetNode.getNodeType(builder):"void"}needsSplitAssign(builder){const{targetNode:targetNode}=this;if(!1===builder.isAvailable("swizzleAssign")&&targetNode.isSplitNode&&targetNode.components.length>1){const targetLength=builder.getTypeLength(targetNode.node.getNodeType(builder));return vectorComponents.join("").slice(0,targetLength)!==targetNode.components}return!1}setup(builder){const{targetNode:targetNode,sourceNode:sourceNode}=this,scope=targetNode.getScope();builder.getDataFromNode(scope).assign=!0;const properties=builder.getNodeProperties(this);properties.sourceNode=sourceNode,properties.targetNode=targetNode.context({assign:!0})}generate(builder,output){const{targetNode:targetNode,sourceNode:sourceNode}=builder.getNodeProperties(this),needsSplitAssign=this.needsSplitAssign(builder),target=targetNode.build(builder),targetType=targetNode.getNodeType(builder),source=sourceNode.build(builder,targetType),sourceType=sourceNode.getNodeType(builder),nodeData=builder.getDataFromNode(this);let snippet;if(!0===nodeData.initialized)"void"!==output&&(snippet=target);else if(needsSplitAssign){const sourceVar=builder.getVarFromNode(this,null,targetType),sourceProperty=builder.getPropertyName(sourceVar);builder.addLineFlowCode(`${sourceProperty} = ${source}`,this);const splitNode=targetNode.node,targetRoot=splitNode.node.context({assign:!0}).build(builder);for(let i=0;i<splitNode.components.length;i++){const component=splitNode.components[i];builder.addLineFlowCode(`${targetRoot}.${component} = ${sourceProperty}[ ${i} ]`,this)}"void"!==output&&(snippet=target)}else snippet=`${target} = ${source}`,"void"!==output&&"void"!==sourceType||(builder.addLineFlowCode(snippet,this),"void"!==output&&(snippet=target));return nodeData.initialized=!0,builder.format(snippet,targetType,output)}}addMethodChaining("assign",/*@__PURE__*/nodeProxy(AssignNode).setParameterLength(2));class FunctionCallNode extends TempNode{static get type(){return"FunctionCallNode"}constructor(functionNode=null,parameters={}){super(),this.functionNode=functionNode,this.parameters=parameters}setParameters(parameters){return this.parameters=parameters,this}getParameters(){return this.parameters}getNodeType(builder){return this.functionNode.getNodeType(builder)}getMemberType(builder,name){return this.functionNode.getMemberType(builder,name)}generate(builder){const params=[],functionNode=this.functionNode,inputs=functionNode.getInputs(builder),parameters=this.parameters,generateInput=(node,inputNode)=>{const type=inputNode.type;let output;return output="pointer"===type?"&"+node.build(builder):node.build(builder,type),output};if(Array.isArray(parameters)){if(parameters.length>inputs.length)error("TSL: The number of provided parameters exceeds the expected number of inputs in 'Fn()'."),parameters.length=inputs.length;else if(parameters.length<inputs.length)for(error("TSL: The number of provided parameters is less than the expected number of inputs in 'Fn()'.");parameters.length<inputs.length;)parameters.push(float(0));for(let i=0;i<parameters.length;i++)params.push(generateInput(parameters[i],inputs[i]))}else for(const inputNode of inputs){const node=parameters[inputNode.name];void 0!==node?params.push(generateInput(node,inputNode)):(error(`TSL: Input '${inputNode.name}' not found in 'Fn()'.`),params.push(generateInput(float(0),inputNode)))}return`${functionNode.build(builder,"property")}( ${params.join(", ")} )`}}addMethodChaining("call",(func,...params)=>(params=params.length>1||params[0]&&!0===params[0].isNode?nodeArray(params):nodeObjects(params[0]),new FunctionCallNode(nodeObject(func),params)));const _vectorOperators={"==":"equal","!=":"notEqual","<":"lessThan",">":"greaterThan","<=":"lessThanEqual",">=":"greaterThanEqual","%":"mod"};class OperatorNode extends TempNode{static get type(){return"OperatorNode"}constructor(op,aNode,bNode,...params){if(super(),params.length>0){let finalOp=new OperatorNode(op,aNode,bNode);for(let i=0;i<params.length-1;i++)finalOp=new OperatorNode(op,finalOp,params[i]);aNode=finalOp,bNode=params[params.length-1]}this.op=op,this.aNode=aNode,this.bNode=bNode,this.isOperatorNode=!0}getOperatorMethod(builder,output){return builder.getMethod(_vectorOperators[this.op],output)}getNodeType(builder,output=null){const op=this.op,aNode=this.aNode,bNode=this.bNode,typeA=aNode.getNodeType(builder),typeB=bNode?bNode.getNodeType(builder):null;if("void"===typeA||"void"===typeB)return output||"void";if("%"===op)return typeA;if("~"===op||"&"===op||"|"===op||"^"===op||">>"===op||"<<"===op)return builder.getIntegerType(typeA);if("!"===op||"&&"===op||"||"===op||"^^"===op)return"bool";if("=="===op||"!="===op||"<"===op||">"===op||"<="===op||">="===op){const typeLength=Math.max(builder.getTypeLength(typeA),builder.getTypeLength(typeB));return typeLength>1?`bvec${typeLength}`:"bool"}if(builder.isMatrix(typeA)){if("float"===typeB)return typeA;if(builder.isVector(typeB))return builder.getVectorFromMatrix(typeA);if(builder.isMatrix(typeB))return typeA}else if(builder.isMatrix(typeB)){if("float"===typeA)return typeB;if(builder.isVector(typeA))return builder.getVectorFromMatrix(typeB)}return builder.getTypeLength(typeB)>builder.getTypeLength(typeA)?typeB:typeA}generate(builder,output){const op=this.op,{aNode:aNode,bNode:bNode}=this,type=this.getNodeType(builder,output);let typeA=null,typeB=null;"void"!==type?(typeA=aNode.getNodeType(builder),typeB=bNode?bNode.getNodeType(builder):null,"<"===op||">"===op||"<="===op||">="===op||"=="===op||"!="===op?builder.isVector(typeA)?typeB=typeA:builder.isVector(typeB)?typeA=typeB:typeA!==typeB&&(typeA=typeB="float"):">>"===op||"<<"===op?(typeA=type,typeB=builder.changeComponentType(typeB,"uint")):"%"===op?(typeA=type,typeB=builder.isInteger(typeA)&&builder.isInteger(typeB)?typeB:typeA):builder.isMatrix(typeA)?"float"===typeB?typeB="float":builder.isVector(typeB)?typeB=builder.getVectorFromMatrix(typeA):builder.isMatrix(typeB)||(typeA=typeB=type):typeA=builder.isMatrix(typeB)?"float"===typeA?"float":builder.isVector(typeA)?builder.getVectorFromMatrix(typeB):typeB=type:typeB=type):typeA=typeB=type;const a=aNode.build(builder,typeA),b=bNode?bNode.build(builder,typeB):null,fnOpSnippet=builder.getFunctionOperator(op);if("void"!==output){const isGLSL=2e3===builder.renderer.coordinateSystem;if("=="===op||"!="===op||"<"===op||">"===op||"<="===op||">="===op)return isGLSL&&builder.isVector(typeA)?builder.format(`${this.getOperatorMethod(builder,output)}( ${a}, ${b} )`,type,output):builder.format(`( ${a} ${op} ${b} )`,type,output);if("%"===op)return builder.isInteger(typeB)?builder.format(`( ${a} % ${b} )`,type,output):builder.format(`${this.getOperatorMethod(builder,type)}( ${a}, ${b} )`,type,output);if("!"===op||"~"===op)return builder.format(`(${op}${a})`,typeA,output);if(fnOpSnippet)return builder.format(`${fnOpSnippet}( ${a}, ${b} )`,type,output);if(builder.isMatrix(typeA)&&"float"===typeB)return builder.format(`( ${b} ${op} ${a} )`,type,output);if("float"===typeA&&builder.isMatrix(typeB))return builder.format(`${a} ${op} ${b}`,type,output);{let snippet=`( ${a} ${op} ${b} )`;return!isGLSL&&"bool"===type&&builder.isVector(typeA)&&builder.isVector(typeB)&&(snippet=`all${snippet}`),builder.format(snippet,type,output)}}if("void"!==typeA)return fnOpSnippet?builder.format(`${fnOpSnippet}( ${a}, ${b} )`,type,output):builder.isMatrix(typeA)&&"float"===typeB?builder.format(`${b} ${op} ${a}`,type,output):builder.format(`${a} ${op} ${b}`,type,output)}serialize(data){super.serialize(data),data.op=this.op}deserialize(data){super.deserialize(data),this.op=data.op}}const add=/*@__PURE__*/nodeProxyIntent(OperatorNode,"+").setParameterLength(2,Infinity).setName("add"),sub=/*@__PURE__*/nodeProxyIntent(OperatorNode,"-").setParameterLength(2,Infinity).setName("sub"),mul=/*@__PURE__*/nodeProxyIntent(OperatorNode,"*").setParameterLength(2,Infinity).setName("mul"),div=/*@__PURE__*/nodeProxyIntent(OperatorNode,"/").setParameterLength(2,Infinity).setName("div"),mod=/*@__PURE__*/nodeProxyIntent(OperatorNode,"%").setParameterLength(2).setName("mod"),equal=/*@__PURE__*/nodeProxyIntent(OperatorNode,"==").setParameterLength(2).setName("equal"),notEqual=/*@__PURE__*/nodeProxyIntent(OperatorNode,"!=").setParameterLength(2).setName("notEqual"),lessThan=/*@__PURE__*/nodeProxyIntent(OperatorNode,"<").setParameterLength(2).setName("lessThan"),greaterThan=/*@__PURE__*/nodeProxyIntent(OperatorNode,">").setParameterLength(2).setName("greaterThan"),lessThanEqual=/*@__PURE__*/nodeProxyIntent(OperatorNode,"<=").setParameterLength(2).setName("lessThanEqual"),greaterThanEqual=/*@__PURE__*/nodeProxyIntent(OperatorNode,">=").setParameterLength(2).setName("greaterThanEqual"),and=/*@__PURE__*/nodeProxyIntent(OperatorNode,"&&").setParameterLength(2,Infinity).setName("and"),or=/*@__PURE__*/nodeProxyIntent(OperatorNode,"||").setParameterLength(2,Infinity).setName("or"),not=/*@__PURE__*/nodeProxyIntent(OperatorNode,"!").setParameterLength(1).setName("not"),xor=/*@__PURE__*/nodeProxyIntent(OperatorNode,"^^").setParameterLength(2).setName("xor"),bitAnd=/*@__PURE__*/nodeProxyIntent(OperatorNode,"&").setParameterLength(2).setName("bitAnd"),bitNot=/*@__PURE__*/nodeProxyIntent(OperatorNode,"~").setParameterLength(1).setName("bitNot"),bitOr=/*@__PURE__*/nodeProxyIntent(OperatorNode,"|").setParameterLength(2).setName("bitOr"),bitXor=/*@__PURE__*/nodeProxyIntent(OperatorNode,"^").setParameterLength(2).setName("bitXor"),shiftLeft=/*@__PURE__*/nodeProxyIntent(OperatorNode,"<<").setParameterLength(2).setName("shiftLeft"),shiftRight=/*@__PURE__*/nodeProxyIntent(OperatorNode,">>").setParameterLength(2).setName("shiftRight"),incrementBefore=Fn(([a])=>(a.addAssign(1),a)),decrementBefore=Fn(([a])=>(a.subAssign(1),a)),increment=/*@__PURE__*/Fn(([a])=>{const temp=int(a).toConst();return a.addAssign(1),temp}),decrement=/*@__PURE__*/Fn(([a])=>{const temp=int(a).toConst();return a.subAssign(1),temp});addMethodChaining("add",add),addMethodChaining("sub",sub),addMethodChaining("mul",mul),addMethodChaining("div",div),addMethodChaining("mod",mod),addMethodChaining("equal",equal),addMethodChaining("notEqual",notEqual),addMethodChaining("lessThan",lessThan),addMethodChaining("greaterThan",greaterThan),addMethodChaining("lessThanEqual",lessThanEqual),addMethodChaining("greaterThanEqual",greaterThanEqual),addMethodChaining("and",and),addMethodChaining("or",or),addMethodChaining("not",not),addMethodChaining("xor",xor),addMethodChaining("bitAnd",bitAnd),addMethodChaining("bitNot",bitNot),addMethodChaining("bitOr",bitOr),addMethodChaining("bitXor",bitXor),addMethodChaining("shiftLeft",shiftLeft),addMethodChaining("shiftRight",shiftRight),addMethodChaining("incrementBefore",incrementBefore),addMethodChaining("decrementBefore",decrementBefore),addMethodChaining("increment",increment),addMethodChaining("decrement",decrement);addMethodChaining("modInt",(a,b)=>(warn('TSL: "modInt()" is deprecated. Use "mod( int( ... ) )" instead.',new StackTrace),mod(int(a),int(b))));class MathNode extends TempNode{static get type(){return"MathNode"}constructor(method,aNode,bNode=null,cNode=null){if(super(),(method===MathNode.MAX||method===MathNode.MIN)&&arguments.length>3){let finalOp=new MathNode(method,aNode,bNode);for(let i=2;i<arguments.length-1;i++)finalOp=new MathNode(method,finalOp,arguments[i]);aNode=finalOp,bNode=arguments[arguments.length-1],cNode=null}this.method=method,this.aNode=aNode,this.bNode=bNode,this.cNode=cNode,this.isMathNode=!0}getInputType(builder){const aType=this.aNode.getNodeType(builder),bType=this.bNode?this.bNode.getNodeType(builder):null,cType=this.cNode?this.cNode.getNodeType(builder):null,aLen=builder.isMatrix(aType)?0:builder.getTypeLength(aType),bLen=builder.isMatrix(bType)?0:builder.getTypeLength(bType),cLen=builder.isMatrix(cType)?0:builder.getTypeLength(cType);return aLen>bLen&&aLen>cLen?aType:bLen>cLen?bType:cLen>aLen?cType:aType}getNodeType(builder){const method=this.method;return method===MathNode.LENGTH||method===MathNode.DISTANCE||method===MathNode.DOT?"float":method===MathNode.CROSS?"vec3":method===MathNode.ALL||method===MathNode.ANY?"bool":method===MathNode.EQUALS?builder.changeComponentType(this.aNode.getNodeType(builder),"bool"):this.getInputType(builder)}setup(builder){const{aNode:aNode,bNode:bNode,method:method}=this;let outputNode=null;if(method===MathNode.ONE_MINUS)outputNode=sub(1,aNode);else if(method===MathNode.RECIPROCAL)outputNode=div(1,aNode);else if(method===MathNode.DIFFERENCE)outputNode=abs(sub(aNode,bNode));else if(method===MathNode.TRANSFORM_DIRECTION){let tA=aNode,tB=bNode;builder.isMatrix(tA.getNodeType(builder))?tB=vec4(vec3(tB),0):tA=vec4(vec3(tA),0);const mulNode=mul(tA,tB).xyz;outputNode=normalize(mulNode)}return null!==outputNode?outputNode:super.setup(builder)}generate(builder,output){if(builder.getNodeProperties(this).outputNode)return super.generate(builder,output);let method=this.method;const type=this.getNodeType(builder),inputType=this.getInputType(builder),a=this.aNode,b=this.bNode,c=this.cNode,coordinateSystem=builder.renderer.coordinateSystem;if(method===MathNode.NEGATE)return builder.format("( - "+a.build(builder,inputType)+" )",type,output);{const params=[];return method===MathNode.CROSS?params.push(a.build(builder,type),b.build(builder,type)):2e3===coordinateSystem&&method===MathNode.STEP?params.push(a.build(builder,1===builder.getTypeLength(a.getNodeType(builder))?"float":inputType),b.build(builder,inputType)):2e3!==coordinateSystem||method!==MathNode.MIN&&method!==MathNode.MAX?method===MathNode.REFRACT?params.push(a.build(builder,inputType),b.build(builder,inputType),c.build(builder,"float")):method===MathNode.MIX?params.push(a.build(builder,inputType),b.build(builder,inputType),c.build(builder,1===builder.getTypeLength(c.getNodeType(builder))?"float":inputType)):(2001===coordinateSystem&&method===MathNode.ATAN&&null!==b&&(method="atan2"),"fragment"===builder.shaderStage||method!==MathNode.DFDX&&method!==MathNode.DFDY||(warn(`TSL: '${method}' is not supported in the ${builder.shaderStage} stage.`,this.stackTrace),method="/*"+method+"*/"),params.push(a.build(builder,inputType)),null!==b&&params.push(b.build(builder,inputType)),null!==c&&params.push(c.build(builder,inputType))):params.push(a.build(builder,inputType),b.build(builder,1===builder.getTypeLength(b.getNodeType(builder))?"float":inputType)),builder.format(`${builder.getMethod(method,type)}( ${params.join(", ")} )`,type,output)}}serialize(data){super.serialize(data),data.method=this.method}deserialize(data){super.deserialize(data),this.method=data.method}}MathNode.ALL="all",MathNode.ANY="any",MathNode.RADIANS="radians",MathNode.DEGREES="degrees",MathNode.EXP="exp",MathNode.EXP2="exp2",MathNode.LOG="log",MathNode.LOG2="log2",MathNode.SQRT="sqrt",MathNode.INVERSE_SQRT="inversesqrt",MathNode.FLOOR="floor",MathNode.CEIL="ceil",MathNode.NORMALIZE="normalize",MathNode.FRACT="fract",MathNode.SIN="sin",MathNode.COS="cos",MathNode.TAN="tan",MathNode.ASIN="asin",MathNode.ACOS="acos",MathNode.ATAN="atan",MathNode.ABS="abs",MathNode.SIGN="sign",MathNode.LENGTH="length",MathNode.NEGATE="negate",MathNode.ONE_MINUS="oneMinus",MathNode.DFDX="dFdx",MathNode.DFDY="dFdy",MathNode.ROUND="round",MathNode.RECIPROCAL="reciprocal",MathNode.TRUNC="trunc",MathNode.FWIDTH="fwidth",MathNode.TRANSPOSE="transpose",MathNode.DETERMINANT="determinant",MathNode.INVERSE="inverse",MathNode.EQUALS="equals",MathNode.MIN="min",MathNode.MAX="max",MathNode.STEP="step",MathNode.REFLECT="reflect",MathNode.DISTANCE="distance",MathNode.DIFFERENCE="difference",MathNode.DOT="dot",MathNode.CROSS="cross",MathNode.POW="pow",MathNode.TRANSFORM_DIRECTION="transformDirection",MathNode.MIX="mix",MathNode.CLAMP="clamp",MathNode.REFRACT="refract",MathNode.SMOOTHSTEP="smoothstep",MathNode.FACEFORWARD="faceforward";const EPSILON=/*@__PURE__*/float(1e-6),PI=/*@__PURE__*/float(Math.PI),all=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ALL).setParameterLength(1),any=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ANY).setParameterLength(1),radians=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.RADIANS).setParameterLength(1),degrees=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.DEGREES).setParameterLength(1),exp=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.EXP).setParameterLength(1),exp2=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.EXP2).setParameterLength(1),log=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.LOG).setParameterLength(1),log2=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.LOG2).setParameterLength(1),sqrt=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.SQRT).setParameterLength(1),inverseSqrt=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.INVERSE_SQRT).setParameterLength(1),floor=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.FLOOR).setParameterLength(1),ceil=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.CEIL).setParameterLength(1),normalize=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.NORMALIZE).setParameterLength(1),fract=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.FRACT).setParameterLength(1),sin=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.SIN).setParameterLength(1),cos=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.COS).setParameterLength(1),tan=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.TAN).setParameterLength(1),asin=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ASIN).setParameterLength(1),acos=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ACOS).setParameterLength(1),atan=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ATAN).setParameterLength(1,2),abs=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ABS).setParameterLength(1),sign=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.SIGN).setParameterLength(1),length=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.LENGTH).setParameterLength(1),negate=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.NEGATE).setParameterLength(1),oneMinus=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ONE_MINUS).setParameterLength(1),dFdx=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.DFDX).setParameterLength(1),dFdy=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.DFDY).setParameterLength(1),round=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.ROUND).setParameterLength(1),reciprocal=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.RECIPROCAL).setParameterLength(1),trunc=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.TRUNC).setParameterLength(1),fwidth=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.FWIDTH).setParameterLength(1),transpose=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.TRANSPOSE).setParameterLength(1),determinant=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.DETERMINANT).setParameterLength(1),inverse=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.INVERSE).setParameterLength(1),min$1=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.MIN).setParameterLength(2,Infinity),max$1=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.MAX).setParameterLength(2,Infinity),step=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.STEP).setParameterLength(2),reflect=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.REFLECT).setParameterLength(2),distance=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.DISTANCE).setParameterLength(2),difference=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.DIFFERENCE).setParameterLength(2),dot=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.DOT).setParameterLength(2),cross=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.CROSS).setParameterLength(2),pow=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.POW).setParameterLength(2),pow2=x=>mul(x,x),pow4=x=>mul(x,x,x,x),transformDirection=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.TRANSFORM_DIRECTION).setParameterLength(2),lengthSq=a=>dot(a,a),mix=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.MIX).setParameterLength(3),clamp$2=(value,low=0,high=1)=>nodeObject(new MathNode(MathNode.CLAMP,nodeObject(value),nodeObject(low),nodeObject(high))),saturate=value=>clamp$2(value),refract=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.REFRACT).setParameterLength(3),smoothstep=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.SMOOTHSTEP).setParameterLength(3),faceForward=/*@__PURE__*/nodeProxyIntent(MathNode,MathNode.FACEFORWARD).setParameterLength(3),rand=/*@__PURE__*/Fn(([uv])=>{const dt=dot(uv.xy,vec2(12.9898,78.233)),sn=mod(dt,PI);return fract(sin(sn).mul(43758.5453))});addMethodChaining("all",all),addMethodChaining("any",any),addMethodChaining("radians",radians),addMethodChaining("degrees",degrees),addMethodChaining("exp",exp),addMethodChaining("exp2",exp2),addMethodChaining("log",log),addMethodChaining("log2",log2),addMethodChaining("sqrt",sqrt),addMethodChaining("inverseSqrt",inverseSqrt),addMethodChaining("floor",floor),addMethodChaining("ceil",ceil),addMethodChaining("normalize",normalize),addMethodChaining("fract",fract),addMethodChaining("sin",sin),addMethodChaining("cos",cos),addMethodChaining("tan",tan),addMethodChaining("asin",asin),addMethodChaining("acos",acos),addMethodChaining("atan",atan),addMethodChaining("abs",abs),addMethodChaining("sign",sign),addMethodChaining("length",length),addMethodChaining("lengthSq",lengthSq),addMethodChaining("negate",negate),addMethodChaining("oneMinus",oneMinus),addMethodChaining("dFdx",dFdx),addMethodChaining("dFdy",dFdy),addMethodChaining("round",round),addMethodChaining("reciprocal",reciprocal),addMethodChaining("trunc",trunc),addMethodChaining("fwidth",fwidth),addMethodChaining("min",min$1),addMethodChaining("max",max$1),addMethodChaining("step",(x,edge)=>step(edge,x)),addMethodChaining("reflect",reflect),addMethodChaining("distance",distance),addMethodChaining("dot",dot),addMethodChaining("cross",cross),addMethodChaining("pow",pow),addMethodChaining("pow2",pow2),addMethodChaining("pow3",x=>mul(x,x,x)),addMethodChaining("pow4",pow4),addMethodChaining("transformDirection",transformDirection),addMethodChaining("mix",(t,e1,e2)=>mix(e1,e2,t)),addMethodChaining("clamp",clamp$2),addMethodChaining("refract",refract),addMethodChaining("smoothstep",(x,low,high)=>smoothstep(low,high,x)),addMethodChaining("faceForward",faceForward),addMethodChaining("difference",difference),addMethodChaining("saturate",saturate),addMethodChaining("cbrt",a=>mul(sign(a),pow(abs(a),1/3))),addMethodChaining("transpose",transpose),addMethodChaining("determinant",determinant),addMethodChaining("inverse",inverse),addMethodChaining("rand",rand);class ConditionalNode extends Node$1{static get type(){return"ConditionalNode"}constructor(condNode,ifNode,elseNode=null){super(),this.condNode=condNode,this.ifNode=ifNode,this.elseNode=elseNode}getNodeType(builder){const{ifNode:ifNode,elseNode:elseNode}=builder.getNodeProperties(this);if(void 0===ifNode)return builder.flowBuildStage(this,"setup"),this.getNodeType(builder);const ifType=ifNode.getNodeType(builder);if(null!==elseNode){const elseType=elseNode.getNodeType(builder);if(builder.getTypeLength(elseType)>builder.getTypeLength(ifType))return elseType}return ifType}setup(builder){const condNode=this.condNode,ifNode=this.ifNode.isolate(),elseNode=this.elseNode?this.elseNode.isolate():null,currentNodeBlock=builder.context.nodeBlock;builder.getDataFromNode(ifNode).parentNodeBlock=currentNodeBlock,null!==elseNode&&(builder.getDataFromNode(elseNode).parentNodeBlock=currentNodeBlock);const isUniformFlow=builder.context.uniformFlow,properties=builder.getNodeProperties(this);properties.condNode=condNode,properties.ifNode=isUniformFlow?ifNode:ifNode.context({nodeBlock:ifNode}),properties.elseNode=elseNode?isUniformFlow?elseNode:elseNode.context({nodeBlock:elseNode}):null}generate(builder,output){const type=this.getNodeType(builder),nodeData=builder.getDataFromNode(this);if(void 0!==nodeData.nodeProperty)return nodeData.nodeProperty;const{condNode:condNode,ifNode:ifNode,elseNode:elseNode}=builder.getNodeProperties(this),functionNode=builder.currentFunctionNode,needsOutput="void"!==output,nodeProperty=needsOutput?property(type).build(builder):"";nodeData.nodeProperty=nodeProperty;const nodeSnippet=condNode.build(builder,"bool");if(builder.context.uniformFlow&&null!==elseNode){const ifSnippet=ifNode.build(builder,type),elseSnippet=elseNode.build(builder,type),mathSnippet=builder.getTernary(nodeSnippet,ifSnippet,elseSnippet);return builder.format(mathSnippet,type,output)}builder.addFlowCode(`\n${builder.tab}if ( ${nodeSnippet} ) {\n\n`).addFlowTab();let ifSnippet=ifNode.build(builder,type);if(ifSnippet&&(needsOutput?ifSnippet=nodeProperty+" = "+ifSnippet+";":(ifSnippet="return "+ifSnippet+";",null===functionNode&&(warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.",this.stackTrace),ifSnippet="// "+ifSnippet))),builder.removeFlowTab().addFlowCode(builder.tab+"\t"+ifSnippet+"\n\n"+builder.tab+"}"),null!==elseNode){builder.addFlowCode(" else {\n\n").addFlowTab();let elseSnippet=elseNode.build(builder,type);elseSnippet&&(needsOutput?elseSnippet=nodeProperty+" = "+elseSnippet+";":(elseSnippet="return "+elseSnippet+";",null===functionNode&&(warn("TSL: Return statement used in an inline 'Fn()'. Define a layout struct to allow return values.",this.stackTrace),elseSnippet="// "+elseSnippet))),builder.removeFlowTab().addFlowCode(builder.tab+"\t"+elseSnippet+"\n\n"+builder.tab+"}\n\n")}else builder.addFlowCode("\n\n");return builder.format(nodeProperty,type,output)}}const select=/*@__PURE__*/nodeProxy(ConditionalNode).setParameterLength(2,3);addMethodChaining("select",select);class ContextNode extends Node$1{static get type(){return"ContextNode"}constructor(node=null,value={}){super(),this.isContextNode=!0,this.node=node,this.value=value}getScope(){return this.node.getScope()}getNodeType(builder){return this.node.getNodeType(builder)}getFlowContextData(){const children=[];return this.traverse(node=>{!0===node.isContextNode&&children.push(node.value)}),Object.assign({},...children)}getMemberType(builder,name){return this.node.getMemberType(builder,name)}analyze(builder){const previousContext=builder.addContext(this.value);this.node.build(builder),builder.setContext(previousContext)}setup(builder){const previousContext=builder.addContext(this.value);this.node.build(builder),builder.setContext(previousContext)}generate(builder,output){const previousContext=builder.addContext(this.value),snippet=this.node.build(builder,output);return builder.setContext(previousContext),snippet}}const context=(nodeOrValue=null,value={})=>{let node=nodeOrValue;return null!==node&&!0===node.isNode||(value=node||value,node=null),new ContextNode(node,value)},setName=(node,name)=>context(node,{nodeName:name});addMethodChaining("context",context),addMethodChaining("label",function label(node,name){return warn('TSL: "label()" has been deprecated. Use "setName()" instead.'),setName(node,name)}),addMethodChaining("uniformFlow",node=>context(node,{uniformFlow:!0})),addMethodChaining("setName",setName),addMethodChaining("builtinShadowContext",(node,shadowNode,light)=>function builtinShadowContext(shadowNode,light,node=null){return context(node,{getShadow:({light:shadowLight,shadowColorNode:shadowColorNode})=>light===shadowLight?shadowColorNode.mul(shadowNode):shadowColorNode})}(shadowNode,light,node)),addMethodChaining("builtinAOContext",(node,aoValue)=>function builtinAOContext(aoNode,node=null){return context(node,{getAO:(inputNode,{material:material})=>!0===material.transparent?inputNode:null!==inputNode?inputNode.mul(aoNode):aoNode})}(aoValue,node));class VarNode extends Node$1{static get type(){return"VarNode"}constructor(node,name=null,readOnly=!1){super(),this.node=node,this.name=name,this.global=!0,this.isVarNode=!0,this.readOnly=readOnly,this.parents=!0,this.intent=!1}setIntent(value){return this.intent=value,this}isIntent(builder){return!0!==builder.getDataFromNode(this).forceDeclaration&&this.intent}getIntent(){return this.intent}getMemberType(builder,name){return this.node.getMemberType(builder,name)}getElementType(builder){return this.node.getElementType(builder)}getNodeType(builder){return this.node.getNodeType(builder)}getArrayCount(builder){return this.node.getArrayCount(builder)}isAssign(builder){return builder.getDataFromNode(this).assign}build(...params){const builder=params[0];if(!1===this._hasStack(builder)&&"setup"===builder.buildStage&&(builder.context.nodeLoop||builder.context.nodeBlock)){let addBefore=!1;if(this.node.isShaderCallNodeInternal&&null===this.node.shaderNode.getLayout()&&builder.fnCall&&builder.fnCall.shaderNode){if(builder.getDataFromNode(this.node.shaderNode).hasLoop){builder.getDataFromNode(this).forceDeclaration=!0,addBefore=!0}}const baseStack=builder.getBaseStack();addBefore?baseStack.addToStackBefore(this):baseStack.addToStack(this)}return this.isIntent(builder)&&!0!==this.isAssign(builder)?this.node.build(...params):super.build(...params)}generate(builder){const{node:node,name:name,readOnly:readOnly}=this,{renderer:renderer}=builder,isWebGPUBackend=!0===renderer.backend.isWebGPUBackend;let isDeterministic=!1,shouldTreatAsReadOnly=!1;readOnly&&(isDeterministic=builder.isDeterministic(node),shouldTreatAsReadOnly=isWebGPUBackend?readOnly:isDeterministic);const nodeType=this.getNodeType(builder);if("void"==nodeType){!0!==this.isIntent(builder)&&error('TSL: ".toVar()" can not be used with void type.',this.stackTrace);return node.build(builder)}const vectorType=builder.getVectorType(nodeType),snippet=node.build(builder,vectorType),nodeVar=builder.getVarFromNode(this,name,vectorType,void 0,shouldTreatAsReadOnly),propertyName=builder.getPropertyName(nodeVar);let declarationPrefix=propertyName;if(shouldTreatAsReadOnly)if(isWebGPUBackend)declarationPrefix=isDeterministic?`const ${propertyName}`:`let ${propertyName}`;else{const count=node.getArrayCount(builder);declarationPrefix=`const ${builder.getVar(nodeVar.type,propertyName,count)}`}return builder.addLineFlowCode(`${declarationPrefix} = ${snippet}`,this),propertyName}_hasStack(builder){return void 0!==builder.getDataFromNode(this).stack}}const createVar=/*@__PURE__*/nodeProxy(VarNode);addMethodChaining("toVar",(node,name=null)=>createVar(node,name).toStack()),addMethodChaining("toConst",(node,name=null)=>createVar(node,name,!0).toStack()),addMethodChaining("toVarIntent",node=>createVar(node).setIntent(!0).toStack());class SubBuildNode extends Node$1{static get type(){return"SubBuild"}constructor(node,name,nodeType=null){super(nodeType),this.node=node,this.name=name,this.isSubBuildNode=!0}getNodeType(builder){if(null!==this.nodeType)return this.nodeType;builder.addSubBuild(this.name);const nodeType=this.node.getNodeType(builder);return builder.removeSubBuild(),nodeType}build(builder,...params){builder.addSubBuild(this.name);const data=this.node.build(builder,...params);return builder.removeSubBuild(),data}}const subBuild=(node,name,type=null)=>nodeObject(new SubBuildNode(nodeObject(node),name,type));class VaryingNode extends Node$1{static get type(){return"VaryingNode"}constructor(node,name=null){super(),this.node=subBuild(node,"VERTEX"),this.name=name,this.isVaryingNode=!0,this.interpolationType=null,this.interpolationSampling=null,this.global=!0}setInterpolation(type,sampling=null){return this.interpolationType=type,this.interpolationSampling=sampling,this}getHash(builder){return this.name||super.getHash(builder)}getNodeType(builder){return this.node.getNodeType(builder)}setupVarying(builder){const properties=builder.getNodeProperties(this);let varying=properties.varying;if(void 0===varying){const name=this.name,type=this.getNodeType(builder),interpolationType=this.interpolationType,interpolationSampling=this.interpolationSampling;properties.varying=varying=builder.getVaryingFromNode(this,name,type,interpolationType,interpolationSampling),properties.node=subBuild(this.node,"VERTEX")}return varying.needsInterpolation||(varying.needsInterpolation="fragment"===builder.shaderStage),varying}setup(builder){this.setupVarying(builder),builder.flowNodeFromShaderStage(NodeShaderStage_VERTEX,this.node)}analyze(builder){this.setupVarying(builder),builder.flowNodeFromShaderStage(NodeShaderStage_VERTEX,this.node)}generate(builder){const propertyKey=builder.getSubBuildProperty("property",builder.currentStack),properties=builder.getNodeProperties(this),varying=this.setupVarying(builder);if(void 0===properties[propertyKey]){const type=this.getNodeType(builder),propertyName=builder.getPropertyName(varying,NodeShaderStage_VERTEX);builder.flowNodeFromShaderStage(NodeShaderStage_VERTEX,properties.node,type,propertyName),properties[propertyKey]=propertyName}return builder.getPropertyName(varying)}}const varying=/*@__PURE__*/nodeProxy(VaryingNode).setParameterLength(1,2);addMethodChaining("toVarying",varying),addMethodChaining("toVertexStage",node=>varying(node));const sRGBTransferEOTF=/*@__PURE__*/Fn(([color])=>{const a=color.mul(.9478672986).add(.0521327014).pow(2.4),b=color.mul(.0773993808),factor=color.lessThanEqual(.04045);return mix(a,b,factor)}).setLayout({name:"sRGBTransferEOTF",type:"vec3",inputs:[{name:"color",type:"vec3"}]}),sRGBTransferOETF=/*@__PURE__*/Fn(([color])=>{const a=color.pow(.41666).mul(1.055).sub(.055),b=color.mul(12.92),factor=color.lessThanEqual(.0031308);return mix(a,b,factor)}).setLayout({name:"sRGBTransferOETF",type:"vec3",inputs:[{name:"color",type:"vec3"}]});class ColorSpaceNode extends TempNode{static get type(){return"ColorSpaceNode"}constructor(colorNode,source,target){super("vec4"),this.colorNode=colorNode,this.source=source,this.target=target}resolveColorSpace(builder,colorSpace){return"WorkingColorSpace"===colorSpace?ColorManagement.workingColorSpace:"OutputColorSpace"===colorSpace?builder.context.outputColorSpace||builder.renderer.outputColorSpace:colorSpace}setup(builder){const{colorNode:colorNode}=this,source=this.resolveColorSpace(builder,this.source),target=this.resolveColorSpace(builder,this.target);let outputNode=colorNode;return!1!==ColorManagement.enabled&&source!==target&&source&&target?("srgb"===ColorManagement.getTransfer(source)&&(outputNode=vec4(sRGBTransferEOTF(outputNode.rgb),outputNode.a)),ColorManagement.getPrimaries(source)!==ColorManagement.getPrimaries(target)&&(outputNode=vec4(mat3(ColorManagement._getMatrix(new Matrix3,source,target)).mul(outputNode.rgb),outputNode.a)),"srgb"===ColorManagement.getTransfer(target)&&(outputNode=vec4(sRGBTransferOETF(outputNode.rgb),outputNode.a)),outputNode):outputNode}}const colorSpaceToWorking=(node,sourceColorSpace)=>nodeObject(new ColorSpaceNode(nodeObject(node),sourceColorSpace,"WorkingColorSpace"));addMethodChaining("workingToColorSpace",(node,targetColorSpace)=>nodeObject(new ColorSpaceNode(nodeObject(node),"WorkingColorSpace",targetColorSpace))),addMethodChaining("colorSpaceToWorking",colorSpaceToWorking);let ReferenceElementNode$1=class ReferenceElementNode extends ArrayElementNode{static get type(){return"ReferenceElementNode"}constructor(referenceNode,indexNode){super(referenceNode,indexNode),this.referenceNode=referenceNode,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(builder){const snippet=super.generate(builder),arrayType=this.referenceNode.getNodeType(),elementType=this.getNodeType();return builder.format(snippet,arrayType,elementType)}};class ReferenceBaseNode extends Node$1{static get type(){return"ReferenceBaseNode"}constructor(property,uniformType,object=null,count=null){super(),this.property=property,this.uniformType=uniformType,this.object=object,this.count=count,this.properties=property.split("."),this.reference=object,this.node=null,this.group=null,this.updateType=NodeUpdateType_OBJECT}setGroup(group){return this.group=group,this}element(indexNode){return new ReferenceElementNode$1(this,nodeObject(indexNode))}setNodeType(uniformType){const node=uniform(null,uniformType);null!==this.group&&node.setGroup(this.group),this.node=node}getNodeType(builder){return null===this.node&&(this.updateReference(builder),this.updateValue()),this.node.getNodeType(builder)}getValueFromReference(object=this.reference){const{properties:properties}=this;let value=object[properties[0]];for(let i=1;i<properties.length;i++)value=value[properties[i]];return value}updateReference(state){return this.reference=null!==this.object?this.object:state.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const value=this.getValueFromReference();Array.isArray(value)?this.node.array=value:this.node.value=value}}class RendererReferenceNode extends ReferenceBaseNode{static get type(){return"RendererReferenceNode"}constructor(property,inputType,renderer=null){super(property,inputType,renderer),this.renderer=renderer,this.setGroup(renderGroup)}updateReference(state){return this.reference=null!==this.renderer?this.renderer:state.renderer,this.reference}}const rendererReference=(name,type,renderer=null)=>new RendererReferenceNode(name,type,renderer);class ToneMappingNode extends TempNode{static get type(){return"ToneMappingNode"}constructor(toneMapping,exposureNode=toneMappingExposure,colorNode=null){super("vec3"),this._toneMapping=toneMapping,this.exposureNode=exposureNode,this.colorNode=colorNode}customCacheKey(){return hash$1(this._toneMapping)}setToneMapping(value){return this._toneMapping=value,this}getToneMapping(){return this._toneMapping}setup(builder){const colorNode=this.colorNode||builder.context.color,toneMapping=this._toneMapping;if(0===toneMapping)return colorNode;let outputNode=null;const toneMappingFn=builder.renderer.library.getToneMappingFunction(toneMapping);return null!==toneMappingFn?outputNode=vec4(toneMappingFn(colorNode.rgb,this.exposureNode),colorNode.a):(error("ToneMappingNode: Unsupported Tone Mapping configuration.",toneMapping),outputNode=colorNode),outputNode}}const toneMappingExposure=/*@__PURE__*/rendererReference("toneMappingExposure","float");addMethodChaining("toneMapping",(color,mapping,exposure)=>((mapping,exposure,color)=>nodeObject(new ToneMappingNode(mapping,nodeObject(exposure),nodeObject(color))))(mapping,exposure,color));const _bufferLib=new WeakMap;function _getBufferAttribute(value,itemSize){let buffer=_bufferLib.get(value);return void 0===buffer&&(buffer=new InterleavedBuffer(value,itemSize),_bufferLib.set(value,buffer)),buffer}class BufferAttributeNode extends InputNode{static get type(){return"BufferAttributeNode"}constructor(value,bufferType=null,bufferStride=0,bufferOffset=0){super(value,bufferType),this.isBufferNode=!0,this.bufferType=bufferType,this.bufferStride=bufferStride,this.bufferOffset=bufferOffset,this.usage=35044,this.instanced=!1,this.attribute=null,this.global=!0,value&&!0===value.isBufferAttribute&&value.itemSize<=4&&(this.attribute=value,this.usage=value.usage,this.instanced=value.isInstancedBufferAttribute)}getHash(builder){if(0===this.bufferStride&&0===this.bufferOffset){let bufferData=builder.globalCache.getData(this.value);return void 0===bufferData&&(bufferData={node:this},builder.globalCache.setData(this.value,bufferData)),bufferData.node.uuid}return this.uuid}getNodeType(builder){return null===this.bufferType&&(this.bufferType=builder.getTypeFromAttribute(this.attribute)),this.bufferType}setup(builder){if(null!==this.attribute)return;const type=this.getNodeType(builder),itemSize=builder.getTypeLength(type),value=this.value,stride=this.bufferStride||itemSize,offset=this.bufferOffset;let buffer;buffer=!0===value.isInterleavedBuffer?value:!0===value.isBufferAttribute?_getBufferAttribute(value.array,stride):_getBufferAttribute(value,stride);const bufferAttribute=new InterleavedBufferAttribute(buffer,itemSize,offset);buffer.setUsage(this.usage),this.attribute=bufferAttribute,this.attribute.isInstancedBufferAttribute=this.instanced}generate(builder){const nodeType=this.getNodeType(builder),nodeAttribute=builder.getBufferAttributeFromNode(this,nodeType),propertyName=builder.getPropertyName(nodeAttribute);let output=null;if("vertex"===builder.shaderStage||"compute"===builder.shaderStage)this.name=propertyName,output=propertyName;else{output=varying(this).build(builder,nodeType)}return output}getInputType(){return"bufferAttribute"}setUsage(value){return this.usage=value,this.attribute&&!0===this.attribute.isBufferAttribute&&(this.attribute.usage=value),this}setInstanced(value){return this.instanced=value,this}}function createBufferAttribute(array,type=null,stride=0,offset=0,usage=35044,instanced=!1){return"mat3"===type||null===type&&9===array.itemSize?mat3(new BufferAttributeNode(array,"vec3",9,0).setUsage(usage).setInstanced(instanced),new BufferAttributeNode(array,"vec3",9,3).setUsage(usage).setInstanced(instanced),new BufferAttributeNode(array,"vec3",9,6).setUsage(usage).setInstanced(instanced)):"mat4"===type||null===type&&16===array.itemSize?mat4(new BufferAttributeNode(array,"vec4",16,0).setUsage(usage).setInstanced(instanced),new BufferAttributeNode(array,"vec4",16,4).setUsage(usage).setInstanced(instanced),new BufferAttributeNode(array,"vec4",16,8).setUsage(usage).setInstanced(instanced),new BufferAttributeNode(array,"vec4",16,12).setUsage(usage).setInstanced(instanced)):new BufferAttributeNode(array,type,stride,offset).setUsage(usage)}const bufferAttribute=(array,type=null,stride=0,offset=0)=>createBufferAttribute(array,type,stride,offset),instancedBufferAttribute=(array,type=null,stride=0,offset=0)=>createBufferAttribute(array,type,stride,offset,35044,!0),instancedDynamicBufferAttribute=(array,type=null,stride=0,offset=0)=>createBufferAttribute(array,type,stride,offset,35048,!0);addMethodChaining("toAttribute",bufferNode=>bufferAttribute(bufferNode.value));class ComputeNode extends Node$1{static get type(){return"ComputeNode"}constructor(computeNode,workgroupSize){super("void"),this.isComputeNode=!0,this.computeNode=computeNode,this.workgroupSize=workgroupSize,this.count=null,this.version=1,this.name="",this.updateBeforeType=NodeUpdateType_OBJECT,this.onInitFunction=null}setCount(count){return this.count=count,this}getCount(){return this.count}dispose(){this.dispatchEvent({type:"dispose"})}setName(name){return this.name=name,this}label(name){return warn('TSL: "label()" has been deprecated. Use "setName()" instead.',new StackTrace),this.setName(name)}onInit(callback){return this.onInitFunction=callback,this}updateBefore({renderer:renderer}){renderer.compute(this)}setup(builder){const result=this.computeNode.build(builder);if(result){builder.getNodeProperties(this).outputComputeNode=result.outputNode,result.outputNode=null}return result}generate(builder,output){const{shaderStage:shaderStage}=builder;if("compute"===shaderStage){const snippet=this.computeNode.build(builder,"void");""!==snippet&&builder.addLineFlowCode(snippet,this)}else{const outputComputeNode=builder.getNodeProperties(this).outputComputeNode;if(outputComputeNode)return outputComputeNode.build(builder,output)}}}const computeKernel=(node,workgroupSize=[64])=>{(0===workgroupSize.length||workgroupSize.length>3)&&error("TSL: compute() workgroupSize must have 1, 2, or 3 elements",new StackTrace);for(let i=0;i<workgroupSize.length;i++){const val=workgroupSize[i];("number"!=typeof val||val<=0||!Number.isInteger(val))&&error(`TSL: compute() workgroupSize element at index [ ${i} ] must be a positive integer`,new StackTrace)}for(;workgroupSize.length<3;)workgroupSize.push(1);return nodeObject(new ComputeNode(nodeObject(node),workgroupSize))};addMethodChaining("compute",(node,count,workgroupSize)=>computeKernel(node,workgroupSize).setCount(count)),addMethodChaining("computeKernel",computeKernel);class IsolateNode extends Node$1{static get type(){return"IsolateNode"}constructor(node,parent=!0){super(),this.node=node,this.parent=parent,this.isIsolateNode=!0}getNodeType(builder){const previousCache=builder.getCache(),cache=builder.getCacheFromNode(this,this.parent);builder.setCache(cache);const nodeType=this.node.getNodeType(builder);return builder.setCache(previousCache),nodeType}build(builder,...params){const previousCache=builder.getCache(),cache=builder.getCacheFromNode(this,this.parent);builder.setCache(cache);const data=this.node.build(builder,...params);return builder.setCache(previousCache),data}setParent(parent){return this.parent=parent,this}getParent(){return this.parent}}const isolate=node=>new IsolateNode(nodeObject(node));addMethodChaining("cache",function cache(node,parent=!0){return warn('TSL: "cache()" has been deprecated. Use "isolate()" instead.'),isolate(node).setParent(parent)}),addMethodChaining("isolate",isolate);class BypassNode extends Node$1{static get type(){return"BypassNode"}constructor(outputNode,callNode){super(),this.isBypassNode=!0,this.outputNode=outputNode,this.callNode=callNode}getNodeType(builder){return this.outputNode.getNodeType(builder)}generate(builder){const snippet=this.callNode.build(builder,"void");return""!==snippet&&builder.addLineFlowCode(snippet,this),this.outputNode.build(builder)}}addMethodChaining("bypass",/*@__PURE__*/nodeProxy(BypassNode).setParameterLength(2));class RemapNode extends Node$1{static get type(){return"RemapNode"}constructor(node,inLowNode,inHighNode,outLowNode=float(0),outHighNode=float(1)){super(),this.node=node,this.inLowNode=inLowNode,this.inHighNode=inHighNode,this.outLowNode=outLowNode,this.outHighNode=outHighNode,this.doClamp=!0}setup(){const{node:node,inLowNode:inLowNode,inHighNode:inHighNode,outLowNode:outLowNode,outHighNode:outHighNode,doClamp:doClamp}=this;let t=node.sub(inLowNode).div(inHighNode.sub(inLowNode));return!0===doClamp&&(t=t.clamp()),t.mul(outHighNode.sub(outLowNode)).add(outLowNode)}}const remap=/*@__PURE__*/nodeProxy(RemapNode,null,null,{doClamp:!1}).setParameterLength(3,5),remapClamp=/*@__PURE__*/nodeProxy(RemapNode).setParameterLength(3,5);addMethodChaining("remap",remap),addMethodChaining("remapClamp",remapClamp);class ExpressionNode extends Node$1{static get type(){return"ExpressionNode"}constructor(snippet="",nodeType="void"){super(nodeType),this.snippet=snippet}generate(builder,output){const type=this.getNodeType(builder),snippet=this.snippet;if("void"!==type)return builder.format(snippet,type,output);builder.addLineFlowCode(snippet,this)}}const expression=/*@__PURE__*/nodeProxy(ExpressionNode).setParameterLength(1,2);addMethodChaining("discard",conditional=>(conditional?select(conditional,expression("discard")):expression("discard")).toStack());class RenderOutputNode extends TempNode{static get type(){return"RenderOutputNode"}constructor(colorNode,toneMapping,outputColorSpace){super("vec4"),this.colorNode=colorNode,this._toneMapping=toneMapping,this.outputColorSpace=outputColorSpace,this.isRenderOutputNode=!0}setToneMapping(value){return this._toneMapping=value,this}getToneMapping(){return this._toneMapping}setup({context:context}){let outputNode=this.colorNode||context.color;const toneMapping=(null!==this._toneMapping?this._toneMapping:context.toneMapping)||0,outputColorSpace=(null!==this.outputColorSpace?this.outputColorSpace:context.outputColorSpace)||"";return 0!==toneMapping&&(outputNode=outputNode.toneMapping(toneMapping)),""!==outputColorSpace&&outputColorSpace!==ColorManagement.workingColorSpace&&(outputNode=outputNode.workingToColorSpace(outputColorSpace)),outputNode}}const renderOutput=(color,toneMapping=null,outputColorSpace=null)=>nodeObject(new RenderOutputNode(nodeObject(color),toneMapping,outputColorSpace));addMethodChaining("renderOutput",renderOutput);class DebugNode extends TempNode{static get type(){return"DebugNode"}constructor(node,callback=null){super(),this.node=node,this.callback=callback}getNodeType(builder){return this.node.getNodeType(builder)}setup(builder){return this.node.build(builder)}analyze(builder){return this.node.build(builder)}generate(builder){const callback=this.callback,snippet=this.node.build(builder);if(null!==callback)callback(builder,snippet);else{const title="--- TSL debug - "+builder.shaderStage+" shader ---",border="-".repeat(title.length);let code="";code+="// #"+title+"#\n",code+=builder.flow.code.replace(/^\t/gm,"")+"\n",code+="/* ... */ "+snippet+" /* ... */\n",code+="// #"+border+"#\n",log$1(code)}return snippet}}addMethodChaining("debug",(node,callback=null)=>nodeObject(new DebugNode(nodeObject(node),callback)).toStack());class InspectorBase{constructor(){this._renderer=null,this.currentFrame=null}get nodeFrame(){return this._renderer._nodes.nodeFrame}setRenderer(renderer){return this._renderer=renderer,this}getRenderer(){return this._renderer}init(){}begin(){}finish(){}inspect(){}computeAsync(){}beginCompute(){}finishCompute(){}beginRender(){}finishRender(){}copyTextureToTexture(){}copyFramebufferToTexture(){}}class InspectorNode extends Node$1{static get type(){return"InspectorNode"}constructor(node,name="",callback=null){super(),this.node=node,this.name=name,this.callback=callback,this.updateType=NodeUpdateType_FRAME,this.isInspectorNode=!0}getName(){return this.name||this.node.name}update(frame){frame.renderer.inspector.inspect(this)}getNodeType(builder){return this.node.getNodeType(builder)}setup(builder){let node=this.node;return!0===builder.context.inspector&&null!==this.callback&&(node=this.callback(node)),!0!==builder.renderer.backend.isWebGPUBackend&&builder.renderer.inspector.constructor!==InspectorBase&&warnOnce('TSL: ".toInspector()" is only available with WebGPU.'),node}}addMethodChaining("toInspector",function inspector(node,name="",callback=null){return(node=nodeObject(node)).before(new InspectorNode(node,name,callback))});class AttributeNode extends Node$1{static get type(){return"AttributeNode"}constructor(attributeName,nodeType=null){super(nodeType),this.global=!0,this._attributeName=attributeName}getHash(builder){return this.getAttributeName(builder)}getNodeType(builder){let nodeType=this.nodeType;if(null===nodeType){const attributeName=this.getAttributeName(builder);if(builder.hasGeometryAttribute(attributeName)){const attribute=builder.geometry.getAttribute(attributeName);nodeType=builder.getTypeFromAttribute(attribute)}else nodeType="float"}return nodeType}setAttributeName(attributeName){return this._attributeName=attributeName,this}getAttributeName(){return this._attributeName}generate(builder){const attributeName=this.getAttributeName(builder),nodeType=this.getNodeType(builder);if(!0===builder.hasGeometryAttribute(attributeName)){const attribute=builder.geometry.getAttribute(attributeName),attributeType=builder.getTypeFromAttribute(attribute),nodeAttribute=builder.getAttribute(attributeName,attributeType);if("vertex"===builder.shaderStage)return builder.format(nodeAttribute.name,attributeType,nodeType);return varying(this).build(builder,nodeType)}return warn(`AttributeNode: Vertex attribute "${attributeName}" not found on geometry.`),builder.generateConst(nodeType)}serialize(data){super.serialize(data),data.global=this.global,data._attributeName=this._attributeName}deserialize(data){super.deserialize(data),this.global=data.global,this._attributeName=data._attributeName}}const attribute=(name,nodeType=null)=>new AttributeNode(name,nodeType),uv$1=(index=0)=>attribute("uv"+(index>0?index:""),"vec2");class TextureSizeNode extends Node$1{static get type(){return"TextureSizeNode"}constructor(textureNode,levelNode=null){super("uvec2"),this.isTextureSizeNode=!0,this.textureNode=textureNode,this.levelNode=levelNode}generate(builder,output){const textureProperty=this.textureNode.build(builder,"property"),level=null===this.levelNode?"0":this.levelNode.build(builder,"int");return builder.format(`${builder.getMethod("textureDimensions")}( ${textureProperty}, ${level} )`,this.getNodeType(builder),output)}}const textureSize=/*@__PURE__*/nodeProxy(TextureSizeNode).setParameterLength(1,2);class MaxMipLevelNode extends UniformNode{static get type(){return"MaxMipLevelNode"}constructor(textureNode){super(0),this._textureNode=textureNode,this.updateType=NodeUpdateType_FRAME}get textureNode(){return this._textureNode}get texture(){return this._textureNode.value}update(){const texture=this.texture,images=texture.images,image=images&&images.length>0?images[0]&&images[0].image||images[0]:texture.image;if(image&&void 0!==image.width){const{width:width,height:height}=image;this.value=Math.log2(Math.max(width,height))}}}const maxMipLevel=/*@__PURE__*/nodeProxy(MaxMipLevelNode).setParameterLength(1);class NodeError extends Error{constructor(message,stackTrace=null){super(message),this.name="NodeError",this.stackTrace=stackTrace}}const EmptyTexture$1=/*@__PURE__*/new Texture;class TextureNode extends UniformNode{static get type(){return"TextureNode"}constructor(value=EmptyTexture$1,uvNode=null,levelNode=null,biasNode=null){super(value),this.isTextureNode=!0,this.uvNode=uvNode,this.levelNode=levelNode,this.biasNode=biasNode,this.compareNode=null,this.depthNode=null,this.gradNode=null,this.offsetNode=null,this.sampler=!0,this.updateMatrix=!1,this.updateType=NodeUpdateType_NONE,this.referenceNode=null,this._value=value,this._matrixUniform=null,this._flipYUniform=null,this.setUpdateMatrix(null===uvNode)}set value(value){this.referenceNode?this.referenceNode.value=value:this._value=value}get value(){return this.referenceNode?this.referenceNode.value:this._value}getUniformHash(){return this.value.uuid}getNodeType(){return!0===this.value.isDepthTexture?"float":1014===this.value.type?"uvec4":1013===this.value.type?"ivec4":"vec4"}getInputType(){return"texture"}getDefaultUV(){return uv$1(this.value.channel)}updateReference(){return this.value}getTransformedUV(uvNode){return null===this._matrixUniform&&(this._matrixUniform=uniform(this.value.matrix)),this._matrixUniform.mul(vec3(uvNode,1)).xy}setUpdateMatrix(value){return this.updateMatrix=value,this}setupUV(builder,uvNode){return builder.isFlipY()&&(null===this._flipYUniform&&(this._flipYUniform=uniform(!1)),uvNode=uvNode.toVar(),uvNode=this.sampler?this._flipYUniform.select(uvNode.flipY(),uvNode):this._flipYUniform.select(uvNode.setY(int(textureSize(this,this.levelNode).y).sub(uvNode.y).sub(1)),uvNode)),uvNode}setup(builder){const properties=builder.getNodeProperties(this);properties.referenceNode=this.referenceNode;const texture=this.value;if(!texture||!0!==texture.isTexture)throw new NodeError("THREE.TSL: `texture( value )` function expects a valid instance of THREE.Texture().",this.stackTrace);const uvNode=Fn(()=>{let uvNode=this.uvNode;return null!==uvNode&&!0!==builder.context.forceUVContext||!builder.context.getUV||(uvNode=builder.context.getUV(this,builder)),uvNode||(uvNode=this.getDefaultUV()),!0===this.updateMatrix&&(uvNode=this.getTransformedUV(uvNode)),uvNode=this.setupUV(builder,uvNode),this.updateType=null!==this._matrixUniform||null!==this._flipYUniform?NodeUpdateType_OBJECT:NodeUpdateType_NONE,uvNode})();let levelNode=this.levelNode;null===levelNode&&builder.context.getTextureLevel&&(levelNode=builder.context.getTextureLevel(this));let compareNode=null,compareStepNode=null;null!==this.compareNode&&(builder.renderer.hasCompatibility(Compatibility_TEXTURE_COMPARE)?compareNode=this.compareNode:null===this.value.compareFunction||513===this.value.compareFunction?compareStepNode=this.compareNode:(compareNode=this.compareNode,warnOnce('TSL: Only "LessCompare" is supported for depth texture comparison fallback.'))),properties.uvNode=uvNode,properties.levelNode=levelNode,properties.biasNode=this.biasNode,properties.compareNode=compareNode,properties.compareStepNode=compareStepNode,properties.gradNode=this.gradNode,properties.depthNode=this.depthNode,properties.offsetNode=this.offsetNode}generateUV(builder,uvNode){return uvNode.build(builder,!0===this.sampler?"vec2":"ivec2")}generateOffset(builder,offsetNode){return offsetNode.build(builder,"ivec2")}generateSnippet(builder,textureProperty,uvSnippet,levelSnippet,biasSnippet,depthSnippet,compareSnippet,gradSnippet,offsetSnippet){const texture=this.value;let snippet;return snippet=biasSnippet?builder.generateTextureBias(texture,textureProperty,uvSnippet,biasSnippet,depthSnippet,offsetSnippet):gradSnippet?builder.generateTextureGrad(texture,textureProperty,uvSnippet,gradSnippet,depthSnippet,offsetSnippet):compareSnippet?builder.generateTextureCompare(texture,textureProperty,uvSnippet,compareSnippet,depthSnippet,offsetSnippet):!1===this.sampler?builder.generateTextureLoad(texture,textureProperty,uvSnippet,levelSnippet,depthSnippet,offsetSnippet):levelSnippet?builder.generateTextureLevel(texture,textureProperty,uvSnippet,levelSnippet,depthSnippet,offsetSnippet):builder.generateTexture(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet),snippet}generate(builder,output){const texture=this.value,properties=builder.getNodeProperties(this),textureProperty=super.generate(builder,"property");if(/^sampler/.test(output))return textureProperty+"_sampler";if(builder.isReference(output))return textureProperty;{const nodeData=builder.getDataFromNode(this),nodeType=this.getNodeType(builder);let propertyName=nodeData.propertyName;if(void 0===propertyName){const{uvNode:uvNode,levelNode:levelNode,biasNode:biasNode,compareNode:compareNode,compareStepNode:compareStepNode,depthNode:depthNode,gradNode:gradNode,offsetNode:offsetNode}=properties,uvSnippet=this.generateUV(builder,uvNode),levelSnippet=levelNode?levelNode.build(builder,"float"):null,biasSnippet=biasNode?biasNode.build(builder,"float"):null,depthSnippet=depthNode?depthNode.build(builder,"int"):null,compareSnippet=compareNode?compareNode.build(builder,"float"):null,compareStepSnippet=compareStepNode?compareStepNode.build(builder,"float"):null,gradSnippet=gradNode?[gradNode[0].build(builder,"vec2"),gradNode[1].build(builder,"vec2")]:null,offsetSnippet=offsetNode?this.generateOffset(builder,offsetNode):null,nodeVar=builder.getVarFromNode(this);propertyName=builder.getPropertyName(nodeVar);let snippet=this.generateSnippet(builder,textureProperty,uvSnippet,levelSnippet,biasSnippet,depthSnippet,compareSnippet,gradSnippet,offsetSnippet);null!==compareStepSnippet&&(snippet=step(expression(compareStepSnippet,"float"),expression(snippet,nodeType)).build(builder,nodeType)),builder.addLineFlowCode(`${propertyName} = ${snippet}`,this),nodeData.snippet=snippet,nodeData.propertyName=propertyName}let snippet=propertyName;return builder.needsToWorkingColorSpace(texture)&&(snippet=colorSpaceToWorking(expression(snippet,nodeType),texture.colorSpace).setup(builder).build(builder,nodeType)),builder.format(snippet,nodeType,output)}}setSampler(value){return this.sampler=value,this}getSampler(){return this.sampler}sample(uvNode){const textureNode=this.clone();return textureNode.uvNode=nodeObject(uvNode),textureNode.referenceNode=this.getBase(),nodeObject(textureNode)}load(uvNode){return this.sample(uvNode).setSampler(!1)}blur(amountNode){const textureNode=this.clone();textureNode.biasNode=nodeObject(amountNode).mul(maxMipLevel(textureNode)),textureNode.referenceNode=this.getBase();const map=textureNode.value;return!1===textureNode.generateMipmaps&&(map&&!1===map.generateMipmaps||1003===map.minFilter||1003===map.magFilter)&&(warn("TSL: texture().blur() requires mipmaps and sampling. Use .generateMipmaps=true and .minFilter/.magFilter=THREE.LinearFilter in the Texture."),textureNode.biasNode=null),nodeObject(textureNode)}level(levelNode){const textureNode=this.clone();return textureNode.levelNode=nodeObject(levelNode),textureNode.referenceNode=this.getBase(),nodeObject(textureNode)}size(levelNode){return textureSize(this,levelNode)}bias(biasNode){const textureNode=this.clone();return textureNode.biasNode=nodeObject(biasNode),textureNode.referenceNode=this.getBase(),nodeObject(textureNode)}getBase(){return this.referenceNode?this.referenceNode.getBase():this}compare(compareNode){const textureNode=this.clone();return textureNode.compareNode=nodeObject(compareNode),textureNode.referenceNode=this.getBase(),nodeObject(textureNode)}grad(gradNodeX,gradNodeY){const textureNode=this.clone();return textureNode.gradNode=[nodeObject(gradNodeX),nodeObject(gradNodeY)],textureNode.referenceNode=this.getBase(),nodeObject(textureNode)}depth(depthNode){const textureNode=this.clone();return textureNode.depthNode=nodeObject(depthNode),textureNode.referenceNode=this.getBase(),nodeObject(textureNode)}offset(offsetNode){const textureNode=this.clone();return textureNode.offsetNode=nodeObject(offsetNode),textureNode.referenceNode=this.getBase(),nodeObject(textureNode)}serialize(data){super.serialize(data),data.value=this.value.toJSON(data.meta).uuid,data.sampler=this.sampler,data.updateMatrix=this.updateMatrix,data.updateType=this.updateType}deserialize(data){super.deserialize(data),this.value=data.meta.textures[data.value],this.sampler=data.sampler,this.updateMatrix=data.updateMatrix,this.updateType=data.updateType}update(){const texture=this.value,matrixUniform=this._matrixUniform;null!==matrixUniform&&(matrixUniform.value=texture.matrix),!0===texture.matrixAutoUpdate&&texture.updateMatrix();const flipYUniform=this._flipYUniform;null!==flipYUniform&&(flipYUniform.value=texture.image instanceof ImageBitmap&&!0===texture.flipY||!0===texture.isRenderTargetTexture||!0===texture.isFramebufferTexture||!0===texture.isDepthTexture)}clone(){const newNode=new this.constructor(this.value,this.uvNode,this.levelNode,this.biasNode);return newNode.sampler=this.sampler,newNode.depthNode=this.depthNode,newNode.compareNode=this.compareNode,newNode.gradNode=this.gradNode,newNode.offsetNode=this.offsetNode,newNode}}const textureBase=/*@__PURE__*/nodeProxy(TextureNode).setParameterLength(1,4).setName("texture"),texture=(value=EmptyTexture$1,uvNode=null,levelNode=null,biasNode=null)=>{let textureNode;return value&&!0===value.isTextureNode?(textureNode=nodeObject(value.clone()),textureNode.referenceNode=value.getBase(),null!==uvNode&&(textureNode.uvNode=nodeObject(uvNode)),null!==levelNode&&(textureNode.levelNode=nodeObject(levelNode)),null!==biasNode&&(textureNode.biasNode=nodeObject(biasNode))):textureNode=textureBase(value,uvNode,levelNode,biasNode),textureNode},textureLoad=(...params)=>texture(...params).setSampler(!1);class BufferNode extends UniformNode{static get type(){return"BufferNode"}constructor(value,bufferType,bufferCount=0){super(value,bufferType),this.isBufferNode=!0,this.bufferType=bufferType,this.bufferCount=bufferCount,this.updateRanges=[]}addUpdateRange(start,count){this.updateRanges.push({start:start,count:count})}clearUpdateRanges(){this.updateRanges.length=0}getElementType(builder){return this.getNodeType(builder)}getInputType(){return"buffer"}}const buffer=(value,type,count)=>new BufferNode(value,type,count);class UniformArrayElementNode extends ArrayElementNode{static get type(){return"UniformArrayElementNode"}constructor(uniformArrayNode,indexNode){super(uniformArrayNode,indexNode),this.isArrayBufferElementNode=!0}generate(builder){const snippet=super.generate(builder),type=this.getNodeType(),paddedType=this.node.getPaddedType();return builder.format(snippet,paddedType,type)}}class UniformArrayNode extends BufferNode{static get type(){return"UniformArrayNode"}constructor(value,elementType=null){super(null),this.array=value,this.elementType=null===elementType?getValueType(value[0]):elementType,this.paddedType=this.getPaddedType(),this.updateType=NodeUpdateType_RENDER,this.isArrayBufferNode=!0}getNodeType(){return this.paddedType}getElementType(){return this.elementType}getPaddedType(){const elementType=this.elementType;let paddedType="vec4";return"mat2"===elementType?paddedType="mat2":!0===/mat/.test(elementType)?paddedType="mat4":"i"===elementType.charAt(0)?paddedType="ivec4":"u"===elementType.charAt(0)&&(paddedType="uvec4"),paddedType}update(){const{array:array,value:value}=this,elementType=this.elementType;if("float"===elementType||"int"===elementType||"uint"===elementType)for(let i=0;i<array.length;i++){value[4*i]=array[i]}else if("color"===elementType)for(let i=0;i<array.length;i++){const index=4*i,vector=array[i];value[index]=vector.r,value[index+1]=vector.g,value[index+2]=vector.b||0}else if("mat2"===elementType)for(let i=0;i<array.length;i++){const index=4*i,matrix=array[i];value[index]=matrix.elements[0],value[index+1]=matrix.elements[1],value[index+2]=matrix.elements[2],value[index+3]=matrix.elements[3]}else if("mat3"===elementType)for(let i=0;i<array.length;i++){const index=16*i,matrix=array[i];value[index]=matrix.elements[0],value[index+1]=matrix.elements[1],value[index+2]=matrix.elements[2],value[index+4]=matrix.elements[3],value[index+5]=matrix.elements[4],value[index+6]=matrix.elements[5],value[index+8]=matrix.elements[6],value[index+9]=matrix.elements[7],value[index+10]=matrix.elements[8],value[index+15]=1}else if("mat4"===elementType)for(let i=0;i<array.length;i++){const index=16*i,matrix=array[i];for(let i=0;i<matrix.elements.length;i++)value[index+i]=matrix.elements[i]}else for(let i=0;i<array.length;i++){const index=4*i,vector=array[i];value[index]=vector.x,value[index+1]=vector.y,value[index+2]=vector.z||0,value[index+3]=vector.w||0}}setup(builder){const length=this.array.length,elementType=this.elementType;let arrayType=Float32Array;const paddedType=this.paddedType,paddedElementLength=builder.getTypeLength(paddedType);return"i"===elementType.charAt(0)&&(arrayType=Int32Array),"u"===elementType.charAt(0)&&(arrayType=Uint32Array),this.value=new arrayType(length*paddedElementLength),this.bufferCount=length,this.bufferType=paddedType,this.update(),super.setup(builder)}element(indexNode){return new UniformArrayElementNode(this,nodeObject(indexNode))}}const uniformArray=(values,nodeType)=>new UniformArrayNode(values,nodeType);const builtin=nodeProxy(class BuiltinNode extends Node$1{constructor(name){super("float"),this.name=name,this.isBuiltinNode=!0}generate(){return this.name}}).setParameterLength(1);let _screenSizeVec,_viewportVec;class ScreenNode extends Node$1{static get type(){return"ScreenNode"}constructor(scope){super(),this.scope=scope,this._output=null,this.isViewportNode=!0}getNodeType(){return this.scope===ScreenNode.DPR?"float":this.scope===ScreenNode.VIEWPORT?"vec4":"vec2"}getUpdateType(){let updateType=NodeUpdateType_NONE;return this.scope!==ScreenNode.SIZE&&this.scope!==ScreenNode.VIEWPORT&&this.scope!==ScreenNode.DPR||(updateType=NodeUpdateType_RENDER),this.updateType=updateType,updateType}update({renderer:renderer}){const renderTarget=renderer.getRenderTarget();this.scope===ScreenNode.VIEWPORT?null!==renderTarget?_viewportVec.copy(renderTarget.viewport):(renderer.getViewport(_viewportVec),_viewportVec.multiplyScalar(renderer.getPixelRatio())):this.scope===ScreenNode.DPR?this._output.value=renderer.getPixelRatio():null!==renderTarget?(_screenSizeVec.width=renderTarget.width,_screenSizeVec.height=renderTarget.height):renderer.getDrawingBufferSize(_screenSizeVec)}setup(){const scope=this.scope;let output=null;return output=scope===ScreenNode.SIZE?uniform(_screenSizeVec||(_screenSizeVec=new Vector2)):scope===ScreenNode.VIEWPORT?uniform(_viewportVec||(_viewportVec=new Vector4)):scope===ScreenNode.DPR?uniform(1):vec2(screenCoordinate.div(screenSize)),this._output=output,output}generate(builder){if(this.scope===ScreenNode.COORDINATE){let coord=builder.getFragCoord();if(builder.isFlipY()){const size=builder.getNodeProperties(screenSize).outputNode.build(builder);coord=`${builder.getType("vec2")}( ${coord}.x, ${size}.y - ${coord}.y )`}return coord}return super.generate(builder)}}ScreenNode.COORDINATE="coordinate",ScreenNode.VIEWPORT="viewport",ScreenNode.SIZE="size",ScreenNode.UV="uv",ScreenNode.DPR="dpr";const screenDPR=/*@__PURE__*/nodeImmutable(ScreenNode,ScreenNode.DPR),screenUV=/*@__PURE__*/nodeImmutable(ScreenNode,ScreenNode.UV),screenSize=/*@__PURE__*/nodeImmutable(ScreenNode,ScreenNode.SIZE),screenCoordinate=/*@__PURE__*/nodeImmutable(ScreenNode,ScreenNode.COORDINATE),viewport=/*@__PURE__*/nodeImmutable(ScreenNode,ScreenNode.VIEWPORT),viewportSize=viewport.zw;viewport.xy;let _cameraProjectionMatrixBase=null,_cameraProjectionMatrixArray=null,_cameraProjectionMatrixInverseBase=null,_cameraProjectionMatrixInverseArray=null,_cameraViewMatrixBase=null,_cameraViewMatrixArray=null,_cameraPositionBase=null,_cameraPositionArray=null;const cameraIndex=/*@__PURE__*/uniform(0,"uint").setName("u_cameraIndex").setGroup(sharedUniformGroup("cameraIndex")).toVarying("v_cameraIndex"),cameraNear=/*@__PURE__*/uniform("float").setName("cameraNear").setGroup(renderGroup).onRenderUpdate(({camera:camera})=>camera.near),cameraFar=/*@__PURE__*/uniform("float").setName("cameraFar").setGroup(renderGroup).onRenderUpdate(({camera:camera})=>camera.far),cameraProjectionMatrix=/*@__PURE__*/Fn(({camera:camera})=>{let cameraProjectionMatrix;if(camera.isArrayCamera&&camera.cameras.length>0){const matrices=[];for(const subCamera of camera.cameras)matrices.push(subCamera.projectionMatrix);null===_cameraProjectionMatrixArray?_cameraProjectionMatrixArray=uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatrices"):_cameraProjectionMatrixArray.array=matrices,cameraProjectionMatrix=_cameraProjectionMatrixArray.element(camera.isMultiViewCamera?builtin("gl_ViewID_OVR"):cameraIndex).toConst("cameraProjectionMatrix")}else null===_cameraProjectionMatrixBase&&(_cameraProjectionMatrixBase=uniform(camera.projectionMatrix).setName("cameraProjectionMatrix").setGroup(renderGroup).onRenderUpdate(({camera:camera})=>camera.projectionMatrix)),cameraProjectionMatrix=_cameraProjectionMatrixBase;return cameraProjectionMatrix}).once()(),cameraProjectionMatrixInverse=/*@__PURE__*/Fn(({camera:camera})=>{let cameraProjectionMatrixInverse;if(camera.isArrayCamera&&camera.cameras.length>0){const matrices=[];for(const subCamera of camera.cameras)matrices.push(subCamera.projectionMatrixInverse);null===_cameraProjectionMatrixInverseArray?_cameraProjectionMatrixInverseArray=uniformArray(matrices).setGroup(renderGroup).setName("cameraProjectionMatricesInverse"):_cameraProjectionMatrixInverseArray.array=matrices,cameraProjectionMatrixInverse=_cameraProjectionMatrixInverseArray.element(camera.isMultiViewCamera?builtin("gl_ViewID_OVR"):cameraIndex).toConst("cameraProjectionMatrixInverse")}else null===_cameraProjectionMatrixInverseBase&&(_cameraProjectionMatrixInverseBase=uniform(camera.projectionMatrixInverse).setName("cameraProjectionMatrixInverse").setGroup(renderGroup).onRenderUpdate(({camera:camera})=>camera.projectionMatrixInverse)),cameraProjectionMatrixInverse=_cameraProjectionMatrixInverseBase;return cameraProjectionMatrixInverse}).once()(),cameraViewMatrix=/*@__PURE__*/Fn(({camera:camera})=>{let cameraViewMatrix;if(camera.isArrayCamera&&camera.cameras.length>0){const matrices=[];for(const subCamera of camera.cameras)matrices.push(subCamera.matrixWorldInverse);null===_cameraViewMatrixArray?_cameraViewMatrixArray=uniformArray(matrices).setGroup(renderGroup).setName("cameraViewMatrices"):_cameraViewMatrixArray.array=matrices,cameraViewMatrix=_cameraViewMatrixArray.element(camera.isMultiViewCamera?builtin("gl_ViewID_OVR"):cameraIndex).toConst("cameraViewMatrix")}else null===_cameraViewMatrixBase&&(_cameraViewMatrixBase=uniform(camera.matrixWorldInverse).setName("cameraViewMatrix").setGroup(renderGroup).onRenderUpdate(({camera:camera})=>camera.matrixWorldInverse)),cameraViewMatrix=_cameraViewMatrixBase;return cameraViewMatrix}).once()(),cameraPosition=/*@__PURE__*/Fn(({camera:camera})=>{let cameraPosition;if(camera.isArrayCamera&&camera.cameras.length>0){const positions=[];for(let i=0,l=camera.cameras.length;i<l;i++)positions.push(new Vector3);null===_cameraPositionArray?_cameraPositionArray=uniformArray(positions).setGroup(renderGroup).setName("cameraPositions").onRenderUpdate(({camera:camera},self)=>{const subCameras=camera.cameras,array=self.array;for(let i=0,l=subCameras.length;i<l;i++)array[i].setFromMatrixPosition(subCameras[i].matrixWorld)}):_cameraPositionArray.array=positions,cameraPosition=_cameraPositionArray.element(camera.isMultiViewCamera?builtin("gl_ViewID_OVR"):cameraIndex).toConst("cameraPosition")}else null===_cameraPositionBase&&(_cameraPositionBase=uniform(new Vector3).setName("cameraPosition").setGroup(renderGroup).onRenderUpdate(({camera:camera},self)=>self.value.setFromMatrixPosition(camera.matrixWorld))),cameraPosition=_cameraPositionBase;return cameraPosition}).once()(),_sphere=/*@__PURE__*/new Sphere;class Object3DNode extends Node$1{static get type(){return"Object3DNode"}constructor(scope,object3d=null){super(),this.scope=scope,this.object3d=object3d,this.updateType=NodeUpdateType_OBJECT,this.uniformNode=new UniformNode(null)}getNodeType(){const scope=this.scope;return scope===Object3DNode.WORLD_MATRIX?"mat4":scope===Object3DNode.POSITION||scope===Object3DNode.VIEW_POSITION||scope===Object3DNode.DIRECTION||scope===Object3DNode.SCALE?"vec3":scope===Object3DNode.RADIUS?"float":void 0}update(frame){const object=this.object3d,uniformNode=this.uniformNode,scope=this.scope;if(scope===Object3DNode.WORLD_MATRIX)uniformNode.value=object.matrixWorld;else if(scope===Object3DNode.POSITION)uniformNode.value=uniformNode.value||new Vector3,uniformNode.value.setFromMatrixPosition(object.matrixWorld);else if(scope===Object3DNode.SCALE)uniformNode.value=uniformNode.value||new Vector3,uniformNode.value.setFromMatrixScale(object.matrixWorld);else if(scope===Object3DNode.DIRECTION)uniformNode.value=uniformNode.value||new Vector3,object.getWorldDirection(uniformNode.value);else if(scope===Object3DNode.VIEW_POSITION){const camera=frame.camera;uniformNode.value=uniformNode.value||new Vector3,uniformNode.value.setFromMatrixPosition(object.matrixWorld),uniformNode.value.applyMatrix4(camera.matrixWorldInverse)}else if(scope===Object3DNode.RADIUS){const geometry=frame.object.geometry;null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere.copy(geometry.boundingSphere).applyMatrix4(object.matrixWorld),uniformNode.value=_sphere.radius}}generate(builder){const scope=this.scope;return scope===Object3DNode.WORLD_MATRIX?this.uniformNode.nodeType="mat4":scope===Object3DNode.POSITION||scope===Object3DNode.VIEW_POSITION||scope===Object3DNode.DIRECTION||scope===Object3DNode.SCALE?this.uniformNode.nodeType="vec3":scope===Object3DNode.RADIUS&&(this.uniformNode.nodeType="float"),this.uniformNode.build(builder)}serialize(data){super.serialize(data),data.scope=this.scope}deserialize(data){super.deserialize(data),this.scope=data.scope}}Object3DNode.WORLD_MATRIX="worldMatrix",Object3DNode.POSITION="position",Object3DNode.SCALE="scale",Object3DNode.VIEW_POSITION="viewPosition",Object3DNode.DIRECTION="direction",Object3DNode.RADIUS="radius";class ModelNode extends Object3DNode{static get type(){return"ModelNode"}constructor(scope){super(scope)}update(frame){this.object3d=frame.object,super.update(frame)}}
/*@__PURE__*/const modelWorldMatrix=/*@__PURE__*/nodeImmutable(ModelNode,ModelNode.WORLD_MATRIX),modelNormalMatrix=/*@__PURE__*/uniform(new Matrix3).onObjectUpdate(({object:object},self)=>self.value.getNormalMatrix(object.matrixWorld)),modelViewMatrix=/*@__PURE__*/Fn(builder=>builder.context.modelViewMatrix||mediumpModelViewMatrix).once()().toVar("modelViewMatrix"),mediumpModelViewMatrix=/*@__PURE__*/cameraViewMatrix.mul(modelWorldMatrix),highpModelViewMatrix=/*@__PURE__*/Fn(builder=>(builder.context.isHighPrecisionModelViewMatrix=!0,uniform("mat4").onObjectUpdate(({object:object,camera:camera})=>object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld)))).once()().toVar("highpModelViewMatrix"),highpModelNormalViewMatrix=/*@__PURE__*/Fn(builder=>{const isHighPrecisionModelViewMatrix=builder.context.isHighPrecisionModelViewMatrix;return uniform("mat3").onObjectUpdate(({object:object,camera:camera})=>(!0!==isHighPrecisionModelViewMatrix&&object.modelViewMatrix.multiplyMatrices(camera.matrixWorldInverse,object.matrixWorld),object.normalMatrix.getNormalMatrix(object.modelViewMatrix)))}).once()().toVar("highpModelNormalViewMatrix"),clipSpace=/*@__PURE__*/Fn(builder=>"fragment"!==builder.shaderStage?(warnOnce("TSL: `clipSpace` is only available in fragment stage."),vec4()):builder.context.clipSpace.toVarying("v_clipSpace")).once()(),positionGeometry=/*@__PURE__*/attribute("position","vec3"),positionLocal=/*@__PURE__*/positionGeometry.toVarying("positionLocal"),positionPrevious=/*@__PURE__*/positionGeometry.toVarying("positionPrevious"),positionWorld=/*@__PURE__*/Fn(builder=>modelWorldMatrix.mul(positionLocal).xyz.toVarying(builder.getSubBuildProperty("v_positionWorld")),"vec3").once(["POSITION"])(),positionWorldDirection=/*@__PURE__*/Fn(()=>positionLocal.transformDirection(modelWorldMatrix).toVarying("v_positionWorldDirection").normalize().toVar("positionWorldDirection"),"vec3").once(["POSITION"])(),positionView=/*@__PURE__*/Fn(builder=>{if("fragment"===builder.shaderStage&&builder.material.vertexNode){const viewPos=cameraProjectionMatrixInverse.mul(clipSpace);return viewPos.xyz.div(viewPos.w).toVar("positionView")}return builder.context.setupPositionView().toVarying("v_positionView")},"vec3").once(["POSITION","VERTEX"])(),positionViewDirection=/*@__PURE__*/Fn(builder=>{let output;return output=builder.camera.isOrthographicCamera?vec3(0,0,1):positionView.negate().toVarying("v_positionViewDirection").normalize(),output.toVar("positionViewDirection")},"vec3").once(["POSITION"])();
/*@__PURE__*/class FrontFacingNode extends Node$1{static get type(){return"FrontFacingNode"}constructor(){super("bool"),this.isFrontFacingNode=!0}generate(builder){if("fragment"!==builder.shaderStage)return"true";const{material:material}=builder;return 1===material.side?"false":builder.getFrontFacing()}}const faceDirection=/*@__PURE__*/float(/*@__PURE__*/nodeImmutable(FrontFacingNode)).mul(2).sub(1),directionToFaceDirection=/*@__PURE__*/Fn(([direction],{material:material})=>{const side=material.side;return 1===side?direction=direction.mul(-1):2===side&&(direction=direction.mul(faceDirection)),direction}),normalGeometry=/*@__PURE__*/attribute("normal","vec3"),normalLocal=/*@__PURE__*/Fn(builder=>!1===builder.geometry.hasAttribute("normal")?(warn('TSL: Vertex attribute "normal" not found on geometry.'),vec3(0,1,0)):normalGeometry,"vec3").once()().toVar("normalLocal"),normalFlat=/*@__PURE__*/positionView.dFdx().cross(positionView.dFdy()).normalize().toVar("normalFlat"),normalViewGeometry=/*@__PURE__*/Fn(builder=>{let node;return node=builder.isFlatShading()?normalFlat:transformNormalToView(normalLocal).toVarying("v_normalViewGeometry").normalize(),node},"vec3").once()().toVar("normalViewGeometry"),normalWorldGeometry=/*@__PURE__*/Fn(builder=>{let normal=normalViewGeometry.transformDirection(cameraViewMatrix);return!0!==builder.isFlatShading()&&(normal=normal.toVarying("v_normalWorldGeometry")),normal.normalize().toVar("normalWorldGeometry")},"vec3").once()(),normalView=/*@__PURE__*/Fn(builder=>{let node;return"NORMAL"===builder.subBuildFn||"VERTEX"===builder.subBuildFn?(node=normalViewGeometry,!0!==builder.isFlatShading()&&(node=directionToFaceDirection(node))):node=builder.context.setupNormal().context({getUV:null,getTextureLevel:null}),node},"vec3").once(["NORMAL","VERTEX"])().toVar("normalView"),normalWorld=/*@__PURE__*/normalView.transformDirection(cameraViewMatrix).toVar("normalWorld"),clearcoatNormalView=/*@__PURE__*/Fn(({subBuildFn:subBuildFn,context:context})=>{let node;return node="NORMAL"===subBuildFn||"VERTEX"===subBuildFn?normalView:context.setupClearcoatNormal().context({getUV:null,getTextureLevel:null}),node},"vec3").once(["NORMAL","VERTEX"])().toVar("clearcoatNormalView"),transformNormal=/*@__PURE__*/Fn(([normal,matrix=modelWorldMatrix])=>{const m=mat3(matrix),transformedNormal=normal.div(vec3(m[0].dot(m[0]),m[1].dot(m[1]),m[2].dot(m[2])));return m.mul(transformedNormal).xyz}),transformNormalToView=/*@__PURE__*/Fn(([normal],builder)=>{const modelNormalViewMatrix=builder.context.modelNormalViewMatrix;if(modelNormalViewMatrix)return modelNormalViewMatrix.transformDirection(normal);const transformedNormal=modelNormalMatrix.mul(normal);return cameraViewMatrix.transformDirection(transformedNormal)});Fn(()=>(warn('TSL: "transformedNormalView" is deprecated. Use "normalView" instead.'),normalView)).once(["NORMAL","VERTEX"])(),Fn(()=>(warn('TSL: "transformedNormalWorld" is deprecated. Use "normalWorld" instead.'),normalWorld)).once(["NORMAL","VERTEX"])(),Fn(()=>(warn('TSL: "transformedClearcoatNormalView" is deprecated. Use "clearcoatNormalView" instead.'),clearcoatNormalView)).once(["NORMAL","VERTEX"])();const _e1$1=/*@__PURE__*/new Euler,_m1$1=/*@__PURE__*/new Matrix4,materialRefractionRatio=/*@__PURE__*/uniform(0).onReference(({material:material})=>material).onObjectUpdate(({material:material})=>material.refractionRatio),materialEnvIntensity=/*@__PURE__*/uniform(1).onReference(({material:material})=>material).onObjectUpdate(function({material:material,scene:scene}){return material.envMap?material.envMapIntensity:scene.environmentIntensity}),materialEnvRotation=/*@__PURE__*/uniform(new Matrix4).onReference(function(frame){return frame.material}).onObjectUpdate(function({material:material,scene:scene}){const rotation=null!==scene.environment&&null===material.envMap?scene.environmentRotation:material.envMapRotation;return rotation?(_e1$1.copy(rotation),_m1$1.makeRotationFromEuler(_e1$1)):_m1$1.identity(),_m1$1}),reflectView=/*@__PURE__*/positionViewDirection.negate().reflect(normalView),refractView=/*@__PURE__*/positionViewDirection.negate().refract(normalView,materialRefractionRatio),reflectVector=/*@__PURE__*/reflectView.transformDirection(cameraViewMatrix).toVar("reflectVector"),refractVector=/*@__PURE__*/refractView.transformDirection(cameraViewMatrix).toVar("reflectVector"),EmptyTexture=/*@__PURE__*/new CubeTexture;class CubeTextureNode extends TextureNode{static get type(){return"CubeTextureNode"}constructor(value,uvNode=null,levelNode=null,biasNode=null){super(value,uvNode,levelNode,biasNode),this.isCubeTextureNode=!0}getInputType(){return!0===this.value.isDepthTexture?"cubeDepthTexture":"cubeTexture"}getDefaultUV(){const texture=this.value;return 301===texture.mapping?reflectVector:302===texture.mapping?refractVector:(error('CubeTextureNode: Mapping "%s" not supported.',texture.mapping),vec3(0,0,0))}setUpdateMatrix(){}setupUV(builder,uvNode){const texture=this.value;return!0===texture.isDepthTexture?2001===builder.renderer.coordinateSystem?vec3(uvNode.x,uvNode.y.negate(),uvNode.z):uvNode:(2001!==builder.renderer.coordinateSystem&&texture.isRenderTargetTexture||(uvNode=vec3(uvNode.x.negate(),uvNode.yz)),materialEnvRotation.mul(uvNode))}generateUV(builder,cubeUV){return cubeUV.build(builder,!0===this.sampler?"vec3":"ivec3")}}const cubeTextureBase=/*@__PURE__*/nodeProxy(CubeTextureNode).setParameterLength(1,4).setName("cubeTexture"),cubeTexture=(value=EmptyTexture,uvNode=null,levelNode=null,biasNode=null)=>{let textureNode;return value&&!0===value.isCubeTextureNode?(textureNode=nodeObject(value.clone()),textureNode.referenceNode=value,null!==uvNode&&(textureNode.uvNode=nodeObject(uvNode)),null!==levelNode&&(textureNode.levelNode=nodeObject(levelNode)),null!==biasNode&&(textureNode.biasNode=nodeObject(biasNode))):textureNode=cubeTextureBase(value,uvNode,levelNode,biasNode),textureNode};class ReferenceElementNode extends ArrayElementNode{static get type(){return"ReferenceElementNode"}constructor(referenceNode,indexNode){super(referenceNode,indexNode),this.referenceNode=referenceNode,this.isReferenceElementNode=!0}getNodeType(){return this.referenceNode.uniformType}generate(builder){const snippet=super.generate(builder),arrayType=this.referenceNode.getNodeType(),elementType=this.getNodeType();return builder.format(snippet,arrayType,elementType)}}class ReferenceNode extends Node$1{static get type(){return"ReferenceNode"}constructor(property,uniformType,object=null,count=null){super(),this.property=property,this.uniformType=uniformType,this.object=object,this.count=count,this.properties=property.split("."),this.reference=object,this.node=null,this.group=null,this.name=null,this.updateType=NodeUpdateType_OBJECT}element(indexNode){return new ReferenceElementNode(this,nodeObject(indexNode))}setGroup(group){return this.group=group,this}setName(name){return this.name=name,this}label(name){return warn('TSL: "label()" has been deprecated. Use "setName()" instead.'),this.setName(name)}setNodeType(uniformType){let node=null;node=null!==this.count?buffer(null,uniformType,this.count):Array.isArray(this.getValueFromReference())?uniformArray(null,uniformType):"texture"===uniformType?texture(null):"cubeTexture"===uniformType?cubeTexture(null):uniform(null,uniformType),null!==this.group&&node.setGroup(this.group),null!==this.name&&node.setName(this.name),this.node=node}getNodeType(builder){return null===this.node&&(this.updateReference(builder),this.updateValue()),this.node.getNodeType(builder)}getValueFromReference(object=this.reference){const{properties:properties}=this;let value=object[properties[0]];for(let i=1;i<properties.length;i++)value=value[properties[i]];return value}updateReference(state){return this.reference=null!==this.object?this.object:state.object,this.reference}setup(){return this.updateValue(),this.node}update(){this.updateValue()}updateValue(){null===this.node&&this.setNodeType(this.uniformType);const value=this.getValueFromReference();Array.isArray(value)?this.node.array=value:this.node.value=value}}const reference=(name,type,object)=>new ReferenceNode(name,type,object),referenceBuffer=(name,type,count,object)=>new ReferenceNode(name,type,object,count);class MaterialReferenceNode extends ReferenceNode{static get type(){return"MaterialReferenceNode"}constructor(property,inputType,material=null){super(property,inputType,material),this.material=material,this.isMaterialReferenceNode=!0}updateReference(state){return this.reference=null!==this.material?this.material:state.material,this.reference}}const materialReference=(name,type,material=null)=>new MaterialReferenceNode(name,type,material),uv=uv$1(),q0=positionView.dFdx(),q1=positionView.dFdy(),st0=uv.dFdx(),st1=uv.dFdy(),N=normalView,q1perp=q1.cross(N),q0perp=N.cross(q0),T=q1perp.mul(st0.x).add(q0perp.mul(st1.x)),B=q1perp.mul(st0.y).add(q0perp.mul(st1.y)),det=T.dot(T).max(B.dot(B)),scale$1=det.equal(0).select(0,det.inverseSqrt()),tangentViewFrame=/*@__PURE__*/T.mul(scale$1).toVar("tangentViewFrame"),bitangentViewFrame=/*@__PURE__*/B.mul(scale$1).toVar("bitangentViewFrame"),tangentGeometry=/*@__PURE__*/attribute("tangent","vec4"),tangentLocal=/*@__PURE__*/tangentGeometry.xyz.toVar("tangentLocal"),tangentView=/*@__PURE__*/Fn(builder=>{let node;return node="VERTEX"===builder.subBuildFn||builder.geometry.hasAttribute("tangent")?modelViewMatrix.mul(vec4(tangentLocal,0)).xyz.toVarying("v_tangentView").normalize():tangentViewFrame,!0!==builder.isFlatShading()&&(node=directionToFaceDirection(node)),node},"vec3").once(["NORMAL","VERTEX"])().toVar("tangentView"),getBitangent=/*@__PURE__*/Fn(([crossNormalTangent,varyingName],builder)=>{let bitangent=crossNormalTangent.mul(tangentGeometry.w).xyz;return"NORMAL"===builder.subBuildFn&&!0!==builder.isFlatShading()&&(bitangent=bitangent.toVarying(varyingName)),bitangent}).once(["NORMAL"]),TBNViewMatrix=/*@__PURE__*/mat3(tangentView,/*@__PURE__*/Fn(builder=>{let node;return node="VERTEX"===builder.subBuildFn||builder.geometry.hasAttribute("tangent")?getBitangent(normalView.cross(tangentView),"v_bitangentView").normalize():bitangentViewFrame,!0!==builder.isFlatShading()&&(node=directionToFaceDirection(node)),node},"vec3").once(["NORMAL","VERTEX"])().toVar("bitangentView"),normalView).toVar("TBNViewMatrix"),bentNormalView=/*@__PURE__*/Fn(()=>{let bentNormal=anisotropyB.cross(positionViewDirection);return bentNormal=bentNormal.cross(anisotropyB).normalize(),bentNormal=mix(bentNormal,normalView,anisotropy.mul(roughness.oneMinus()).oneMinus().pow2().pow2()).normalize(),bentNormal}).once()(),unpackNormal=xy=>vec3(xy,sqrt(saturate(float(1).sub(dot(xy,xy)))));class NormalMapNode extends TempNode{static get type(){return"NormalMapNode"}constructor(node,scaleNode=null){super("vec3"),this.node=node,this.scaleNode=scaleNode,this.normalMapType=0,this.unpackNormalMode=""}setup(builder){const{normalMapType:normalMapType,scaleNode:scaleNode,unpackNormalMode:unpackNormalMode}=this;let normalMap=this.node.mul(2).sub(1);if(0===normalMapType?"rg"===unpackNormalMode?normalMap=unpackNormal(normalMap.xy):"ga"===unpackNormalMode?normalMap=unpackNormal(normalMap.yw):""!==unpackNormalMode&&console.error(`THREE.NodeMaterial: Unexpected unpack normal mode: ${unpackNormalMode}`):""!==unpackNormalMode&&console.error(`THREE.NodeMaterial: Normal map type '${normalMapType}' is not compatible with unpack normal mode '${unpackNormalMode}'`),null!==scaleNode){let scale=scaleNode;!0===builder.isFlatShading()&&(scale=directionToFaceDirection(scale)),normalMap=vec3(normalMap.xy.mul(scale),normalMap.z)}let output=null;return 1===normalMapType?output=transformNormalToView(normalMap):0===normalMapType?output=TBNViewMatrix.mul(normalMap).normalize():(error(`NodeMaterial: Unsupported normal map type: ${normalMapType}`),output=normalView),output}}const normalMap=/*@__PURE__*/nodeProxy(NormalMapNode).setParameterLength(1,2),dHdxy_fwd=Fn(({textureNode:textureNode,bumpScale:bumpScale})=>{const sampleTexture=callback=>textureNode.isolate().context({getUV:texNode=>callback(texNode.uvNode||uv$1()),forceUVContext:!0}),Hll=float(sampleTexture(uvNode=>uvNode));return vec2(float(sampleTexture(uvNode=>uvNode.add(uvNode.dFdx()))).sub(Hll),float(sampleTexture(uvNode=>uvNode.add(uvNode.dFdy()))).sub(Hll)).mul(bumpScale)}),perturbNormalArb=Fn(inputs=>{const{surf_pos:surf_pos,surf_norm:surf_norm,dHdxy:dHdxy}=inputs,vSigmaX=surf_pos.dFdx().normalize(),vN=surf_norm,R1=surf_pos.dFdy().normalize().cross(vN),R2=vN.cross(vSigmaX),fDet=vSigmaX.dot(R1).mul(faceDirection),vGrad=fDet.sign().mul(dHdxy.x.mul(R1).add(dHdxy.y.mul(R2)));return fDet.abs().mul(surf_norm).sub(vGrad).normalize()});class BumpMapNode extends TempNode{static get type(){return"BumpMapNode"}constructor(textureNode,scaleNode=null){super("vec3"),this.textureNode=textureNode,this.scaleNode=scaleNode}setup(){const bumpScale=null!==this.scaleNode?this.scaleNode:1,dHdxy=dHdxy_fwd({textureNode:this.textureNode,bumpScale:bumpScale});return perturbNormalArb({surf_pos:positionView,surf_norm:normalView,dHdxy:dHdxy})}}const bumpMap=/*@__PURE__*/nodeProxy(BumpMapNode).setParameterLength(1,2),_propertyCache=new Map;class MaterialNode extends Node$1{static get type(){return"MaterialNode"}constructor(scope){super(),this.scope=scope}getCache(property,type){let node=_propertyCache.get(property);return void 0===node&&(node=materialReference(property,type),_propertyCache.set(property,node)),node}getFloat(property){return this.getCache(property,"float")}getColor(property){return this.getCache(property,"color")}getTexture(property){return this.getCache("map"===property?"map":property+"Map","texture")}setup(builder){const material=builder.context.material,scope=this.scope;let node=null;if(scope===MaterialNode.COLOR){const colorNode=void 0!==material.color?this.getColor(scope):vec3();node=material.map&&!0===material.map.isTexture?colorNode.mul(this.getTexture("map")):colorNode}else if(scope===MaterialNode.OPACITY){const opacityNode=this.getFloat(scope);node=material.alphaMap&&!0===material.alphaMap.isTexture?opacityNode.mul(this.getTexture("alpha")):opacityNode}else if(scope===MaterialNode.SPECULAR_STRENGTH)node=material.specularMap&&!0===material.specularMap.isTexture?this.getTexture("specular").r:float(1);else if(scope===MaterialNode.SPECULAR_INTENSITY){const specularIntensityNode=this.getFloat(scope);node=material.specularIntensityMap&&!0===material.specularIntensityMap.isTexture?specularIntensityNode.mul(this.getTexture(scope).a):specularIntensityNode}else if(scope===MaterialNode.SPECULAR_COLOR){const specularColorNode=this.getColor(scope);node=material.specularColorMap&&!0===material.specularColorMap.isTexture?specularColorNode.mul(this.getTexture(scope).rgb):specularColorNode}else if(scope===MaterialNode.ROUGHNESS){const roughnessNode=this.getFloat(scope);node=material.roughnessMap&&!0===material.roughnessMap.isTexture?roughnessNode.mul(this.getTexture(scope).g):roughnessNode}else if(scope===MaterialNode.METALNESS){const metalnessNode=this.getFloat(scope);node=material.metalnessMap&&!0===material.metalnessMap.isTexture?metalnessNode.mul(this.getTexture(scope).b):metalnessNode}else if(scope===MaterialNode.EMISSIVE){const emissiveIntensityNode=this.getFloat("emissiveIntensity"),emissiveNode=this.getColor(scope).mul(emissiveIntensityNode);node=material.emissiveMap&&!0===material.emissiveMap.isTexture?emissiveNode.mul(this.getTexture(scope)):emissiveNode}else if(scope===MaterialNode.NORMAL)material.normalMap?(node=normalMap(this.getTexture("normal"),this.getCache("normalScale","vec2")),node.normalMapType=material.normalMapType,1030!=material.normalMap.format&&36285!=material.normalMap.format&&37490!=material.normalMap.format||(node.unpackNormalMode="rg")):node=material.bumpMap?bumpMap(this.getTexture("bump").r,this.getFloat("bumpScale")):normalView;else if(scope===MaterialNode.CLEARCOAT){const clearcoatNode=this.getFloat(scope);node=material.clearcoatMap&&!0===material.clearcoatMap.isTexture?clearcoatNode.mul(this.getTexture(scope).r):clearcoatNode}else if(scope===MaterialNode.CLEARCOAT_ROUGHNESS){const clearcoatRoughnessNode=this.getFloat(scope);node=material.clearcoatRoughnessMap&&!0===material.clearcoatRoughnessMap.isTexture?clearcoatRoughnessNode.mul(this.getTexture(scope).r):clearcoatRoughnessNode}else if(scope===MaterialNode.CLEARCOAT_NORMAL)node=material.clearcoatNormalMap?normalMap(this.getTexture(scope),this.getCache(scope+"Scale","vec2")):normalView;else if(scope===MaterialNode.SHEEN){const sheenNode=this.getColor("sheenColor").mul(this.getFloat("sheen"));node=material.sheenColorMap&&!0===material.sheenColorMap.isTexture?sheenNode.mul(this.getTexture("sheenColor").rgb):sheenNode}else if(scope===MaterialNode.SHEEN_ROUGHNESS){const sheenRoughnessNode=this.getFloat(scope);node=material.sheenRoughnessMap&&!0===material.sheenRoughnessMap.isTexture?sheenRoughnessNode.mul(this.getTexture(scope).a):sheenRoughnessNode,node=node.clamp(1e-4,1)}else if(scope===MaterialNode.ANISOTROPY)if(material.anisotropyMap&&!0===material.anisotropyMap.isTexture){const anisotropyPolar=this.getTexture(scope);node=mat2(materialAnisotropyVector.x,materialAnisotropyVector.y,materialAnisotropyVector.y.negate(),materialAnisotropyVector.x).mul(anisotropyPolar.rg.mul(2).sub(vec2(1)).normalize().mul(anisotropyPolar.b))}else node=materialAnisotropyVector;else if(scope===MaterialNode.IRIDESCENCE_THICKNESS){const iridescenceThicknessMaximum=reference("1","float",material.iridescenceThicknessRange);if(material.iridescenceThicknessMap){const iridescenceThicknessMinimum=reference("0","float",material.iridescenceThicknessRange);node=iridescenceThicknessMaximum.sub(iridescenceThicknessMinimum).mul(this.getTexture(scope).g).add(iridescenceThicknessMinimum)}else node=iridescenceThicknessMaximum}else if(scope===MaterialNode.TRANSMISSION){const transmissionNode=this.getFloat(scope);node=material.transmissionMap?transmissionNode.mul(this.getTexture(scope).r):transmissionNode}else if(scope===MaterialNode.THICKNESS){const thicknessNode=this.getFloat(scope);node=material.thicknessMap?thicknessNode.mul(this.getTexture(scope).g):thicknessNode}else if(scope===MaterialNode.IOR)node=this.getFloat(scope);else if(scope===MaterialNode.LIGHT_MAP)node=this.getTexture(scope).rgb.mul(this.getFloat("lightMapIntensity"));else if(scope===MaterialNode.AO)node=this.getTexture(scope).r.sub(1).mul(this.getFloat("aoMapIntensity")).add(1);else if(scope===MaterialNode.LINE_DASH_OFFSET)node=material.dashOffset?this.getFloat(scope):float(0);else{const outputType=this.getNodeType(builder);node=this.getCache(scope,outputType)}return node}}MaterialNode.ALPHA_TEST="alphaTest",MaterialNode.COLOR="color",MaterialNode.OPACITY="opacity",MaterialNode.SHININESS="shininess",MaterialNode.SPECULAR="specular",MaterialNode.SPECULAR_STRENGTH="specularStrength",MaterialNode.SPECULAR_INTENSITY="specularIntensity",MaterialNode.SPECULAR_COLOR="specularColor",MaterialNode.REFLECTIVITY="reflectivity",MaterialNode.ROUGHNESS="roughness",MaterialNode.METALNESS="metalness",MaterialNode.NORMAL="normal",MaterialNode.CLEARCOAT="clearcoat",MaterialNode.CLEARCOAT_ROUGHNESS="clearcoatRoughness",MaterialNode.CLEARCOAT_NORMAL="clearcoatNormal",MaterialNode.EMISSIVE="emissive",MaterialNode.ROTATION="rotation",MaterialNode.SHEEN="sheen",MaterialNode.SHEEN_ROUGHNESS="sheenRoughness",MaterialNode.ANISOTROPY="anisotropy",MaterialNode.IRIDESCENCE="iridescence",MaterialNode.IRIDESCENCE_IOR="iridescenceIOR",MaterialNode.IRIDESCENCE_THICKNESS="iridescenceThickness",MaterialNode.IOR="ior",MaterialNode.TRANSMISSION="transmission",MaterialNode.THICKNESS="thickness",MaterialNode.ATTENUATION_DISTANCE="attenuationDistance",MaterialNode.ATTENUATION_COLOR="attenuationColor",MaterialNode.LINE_SCALE="scale",MaterialNode.LINE_DASH_SIZE="dashSize",MaterialNode.LINE_GAP_SIZE="gapSize",MaterialNode.LINE_WIDTH="linewidth",MaterialNode.LINE_DASH_OFFSET="dashOffset",MaterialNode.POINT_SIZE="size",MaterialNode.DISPERSION="dispersion",MaterialNode.LIGHT_MAP="light",MaterialNode.AO="ao";const materialAlphaTest=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.ALPHA_TEST),materialColor=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.COLOR),materialShininess=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.SHININESS),materialEmissive=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.EMISSIVE),materialOpacity=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.OPACITY),materialSpecular=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.SPECULAR),materialSpecularIntensity=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.SPECULAR_INTENSITY),materialSpecularColor=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.SPECULAR_COLOR),materialSpecularStrength=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.SPECULAR_STRENGTH),materialReflectivity=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.REFLECTIVITY),materialRoughness=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.ROUGHNESS),materialMetalness=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.METALNESS),materialNormal=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.NORMAL),materialClearcoat=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.CLEARCOAT),materialClearcoatRoughness=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.CLEARCOAT_ROUGHNESS),materialClearcoatNormal=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.CLEARCOAT_NORMAL),materialRotation=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.ROTATION),materialSheen=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.SHEEN),materialSheenRoughness=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.SHEEN_ROUGHNESS),materialAnisotropy=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.ANISOTROPY),materialIridescence=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.IRIDESCENCE),materialIridescenceIOR=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.IRIDESCENCE_IOR),materialIridescenceThickness=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.IRIDESCENCE_THICKNESS),materialTransmission=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.TRANSMISSION),materialThickness=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.THICKNESS),materialIOR=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.IOR),materialAttenuationDistance=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.ATTENUATION_DISTANCE),materialAttenuationColor=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.ATTENUATION_COLOR),materialLineScale=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.LINE_SCALE),materialLineDashSize=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.LINE_DASH_SIZE),materialLineGapSize=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.LINE_GAP_SIZE);MaterialNode.LINE_WIDTH;const materialLineDashOffset=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.LINE_DASH_OFFSET),materialPointSize=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.POINT_SIZE),materialDispersion=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.DISPERSION),materialLightMap=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.LIGHT_MAP),materialAO=/*@__PURE__*/nodeImmutable(MaterialNode,MaterialNode.AO),materialAnisotropyVector=/*@__PURE__*/uniform(new Vector2).onReference(function(frame){return frame.material}).onRenderUpdate(function({material:material}){this.value.set(material.anisotropy*Math.cos(material.anisotropyRotation),material.anisotropy*Math.sin(material.anisotropyRotation))}),modelViewProjection=/*@__PURE__*/Fn(builder=>builder.context.setupModelViewProjection(),"vec4").once()().toVarying("v_modelViewProjection");class StorageArrayElementNode extends ArrayElementNode{static get type(){return"StorageArrayElementNode"}constructor(storageBufferNode,indexNode){super(storageBufferNode,indexNode),this.isStorageArrayElementNode=!0}set storageBufferNode(value){this.node=value}get storageBufferNode(){return this.node}getMemberType(builder,name){const structTypeNode=this.storageBufferNode.structTypeNode;return structTypeNode?structTypeNode.getMemberType(builder,name):"void"}setup(builder){return!1===builder.isAvailable("storageBuffer")&&!0===this.node.isPBO&&builder.setupPBO(this.node),super.setup(builder)}generate(builder,output){let snippet;const isAssignContext=builder.context.assign;if(snippet=!1===builder.isAvailable("storageBuffer")?!0!==this.node.isPBO||!0===isAssignContext||!this.node.value.isInstancedBufferAttribute&&"compute"===builder.shaderStage?this.node.build(builder):builder.generatePBO(this):super.generate(builder),!0!==isAssignContext){const type=this.getNodeType(builder);snippet=builder.format(snippet,type,output)}return snippet}}const storageElement=/*@__PURE__*/nodeProxy(StorageArrayElementNode).setParameterLength(2);class StorageBufferNode extends BufferNode{static get type(){return"StorageBufferNode"}constructor(value,bufferType=null,bufferCount=0){let nodeType,structTypeNode=null;bufferType&&bufferType.isStruct?(nodeType="struct",structTypeNode=bufferType.layout,(value.isStorageBufferAttribute||value.isStorageInstancedBufferAttribute)&&(bufferCount=value.count)):null===bufferType&&(value.isStorageBufferAttribute||value.isStorageInstancedBufferAttribute)?(nodeType=getTypeFromLength(value.itemSize),bufferCount=value.count):nodeType=bufferType,super(value,nodeType,bufferCount),this.isStorageBufferNode=!0,this.structTypeNode=structTypeNode,this.access=NodeAccess_READ_WRITE,this.isAtomic=!1,this.isPBO=!1,this._attribute=null,this._varying=null,this.global=!0,!0!==value.isStorageBufferAttribute&&!0!==value.isStorageInstancedBufferAttribute&&(value.isInstancedBufferAttribute?value.isStorageInstancedBufferAttribute=!0:value.isStorageBufferAttribute=!0)}getHash(builder){if(0===this.bufferCount){let bufferData=builder.globalCache.getData(this.value);return void 0===bufferData&&(bufferData={node:this},builder.globalCache.setData(this.value,bufferData)),bufferData.node.uuid}return this.uuid}getInputType(){return this.value.isIndirectStorageBufferAttribute?"indirectStorageBuffer":"storageBuffer"}element(indexNode){return storageElement(this,indexNode)}setPBO(value){return this.isPBO=value,this}getPBO(){return this.isPBO}setAccess(value){return this.access=value,this}toReadOnly(){return this.setAccess(NodeAccess_READ_ONLY)}setAtomic(value){return this.isAtomic=value,this}toAtomic(){return this.setAtomic(!0)}getAttributeData(){return null===this._attribute&&(this._attribute=bufferAttribute(this.value),this._varying=varying(this._attribute)),{attribute:this._attribute,varying:this._varying}}getNodeType(builder){if(null!==this.structTypeNode)return this.structTypeNode.getNodeType(builder);if(builder.isAvailable("storageBuffer")||builder.isAvailable("indirectStorageBuffer"))return super.getNodeType(builder);const{attribute:attribute}=this.getAttributeData();return attribute.getNodeType(builder)}getMemberType(builder,name){return null!==this.structTypeNode?this.structTypeNode.getMemberType(builder,name):"void"}generate(builder){if(null!==this.structTypeNode&&this.structTypeNode.build(builder),builder.isAvailable("storageBuffer")||builder.isAvailable("indirectStorageBuffer"))return super.generate(builder);const{attribute:attribute,varying:varying}=this.getAttributeData(),output=varying.build(builder);return builder.registerTransform(output,attribute),output}}const storage=(value,type=null,count=0)=>new StorageBufferNode(value,type,count);class IndexNode extends Node$1{static get type(){return"IndexNode"}constructor(scope){super("uint"),this.scope=scope,this.isIndexNode=!0}generate(builder){const nodeType=this.getNodeType(builder),scope=this.scope;let propertyName,output;if(scope===IndexNode.VERTEX)propertyName=builder.getVertexIndex();else if(scope===IndexNode.INSTANCE)propertyName=builder.getInstanceIndex();else if(scope===IndexNode.DRAW)propertyName=builder.getDrawIndex();else if(scope===IndexNode.INVOCATION_LOCAL)propertyName=builder.getInvocationLocalIndex();else if(scope===IndexNode.INVOCATION_SUBGROUP)propertyName=builder.getInvocationSubgroupIndex();else{if(scope!==IndexNode.SUBGROUP)throw new Error("THREE.IndexNode: Unknown scope: "+scope);propertyName=builder.getSubgroupIndex()}if("vertex"===builder.shaderStage||"compute"===builder.shaderStage)output=propertyName;else{output=varying(this).build(builder,nodeType)}return output}}IndexNode.VERTEX="vertex",IndexNode.INSTANCE="instance",IndexNode.SUBGROUP="subgroup",IndexNode.INVOCATION_LOCAL="invocationLocal",IndexNode.INVOCATION_SUBGROUP="invocationSubgroup",IndexNode.DRAW="draw";const vertexIndex=/*@__PURE__*/nodeImmutable(IndexNode,IndexNode.VERTEX),instanceIndex=/*@__PURE__*/nodeImmutable(IndexNode,IndexNode.INSTANCE);IndexNode.SUBGROUP,IndexNode.INVOCATION_SUBGROUP,IndexNode.INVOCATION_LOCAL;const drawIndex=/*@__PURE__*/nodeImmutable(IndexNode,IndexNode.DRAW);class InstanceNode extends Node$1{static get type(){return"InstanceNode"}constructor(count,instanceMatrix,instanceColor=null){super("void"),this.count=count,this.instanceMatrix=instanceMatrix,this.instanceColor=instanceColor,this.instanceMatrixNode=null,this.instanceColorNode=null,this.updateType=NodeUpdateType_FRAME,this.buffer=null,this.bufferColor=null,this.previousInstanceMatrixNode=null}get isStorageMatrix(){const{instanceMatrix:instanceMatrix}=this;return instanceMatrix&&!0===instanceMatrix.isStorageInstancedBufferAttribute}get isStorageColor(){const{instanceColor:instanceColor}=this;return instanceColor&&!0===instanceColor.isStorageInstancedBufferAttribute}setup(builder){let{instanceMatrixNode:instanceMatrixNode,instanceColorNode:instanceColorNode}=this;null===instanceMatrixNode&&(instanceMatrixNode=this._createInstanceMatrixNode(!0,builder),this.instanceMatrixNode=instanceMatrixNode);const{instanceColor:instanceColor,isStorageColor:isStorageColor}=this;if(instanceColor&&null===instanceColorNode){if(isStorageColor)instanceColorNode=storage(instanceColor,"vec3",Math.max(instanceColor.count,1)).element(instanceIndex);else{const bufferAttribute=new InstancedBufferAttribute(instanceColor.array,3),bufferFn=35048===instanceColor.usage?instancedDynamicBufferAttribute:instancedBufferAttribute;this.bufferColor=bufferAttribute,instanceColorNode=vec3(bufferFn(bufferAttribute,"vec3",3,0))}this.instanceColorNode=instanceColorNode}const instancePosition=instanceMatrixNode.mul(positionLocal).xyz;if(positionLocal.assign(instancePosition),builder.needsPreviousData()&&positionPrevious.assign(this.getPreviousInstancedPosition(builder)),builder.hasGeometryAttribute("normal")){const instanceNormal=transformNormal(normalLocal,instanceMatrixNode);normalLocal.assign(instanceNormal)}null!==this.instanceColorNode&&varyingProperty("vec3","vInstanceColor").assign(this.instanceColorNode)}update(frame){null!==this.buffer&&!0!==this.isStorageMatrix&&(this.buffer.clearUpdateRanges(),this.buffer.updateRanges.push(...this.instanceMatrix.updateRanges),this.instanceMatrix.version!==this.buffer.version&&(this.buffer.version=this.instanceMatrix.version)),this.instanceColor&&null!==this.bufferColor&&!0!==this.isStorageColor&&(this.bufferColor.clearUpdateRanges(),this.bufferColor.updateRanges.push(...this.instanceColor.updateRanges),this.instanceColor.version!==this.bufferColor.version&&(this.bufferColor.version=this.instanceColor.version)),null!==this.previousInstanceMatrixNode&&frame.object.previousInstanceMatrix.array.set(this.instanceMatrix.array)}getPreviousInstancedPosition(builder){const instancedMesh=builder.object;return null===this.previousInstanceMatrixNode&&(instancedMesh.previousInstanceMatrix=this.instanceMatrix.clone(),this.previousInstanceMatrixNode=this._createInstanceMatrixNode(!1,builder)),this.previousInstanceMatrixNode.mul(positionPrevious).xyz}_createInstanceMatrixNode(assignBuffer,builder){let instanceMatrixNode;const{instanceMatrix:instanceMatrix}=this,{count:count}=instanceMatrix;if(this.isStorageMatrix)instanceMatrixNode=storage(instanceMatrix,"mat4",Math.max(count,1)).element(instanceIndex);else{if(16*count*4<=builder.getUniformBufferLimit())instanceMatrixNode=buffer(instanceMatrix.array,"mat4",Math.max(count,1)).element(instanceIndex);else{const interleaved=new InstancedInterleavedBuffer(instanceMatrix.array,16,1);!0===assignBuffer&&(this.buffer=interleaved);const bufferFn=35048===instanceMatrix.usage?instancedDynamicBufferAttribute:instancedBufferAttribute,instanceBuffers=[bufferFn(interleaved,"vec4",16,0),bufferFn(interleaved,"vec4",16,4),bufferFn(interleaved,"vec4",16,8),bufferFn(interleaved,"vec4",16,12)];instanceMatrixNode=mat4(...instanceBuffers)}}return instanceMatrixNode}}class InstancedMeshNode extends InstanceNode{static get type(){return"InstancedMeshNode"}constructor(instancedMesh){const{count:count,instanceMatrix:instanceMatrix,instanceColor:instanceColor}=instancedMesh;super(count,instanceMatrix,instanceColor),this.instancedMesh=instancedMesh}}const instancedMesh=/*@__PURE__*/nodeProxy(InstancedMeshNode).setParameterLength(1);class BatchNode extends Node$1{static get type(){return"BatchNode"}constructor(batchMesh){super("void"),this.batchMesh=batchMesh,this.batchingIdNode=null}setup(builder){null===this.batchingIdNode&&(null===builder.getDrawIndex()?this.batchingIdNode=instanceIndex:this.batchingIdNode=drawIndex);const getIndirectIndex=Fn(([id])=>{const size=int(textureSize(textureLoad(this.batchMesh._indirectTexture),0).x).toConst(),x=int(id).mod(size).toConst(),y=int(id).div(size).toConst();return textureLoad(this.batchMesh._indirectTexture,ivec2(x,y)).x}).setLayout({name:"getIndirectIndex",type:"uint",inputs:[{name:"id",type:"int"}]}),indirectId=getIndirectIndex(int(this.batchingIdNode)),matricesTexture=this.batchMesh._matricesTexture,size=int(textureSize(textureLoad(matricesTexture),0).x).toConst(),j=float(indirectId).mul(4).toInt().toConst(),x=j.mod(size).toConst(),y=j.div(size).toConst(),batchingMatrix=mat4(textureLoad(matricesTexture,ivec2(x,y)),textureLoad(matricesTexture,ivec2(x.add(1),y)),textureLoad(matricesTexture,ivec2(x.add(2),y)),textureLoad(matricesTexture,ivec2(x.add(3),y))),colorsTexture=this.batchMesh._colorsTexture;if(null!==colorsTexture){const getBatchingColor=Fn(([id])=>{const size=int(textureSize(textureLoad(colorsTexture),0).x).toConst(),j=id,x=j.mod(size).toConst(),y=j.div(size).toConst();return textureLoad(colorsTexture,ivec2(x,y)).rgb}).setLayout({name:"getBatchingColor",type:"vec3",inputs:[{name:"id",type:"int"}]}),color=getBatchingColor(indirectId);varyingProperty("vec3","vBatchColor").assign(color)}const bm=mat3(batchingMatrix);positionLocal.assign(batchingMatrix.mul(positionLocal));const transformedNormal=normalLocal.div(vec3(bm[0].dot(bm[0]),bm[1].dot(bm[1]),bm[2].dot(bm[2]))),batchingNormal=bm.mul(transformedNormal).xyz;normalLocal.assign(batchingNormal),builder.hasGeometryAttribute("tangent")&&tangentLocal.mulAssign(bm)}}const batch=/*@__PURE__*/nodeProxy(BatchNode).setParameterLength(1),_frameId=new WeakMap;class SkinningNode extends Node$1{static get type(){return"SkinningNode"}constructor(skinnedMesh){super("void"),this.skinnedMesh=skinnedMesh,this.updateType=NodeUpdateType_OBJECT,this.skinIndexNode=attribute("skinIndex","uvec4"),this.skinWeightNode=attribute("skinWeight","vec4"),this.bindMatrixNode=reference("bindMatrix","mat4"),this.bindMatrixInverseNode=reference("bindMatrixInverse","mat4"),this.boneMatricesNode=referenceBuffer("skeleton.boneMatrices","mat4",skinnedMesh.skeleton.bones.length),this.positionNode=positionLocal,this.toPositionNode=positionLocal,this.previousBoneMatricesNode=null}getSkinnedPosition(boneMatrices=this.boneMatricesNode,position=this.positionNode){const{skinIndexNode:skinIndexNode,skinWeightNode:skinWeightNode,bindMatrixNode:bindMatrixNode,bindMatrixInverseNode:bindMatrixInverseNode}=this,boneMatX=boneMatrices.element(skinIndexNode.x),boneMatY=boneMatrices.element(skinIndexNode.y),boneMatZ=boneMatrices.element(skinIndexNode.z),boneMatW=boneMatrices.element(skinIndexNode.w),skinVertex=bindMatrixNode.mul(position),skinned=add(boneMatX.mul(skinWeightNode.x).mul(skinVertex),boneMatY.mul(skinWeightNode.y).mul(skinVertex),boneMatZ.mul(skinWeightNode.z).mul(skinVertex),boneMatW.mul(skinWeightNode.w).mul(skinVertex));return bindMatrixInverseNode.mul(skinned).xyz}getSkinnedNormalAndTangent(boneMatrices=this.boneMatricesNode,normal=normalLocal,tangent=tangentLocal){const{skinIndexNode:skinIndexNode,skinWeightNode:skinWeightNode,bindMatrixNode:bindMatrixNode,bindMatrixInverseNode:bindMatrixInverseNode}=this,boneMatX=boneMatrices.element(skinIndexNode.x),boneMatY=boneMatrices.element(skinIndexNode.y),boneMatZ=boneMatrices.element(skinIndexNode.z),boneMatW=boneMatrices.element(skinIndexNode.w);let skinMatrix=add(skinWeightNode.x.mul(boneMatX),skinWeightNode.y.mul(boneMatY),skinWeightNode.z.mul(boneMatZ),skinWeightNode.w.mul(boneMatW));skinMatrix=bindMatrixInverseNode.mul(skinMatrix).mul(bindMatrixNode);return{skinNormal:skinMatrix.transformDirection(normal).xyz,skinTangent:skinMatrix.transformDirection(tangent).xyz}}getPreviousSkinnedPosition(builder){const skinnedMesh=builder.object;return null===this.previousBoneMatricesNode&&(skinnedMesh.skeleton.previousBoneMatrices=new Float32Array(skinnedMesh.skeleton.boneMatrices),this.previousBoneMatricesNode=referenceBuffer("skeleton.previousBoneMatrices","mat4",skinnedMesh.skeleton.bones.length)),this.getSkinnedPosition(this.previousBoneMatricesNode,positionPrevious)}setup(builder){builder.needsPreviousData()&&positionPrevious.assign(this.getPreviousSkinnedPosition(builder));const skinPosition=this.getSkinnedPosition();if(this.toPositionNode&&this.toPositionNode.assign(skinPosition),builder.hasGeometryAttribute("normal")){const{skinNormal:skinNormal,skinTangent:skinTangent}=this.getSkinnedNormalAndTangent();normalLocal.assign(skinNormal),builder.hasGeometryAttribute("tangent")&&tangentLocal.assign(skinTangent)}return skinPosition}generate(builder,output){if("void"!==output)return super.generate(builder,output)}update(frame){const skeleton=frame.object&&frame.object.skeleton?frame.object.skeleton:this.skinnedMesh.skeleton;_frameId.get(skeleton)!==frame.frameId&&(_frameId.set(skeleton,frame.frameId),null!==this.previousBoneMatricesNode&&(null===skeleton.previousBoneMatrices&&(skeleton.previousBoneMatrices=new Float32Array(skeleton.boneMatrices)),skeleton.previousBoneMatrices.set(skeleton.boneMatrices)),skeleton.update())}}class LoopNode extends Node$1{static get type(){return"LoopNode"}constructor(params=[]){super("void"),this.params=params}getVarName(index){return String.fromCharCode("i".charCodeAt(0)+index)}getProperties(builder){const properties=builder.getNodeProperties(this);if(void 0!==properties.stackNode)return properties;const inputs={};for(let i=0,l=this.params.length-1;i<l;i++){const param=this.params[i],name=!0!==param.isNode&&param.name||this.getVarName(i),type=!0!==param.isNode&&param.type||"int";inputs[name]=expression(name,type)}const stack=builder.addStack(),fnCall=this.params[this.params.length-1](inputs);properties.returnsNode=fnCall.context({nodeLoop:fnCall}),properties.stackNode=stack;const baseParam=this.params[0];if(!0!==baseParam.isNode&&"function"==typeof baseParam.update){const fnUpdateCall=Fn(this.params[0].update)(inputs);properties.updateNode=fnUpdateCall.context({nodeLoop:fnUpdateCall})}return builder.removeStack(),properties}setup(builder){if(this.getProperties(builder),builder.fnCall){builder.getDataFromNode(builder.fnCall.shaderNode).hasLoop=!0}}generate(builder){const properties=this.getProperties(builder),params=this.params,stackNode=properties.stackNode;for(let i=0,l=params.length-1;i<l;i++){const param=params[i];let loopSnippet,isWhile=!1,start=null,end=null,name=null,type=null,condition=null,update=null;if(param.isNode?"bool"===param.getNodeType(builder)?(isWhile=!0,type="bool",end=param.build(builder,type)):(type="int",name=this.getVarName(i),start="0",end=param.build(builder,type),condition="<"):(type=param.type||"int",name=param.name||this.getVarName(i),start=param.start,end=param.end,condition=param.condition,update=param.update,"number"==typeof start?start=builder.generateConst(type,start):start&&start.isNode&&(start=start.build(builder,type)),"number"==typeof end?end=builder.generateConst(type,end):end&&end.isNode&&(end=end.build(builder,type)),void 0!==start&&void 0===end?(start+=" - 1",end="0",condition=">="):void 0!==end&&void 0===start&&(start="0",condition="<"),void 0===condition&&(condition=Number(start)>Number(end)?">=":"<")),isWhile)loopSnippet=`while ( ${end} )`;else{const internalParam={start:start,end:end},startSnippet=internalParam.start,endSnippet=internalParam.end;let updateSnippet;const deltaOperator=()=>condition.includes("<")?"+=":"-=";if(null!=update)switch(typeof update){case"function":updateSnippet=builder.flowStagesNode(properties.updateNode,"void").code.replace(/\t|;/g,"");break;case"number":updateSnippet=name+" "+deltaOperator()+" "+builder.generateConst(type,update);break;case"string":updateSnippet=name+" "+update;break;default:update.isNode?updateSnippet=name+" "+deltaOperator()+" "+update.build(builder):(error("TSL: 'Loop( { update: ... } )' is not a function, string or number.",this.stackTrace),updateSnippet="break /* invalid update */")}else update="int"===type||"uint"===type?condition.includes("<")?"++":"--":deltaOperator()+" 1.",updateSnippet=name+" "+update;loopSnippet=`for ( ${builder.getVar(type,name)+" = "+startSnippet}; ${name+" "+condition+" "+endSnippet}; ${updateSnippet} )`}builder.addFlowCode((0===i?"\n":"")+builder.tab+loopSnippet+" {\n\n").addFlowTab()}const stackSnippet=stackNode.build(builder,"void");properties.returnsNode.build(builder,"void"),builder.removeFlowTab().addFlowCode("\n"+builder.tab+stackSnippet);for(let i=0,l=this.params.length-1;i<l;i++)builder.addFlowCode((0===i?"":builder.tab)+"}\n\n").removeFlowTab();builder.addFlowTab()}}const Loop=(...params)=>new LoopNode(nodeArray(params,"int")).toStack(),_morphTextures=/*@__PURE__*/new WeakMap,_morphVec4=/*@__PURE__*/new Vector4,getMorph=/*@__PURE__*/Fn(({bufferMap:bufferMap,influence:influence,stride:stride,width:width,depth:depth,offset:offset})=>{const texelIndex=int(vertexIndex).mul(stride).add(offset),y=texelIndex.div(width),x=texelIndex.sub(y.mul(width));return textureLoad(bufferMap,ivec2(x,y)).depth(depth).xyz.mul(influence)});class MorphNode extends Node$1{static get type(){return"MorphNode"}constructor(mesh){super("void"),this.mesh=mesh,this.morphBaseInfluence=uniform(1),this.updateType=NodeUpdateType_OBJECT}setup(builder){const{geometry:geometry}=builder,hasMorphPosition=void 0!==geometry.morphAttributes.position,hasMorphNormals=geometry.hasAttribute("normal")&&void 0!==geometry.morphAttributes.normal,morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color,morphTargetsCount=void 0!==morphAttribute?morphAttribute.length:0,{texture:bufferMap,stride:stride,size:size}=function getEntry(geometry){const hasMorphPosition=void 0!==geometry.morphAttributes.position,hasMorphNormals=void 0!==geometry.morphAttributes.normal,hasMorphColors=void 0!==geometry.morphAttributes.color,morphAttribute=geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color,morphTargetsCount=void 0!==morphAttribute?morphAttribute.length:0;let entry=_morphTextures.get(geometry);if(void 0===entry||entry.count!==morphTargetsCount){void 0!==entry&&entry.texture.dispose();const morphTargets=geometry.morphAttributes.position||[],morphNormals=geometry.morphAttributes.normal||[],morphColors=geometry.morphAttributes.color||[];let vertexDataCount=0;!0===hasMorphPosition&&(vertexDataCount=1),!0===hasMorphNormals&&(vertexDataCount=2),!0===hasMorphColors&&(vertexDataCount=3);let width=geometry.attributes.position.count*vertexDataCount,height=1;const maxTextureSize=4096;width>maxTextureSize&&(height=Math.ceil(width/maxTextureSize),width=maxTextureSize);const buffer=new Float32Array(width*height*4*morphTargetsCount),bufferTexture=new DataArrayTexture(buffer,width,height,morphTargetsCount);bufferTexture.type=1015,bufferTexture.needsUpdate=!0;const vertexDataStride=4*vertexDataCount;for(let i=0;i<morphTargetsCount;i++){const morphTarget=morphTargets[i],morphNormal=morphNormals[i],morphColor=morphColors[i],offset=width*height*4*i;for(let j=0;j<morphTarget.count;j++){const stride=j*vertexDataStride;!0===hasMorphPosition&&(_morphVec4.fromBufferAttribute(morphTarget,j),buffer[offset+stride+0]=_morphVec4.x,buffer[offset+stride+1]=_morphVec4.y,buffer[offset+stride+2]=_morphVec4.z,buffer[offset+stride+3]=0),!0===hasMorphNormals&&(_morphVec4.fromBufferAttribute(morphNormal,j),buffer[offset+stride+4]=_morphVec4.x,buffer[offset+stride+5]=_morphVec4.y,buffer[offset+stride+6]=_morphVec4.z,buffer[offset+stride+7]=0),!0===hasMorphColors&&(_morphVec4.fromBufferAttribute(morphColor,j),buffer[offset+stride+8]=_morphVec4.x,buffer[offset+stride+9]=_morphVec4.y,buffer[offset+stride+10]=_morphVec4.z,buffer[offset+stride+11]=4===morphColor.itemSize?_morphVec4.w:1)}}function disposeTexture(){bufferTexture.dispose(),_morphTextures.delete(geometry),geometry.removeEventListener("dispose",disposeTexture)}entry={count:morphTargetsCount,texture:bufferTexture,stride:vertexDataCount,size:new Vector2(width,height)},_morphTextures.set(geometry,entry),geometry.addEventListener("dispose",disposeTexture)}return entry}(geometry);!0===hasMorphPosition&&positionLocal.mulAssign(this.morphBaseInfluence),!0===hasMorphNormals&&normalLocal.mulAssign(this.morphBaseInfluence);const width=int(size.width);Loop(morphTargetsCount,({i:i})=>{const influence=float(0).toVar();this.mesh.count>1&&null!==this.mesh.morphTexture&&void 0!==this.mesh.morphTexture?influence.assign(textureLoad(this.mesh.morphTexture,ivec2(int(i).add(1),int(instanceIndex))).r):influence.assign(reference("morphTargetInfluences","float").element(i).toVar()),If(influence.notEqual(0),()=>{!0===hasMorphPosition&&positionLocal.addAssign(getMorph({bufferMap:bufferMap,influence:influence,stride:stride,width:width,depth:i,offset:int(0)})),!0===hasMorphNormals&&normalLocal.addAssign(getMorph({bufferMap:bufferMap,influence:influence,stride:stride,width:width,depth:i,offset:int(1)}))})})}update(){const morphBaseInfluence=this.morphBaseInfluence;this.mesh.geometry.morphTargetsRelative?morphBaseInfluence.value=1:morphBaseInfluence.value=1-this.mesh.morphTargetInfluences.reduce((a,b)=>a+b,0)}}const morphReference=/*@__PURE__*/nodeProxy(MorphNode).setParameterLength(1);class LightingNode extends Node$1{static get type(){return"LightingNode"}constructor(){super("vec3"),this.isLightingNode=!0}}class AONode extends LightingNode{static get type(){return"AONode"}constructor(aoNode=null){super(),this.aoNode=aoNode}setup(builder){builder.context.ambientOcclusion.mulAssign(this.aoNode)}}class LightingContextNode extends ContextNode{static get type(){return"LightingContextNode"}constructor(lightsNode,lightingModel=null,backdropNode=null,backdropAlphaNode=null){super(lightsNode),this.lightingModel=lightingModel,this.backdropNode=backdropNode,this.backdropAlphaNode=backdropAlphaNode,this._value=null}getContext(){const{backdropNode:backdropNode,backdropAlphaNode:backdropAlphaNode}=this,reflectedLight={directDiffuse:vec3().toVar("directDiffuse"),directSpecular:vec3().toVar("directSpecular"),indirectDiffuse:vec3().toVar("indirectDiffuse"),indirectSpecular:vec3().toVar("indirectSpecular")};return{radiance:vec3().toVar("radiance"),irradiance:vec3().toVar("irradiance"),iblIrradiance:vec3().toVar("iblIrradiance"),ambientOcclusion:float(1).toVar("ambientOcclusion"),reflectedLight:reflectedLight,backdrop:backdropNode,backdropAlpha:backdropAlphaNode}}setup(builder){return this.value=this._value||(this._value=this.getContext()),this.value.lightingModel=this.lightingModel||builder.context.lightingModel,super.setup(builder)}}const lightingContext=/*@__PURE__*/nodeProxy(LightingContextNode);class IrradianceNode extends LightingNode{static get type(){return"IrradianceNode"}constructor(node){super(),this.node=node}setup(builder){builder.context.irradiance.addAssign(this.node)}}const _size$5=/*@__PURE__*/new Vector2;class ViewportTextureNode extends TextureNode{static get type(){return"ViewportTextureNode"}constructor(uvNode=screenUV,levelNode=null,framebufferTexture=null){let defaultFramebuffer=null;null===framebufferTexture?(defaultFramebuffer=new FramebufferTexture,defaultFramebuffer.minFilter=1008,framebufferTexture=defaultFramebuffer):defaultFramebuffer=framebufferTexture,super(framebufferTexture,uvNode,levelNode),this.generateMipmaps=!1,this.defaultFramebuffer=defaultFramebuffer,this.isOutputTextureNode=!0,this.updateBeforeType=NodeUpdateType_RENDER,this._cacheTextures=new WeakMap}getTextureForReference(reference=null){let defaultFramebuffer,cacheTextures;if(this.referenceNode?(defaultFramebuffer=this.referenceNode.defaultFramebuffer,cacheTextures=this.referenceNode._cacheTextures):(defaultFramebuffer=this.defaultFramebuffer,cacheTextures=this._cacheTextures),null===reference||!0===reference.isDefaultCanvasTarget)return defaultFramebuffer;if(!1===cacheTextures.has(reference)){const framebufferTexture=defaultFramebuffer.clone();cacheTextures.set(reference,framebufferTexture)}return cacheTextures.get(reference)}updateReference(frame){const renderer=frame.renderer,renderTarget=renderer.getRenderTarget(),canvasTarget=renderer.getCanvasTarget(),reference=null!==canvasTarget?canvasTarget:renderTarget;return this.value=this.getTextureForReference(reference),this.value}updateBefore(frame){const renderer=frame.renderer,renderTarget=renderer.getRenderTarget(),canvasTarget=renderer.getCanvasTarget(),reference=null!==canvasTarget?canvasTarget:renderTarget;null===reference?renderer.getDrawingBufferSize(_size$5):_size$5.set(renderTarget.width,renderTarget.height);const framebufferTexture=this.getTextureForReference(reference);framebufferTexture.image.width===_size$5.width&&framebufferTexture.image.height===_size$5.height||(framebufferTexture.image.width=_size$5.width,framebufferTexture.image.height=_size$5.height,framebufferTexture.needsUpdate=!0);const currentGenerateMipmaps=framebufferTexture.generateMipmaps;framebufferTexture.generateMipmaps=this.generateMipmaps,renderer.copyFramebufferToTexture(framebufferTexture),framebufferTexture.generateMipmaps=currentGenerateMipmaps}clone(){const viewportTextureNode=new this.constructor(this.uvNode,this.levelNode,this.value);return viewportTextureNode.generateMipmaps=this.generateMipmaps,viewportTextureNode}}const viewportMipTexture=/*@__PURE__*/nodeProxy(ViewportTextureNode,null,null,{generateMipmaps:!0}).setParameterLength(0,3),_singletonOpaqueViewportTextureNode=/*@__PURE__*/viewportMipTexture(),viewportOpaqueMipTexture=(uv=screenUV,level=null)=>_singletonOpaqueViewportTextureNode.sample(uv,level);class ViewportDepthTextureNode extends ViewportTextureNode{static get type(){return"ViewportDepthTextureNode"}constructor(uvNode=screenUV,levelNode=null,depthTexture=null){null===depthTexture&&(depthTexture=new DepthTexture),super(uvNode,levelNode,depthTexture)}}const viewportDepthTexture=/*@__PURE__*/nodeProxy(ViewportDepthTextureNode).setParameterLength(0,3);class ViewportDepthNode extends Node$1{static get type(){return"ViewportDepthNode"}constructor(scope,valueNode=null){super("float"),this.scope=scope,this.valueNode=valueNode,this.isViewportDepthNode=!0}generate(builder){const{scope:scope}=this;return scope===ViewportDepthNode.DEPTH_BASE?builder.getFragDepth():super.generate(builder)}setup(){const{scope:scope}=this,value=this.valueNode;let node=null;const isPerspective=cameraProjectionMatrix.element(3).w.equal(0);if(scope===ViewportDepthNode.DEPTH_BASE)null!==value&&(node=depthBase().assign(value));else if(scope===ViewportDepthNode.DEPTH){const perspectiveDepth=viewZToPerspectiveDepth(positionView.z,cameraNear,cameraFar),orthographicDepth=viewZToOrthographicDepth(positionView.z,cameraNear,cameraFar);node=isPerspective.select(perspectiveDepth,orthographicDepth)}else if(scope===ViewportDepthNode.LINEAR_DEPTH)if(null!==value){const viewZ=perspectiveDepthToViewZ(value,cameraNear,cameraFar),perspectiveLinear=viewZToOrthographicDepth(viewZ,cameraNear,cameraFar);node=isPerspective.select(perspectiveLinear,value)}else node=viewZToOrthographicDepth(positionView.z,cameraNear,cameraFar);return node}}ViewportDepthNode.DEPTH_BASE="depthBase",ViewportDepthNode.DEPTH="depth",ViewportDepthNode.LINEAR_DEPTH="linearDepth";const viewZToOrthographicDepth=(viewZ,near,far)=>viewZ.add(near).div(near.sub(far)),viewZToPerspectiveDepth=(viewZ,near,far)=>near.add(viewZ).mul(far).div(far.sub(near).mul(viewZ)),perspectiveDepthToViewZ=(depth,near,far)=>near.mul(far).div(far.sub(near).mul(depth).sub(far)),viewZToLogarithmicDepth=(viewZ,near,far)=>{near=near.max(1e-6).toVar();const numerator=log2(viewZ.negate().div(near)),denominator=log2(far.div(near));return numerator.div(denominator)},depthBase=/*@__PURE__*/nodeProxy(ViewportDepthNode,ViewportDepthNode.DEPTH_BASE),depth=/*@__PURE__*/nodeImmutable(ViewportDepthNode,ViewportDepthNode.DEPTH);viewportDepthTexture(),depth.assign=value=>depthBase(value);class ClippingNode extends Node$1{static get type(){return"ClippingNode"}constructor(scope=ClippingNode.DEFAULT){super(),this.scope=scope}setup(builder){super.setup(builder);const clippingContext=builder.clippingContext,{intersectionPlanes:intersectionPlanes,unionPlanes:unionPlanes}=clippingContext;return this.hardwareClipping=builder.material.hardwareClipping,this.scope===ClippingNode.ALPHA_TO_COVERAGE?this.setupAlphaToCoverage(intersectionPlanes,unionPlanes):this.scope===ClippingNode.HARDWARE?this.setupHardwareClipping(unionPlanes,builder):this.setupDefault(intersectionPlanes,unionPlanes)}setupAlphaToCoverage(intersectionPlanes,unionPlanes){return Fn(()=>{const distanceToPlane=float().toVar("distanceToPlane"),distanceGradient=float().toVar("distanceToGradient"),clipOpacity=float(1).toVar("clipOpacity"),numUnionPlanes=unionPlanes.length;if(!1===this.hardwareClipping&&numUnionPlanes>0){const clippingPlanes=uniformArray(unionPlanes).setGroup(renderGroup);Loop(numUnionPlanes,({i:i})=>{const plane=clippingPlanes.element(i);distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w)),distanceGradient.assign(distanceToPlane.fwidth().div(2)),clipOpacity.mulAssign(smoothstep(distanceGradient.negate(),distanceGradient,distanceToPlane))})}const numIntersectionPlanes=intersectionPlanes.length;if(numIntersectionPlanes>0){const clippingPlanes=uniformArray(intersectionPlanes).setGroup(renderGroup),intersectionClipOpacity=float(1).toVar("intersectionClipOpacity");Loop(numIntersectionPlanes,({i:i})=>{const plane=clippingPlanes.element(i);distanceToPlane.assign(positionView.dot(plane.xyz).negate().add(plane.w)),distanceGradient.assign(distanceToPlane.fwidth().div(2)),intersectionClipOpacity.mulAssign(smoothstep(distanceGradient.negate(),distanceGradient,distanceToPlane).oneMinus())}),clipOpacity.mulAssign(intersectionClipOpacity.oneMinus())}diffuseColor.a.mulAssign(clipOpacity),diffuseColor.a.equal(0).discard()})()}setupDefault(intersectionPlanes,unionPlanes){return Fn(()=>{const numUnionPlanes=unionPlanes.length;if(!1===this.hardwareClipping&&numUnionPlanes>0){const clippingPlanes=uniformArray(unionPlanes).setGroup(renderGroup);Loop(numUnionPlanes,({i:i})=>{const plane=clippingPlanes.element(i);positionView.dot(plane.xyz).greaterThan(plane.w).discard()})}const numIntersectionPlanes=intersectionPlanes.length;if(numIntersectionPlanes>0){const clippingPlanes=uniformArray(intersectionPlanes).setGroup(renderGroup),clipped=bool(!0).toVar("clipped");Loop(numIntersectionPlanes,({i:i})=>{const plane=clippingPlanes.element(i);clipped.assign(positionView.dot(plane.xyz).greaterThan(plane.w).and(clipped))}),clipped.discard()}})()}setupHardwareClipping(unionPlanes,builder){const numUnionPlanes=unionPlanes.length;return builder.enableHardwareClipping(numUnionPlanes),Fn(()=>{const clippingPlanes=uniformArray(unionPlanes).setGroup(renderGroup),hw_clip_distances=builtin(builder.getClipDistance());Loop(numUnionPlanes,({i:i})=>{const plane=clippingPlanes.element(i),distance=positionView.dot(plane.xyz).sub(plane.w).negate();hw_clip_distances.element(i).assign(distance)})})()}}ClippingNode.ALPHA_TO_COVERAGE="alphaToCoverage",ClippingNode.DEFAULT="default",ClippingNode.HARDWARE="hardware";const hash2D=/*@__PURE__*/Fn(([value])=>fract(mul(1e4,sin(mul(17,value.x).add(mul(.1,value.y)))).mul(add(.1,abs(sin(mul(13,value.y).add(value.x))))))),hash3D=/*@__PURE__*/Fn(([value])=>hash2D(vec2(hash2D(value.xy),value.z))),getAlphaHashThreshold=/*@__PURE__*/Fn(([position])=>{const maxDeriv=max$1(length(dFdx(position.xyz)),length(dFdy(position.xyz))),pixScale=float(1).div(float(.05).mul(maxDeriv)).toVar("pixScale"),pixScales=vec2(exp2(floor(log2(pixScale))),exp2(ceil(log2(pixScale)))),alpha=vec2(hash3D(floor(pixScales.x.mul(position.xyz))),hash3D(floor(pixScales.y.mul(position.xyz)))),lerpFactor=fract(log2(pixScale)),x=add(mul(lerpFactor.oneMinus(),alpha.x),mul(lerpFactor,alpha.y)),a=min$1(lerpFactor,lerpFactor.oneMinus()),cases=vec3(x.mul(x).div(mul(2,a).mul(sub(1,a))),x.sub(mul(.5,a)).div(sub(1,a)),sub(1,sub(1,x).mul(sub(1,x)).div(mul(2,a).mul(sub(1,a))))),threshold=x.lessThan(a.oneMinus()).select(x.lessThan(a).select(cases.x,cases.y),cases.z);return clamp$2(threshold,1e-6,1)}).setLayout({name:"getAlphaHashThreshold",type:"float",inputs:[{name:"position",type:"vec3"}]});class VertexColorNode extends AttributeNode{static get type(){return"VertexColorNode"}constructor(index){super(null,"vec4"),this.isVertexColorNode=!0,this.index=index}getAttributeName(){const index=this.index;return"color"+(index>0?index:"")}generate(builder){const attributeName=this.getAttributeName(builder);let result;return result=!0===builder.hasGeometryAttribute(attributeName)?super.generate(builder):builder.generateConst(this.nodeType,new Vector4(1,1,1,1)),result}serialize(data){super.serialize(data),data.index=this.index}deserialize(data){super.deserialize(data),this.index=data.index}}const premultiplyAlpha=/*@__PURE__*/Fn(([color])=>vec4(color.rgb.mul(color.a),color.a),{color:"vec4",return:"vec4"});class NodeMaterial extends Material{static get type(){return"NodeMaterial"}get type(){return this.constructor.type}set type(_value){}constructor(){super(),this.isNodeMaterial=!0,this.fog=!0,this.lights=!1,this.hardwareClipping=!1,this.lightsNode=null,this.envNode=null,this.aoNode=null,this.colorNode=null,this.normalNode=null,this.opacityNode=null,this.backdropNode=null,this.backdropAlphaNode=null,this.alphaTestNode=null,this.maskNode=null,this.maskShadowNode=null,this.positionNode=null,this.geometryNode=null,this.depthNode=null,this.receivedShadowPositionNode=null,this.castShadowPositionNode=null,this.receivedShadowNode=null,this.castShadowNode=null,this.outputNode=null,this.mrtNode=null,this.fragmentNode=null,this.vertexNode=null,this.contextNode=null}_getNodeChildren(){const children=[];for(const property of Object.getOwnPropertyNames(this)){if(!0===property.startsWith("_"))continue;const object=this[property];object&&!0===object.isNode&&children.push({property:property,childNode:object})}return children}customProgramCacheKey(){const values=[];for(const{property:property,childNode:childNode}of this._getNodeChildren())values.push(hashString(property.slice(0,-4)),childNode.getCacheKey());return this.type+hashArray(values)}build(builder){this.setup(builder)}setupObserver(builder){return new NodeMaterialObserver(builder)}setup(builder){builder.context.setupNormal=()=>subBuild(this.setupNormal(builder),"NORMAL","vec3"),builder.context.setupPositionView=()=>this.setupPositionView(builder),builder.context.setupModelViewProjection=()=>this.setupModelViewProjection(builder);const renderer=builder.renderer,renderTarget=renderer.getRenderTarget();!0===renderer.contextNode.isContextNode?builder.context={...builder.context,...renderer.contextNode.getFlowContextData()}:error('NodeMaterial: "renderer.contextNode" must be an instance of `context()`.'),null!==this.contextNode&&(!0===this.contextNode.isContextNode?builder.context={...builder.context,...this.contextNode.getFlowContextData()}:error('NodeMaterial: "material.contextNode" must be an instance of `context()`.')),builder.addStack();const mvp=this.setupVertex(builder),vertexNode=subBuild(this.vertexNode||mvp,"VERTEX");let resultNode;builder.context.clipSpace=vertexNode,builder.stack.outputNode=vertexNode,this.setupHardwareClipping(builder),null!==this.geometryNode&&(builder.stack.outputNode=builder.stack.outputNode.bypass(this.geometryNode)),builder.addFlow("vertex",builder.removeStack()),builder.addStack();const clippingNode=this.setupClipping(builder);if(!0!==this.depthWrite&&!0!==this.depthTest||(null!==renderTarget?!0===renderTarget.depthBuffer&&this.setupDepth(builder):!0===renderer.depth&&this.setupDepth(builder)),null===this.fragmentNode){this.setupDiffuseColor(builder),this.setupVariants(builder);const outgoingLightNode=this.setupLighting(builder);null!==clippingNode&&builder.stack.addToStack(clippingNode);const basicOutput=vec4(outgoingLightNode,diffuseColor.a).max(0);resultNode=this.setupOutput(builder,basicOutput),output.assign(resultNode);const isCustomOutput=null!==this.outputNode;if(isCustomOutput&&(resultNode=this.outputNode),builder.context.getOutput&&(resultNode=builder.context.getOutput(resultNode,builder)),null!==renderTarget){const mrt=renderer.getMRT(),materialMRT=this.mrtNode;null!==mrt?(isCustomOutput&&output.assign(resultNode),resultNode=mrt,null!==materialMRT&&(resultNode=mrt.merge(materialMRT))):null!==materialMRT&&(resultNode=materialMRT)}}else{let fragmentNode=this.fragmentNode;!0!==fragmentNode.isOutputStructNode&&(fragmentNode=vec4(fragmentNode)),resultNode=this.setupOutput(builder,fragmentNode)}builder.stack.outputNode=resultNode,builder.addFlow("fragment",builder.removeStack()),builder.observer=this.setupObserver(builder)}setupClipping(builder){if(null===builder.clippingContext)return null;const{unionPlanes:unionPlanes,intersectionPlanes:intersectionPlanes}=builder.clippingContext;let result=null;if(unionPlanes.length>0||intersectionPlanes.length>0){const samples=builder.renderer.currentSamples;this.alphaToCoverage&&samples>1?result=new ClippingNode(ClippingNode.ALPHA_TO_COVERAGE):builder.stack.addToStack(new ClippingNode)}return result}setupHardwareClipping(builder){if(this.hardwareClipping=!1,null===builder.clippingContext)return;const candidateCount=builder.clippingContext.unionPlanes.length;candidateCount>0&&candidateCount<=8&&builder.isAvailable("clipDistance")&&(builder.stack.addToStack(new ClippingNode(ClippingNode.HARDWARE)),this.hardwareClipping=!0)}setupDepth(builder){const{renderer:renderer,camera:camera}=builder;let depthNode=this.depthNode;if(null===depthNode){const mrt=renderer.getMRT();mrt&&mrt.has("depth")?depthNode=mrt.get("depth"):!0===renderer.logarithmicDepthBuffer&&(depthNode=camera.isPerspectiveCamera?viewZToLogarithmicDepth(positionView.z,cameraNear,cameraFar):viewZToOrthographicDepth(positionView.z,cameraNear,cameraFar))}null!==depthNode&&depth.assign(depthNode).toStack()}setupPositionView(){return modelViewMatrix.mul(positionLocal).xyz}setupModelViewProjection(){return cameraProjectionMatrix.mul(positionView)}setupVertex(builder){return builder.addStack(),this.setupPosition(builder),builder.context.position=builder.removeStack(),modelViewProjection}setupPosition(builder){const{object:object,geometry:geometry}=builder;var skinnedMesh;if((geometry.morphAttributes.position||geometry.morphAttributes.normal||geometry.morphAttributes.color)&&morphReference(object).toStack(),!0===object.isSkinnedMesh&&(skinnedMesh=object,new SkinningNode(skinnedMesh)).toStack(),this.displacementMap){const displacementMap=materialReference("displacementMap","texture"),displacementScale=materialReference("displacementScale","float"),displacementBias=materialReference("displacementBias","float");positionLocal.addAssign(normalLocal.normalize().mul(displacementMap.x.mul(displacementScale).add(displacementBias)))}return object.isBatchedMesh&&batch(object).toStack(),object.isInstancedMesh&&object.instanceMatrix&&!0===object.instanceMatrix.isInstancedBufferAttribute&&instancedMesh(object).toStack(),null!==this.positionNode&&positionLocal.assign(subBuild(this.positionNode,"POSITION","vec3")),positionLocal}setupDiffuseColor(builder){const{object:object,geometry:geometry}=builder;null!==this.maskNode&&bool(this.maskNode).not().discard();let colorNode=this.colorNode?vec4(this.colorNode):materialColor;if(!0===this.vertexColors&&geometry.hasAttribute("color")&&(colorNode=colorNode.mul(((index=0)=>new VertexColorNode(index))())),object.instanceColor){colorNode=varyingProperty("vec3","vInstanceColor").mul(colorNode)}if(object.isBatchedMesh&&object._colorsTexture){colorNode=varyingProperty("vec3","vBatchColor").mul(colorNode)}diffuseColor.assign(colorNode);const opacityNode=this.opacityNode?float(this.opacityNode):materialOpacity;diffuseColor.a.assign(diffuseColor.a.mul(opacityNode));let alphaTestNode=null;(null!==this.alphaTestNode||this.alphaTest>0)&&(alphaTestNode=null!==this.alphaTestNode?float(this.alphaTestNode):materialAlphaTest,!0===this.alphaToCoverage?(diffuseColor.a=smoothstep(alphaTestNode,alphaTestNode.add(fwidth(diffuseColor.a)),diffuseColor.a),diffuseColor.a.lessThanEqual(0).discard()):diffuseColor.a.lessThanEqual(alphaTestNode).discard()),!0===this.alphaHash&&diffuseColor.a.lessThan(getAlphaHashThreshold(positionLocal)).discard(),builder.isOpaque()&&diffuseColor.a.assign(1)}setupVariants(){}setupOutgoingLight(){return!0===this.lights?vec3(0):diffuseColor.rgb}setupNormal(){return this.normalNode?vec3(this.normalNode):materialNormal}setupEnvironment(){let node=null;return this.envNode?node=this.envNode:this.envMap&&(node=this.envMap.isCubeTexture?materialReference("envMap","cubeTexture"):materialReference("envMap","texture")),node}setupLightMap(builder){let node=null;return builder.material.lightMap&&(node=new IrradianceNode(materialLightMap)),node}setupLights(builder){const materialLightsNode=[],envNode=this.setupEnvironment(builder);envNode&&envNode.isLightingNode&&materialLightsNode.push(envNode);const lightMapNode=this.setupLightMap(builder);lightMapNode&&lightMapNode.isLightingNode&&materialLightsNode.push(lightMapNode);let aoNode=this.aoNode;null===aoNode&&builder.material.aoMap&&(aoNode=materialAO),builder.context.getAO&&(aoNode=builder.context.getAO(aoNode,builder)),aoNode&&materialLightsNode.push(new AONode(aoNode));let lightsN=this.lightsNode||builder.lightsNode;return materialLightsNode.length>0&&(lightsN=builder.renderer.lighting.createNode([...lightsN.getLights(),...materialLightsNode])),lightsN}setupLightingModel(){}setupLighting(builder){const{material:material}=builder,{backdropNode:backdropNode,backdropAlphaNode:backdropAlphaNode,emissiveNode:emissiveNode}=this,lightsNode=!0===this.lights||null!==this.lightsNode?this.setupLights(builder):null;let outgoingLightNode=this.setupOutgoingLight(builder);if(lightsNode&&lightsNode.getScope().hasLights){const lightingModel=this.setupLightingModel(builder)||null;outgoingLightNode=lightingContext(lightsNode,lightingModel,backdropNode,backdropAlphaNode)}else null!==backdropNode&&(outgoingLightNode=vec3(null!==backdropAlphaNode?mix(outgoingLightNode,backdropNode,backdropAlphaNode):backdropNode));return(emissiveNode&&!0===emissiveNode.isNode||material.emissive&&!0===material.emissive.isColor)&&(emissive.assign(vec3(emissiveNode||materialEmissive)),outgoingLightNode=outgoingLightNode.add(emissive)),outgoingLightNode}setupFog(builder,outputNode){const fogNode=builder.fogNode;return fogNode&&(output.assign(outputNode),outputNode=vec4(fogNode.toVar())),outputNode}setupPremultipliedAlpha(builder,outputNode){return premultiplyAlpha(outputNode)}setupOutput(builder,outputNode){return!0===this.fog&&(outputNode=this.setupFog(builder,outputNode)),!0===this.premultipliedAlpha&&(outputNode=this.setupPremultipliedAlpha(builder,outputNode)),outputNode}setDefaultValues(material){for(const property in material){const value=material[property];void 0===this[property]&&(this[property]=value,value&&value.clone&&(this[property]=value.clone()))}const descriptors=Object.getOwnPropertyDescriptors(material.constructor.prototype);for(const key in descriptors)void 0===Object.getOwnPropertyDescriptor(this.constructor.prototype,key)&&void 0!==descriptors[key].get&&Object.defineProperty(this.constructor.prototype,key,descriptors[key])}toJSON(meta){const isRoot=void 0===meta||"string"==typeof meta;isRoot&&(meta={textures:{},images:{},nodes:{}});const data=Material.prototype.toJSON.call(this,meta);data.inputNodes={};for(const{property:property,childNode:childNode}of this._getNodeChildren())data.inputNodes[property]=childNode.toJSON(meta).uuid;function extractFromCache(cache){const values=[];for(const key in cache){const data=cache[key];delete data.metadata,values.push(data)}return values}if(isRoot){const textures=extractFromCache(meta.textures),images=extractFromCache(meta.images),nodes=extractFromCache(meta.nodes);textures.length>0&&(data.textures=textures),images.length>0&&(data.images=images),nodes.length>0&&(data.nodes=nodes)}return data}copy(source){return this.lightsNode=source.lightsNode,this.envNode=source.envNode,this.aoNode=source.aoNode,this.colorNode=source.colorNode,this.normalNode=source.normalNode,this.opacityNode=source.opacityNode,this.backdropNode=source.backdropNode,this.backdropAlphaNode=source.backdropAlphaNode,this.alphaTestNode=source.alphaTestNode,this.maskNode=source.maskNode,this.maskShadowNode=source.maskShadowNode,this.positionNode=source.positionNode,this.geometryNode=source.geometryNode,this.depthNode=source.depthNode,this.receivedShadowPositionNode=source.receivedShadowPositionNode,this.castShadowPositionNode=source.castShadowPositionNode,this.receivedShadowNode=source.receivedShadowNode,this.castShadowNode=source.castShadowNode,this.outputNode=source.outputNode,this.mrtNode=source.mrtNode,this.fragmentNode=source.fragmentNode,this.vertexNode=source.vertexNode,this.contextNode=source.contextNode,super.copy(source)}}const _defaultValues$d=/*@__PURE__*/new LineBasicMaterial;class LineBasicNodeMaterial extends NodeMaterial{static get type(){return"LineBasicNodeMaterial"}constructor(parameters){super(),this.isLineBasicNodeMaterial=!0,this.setDefaultValues(_defaultValues$d),this.setValues(parameters)}}const _defaultValues$c=/*@__PURE__*/new LineDashedMaterial;class LineDashedNodeMaterial extends NodeMaterial{static get type(){return"LineDashedNodeMaterial"}constructor(parameters){super(),this.isLineDashedNodeMaterial=!0,this.setDefaultValues(_defaultValues$c),this.dashOffset=0,this.offsetNode=null,this.dashScaleNode=null,this.dashSizeNode=null,this.gapSizeNode=null,this.setValues(parameters)}setupVariants(){const offsetNode=this.offsetNode?float(this.offsetNode):materialLineDashOffset,dashScaleNode=this.dashScaleNode?float(this.dashScaleNode):materialLineScale,dashSizeNode=this.dashSizeNode?float(this.dashSizeNode):materialLineDashSize,gapSizeNode=this.gapSizeNode?float(this.gapSizeNode):materialLineGapSize;dashSize.assign(dashSizeNode),gapSize.assign(gapSizeNode);const vLineDistance=varying(attribute("lineDistance").mul(dashScaleNode));(offsetNode?vLineDistance.add(offsetNode):vLineDistance).mod(dashSize.add(gapSize)).greaterThan(dashSize).discard()}}const _defaultValues$a=/*@__PURE__*/new MeshNormalMaterial;class MeshNormalNodeMaterial extends NodeMaterial{static get type(){return"MeshNormalNodeMaterial"}constructor(parameters){super(),this.isMeshNormalNodeMaterial=!0,this.setDefaultValues(_defaultValues$a),this.setValues(parameters)}setupDiffuseColor(){const opacityNode=this.opacityNode?float(this.opacityNode):materialOpacity;diffuseColor.assign(colorSpaceToWorking(vec4(nodeObject(normalView).mul(.5).add(.5),opacityNode),"srgb"))}}const equirectUV=/*@__PURE__*/Fn(([dir=positionWorldDirection])=>{const u=dir.z.atan(dir.x).mul(1/(2*Math.PI)).add(.5),v=dir.y.clamp(-1,1).asin().mul(1/Math.PI).add(.5);return vec2(u,v)});class CubeRenderTarget extends RenderTarget{constructor(size=1,options={}){super(size,size,options),this.isCubeRenderTarget=!0;const image={width:size,height:size,depth:1},images=[image,image,image,image,image,image];this.texture=new CubeTexture(images),this._setTextureOptions(options),this.texture.isRenderTargetTexture=!0}fromEquirectangularTexture(renderer,texture$1){const currentMinFilter=texture$1.minFilter,currentGenerateMipmaps=texture$1.generateMipmaps;texture$1.generateMipmaps=!0,this.texture.type=texture$1.type,this.texture.colorSpace=texture$1.colorSpace,this.texture.generateMipmaps=texture$1.generateMipmaps,this.texture.minFilter=texture$1.minFilter,this.texture.magFilter=texture$1.magFilter;const geometry=new BoxGeometry(5,5,5),uvNode=equirectUV(positionWorldDirection),material=new NodeMaterial;material.colorNode=texture(texture$1,uvNode,0),material.side=1,material.blending=0;const mesh=new Mesh(geometry,material),scene=new Scene;scene.add(mesh),1008===texture$1.minFilter&&(texture$1.minFilter=1006);const camera=new CubeCamera(1,10,this),currentMRT=renderer.getMRT();return renderer.setMRT(null),camera.update(renderer,scene),renderer.setMRT(currentMRT),texture$1.minFilter=currentMinFilter,texture$1.currentGenerateMipmaps=currentGenerateMipmaps,mesh.geometry.dispose(),mesh.material.dispose(),this}clear(renderer,color=!0,depth=!0,stencil=!0){const currentRenderTarget=renderer.getRenderTarget();for(let i=0;i<6;i++)renderer.setRenderTarget(this,i),renderer.clear(color,depth,stencil);renderer.setRenderTarget(currentRenderTarget)}}const _cache$1=new WeakMap;class CubeMapNode extends TempNode{static get type(){return"CubeMapNode"}constructor(envNode){super("vec3"),this.envNode=envNode,this._cubeTexture=null,this._cubeTextureNode=cubeTexture(null);const defaultTexture=new CubeTexture;defaultTexture.isRenderTargetTexture=!0,this._defaultTexture=defaultTexture,this.updateBeforeType=NodeUpdateType_RENDER}updateBefore(frame){const{renderer:renderer,material:material}=frame,envNode=this.envNode;if(envNode.isTextureNode||envNode.isMaterialReferenceNode){const texture=envNode.isTextureNode?envNode.value:material[envNode.property];if(texture&&texture.isTexture){const mapping=texture.mapping;if(303===mapping||304===mapping){if(_cache$1.has(texture)){const cubeMap=_cache$1.get(texture);mapTextureMapping(cubeMap,texture.mapping),this._cubeTexture=cubeMap}else{const image=texture.image;if(function isEquirectangularMapReady$1(image){return null!=image&&image.height>0}(image)){const renderTarget=new CubeRenderTarget(image.height);renderTarget.fromEquirectangularTexture(renderer,texture),mapTextureMapping(renderTarget.texture,texture.mapping),this._cubeTexture=renderTarget.texture,_cache$1.set(texture,renderTarget.texture),texture.addEventListener("dispose",onTextureDispose)}else this._cubeTexture=this._defaultTexture}this._cubeTextureNode.value=this._cubeTexture}else this._cubeTextureNode=this.envNode}}}setup(builder){return this.updateBefore(builder),this._cubeTextureNode}}function onTextureDispose(event){const texture=event.target;texture.removeEventListener("dispose",onTextureDispose);const renderTarget=_cache$1.get(texture);void 0!==renderTarget&&(_cache$1.delete(texture),renderTarget.dispose())}function mapTextureMapping(texture,mapping){303===mapping?texture.mapping=301:304===mapping&&(texture.mapping=302)}const cubeMapNode=/*@__PURE__*/nodeProxy(CubeMapNode).setParameterLength(1);class BasicEnvironmentNode extends LightingNode{static get type(){return"BasicEnvironmentNode"}constructor(envNode=null){super(),this.envNode=envNode}setup(builder){builder.context.environment=cubeMapNode(this.envNode)}}class BasicLightMapNode extends LightingNode{static get type(){return"BasicLightMapNode"}constructor(lightMapNode=null){super(),this.lightMapNode=lightMapNode}setup(builder){const RECIPROCAL_PI=float(1/Math.PI);builder.context.irradianceLightMap=this.lightMapNode.mul(RECIPROCAL_PI)}}class LightingModel{start(builder){builder.lightsNode.setupLights(builder,builder.lightsNode.getLightNodes(builder)),this.indirect(builder)}finish(){}direct(){}directRectArea(){}indirect(){}ambientOcclusion(){}}class BasicLightingModel extends LightingModel{constructor(){super()}indirect({context:context}){const ambientOcclusion=context.ambientOcclusion,reflectedLight=context.reflectedLight,irradianceLightMap=context.irradianceLightMap;reflectedLight.indirectDiffuse.assign(vec4(0)),irradianceLightMap?reflectedLight.indirectDiffuse.addAssign(irradianceLightMap):reflectedLight.indirectDiffuse.addAssign(vec4(1,1,1,0)),reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion),reflectedLight.indirectDiffuse.mulAssign(diffuseColor.rgb)}finish(builder){const{material:material,context:context}=builder,outgoingLight=context.outgoingLight,envNode=builder.context.environment;if(envNode)switch(material.combine){case 0:outgoingLight.rgb.assign(mix(outgoingLight.rgb,outgoingLight.rgb.mul(envNode.rgb),materialSpecularStrength.mul(materialReflectivity)));break;case 1:outgoingLight.rgb.assign(mix(outgoingLight.rgb,envNode.rgb,materialSpecularStrength.mul(materialReflectivity)));break;case 2:outgoingLight.rgb.addAssign(envNode.rgb.mul(materialSpecularStrength.mul(materialReflectivity)));break;default:warn("BasicLightingModel: Unsupported .combine value:",material.combine)}}}const _defaultValues$9=/*@__PURE__*/new MeshBasicMaterial;class MeshBasicNodeMaterial extends NodeMaterial{static get type(){return"MeshBasicNodeMaterial"}constructor(parameters){super(),this.isMeshBasicNodeMaterial=!0,this.lights=!0,this.setDefaultValues(_defaultValues$9),this.setValues(parameters)}setupNormal(){return directionToFaceDirection(normalViewGeometry)}setupEnvironment(builder){const envNode=super.setupEnvironment(builder);return envNode?new BasicEnvironmentNode(envNode):null}setupLightMap(builder){let node=null;return builder.material.lightMap&&(node=new BasicLightMapNode(materialLightMap)),node}setupOutgoingLight(){return diffuseColor.rgb}setupLightingModel(){return new BasicLightingModel}}const F_Schlick=/*@__PURE__*/Fn(({f0:f0,f90:f90,dotVH:dotVH})=>{const fresnel=dotVH.mul(-5.55473).sub(6.98316).mul(dotVH).exp2();return f0.mul(fresnel.oneMinus()).add(f90.mul(fresnel))}),BRDF_Lambert=/*@__PURE__*/Fn(inputs=>inputs.diffuseColor.mul(1/Math.PI)),D_BlinnPhong=/*@__PURE__*/Fn(({dotNH:dotNH})=>shininess.mul(float(.5)).add(1).mul(float(1/Math.PI)).mul(dotNH.pow(shininess))),BRDF_BlinnPhong=/*@__PURE__*/Fn(({lightDirection:lightDirection})=>{const halfDir=lightDirection.add(positionViewDirection).normalize(),dotNH=normalView.dot(halfDir).clamp(),dotVH=positionViewDirection.dot(halfDir).clamp(),F=F_Schlick({f0:specularColor,f90:1,dotVH:dotVH}),G=float(.25),D=D_BlinnPhong({dotNH:dotNH});return F.mul(G).mul(D)});class PhongLightingModel extends BasicLightingModel{constructor(specular=!0){super(),this.specular=specular}direct({lightDirection:lightDirection,lightColor:lightColor,reflectedLight:reflectedLight}){const irradiance=normalView.dot(lightDirection).clamp().mul(lightColor);reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({diffuseColor:diffuseColor.rgb}))),!0===this.specular&&reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_BlinnPhong({lightDirection:lightDirection})).mul(materialSpecularStrength))}indirect(builder){const{ambientOcclusion:ambientOcclusion,irradiance:irradiance,reflectedLight:reflectedLight}=builder.context;reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({diffuseColor:diffuseColor}))),reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion)}}const _defaultValues$8=/*@__PURE__*/new MeshLambertMaterial;class MeshLambertNodeMaterial extends NodeMaterial{static get type(){return"MeshLambertNodeMaterial"}constructor(parameters){super(),this.isMeshLambertNodeMaterial=!0,this.lights=!0,this.setDefaultValues(_defaultValues$8),this.setValues(parameters)}setupEnvironment(builder){const envNode=super.setupEnvironment(builder);return envNode?new BasicEnvironmentNode(envNode):null}setupLightingModel(){return new PhongLightingModel(!1)}}const _defaultValues$7=/*@__PURE__*/new MeshPhongMaterial;class MeshPhongNodeMaterial extends NodeMaterial{static get type(){return"MeshPhongNodeMaterial"}constructor(parameters){super(),this.isMeshPhongNodeMaterial=!0,this.lights=!0,this.shininessNode=null,this.specularNode=null,this.setDefaultValues(_defaultValues$7),this.setValues(parameters)}setupEnvironment(builder){const envNode=super.setupEnvironment(builder);return envNode?new BasicEnvironmentNode(envNode):null}setupLightingModel(){return new PhongLightingModel}setupVariants(){const shininessNode=(this.shininessNode?float(this.shininessNode):materialShininess).max(1e-4);shininess.assign(shininessNode);const specularNode=this.specularNode||materialSpecular;specularColor.assign(specularNode)}copy(source){return this.shininessNode=source.shininessNode,this.specularNode=source.specularNode,super.copy(source)}}const getGeometryRoughness=/*@__PURE__*/Fn(builder=>{if(!1===builder.geometry.hasAttribute("normal"))return float(0);const dxy=normalViewGeometry.dFdx().abs().max(normalViewGeometry.dFdy().abs());return dxy.x.max(dxy.y).max(dxy.z)}),getRoughness=/*@__PURE__*/Fn(inputs=>{const{roughness:roughness}=inputs,geometryRoughness=getGeometryRoughness();let roughnessFactor=roughness.max(.0525);return roughnessFactor=roughnessFactor.add(geometryRoughness),roughnessFactor=roughnessFactor.min(1),roughnessFactor}),V_GGX_SmithCorrelated=/*@__PURE__*/Fn(({alpha:alpha,dotNL:dotNL,dotNV:dotNV})=>{const a2=alpha.pow2(),gv=dotNL.mul(a2.add(a2.oneMinus().mul(dotNV.pow2())).sqrt()),gl=dotNV.mul(a2.add(a2.oneMinus().mul(dotNL.pow2())).sqrt());return div(.5,gv.add(gl).max(EPSILON))}).setLayout({name:"V_GGX_SmithCorrelated",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNL",type:"float"},{name:"dotNV",type:"float"}]}),V_GGX_SmithCorrelated_Anisotropic=/*@__PURE__*/Fn(({alphaT:alphaT,alphaB:alphaB,dotTV:dotTV,dotBV:dotBV,dotTL:dotTL,dotBL:dotBL,dotNV:dotNV,dotNL:dotNL})=>{const gv=dotNL.mul(vec3(alphaT.mul(dotTV),alphaB.mul(dotBV),dotNV).length()),gl=dotNV.mul(vec3(alphaT.mul(dotTL),alphaB.mul(dotBL),dotNL).length());return div(.5,gv.add(gl))}).setLayout({name:"V_GGX_SmithCorrelated_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotTV",type:"float",qualifier:"in"},{name:"dotBV",type:"float",qualifier:"in"},{name:"dotTL",type:"float",qualifier:"in"},{name:"dotBL",type:"float",qualifier:"in"},{name:"dotNV",type:"float",qualifier:"in"},{name:"dotNL",type:"float",qualifier:"in"}]}),D_GGX=/*@__PURE__*/Fn(({alpha:alpha,dotNH:dotNH})=>{const a2=alpha.pow2(),denom=dotNH.pow2().mul(a2.oneMinus()).oneMinus();return a2.div(denom.pow2()).mul(1/Math.PI)}).setLayout({name:"D_GGX",type:"float",inputs:[{name:"alpha",type:"float"},{name:"dotNH",type:"float"}]}),RECIPROCAL_PI=/*@__PURE__*/float(1/Math.PI),D_GGX_Anisotropic=/*@__PURE__*/Fn(({alphaT:alphaT,alphaB:alphaB,dotNH:dotNH,dotTH:dotTH,dotBH:dotBH})=>{const a2=alphaT.mul(alphaB),v=vec3(alphaB.mul(dotTH),alphaT.mul(dotBH),a2.mul(dotNH)),v2=v.dot(v),w2=a2.div(v2);return RECIPROCAL_PI.mul(a2.mul(w2.pow2()))}).setLayout({name:"D_GGX_Anisotropic",type:"float",inputs:[{name:"alphaT",type:"float",qualifier:"in"},{name:"alphaB",type:"float",qualifier:"in"},{name:"dotNH",type:"float",qualifier:"in"},{name:"dotTH",type:"float",qualifier:"in"},{name:"dotBH",type:"float",qualifier:"in"}]}),BRDF_GGX=/*@__PURE__*/Fn(({lightDirection:lightDirection,f0:f0,f90:f90,roughness:roughness,f:f,normalView:normalView$1=normalView,USE_IRIDESCENCE:USE_IRIDESCENCE,USE_ANISOTROPY:USE_ANISOTROPY})=>{const alpha=roughness.pow2(),halfDir=lightDirection.add(positionViewDirection).normalize(),dotNL=normalView$1.dot(lightDirection).clamp(),dotNV=normalView$1.dot(positionViewDirection).clamp(),dotNH=normalView$1.dot(halfDir).clamp(),dotVH=positionViewDirection.dot(halfDir).clamp();let V,D,F=F_Schlick({f0:f0,f90:f90,dotVH:dotVH});if(defined(USE_IRIDESCENCE)&&(F=iridescence.mix(F,f)),defined(USE_ANISOTROPY)){const dotTL=anisotropyT.dot(lightDirection),dotTV=anisotropyT.dot(positionViewDirection),dotTH=anisotropyT.dot(halfDir),dotBL=anisotropyB.dot(lightDirection),dotBV=anisotropyB.dot(positionViewDirection),dotBH=anisotropyB.dot(halfDir);V=V_GGX_SmithCorrelated_Anisotropic({alphaT:alphaT,alphaB:alpha,dotTV:dotTV,dotBV:dotBV,dotTL:dotTL,dotBL:dotBL,dotNV:dotNV,dotNL:dotNL}),D=D_GGX_Anisotropic({alphaT:alphaT,alphaB:alpha,dotNH:dotNH,dotTH:dotTH,dotBH:dotBH})}else V=V_GGX_SmithCorrelated({alpha:alpha,dotNL:dotNL,dotNV:dotNV}),D=D_GGX({alpha:alpha,dotNH:dotNH});return F.mul(V).mul(D)}),DATA=new Uint16Array([12469,15057,12620,14925,13266,14620,13807,14376,14323,13990,14545,13625,14713,13328,14840,12882,14931,12528,14996,12233,15039,11829,15066,11525,15080,11295,15085,10976,15082,10705,15073,10495,13880,14564,13898,14542,13977,14430,14158,14124,14393,13732,14556,13410,14702,12996,14814,12596,14891,12291,14937,11834,14957,11489,14958,11194,14943,10803,14921,10506,14893,10278,14858,9960,14484,14039,14487,14025,14499,13941,14524,13740,14574,13468,14654,13106,14743,12678,14818,12344,14867,11893,14889,11509,14893,11180,14881,10751,14852,10428,14812,10128,14765,9754,14712,9466,14764,13480,14764,13475,14766,13440,14766,13347,14769,13070,14786,12713,14816,12387,14844,11957,14860,11549,14868,11215,14855,10751,14825,10403,14782,10044,14729,9651,14666,9352,14599,9029,14967,12835,14966,12831,14963,12804,14954,12723,14936,12564,14917,12347,14900,11958,14886,11569,14878,11247,14859,10765,14828,10401,14784,10011,14727,9600,14660,9289,14586,8893,14508,8533,15111,12234,15110,12234,15104,12216,15092,12156,15067,12010,15028,11776,14981,11500,14942,11205,14902,10752,14861,10393,14812,9991,14752,9570,14682,9252,14603,8808,14519,8445,14431,8145,15209,11449,15208,11451,15202,11451,15190,11438,15163,11384,15117,11274,15055,10979,14994,10648,14932,10343,14871,9936,14803,9532,14729,9218,14645,8742,14556,8381,14461,8020,14365,7603,15273,10603,15272,10607,15267,10619,15256,10631,15231,10614,15182,10535,15118,10389,15042,10167,14963,9787,14883,9447,14800,9115,14710,8665,14615,8318,14514,7911,14411,7507,14279,7198,15314,9675,15313,9683,15309,9712,15298,9759,15277,9797,15229,9773,15166,9668,15084,9487,14995,9274,14898,8910,14800,8539,14697,8234,14590,7790,14479,7409,14367,7067,14178,6621,15337,8619,15337,8631,15333,8677,15325,8769,15305,8871,15264,8940,15202,8909,15119,8775,15022,8565,14916,8328,14804,8009,14688,7614,14569,7287,14448,6888,14321,6483,14088,6171,15350,7402,15350,7419,15347,7480,15340,7613,15322,7804,15287,7973,15229,8057,15148,8012,15046,7846,14933,7611,14810,7357,14682,7069,14552,6656,14421,6316,14251,5948,14007,5528,15356,5942,15356,5977,15353,6119,15348,6294,15332,6551,15302,6824,15249,7044,15171,7122,15070,7050,14949,6861,14818,6611,14679,6349,14538,6067,14398,5651,14189,5311,13935,4958,15359,4123,15359,4153,15356,4296,15353,4646,15338,5160,15311,5508,15263,5829,15188,6042,15088,6094,14966,6001,14826,5796,14678,5543,14527,5287,14377,4985,14133,4586,13869,4257,15360,1563,15360,1642,15358,2076,15354,2636,15341,3350,15317,4019,15273,4429,15203,4732,15105,4911,14981,4932,14836,4818,14679,4621,14517,4386,14359,4156,14083,3795,13808,3437,15360,122,15360,137,15358,285,15355,636,15344,1274,15322,2177,15281,2765,15215,3223,15120,3451,14995,3569,14846,3567,14681,3466,14511,3305,14344,3121,14037,2800,13753,2467,15360,0,15360,1,15359,21,15355,89,15346,253,15325,479,15287,796,15225,1148,15133,1492,15008,1749,14856,1882,14685,1886,14506,1783,14324,1608,13996,1398,13702,1183]);let lut=null;const DFGLUT=/*@__PURE__*/Fn(({roughness:roughness,dotNV:dotNV})=>{null===lut&&(lut=new DataTexture(DATA,16,16,1030,HalfFloatType),lut.name="DFG_LUT",lut.minFilter=1006,lut.magFilter=1006,lut.wrapS=1001,lut.wrapT=1001,lut.generateMipmaps=!1,lut.needsUpdate=!0);const uv=vec2(roughness,dotNV);return texture(lut,uv).rg}),BRDF_GGX_Multiscatter=/*@__PURE__*/Fn(({lightDirection:lightDirection,f0:f0,f90:f90,roughness:_roughness,f:f,USE_IRIDESCENCE:USE_IRIDESCENCE,USE_ANISOTROPY:USE_ANISOTROPY})=>{const singleScatter=BRDF_GGX({lightDirection:lightDirection,f0:f0,f90:f90,roughness:_roughness,f:f,USE_IRIDESCENCE:USE_IRIDESCENCE,USE_ANISOTROPY:USE_ANISOTROPY}),dotNL=normalView.dot(lightDirection).clamp(),dotNV=normalView.dot(positionViewDirection).clamp(),dfgV=DFGLUT({roughness:_roughness,dotNV:dotNV}),dfgL=DFGLUT({roughness:_roughness,dotNV:dotNL}),FssEss_V=f0.mul(dfgV.x).add(f90.mul(dfgV.y)),FssEss_L=f0.mul(dfgL.x).add(f90.mul(dfgL.y)),Ess_V=dfgV.x.add(dfgV.y),Ess_L=dfgL.x.add(dfgL.y),Ems_V=float(1).sub(Ess_V),Ems_L=float(1).sub(Ess_L),Favg=f0.add(f0.oneMinus().mul(.047619)),Fms=FssEss_V.mul(FssEss_L).mul(Favg).div(float(1).sub(Ems_V.mul(Ems_L).mul(Favg).mul(Favg)).add(EPSILON)),compensationFactor=Ems_V.mul(Ems_L),multiScatter=Fms.mul(compensationFactor);return singleScatter.add(multiScatter)}),EnvironmentBRDF=/*@__PURE__*/Fn(inputs=>{const{dotNV:dotNV,specularColor:specularColor,specularF90:specularF90,roughness:roughness}=inputs,fab=DFGLUT({dotNV:dotNV,roughness:roughness});return specularColor.mul(fab.x).add(specularF90.mul(fab.y))}),Schlick_to_F0=/*@__PURE__*/Fn(({f:f,f90:f90,dotVH:dotVH})=>{const x=dotVH.oneMinus().saturate(),x2=x.mul(x),x5=x.mul(x2,x2).clamp(0,.9999);return f.sub(vec3(f90).mul(x5)).div(x5.oneMinus())}).setLayout({name:"Schlick_to_F0",type:"vec3",inputs:[{name:"f",type:"vec3"},{name:"f90",type:"float"},{name:"dotVH",type:"float"}]}),D_Charlie=/*@__PURE__*/Fn(({roughness:roughness,dotNH:dotNH})=>{const alpha=roughness.pow2(),invAlpha=float(1).div(alpha),sin2h=dotNH.pow2().oneMinus().max(.0078125);return float(2).add(invAlpha).mul(sin2h.pow(invAlpha.mul(.5))).div(2*Math.PI)}).setLayout({name:"D_Charlie",type:"float",inputs:[{name:"roughness",type:"float"},{name:"dotNH",type:"float"}]}),V_Neubelt=/*@__PURE__*/Fn(({dotNV:dotNV,dotNL:dotNL})=>float(1).div(float(4).mul(dotNL.add(dotNV).sub(dotNL.mul(dotNV))))).setLayout({name:"V_Neubelt",type:"float",inputs:[{name:"dotNV",type:"float"},{name:"dotNL",type:"float"}]}),BRDF_Sheen=/*@__PURE__*/Fn(({lightDirection:lightDirection})=>{const halfDir=lightDirection.add(positionViewDirection).normalize(),dotNL=normalView.dot(lightDirection).clamp(),dotNV=normalView.dot(positionViewDirection).clamp(),dotNH=normalView.dot(halfDir).clamp(),D=D_Charlie({roughness:sheenRoughness,dotNH:dotNH}),V=V_Neubelt({dotNV:dotNV,dotNL:dotNL});return sheen.mul(D).mul(V)}),LTC_Uv=/*@__PURE__*/Fn(({N:N,V:V,roughness:roughness})=>{const dotNV=N.dot(V).saturate(),uv=vec2(roughness,dotNV.oneMinus().sqrt());return uv.assign(uv.mul(.984375).add(.0078125)),uv}).setLayout({name:"LTC_Uv",type:"vec2",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"roughness",type:"float"}]}),LTC_ClippedSphereFormFactor=/*@__PURE__*/Fn(({f:f})=>{const l=f.length();return max$1(l.mul(l).add(f.z).div(l.add(1)),0)}).setLayout({name:"LTC_ClippedSphereFormFactor",type:"float",inputs:[{name:"f",type:"vec3"}]}),LTC_EdgeVectorFormFactor=/*@__PURE__*/Fn(({v1:v1,v2:v2})=>{const x=v1.dot(v2),y=x.abs().toVar(),a=y.mul(.0145206).add(.4965155).mul(y).add(.8543985).toVar(),b=y.add(4.1616724).mul(y).add(3.417594).toVar(),v=a.div(b),theta_sintheta=x.greaterThan(0).select(v,max$1(x.mul(x).oneMinus(),1e-7).inverseSqrt().mul(.5).sub(v));return v1.cross(v2).mul(theta_sintheta)}).setLayout({name:"LTC_EdgeVectorFormFactor",type:"vec3",inputs:[{name:"v1",type:"vec3"},{name:"v2",type:"vec3"}]}),LTC_Evaluate=/*@__PURE__*/Fn(({N:N,V:V,P:P,mInv:mInv,p0:p0,p1:p1,p2:p2,p3:p3})=>{const v1=p1.sub(p0).toVar(),v2=p3.sub(p0).toVar(),lightNormal=v1.cross(v2),result=vec3().toVar();return If(lightNormal.dot(P.sub(p0)).greaterThanEqual(0),()=>{const T1=V.sub(N.mul(V.dot(N))).normalize(),T2=N.cross(T1).negate(),mat=mInv.mul(mat3(T1,T2,N).transpose()).toVar(),coords0=mat.mul(p0.sub(P)).normalize().toVar(),coords1=mat.mul(p1.sub(P)).normalize().toVar(),coords2=mat.mul(p2.sub(P)).normalize().toVar(),coords3=mat.mul(p3.sub(P)).normalize().toVar(),vectorFormFactor=vec3(0).toVar();vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({v1:coords0,v2:coords1})),vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({v1:coords1,v2:coords2})),vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({v1:coords2,v2:coords3})),vectorFormFactor.addAssign(LTC_EdgeVectorFormFactor({v1:coords3,v2:coords0})),result.assign(vec3(LTC_ClippedSphereFormFactor({f:vectorFormFactor})))}),result}).setLayout({name:"LTC_Evaluate",type:"vec3",inputs:[{name:"N",type:"vec3"},{name:"V",type:"vec3"},{name:"P",type:"vec3"},{name:"mInv",type:"mat3"},{name:"p0",type:"vec3"},{name:"p1",type:"vec3"},{name:"p2",type:"vec3"},{name:"p3",type:"vec3"}]}),bC=1/6,w0=a=>mul(bC,mul(a,mul(a,a.negate().add(3)).sub(3)).add(1)),w1=a=>mul(bC,mul(a,mul(a,mul(3,a).sub(6))).add(4)),w2=a=>mul(bC,mul(a,mul(a,mul(-3,a).add(3)).add(3)).add(1)),w3=a=>mul(bC,pow(a,3)),g0=a=>w0(a).add(w1(a)),g1=a=>w2(a).add(w3(a)),h0=a=>add(-1,w1(a).div(w0(a).add(w1(a)))),h1=a=>add(1,w3(a).div(w2(a).add(w3(a)))),bicubic=(textureNode,texelSize,lod)=>{const uv=textureNode.uvNode,uvScaled=mul(uv,texelSize.zw).add(.5),iuv=floor(uvScaled),fuv=fract(uvScaled),g0x=g0(fuv.x),g1x=g1(fuv.x),h0x=h0(fuv.x),h1x=h1(fuv.x),h0y=h0(fuv.y),h1y=h1(fuv.y),p0=vec2(iuv.x.add(h0x),iuv.y.add(h0y)).sub(.5).mul(texelSize.xy),p1=vec2(iuv.x.add(h1x),iuv.y.add(h0y)).sub(.5).mul(texelSize.xy),p2=vec2(iuv.x.add(h0x),iuv.y.add(h1y)).sub(.5).mul(texelSize.xy),p3=vec2(iuv.x.add(h1x),iuv.y.add(h1y)).sub(.5).mul(texelSize.xy),a=g0(fuv.y).mul(add(g0x.mul(textureNode.sample(p0).level(lod)),g1x.mul(textureNode.sample(p1).level(lod)))),b=g1(fuv.y).mul(add(g0x.mul(textureNode.sample(p2).level(lod)),g1x.mul(textureNode.sample(p3).level(lod))));return a.add(b)},textureBicubicLevel=/*@__PURE__*/Fn(([textureNode,lodNode])=>{const fLodSize=vec2(textureNode.size(int(lodNode))),cLodSize=vec2(textureNode.size(int(lodNode.add(1)))),fLodSizeInv=div(1,fLodSize),cLodSizeInv=div(1,cLodSize),fSample=bicubic(textureNode,vec4(fLodSizeInv,fLodSize),floor(lodNode)),cSample=bicubic(textureNode,vec4(cLodSizeInv,cLodSize),ceil(lodNode));return fract(lodNode).mix(fSample,cSample)}),getVolumeTransmissionRay=/*@__PURE__*/Fn(([n,v,thickness,ior,modelMatrix])=>{const refractionVector=vec3(refract(v.negate(),normalize(n),div(1,ior))),modelScale=vec3(length(modelMatrix[0].xyz),length(modelMatrix[1].xyz),length(modelMatrix[2].xyz));return normalize(refractionVector).mul(thickness.mul(modelScale))}).setLayout({name:"getVolumeTransmissionRay",type:"vec3",inputs:[{name:"n",type:"vec3"},{name:"v",type:"vec3"},{name:"thickness",type:"float"},{name:"ior",type:"float"},{name:"modelMatrix",type:"mat4"}]}),applyIorToRoughness=/*@__PURE__*/Fn(([roughness,ior])=>roughness.mul(clamp$2(ior.mul(2).sub(2),0,1))).setLayout({name:"applyIorToRoughness",type:"float",inputs:[{name:"roughness",type:"float"},{name:"ior",type:"float"}]}),viewportBackSideTexture=/*@__PURE__*/viewportMipTexture(),viewportFrontSideTexture=/*@__PURE__*/viewportOpaqueMipTexture(),getTransmissionSample=/*@__PURE__*/Fn(([fragCoord,roughness,ior],{material:material})=>{const transmissionSample=(1===material.side?viewportBackSideTexture:viewportFrontSideTexture).sample(fragCoord),lod=log2(screenSize.x).mul(applyIorToRoughness(roughness,ior));return textureBicubicLevel(transmissionSample,lod)}),volumeAttenuation=/*@__PURE__*/Fn(([transmissionDistance,attenuationColor,attenuationDistance])=>(If(attenuationDistance.notEqual(0),()=>{const attenuationCoefficient=log(attenuationColor).negate().div(attenuationDistance);return exp(attenuationCoefficient.negate().mul(transmissionDistance))}),vec3(1))).setLayout({name:"volumeAttenuation",type:"vec3",inputs:[{name:"transmissionDistance",type:"float"},{name:"attenuationColor",type:"vec3"},{name:"attenuationDistance",type:"float"}]}),getIBLVolumeRefraction=/*@__PURE__*/Fn(([n,v,roughness,diffuseColor,specularColor,specularF90,position,modelMatrix,viewMatrix,projMatrix,ior,thickness,attenuationColor,attenuationDistance,dispersion])=>{let transmittedLight,transmittance;if(dispersion){transmittedLight=vec4().toVar(),transmittance=vec3().toVar();const halfSpread=ior.sub(1).mul(dispersion.mul(.025)),iors=vec3(ior.sub(halfSpread),ior,ior.add(halfSpread));Loop({start:0,end:3},({i:i})=>{const ior=iors.element(i),transmissionRay=getVolumeTransmissionRay(n,v,thickness,ior,modelMatrix),refractedRayExit=position.add(transmissionRay),ndcPos=projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit,1))),refractionCoords=vec2(ndcPos.xy.div(ndcPos.w)).toVar();refractionCoords.addAssign(1),refractionCoords.divAssign(2),refractionCoords.assign(vec2(refractionCoords.x,refractionCoords.y.oneMinus()));const transmissionSample=getTransmissionSample(refractionCoords,roughness,ior);transmittedLight.element(i).assign(transmissionSample.element(i)),transmittedLight.a.addAssign(transmissionSample.a),transmittance.element(i).assign(diffuseColor.element(i).mul(volumeAttenuation(length(transmissionRay),attenuationColor,attenuationDistance).element(i)))}),transmittedLight.a.divAssign(3)}else{const transmissionRay=getVolumeTransmissionRay(n,v,thickness,ior,modelMatrix),refractedRayExit=position.add(transmissionRay),ndcPos=projMatrix.mul(viewMatrix.mul(vec4(refractedRayExit,1))),refractionCoords=vec2(ndcPos.xy.div(ndcPos.w)).toVar();refractionCoords.addAssign(1),refractionCoords.divAssign(2),refractionCoords.assign(vec2(refractionCoords.x,refractionCoords.y.oneMinus())),transmittedLight=getTransmissionSample(refractionCoords,roughness,ior),transmittance=diffuseColor.mul(volumeAttenuation(length(transmissionRay),attenuationColor,attenuationDistance))}const attenuatedColor=transmittance.rgb.mul(transmittedLight.rgb),dotNV=n.dot(v).clamp(),F=vec3(EnvironmentBRDF({dotNV:dotNV,specularColor:specularColor,specularF90:specularF90,roughness:roughness})),transmittanceFactor=transmittance.r.add(transmittance.g,transmittance.b).div(3);return vec4(F.oneMinus().mul(attenuatedColor),transmittedLight.a.oneMinus().mul(transmittanceFactor).oneMinus())}),XYZ_TO_REC709=/*@__PURE__*/mat3(3.2404542,-.969266,.0556434,-1.5371385,1.8760108,-.2040259,-.4985314,.041556,1.0572252),IorToFresnel0=(transmittedIor,incidentIor)=>transmittedIor.sub(incidentIor).div(transmittedIor.add(incidentIor)).pow2(),evalIridescence=/*@__PURE__*/Fn(({outsideIOR:outsideIOR,eta2:eta2,cosTheta1:cosTheta1,thinFilmThickness:thinFilmThickness,baseF0:baseF0})=>{const iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0,.03,thinFilmThickness)),cosTheta2Sq=outsideIOR.div(iridescenceIOR).pow2().mul(cosTheta1.pow2().oneMinus()).oneMinus();If(cosTheta2Sq.lessThan(0),()=>vec3(1));const cosTheta2=cosTheta2Sq.sqrt(),R0=IorToFresnel0(iridescenceIOR,outsideIOR),R12=F_Schlick({f0:R0,f90:1,dotVH:cosTheta1}),T121=R12.oneMinus(),phi12=iridescenceIOR.lessThan(outsideIOR).select(Math.PI,0),phi21=float(Math.PI).sub(phi12),baseIOR=(fresnel0=>{const sqrtF0=fresnel0.sqrt();return vec3(1).add(sqrtF0).div(vec3(1).sub(sqrtF0))})(baseF0.clamp(0,.9999)),R1=IorToFresnel0(baseIOR,iridescenceIOR.toVec3()),R23=F_Schlick({f0:R1,f90:1,dotVH:cosTheta2}),phi23=vec3(baseIOR.x.lessThan(iridescenceIOR).select(Math.PI,0),baseIOR.y.lessThan(iridescenceIOR).select(Math.PI,0),baseIOR.z.lessThan(iridescenceIOR).select(Math.PI,0)),OPD=iridescenceIOR.mul(thinFilmThickness,cosTheta2,2),phi=vec3(phi21).add(phi23),R123=R12.mul(R23).clamp(1e-5,.9999),r123=R123.sqrt(),Rs=T121.pow2().mul(R23).div(vec3(1).sub(R123)),I=R12.add(Rs).toVar(),Cm=Rs.sub(T121).toVar();return Loop({start:1,end:2,condition:"<=",name:"m"},({m:m})=>{Cm.mulAssign(r123);const Sm=((OPD,shift)=>{const phase=OPD.mul(2*Math.PI*1e-9),val=vec3(54856e-17,44201e-17,52481e-17),pos=vec3(1681e3,1795300,2208400),VAR=vec3(43278e5,93046e5,66121e5),x=float(9747e-17*Math.sqrt(2*Math.PI*45282e5)).mul(phase.mul(2239900).add(shift.x).cos()).mul(phase.pow2().mul(-45282e5).exp());let xyz=val.mul(VAR.mul(2*Math.PI).sqrt()).mul(pos.mul(phase).add(shift).cos()).mul(phase.pow2().negate().mul(VAR).exp());return xyz=vec3(xyz.x.add(x),xyz.y,xyz.z).div(1.0685e-7),XYZ_TO_REC709.mul(xyz)})(float(m).mul(OPD),float(m).mul(phi)).mul(2);I.addAssign(Cm.mul(Sm))}),I.max(vec3(0))}).setLayout({name:"evalIridescence",type:"vec3",inputs:[{name:"outsideIOR",type:"float"},{name:"eta2",type:"float"},{name:"cosTheta1",type:"float"},{name:"thinFilmThickness",type:"float"},{name:"baseF0",type:"vec3"}]}),IBLSheenBRDF=/*@__PURE__*/Fn(({normal:normal,viewDir:viewDir,roughness:roughness})=>{const dotNV=normal.dot(viewDir).saturate(),r2=roughness.mul(roughness),rInv=roughness.add(.1).reciprocal(),a=float(-1.9362).add(roughness.mul(1.0678)).add(r2.mul(.4573)).sub(rInv.mul(.8469)),b=float(-.6014).add(roughness.mul(.5538)).sub(r2.mul(.467)).sub(rInv.mul(.1255));return a.mul(dotNV).add(b).exp().saturate()}),clearcoatF0=vec3(.04),clearcoatF90=float(1);class PhysicalLightingModel extends LightingModel{constructor(clearcoat=!1,sheen=!1,iridescence=!1,anisotropy=!1,transmission=!1,dispersion=!1){super(),this.clearcoat=clearcoat,this.sheen=sheen,this.iridescence=iridescence,this.anisotropy=anisotropy,this.transmission=transmission,this.dispersion=dispersion,this.clearcoatRadiance=null,this.clearcoatSpecularDirect=null,this.clearcoatSpecularIndirect=null,this.sheenSpecularDirect=null,this.sheenSpecularIndirect=null,this.iridescenceFresnel=null,this.iridescenceF0=null,this.iridescenceF0Dielectric=null,this.iridescenceF0Metallic=null}start(builder){if(!0===this.clearcoat&&(this.clearcoatRadiance=vec3().toVar("clearcoatRadiance"),this.clearcoatSpecularDirect=vec3().toVar("clearcoatSpecularDirect"),this.clearcoatSpecularIndirect=vec3().toVar("clearcoatSpecularIndirect")),!0===this.sheen&&(this.sheenSpecularDirect=vec3().toVar("sheenSpecularDirect"),this.sheenSpecularIndirect=vec3().toVar("sheenSpecularIndirect")),!0===this.iridescence){const dotNVi=normalView.dot(positionViewDirection).clamp(),iridescenceFresnelDielectric=evalIridescence({outsideIOR:float(1),eta2:iridescenceIOR,cosTheta1:dotNVi,thinFilmThickness:iridescenceThickness,baseF0:specularColor}),iridescenceFresnelMetallic=evalIridescence({outsideIOR:float(1),eta2:iridescenceIOR,cosTheta1:dotNVi,thinFilmThickness:iridescenceThickness,baseF0:diffuseColor.rgb});this.iridescenceFresnel=mix(iridescenceFresnelDielectric,iridescenceFresnelMetallic,metalness),this.iridescenceF0Dielectric=Schlick_to_F0({f:iridescenceFresnelDielectric,f90:1,dotVH:dotNVi}),this.iridescenceF0Metallic=Schlick_to_F0({f:iridescenceFresnelMetallic,f90:1,dotVH:dotNVi}),this.iridescenceF0=mix(this.iridescenceF0Dielectric,this.iridescenceF0Metallic,metalness)}if(!0===this.transmission){const position=positionWorld,v=cameraPosition.sub(positionWorld).normalize(),n=normalWorld,context=builder.context;context.backdrop=getIBLVolumeRefraction(n,v,roughness,diffuseContribution,specularColorBlended,specularF90,position,modelWorldMatrix,cameraViewMatrix,cameraProjectionMatrix,ior,thickness,attenuationColor,attenuationDistance,this.dispersion?dispersion:null),context.backdropAlpha=transmission,diffuseColor.a.mulAssign(mix(1,context.backdrop.a,transmission))}super.start(builder)}computeMultiscattering(singleScatter,multiScatter,specularF90,f0,iridescenceF0=null){const dotNV=normalView.dot(positionViewDirection).clamp(),fab=DFGLUT({roughness:roughness,dotNV:dotNV}),Fr=iridescenceF0?iridescence.mix(f0,iridescenceF0):f0,FssEss=Fr.mul(fab.x).add(specularF90.mul(fab.y)),Ems=fab.x.add(fab.y).oneMinus(),Favg=Fr.add(Fr.oneMinus().mul(.047619)),Fms=FssEss.mul(Favg).div(Ems.mul(Favg).oneMinus());singleScatter.addAssign(FssEss),multiScatter.addAssign(Fms.mul(Ems))}direct({lightDirection:lightDirection,lightColor:lightColor,reflectedLight:reflectedLight}){const irradiance=normalView.dot(lightDirection).clamp().mul(lightColor).toVar();if(!0===this.sheen){this.sheenSpecularDirect.addAssign(irradiance.mul(BRDF_Sheen({lightDirection:lightDirection})));const sheenAlbedoV=IBLSheenBRDF({normal:normalView,viewDir:positionViewDirection,roughness:sheenRoughness}),sheenAlbedoL=IBLSheenBRDF({normal:normalView,viewDir:lightDirection,roughness:sheenRoughness}),sheenEnergyComp=sheen.r.max(sheen.g).max(sheen.b).mul(sheenAlbedoV.max(sheenAlbedoL)).oneMinus();irradiance.mulAssign(sheenEnergyComp)}if(!0===this.clearcoat){const ccIrradiance=clearcoatNormalView.dot(lightDirection).clamp().mul(lightColor);this.clearcoatSpecularDirect.addAssign(ccIrradiance.mul(BRDF_GGX({lightDirection:lightDirection,f0:clearcoatF0,f90:clearcoatF90,roughness:clearcoatRoughness,normalView:clearcoatNormalView})))}reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({diffuseColor:diffuseContribution}))),reflectedLight.directSpecular.addAssign(irradiance.mul(BRDF_GGX_Multiscatter({lightDirection:lightDirection,f0:specularColorBlended,f90:1,roughness:roughness,f:this.iridescenceFresnel,USE_IRIDESCENCE:this.iridescence,USE_ANISOTROPY:this.anisotropy})))}directRectArea({lightColor:lightColor,lightPosition:lightPosition,halfWidth:halfWidth,halfHeight:halfHeight,reflectedLight:reflectedLight,ltc_1:ltc_1,ltc_2:ltc_2}){const p0=lightPosition.add(halfWidth).sub(halfHeight),p1=lightPosition.sub(halfWidth).sub(halfHeight),p2=lightPosition.sub(halfWidth).add(halfHeight),p3=lightPosition.add(halfWidth).add(halfHeight),N=normalView,V=positionViewDirection,P=positionView.toVar(),uv=LTC_Uv({N:N,V:V,roughness:roughness}),t1=ltc_1.sample(uv).toVar(),t2=ltc_2.sample(uv).toVar(),mInv=mat3(vec3(t1.x,0,t1.y),vec3(0,1,0),vec3(t1.z,0,t1.w)).toVar(),fresnel=specularColorBlended.mul(t2.x).add(specularF90.sub(specularColorBlended).mul(t2.y)).toVar();if(reflectedLight.directSpecular.addAssign(lightColor.mul(fresnel).mul(LTC_Evaluate({N:N,V:V,P:P,mInv:mInv,p0:p0,p1:p1,p2:p2,p3:p3}))),reflectedLight.directDiffuse.addAssign(lightColor.mul(diffuseContribution).mul(LTC_Evaluate({N:N,V:V,P:P,mInv:mat3(1,0,0,0,1,0,0,0,1),p0:p0,p1:p1,p2:p2,p3:p3}))),!0===this.clearcoat){const Ncc=clearcoatNormalView,uvClearcoat=LTC_Uv({N:Ncc,V:V,roughness:clearcoatRoughness}),t1Clearcoat=ltc_1.sample(uvClearcoat),t2Clearcoat=ltc_2.sample(uvClearcoat),mInvClearcoat=mat3(vec3(t1Clearcoat.x,0,t1Clearcoat.y),vec3(0,1,0),vec3(t1Clearcoat.z,0,t1Clearcoat.w)),fresnelClearcoat=clearcoatF0.mul(t2Clearcoat.x).add(clearcoatF90.sub(clearcoatF0).mul(t2Clearcoat.y));this.clearcoatSpecularDirect.addAssign(lightColor.mul(fresnelClearcoat).mul(LTC_Evaluate({N:Ncc,V:V,P:P,mInv:mInvClearcoat,p0:p0,p1:p1,p2:p2,p3:p3})))}}indirect(builder){this.indirectDiffuse(builder),this.indirectSpecular(builder),this.ambientOcclusion(builder)}indirectDiffuse(builder){const{irradiance:irradiance,reflectedLight:reflectedLight}=builder.context,diffuse=irradiance.mul(BRDF_Lambert({diffuseColor:diffuseContribution})).toVar();if(!0===this.sheen){const sheenAlbedo=IBLSheenBRDF({normal:normalView,viewDir:positionViewDirection,roughness:sheenRoughness}),sheenEnergyComp=sheen.r.max(sheen.g).max(sheen.b).mul(sheenAlbedo).oneMinus();diffuse.mulAssign(sheenEnergyComp)}reflectedLight.indirectDiffuse.addAssign(diffuse)}indirectSpecular(builder){const{radiance:radiance,iblIrradiance:iblIrradiance,reflectedLight:reflectedLight}=builder.context;if(!0===this.sheen&&this.sheenSpecularIndirect.addAssign(iblIrradiance.mul(sheen,IBLSheenBRDF({normal:normalView,viewDir:positionViewDirection,roughness:sheenRoughness}))),!0===this.clearcoat){const dotNVcc=clearcoatNormalView.dot(positionViewDirection).clamp(),clearcoatEnv=EnvironmentBRDF({dotNV:dotNVcc,specularColor:clearcoatF0,specularF90:clearcoatF90,roughness:clearcoatRoughness});this.clearcoatSpecularIndirect.addAssign(this.clearcoatRadiance.mul(clearcoatEnv))}const singleScatteringDielectric=vec3().toVar("singleScatteringDielectric"),multiScatteringDielectric=vec3().toVar("multiScatteringDielectric"),singleScatteringMetallic=vec3().toVar("singleScatteringMetallic"),multiScatteringMetallic=vec3().toVar("multiScatteringMetallic");this.computeMultiscattering(singleScatteringDielectric,multiScatteringDielectric,specularF90,specularColor,this.iridescenceF0Dielectric),this.computeMultiscattering(singleScatteringMetallic,multiScatteringMetallic,specularF90,diffuseColor.rgb,this.iridescenceF0Metallic);const singleScattering=mix(singleScatteringDielectric,singleScatteringMetallic,metalness),multiScattering=mix(multiScatteringDielectric,multiScatteringMetallic,metalness),totalScatteringDielectric=singleScatteringDielectric.add(multiScatteringDielectric),diffuse=diffuseContribution.mul(totalScatteringDielectric.oneMinus()),cosineWeightedIrradiance=iblIrradiance.mul(1/Math.PI),indirectSpecular=radiance.mul(singleScattering).add(multiScattering.mul(cosineWeightedIrradiance)).toVar(),indirectDiffuse=diffuse.mul(cosineWeightedIrradiance).toVar();if(!0===this.sheen){const sheenAlbedo=IBLSheenBRDF({normal:normalView,viewDir:positionViewDirection,roughness:sheenRoughness}),sheenEnergyComp=sheen.r.max(sheen.g).max(sheen.b).mul(sheenAlbedo).oneMinus();indirectSpecular.mulAssign(sheenEnergyComp),indirectDiffuse.mulAssign(sheenEnergyComp)}reflectedLight.indirectSpecular.addAssign(indirectSpecular),reflectedLight.indirectDiffuse.addAssign(indirectDiffuse)}ambientOcclusion(builder){const{ambientOcclusion:ambientOcclusion,reflectedLight:reflectedLight}=builder.context,aoNV=normalView.dot(positionViewDirection).clamp().add(ambientOcclusion),aoExp=roughness.mul(-16).oneMinus().negate().exp2(),aoNode=ambientOcclusion.sub(aoNV.pow(aoExp).oneMinus()).clamp();!0===this.clearcoat&&this.clearcoatSpecularIndirect.mulAssign(ambientOcclusion),!0===this.sheen&&this.sheenSpecularIndirect.mulAssign(ambientOcclusion),reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion),reflectedLight.indirectSpecular.mulAssign(aoNode)}finish({context:context}){const{outgoingLight:outgoingLight}=context;if(!0===this.clearcoat){const dotNVcc=clearcoatNormalView.dot(positionViewDirection).clamp(),Fcc=F_Schlick({dotVH:dotNVcc,f0:clearcoatF0,f90:clearcoatF90}),clearcoatLight=outgoingLight.mul(clearcoat.mul(Fcc).oneMinus()).add(this.clearcoatSpecularDirect.add(this.clearcoatSpecularIndirect).mul(clearcoat));outgoingLight.assign(clearcoatLight)}if(!0===this.sheen){const sheenLight=outgoingLight.add(this.sheenSpecularDirect,this.sheenSpecularIndirect.mul(1/Math.PI));outgoingLight.assign(sheenLight)}}}const cubeUV_r0=/*@__PURE__*/float(1),cubeUV_m0=/*@__PURE__*/float(-2),cubeUV_r1=/*@__PURE__*/float(.8),cubeUV_m1=/*@__PURE__*/float(-1),cubeUV_r4=/*@__PURE__*/float(.4),cubeUV_m4=/*@__PURE__*/float(2),cubeUV_r5=/*@__PURE__*/float(.305),cubeUV_m5=/*@__PURE__*/float(3),cubeUV_r6=/*@__PURE__*/float(.21),cubeUV_m6=/*@__PURE__*/float(4),cubeUV_minMipLevel=/*@__PURE__*/float(4),cubeUV_minTileSize=/*@__PURE__*/float(16),getFace=/*@__PURE__*/Fn(([direction])=>{const absDirection=vec3(abs(direction)).toVar(),face=float(-1).toVar();return If(absDirection.x.greaterThan(absDirection.z),()=>{If(absDirection.x.greaterThan(absDirection.y),()=>{face.assign(select(direction.x.greaterThan(0),0,3))}).Else(()=>{face.assign(select(direction.y.greaterThan(0),1,4))})}).Else(()=>{If(absDirection.z.greaterThan(absDirection.y),()=>{face.assign(select(direction.z.greaterThan(0),2,5))}).Else(()=>{face.assign(select(direction.y.greaterThan(0),1,4))})}),face}).setLayout({name:"getFace",type:"float",inputs:[{name:"direction",type:"vec3"}]}),getUV=/*@__PURE__*/Fn(([direction,face])=>{const uv=vec2().toVar();return If(face.equal(0),()=>{uv.assign(vec2(direction.z,direction.y).div(abs(direction.x)))}).ElseIf(face.equal(1),()=>{uv.assign(vec2(direction.x.negate(),direction.z.negate()).div(abs(direction.y)))}).ElseIf(face.equal(2),()=>{uv.assign(vec2(direction.x.negate(),direction.y).div(abs(direction.z)))}).ElseIf(face.equal(3),()=>{uv.assign(vec2(direction.z.negate(),direction.y).div(abs(direction.x)))}).ElseIf(face.equal(4),()=>{uv.assign(vec2(direction.x.negate(),direction.z).div(abs(direction.y)))}).Else(()=>{uv.assign(vec2(direction.x,direction.y).div(abs(direction.z)))}),mul(.5,uv.add(1))}).setLayout({name:"getUV",type:"vec2",inputs:[{name:"direction",type:"vec3"},{name:"face",type:"float"}]}),roughnessToMip=/*@__PURE__*/Fn(([roughness])=>{const mip=float(0).toVar();return If(roughness.greaterThanEqual(cubeUV_r1),()=>{mip.assign(cubeUV_r0.sub(roughness).mul(cubeUV_m1.sub(cubeUV_m0)).div(cubeUV_r0.sub(cubeUV_r1)).add(cubeUV_m0))}).ElseIf(roughness.greaterThanEqual(cubeUV_r4),()=>{mip.assign(cubeUV_r1.sub(roughness).mul(cubeUV_m4.sub(cubeUV_m1)).div(cubeUV_r1.sub(cubeUV_r4)).add(cubeUV_m1))}).ElseIf(roughness.greaterThanEqual(cubeUV_r5),()=>{mip.assign(cubeUV_r4.sub(roughness).mul(cubeUV_m5.sub(cubeUV_m4)).div(cubeUV_r4.sub(cubeUV_r5)).add(cubeUV_m4))}).ElseIf(roughness.greaterThanEqual(cubeUV_r6),()=>{mip.assign(cubeUV_r5.sub(roughness).mul(cubeUV_m6.sub(cubeUV_m5)).div(cubeUV_r5.sub(cubeUV_r6)).add(cubeUV_m5))}).Else(()=>{mip.assign(float(-2).mul(log2(mul(1.16,roughness))))}),mip}).setLayout({name:"roughnessToMip",type:"float",inputs:[{name:"roughness",type:"float"}]}),getDirection=/*@__PURE__*/Fn(([uv_immutable,face])=>{const uv=uv_immutable.toVar();uv.assign(mul(2,uv).sub(1));const direction=vec3(uv,1).toVar();return If(face.equal(0),()=>{direction.assign(direction.zyx)}).ElseIf(face.equal(1),()=>{direction.assign(direction.xzy),direction.xz.mulAssign(-1)}).ElseIf(face.equal(2),()=>{direction.x.mulAssign(-1)}).ElseIf(face.equal(3),()=>{direction.assign(direction.zyx),direction.xz.mulAssign(-1)}).ElseIf(face.equal(4),()=>{direction.assign(direction.xzy),direction.xy.mulAssign(-1)}).ElseIf(face.equal(5),()=>{direction.z.mulAssign(-1)}),direction}).setLayout({name:"getDirection",type:"vec3",inputs:[{name:"uv",type:"vec2"},{name:"face",type:"float"}]}),textureCubeUV=/*@__PURE__*/Fn(([envMap,sampleDir_immutable,roughness_immutable,CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP])=>{const roughness=float(roughness_immutable),sampleDir=vec3(sampleDir_immutable),mip=clamp$2(roughnessToMip(roughness),cubeUV_m0,CUBEUV_MAX_MIP),mipF=fract(mip),mipInt=floor(mip),color0=vec3(bilinearCubeUV(envMap,sampleDir,mipInt,CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP)).toVar();return If(mipF.notEqual(0),()=>{const color1=vec3(bilinearCubeUV(envMap,sampleDir,mipInt.add(1),CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP)).toVar();color0.assign(mix(color0,color1,mipF))}),color0}),bilinearCubeUV=/*@__PURE__*/Fn(([envMap,direction_immutable,mipInt_immutable,CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP])=>{const mipInt=float(mipInt_immutable).toVar(),direction=vec3(direction_immutable),face=float(getFace(direction)).toVar(),filterInt=float(max$1(cubeUV_minMipLevel.sub(mipInt),0)).toVar();mipInt.assign(max$1(mipInt,cubeUV_minMipLevel));const faceSize=float(exp2(mipInt)).toVar(),uv=vec2(getUV(direction,face).mul(faceSize.sub(2)).add(1)).toVar();return If(face.greaterThan(2),()=>{uv.y.addAssign(faceSize),face.subAssign(3)}),uv.x.addAssign(face.mul(faceSize)),uv.x.addAssign(filterInt.mul(mul(3,cubeUV_minTileSize))),uv.y.addAssign(mul(4,exp2(CUBEUV_MAX_MIP).sub(faceSize))),uv.x.mulAssign(CUBEUV_TEXEL_WIDTH),uv.y.mulAssign(CUBEUV_TEXEL_HEIGHT),envMap.sample(uv).grad(vec2(),vec2())}),getSample=/*@__PURE__*/Fn(({envMap:envMap,mipInt:mipInt,outputDirection:outputDirection,theta:theta,axis:axis,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP})=>{const cosTheta=cos(theta),sampleDirection=outputDirection.mul(cosTheta).add(axis.cross(outputDirection).mul(sin(theta))).add(axis.mul(axis.dot(outputDirection).mul(cosTheta.oneMinus())));return bilinearCubeUV(envMap,sampleDirection,mipInt,CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP)}),blur=/*@__PURE__*/Fn(({n:n,latitudinal:latitudinal,poleAxis:poleAxis,outputDirection:outputDirection,weights:weights,samples:samples,dTheta:dTheta,mipInt:mipInt,envMap:envMap,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP})=>{const axis=vec3(select(latitudinal,poleAxis,cross(poleAxis,outputDirection))).toVar();If(axis.equal(vec3(0)),()=>{axis.assign(vec3(outputDirection.z,0,outputDirection.x.negate()))}),axis.assign(normalize(axis));const gl_FragColor=vec3().toVar();return gl_FragColor.addAssign(weights.element(0).mul(getSample({theta:0,axis:axis,outputDirection:outputDirection,mipInt:mipInt,envMap:envMap,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP}))),Loop({start:int(1),end:n},({i:i})=>{If(i.greaterThanEqual(samples),()=>{expression("break").toStack()});const theta=float(dTheta.mul(float(i))).toVar();gl_FragColor.addAssign(weights.element(i).mul(getSample({theta:theta.mul(-1),axis:axis,outputDirection:outputDirection,mipInt:mipInt,envMap:envMap,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP}))),gl_FragColor.addAssign(weights.element(i).mul(getSample({theta:theta,axis:axis,outputDirection:outputDirection,mipInt:mipInt,envMap:envMap,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP})))}),vec4(gl_FragColor,1)}),radicalInverse_VdC=/*@__PURE__*/Fn(([bits_immutable])=>{const bits=uint(bits_immutable).toVar();return bits.assign(bits.shiftLeft(uint(16)).bitOr(bits.shiftRight(uint(16)))),bits.assign(bits.bitAnd(uint(1431655765)).shiftLeft(uint(1)).bitOr(bits.bitAnd(uint(2863311530)).shiftRight(uint(1)))),bits.assign(bits.bitAnd(uint(858993459)).shiftLeft(uint(2)).bitOr(bits.bitAnd(uint(3435973836)).shiftRight(uint(2)))),bits.assign(bits.bitAnd(uint(252645135)).shiftLeft(uint(4)).bitOr(bits.bitAnd(uint(4042322160)).shiftRight(uint(4)))),bits.assign(bits.bitAnd(uint(16711935)).shiftLeft(uint(8)).bitOr(bits.bitAnd(uint(4278255360)).shiftRight(uint(8)))),float(bits).mul(2.3283064365386963e-10)}),hammersley=/*@__PURE__*/Fn(([i,N])=>vec2(float(i).div(float(N)),radicalInverse_VdC(i))),importanceSampleGGX_VNDF=/*@__PURE__*/Fn(([Xi,V,roughness])=>{const alpha=roughness.mul(roughness).toConst(),T1=vec3(1,0,0).toConst(),T2=cross(V,T1).toConst(),r=sqrt(Xi.x).toConst(),phi=mul(2,3.14159265359).mul(Xi.y).toConst(),t1=r.mul(cos(phi)).toConst(),t2=r.mul(sin(phi)).toVar(),s=mul(.5,V.z.add(1)).toConst();t2.assign(s.oneMinus().mul(sqrt(t1.mul(t1).oneMinus())).add(s.mul(t2)));const Nh=T1.mul(t1).add(T2.mul(t2)).add(V.mul(sqrt(max$1(0,t1.mul(t1).add(t2.mul(t2)).oneMinus()))));return normalize(vec3(alpha.mul(Nh.x),alpha.mul(Nh.y),max$1(0,Nh.z)))}),ggxConvolution=/*@__PURE__*/Fn(({roughness:roughness,mipInt:mipInt,envMap:envMap,N_immutable:N_immutable,GGX_SAMPLES:GGX_SAMPLES,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP})=>{const N=vec3(N_immutable).toVar(),prefilteredColor=vec3(0).toVar(),totalWeight=float(0).toVar();return If(roughness.lessThan(.001),()=>{prefilteredColor.assign(bilinearCubeUV(envMap,N,mipInt,CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP))}).Else(()=>{const up=select(abs(N.z).lessThan(.999),vec3(0,0,1),vec3(1,0,0)),tangent=normalize(cross(up,N)).toVar(),bitangent=cross(N,tangent).toVar();Loop({start:uint(0),end:GGX_SAMPLES},({i:i})=>{const Xi=hammersley(i,GGX_SAMPLES),H_tangent=importanceSampleGGX_VNDF(Xi,vec3(0,0,1),roughness),H=normalize(tangent.mul(H_tangent.x).add(bitangent.mul(H_tangent.y)).add(N.mul(H_tangent.z))),L=normalize(H.mul(dot(N,H).mul(2)).sub(N)),NdotL=max$1(dot(N,L),0);If(NdotL.greaterThan(0),()=>{const sampleColor=bilinearCubeUV(envMap,L,mipInt,CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP);prefilteredColor.addAssign(sampleColor.mul(NdotL)),totalWeight.addAssign(NdotL)})}),If(totalWeight.greaterThan(0),()=>{prefilteredColor.assign(prefilteredColor.div(totalWeight))})}),vec4(prefilteredColor,1)}),EXTRA_LOD_SIGMA=[.125,.215,.35,.446,.526,.582],_flatCamera=/*@__PURE__*/new OrthographicCamera(-1,1,1,-1,0,1),_cubeCamera=/*@__PURE__*/new PerspectiveCamera(90,1),_clearColor$2=/*@__PURE__*/new Color;let _oldTarget=null,_oldActiveCubeFace=0,_oldActiveMipmapLevel=0;const _origin=/*@__PURE__*/new Vector3,_uniformsMap=new WeakMap,_faceLib=[3,1,5,0,4,2],_direction=/*@__PURE__*/getDirection(uv$1(),attribute("faceIndex")).normalize(),_outputDirection=/*@__PURE__*/vec3(_direction.x,_direction.y,_direction.z);class PMREMGenerator{constructor(renderer){this._renderer=renderer,this._pingPongRenderTarget=null,this._lodMax=0,this._cubeSize=0,this._sizeLods=[],this._sigmas=[],this._lodMeshes=[],this._blurMaterial=null,this._ggxMaterial=null,this._cubemapMaterial=null,this._equirectMaterial=null,this._backgroundBox=null}get _hasInitialized(){return this._renderer.hasInitialized()}fromScene(scene,sigma=0,near=.1,far=100,options={}){const{size:size=256,position:position=_origin,renderTarget:renderTarget=null}=options;if(this._setSize(size),!1===this._hasInitialized){warn('PMREMGenerator: ".fromScene()" called before the backend is initialized. Try using "await renderer.init()" instead.');const cubeUVRenderTarget=renderTarget||this._allocateTarget();return options.renderTarget=cubeUVRenderTarget,this.fromSceneAsync(scene,sigma,near,far,options),cubeUVRenderTarget}_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const cubeUVRenderTarget=renderTarget||this._allocateTarget();return cubeUVRenderTarget.depthBuffer=!0,this._init(cubeUVRenderTarget),this._sceneToCubeUV(scene,near,far,cubeUVRenderTarget,position),sigma>0&&this._blur(cubeUVRenderTarget,0,0,sigma),this._applyPMREM(cubeUVRenderTarget),this._cleanup(cubeUVRenderTarget),cubeUVRenderTarget}async fromSceneAsync(scene,sigma=0,near=.1,far=100,options={}){return warnOnce('PMREMGenerator: ".fromSceneAsync()" is deprecated. Use "await renderer.init()" instead.'),await this._renderer.init(),this.fromScene(scene,sigma,near,far,options)}fromEquirectangular(equirectangular,renderTarget=null){if(!1===this._hasInitialized){warn('PMREMGenerator: .fromEquirectangular() called before the backend is initialized. Try using "await renderer.init()" instead.'),this._setSizeFromTexture(equirectangular);const cubeUVRenderTarget=renderTarget||this._allocateTarget();return this.fromEquirectangularAsync(equirectangular,cubeUVRenderTarget),cubeUVRenderTarget}return this._fromTexture(equirectangular,renderTarget)}async fromEquirectangularAsync(equirectangular,renderTarget=null){return warnOnce('PMREMGenerator: ".fromEquirectangularAsync()" is deprecated. Use "await renderer.init()" instead.'),await this._renderer.init(),this._fromTexture(equirectangular,renderTarget)}fromCubemap(cubemap,renderTarget=null){if(!1===this._hasInitialized){warn("PMREMGenerator: .fromCubemap() called before the backend is initialized. Try using .fromCubemapAsync() instead."),this._setSizeFromTexture(cubemap);const cubeUVRenderTarget=renderTarget||this._allocateTarget();return this.fromCubemapAsync(cubemap,renderTarget),cubeUVRenderTarget}return this._fromTexture(cubemap,renderTarget)}async fromCubemapAsync(cubemap,renderTarget=null){return warnOnce('PMREMGenerator: ".fromCubemapAsync()" is deprecated. Use "await renderer.init()" instead.'),await this._renderer.init(),this._fromTexture(cubemap,renderTarget)}async compileCubemapShader(){null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(),await this._compileMaterial(this._cubemapMaterial))}async compileEquirectangularShader(){null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(),await this._compileMaterial(this._equirectMaterial))}dispose(){this._dispose(),null!==this._cubemapMaterial&&this._cubemapMaterial.dispose(),null!==this._equirectMaterial&&this._equirectMaterial.dispose(),null!==this._backgroundBox&&(this._backgroundBox.geometry.dispose(),this._backgroundBox.material.dispose())}_setSizeFromTexture(texture){301===texture.mapping||302===texture.mapping?this._setSize(0===texture.image.length?16:texture.image[0].width||texture.image[0].image.width):this._setSize(texture.image.width/4)}_setSize(cubeSize){this._lodMax=Math.floor(Math.log2(cubeSize)),this._cubeSize=Math.pow(2,this._lodMax)}_dispose(){null!==this._blurMaterial&&this._blurMaterial.dispose(),null!==this._ggxMaterial&&this._ggxMaterial.dispose(),null!==this._pingPongRenderTarget&&this._pingPongRenderTarget.dispose();for(let i=0;i<this._lodMeshes.length;i++)this._lodMeshes[i].geometry.dispose()}_cleanup(outputTarget){this._renderer.setRenderTarget(_oldTarget,_oldActiveCubeFace,_oldActiveMipmapLevel),outputTarget.scissorTest=!1,_setViewport(outputTarget,0,0,outputTarget.width,outputTarget.height)}_fromTexture(texture,renderTarget){this._setSizeFromTexture(texture),_oldTarget=this._renderer.getRenderTarget(),_oldActiveCubeFace=this._renderer.getActiveCubeFace(),_oldActiveMipmapLevel=this._renderer.getActiveMipmapLevel();const cubeUVRenderTarget=renderTarget||this._allocateTarget();return this._init(cubeUVRenderTarget),this._textureToCubeUV(texture,cubeUVRenderTarget),this._applyPMREM(cubeUVRenderTarget),this._cleanup(cubeUVRenderTarget),cubeUVRenderTarget}_allocateTarget(){return _createRenderTarget(3*Math.max(this._cubeSize,112),4*this._cubeSize)}_init(renderTarget){if(null===this._pingPongRenderTarget||this._pingPongRenderTarget.width!==renderTarget.width||this._pingPongRenderTarget.height!==renderTarget.height){null!==this._pingPongRenderTarget&&this._dispose(),this._pingPongRenderTarget=_createRenderTarget(renderTarget.width,renderTarget.height);const{_lodMax:_lodMax}=this;({lodMeshes:this._lodMeshes,sizeLods:this._sizeLods,sigmas:this._sigmas}=function _createPlanes(lodMax){const sizeLods=[],sigmas=[],lodMeshes=[];let lod=lodMax;const totalLods=lodMax-4+1+EXTRA_LOD_SIGMA.length;for(let i=0;i<totalLods;i++){const sizeLod=Math.pow(2,lod);sizeLods.push(sizeLod);let sigma=1/sizeLod;i>lodMax-4?sigma=EXTRA_LOD_SIGMA[i-lodMax+4-1]:0===i&&(sigma=0),sigmas.push(sigma);const texelSize=1/(sizeLod-2),min=-texelSize,max=1+texelSize,uv1=[min,min,max,min,max,max,min,min,max,max,min,max],cubeFaces=6,vertices=6,positionSize=3,uvSize=2,faceIndexSize=1,position=new Float32Array(positionSize*vertices*cubeFaces),uv=new Float32Array(uvSize*vertices*cubeFaces),faceIndex=new Float32Array(faceIndexSize*vertices*cubeFaces);for(let face=0;face<cubeFaces;face++){const x=face%3*2/3-1,y=face>2?0:-1,coordinates=[x,y,0,x+2/3,y,0,x+2/3,y+1,0,x,y,0,x+2/3,y+1,0,x,y+1,0],faceIdx=_faceLib[face];position.set(coordinates,positionSize*vertices*faceIdx),uv.set(uv1,uvSize*vertices*faceIdx);const fill=[faceIdx,faceIdx,faceIdx,faceIdx,faceIdx,faceIdx];faceIndex.set(fill,faceIndexSize*vertices*faceIdx)}const planes=new BufferGeometry;planes.setAttribute("position",new BufferAttribute(position,positionSize)),planes.setAttribute("uv",new BufferAttribute(uv,uvSize)),planes.setAttribute("faceIndex",new BufferAttribute(faceIndex,faceIndexSize)),lodMeshes.push(new Mesh(planes,null)),lod>4&&lod--}return{lodMeshes:lodMeshes,sizeLods:sizeLods,sigmas:sigmas}}(_lodMax)),this._blurMaterial=function _getBlurShader(lodMax,width,height){const weights=uniformArray(new Array(20).fill(0)),poleAxis=uniform(new Vector3(0,1,0)),dTheta=uniform(0),n=float(20),latitudinal=uniform(0),samples=uniform(1),envMap=texture(),mipInt=uniform(0),CUBEUV_TEXEL_WIDTH=float(1/width),CUBEUV_TEXEL_HEIGHT=float(1/height),CUBEUV_MAX_MIP=float(lodMax),materialUniforms={n:n,latitudinal:latitudinal,weights:weights,poleAxis:poleAxis,outputDirection:_outputDirection,dTheta:dTheta,samples:samples,envMap:envMap,mipInt:mipInt,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP},material=_getMaterial("blur");return material.fragmentNode=blur({...materialUniforms,latitudinal:latitudinal.equal(1)}),_uniformsMap.set(material,materialUniforms),material}(_lodMax,renderTarget.width,renderTarget.height),this._ggxMaterial=function _getGGXShader(lodMax,width,height){const envMap=texture(),roughness=uniform(0),mipInt=uniform(0),CUBEUV_TEXEL_WIDTH=float(1/width),CUBEUV_TEXEL_HEIGHT=float(1/height),CUBEUV_MAX_MIP=float(lodMax),materialUniforms={envMap:envMap,roughness:roughness,mipInt:mipInt,CUBEUV_TEXEL_WIDTH:CUBEUV_TEXEL_WIDTH,CUBEUV_TEXEL_HEIGHT:CUBEUV_TEXEL_HEIGHT,CUBEUV_MAX_MIP:CUBEUV_MAX_MIP},material=_getMaterial("ggx");return material.fragmentNode=ggxConvolution({...materialUniforms,N_immutable:_outputDirection,GGX_SAMPLES:uint(512)}),_uniformsMap.set(material,materialUniforms),material}(_lodMax,renderTarget.width,renderTarget.height)}}async _compileMaterial(material){const mesh=new Mesh(new BufferGeometry,material);await this._renderer.compile(mesh,_flatCamera)}_sceneToCubeUV(scene,near,far,cubeUVRenderTarget,position){const cubeCamera=_cubeCamera;cubeCamera.near=near,cubeCamera.far=far;const upSign=[1,1,1,1,-1,1],forwardSign=[1,-1,1,-1,1,-1],renderer=this._renderer,originalAutoClear=renderer.autoClear;renderer.getClearColor(_clearColor$2),renderer.autoClear=!1,null===this._backgroundBox&&(this._backgroundBox=new Mesh(new BoxGeometry,new MeshBasicMaterial({name:"PMREM.Background",side:1,depthWrite:!1,depthTest:!1})));const backgroundBox=this._backgroundBox,backgroundMaterial=backgroundBox.material;let useSolidColor=!1;const background=scene.background;background?background.isColor&&(backgroundMaterial.color.copy(background),scene.background=null,useSolidColor=!0):(backgroundMaterial.color.copy(_clearColor$2),useSolidColor=!0),renderer.setRenderTarget(cubeUVRenderTarget),renderer.clear(),useSolidColor&&renderer.render(backgroundBox,cubeCamera);for(let i=0;i<6;i++){const col=i%3;0===col?(cubeCamera.up.set(0,upSign[i],0),cubeCamera.position.set(position.x,position.y,position.z),cubeCamera.lookAt(position.x+forwardSign[i],position.y,position.z)):1===col?(cubeCamera.up.set(0,0,upSign[i]),cubeCamera.position.set(position.x,position.y,position.z),cubeCamera.lookAt(position.x,position.y+forwardSign[i],position.z)):(cubeCamera.up.set(0,upSign[i],0),cubeCamera.position.set(position.x,position.y,position.z),cubeCamera.lookAt(position.x,position.y,position.z+forwardSign[i]));const size=this._cubeSize;_setViewport(cubeUVRenderTarget,col*size,i>2?size:0,size,size),renderer.render(scene,cubeCamera)}renderer.autoClear=originalAutoClear,scene.background=background}_textureToCubeUV(texture,cubeUVRenderTarget){const renderer=this._renderer,isCubeTexture=301===texture.mapping||302===texture.mapping;isCubeTexture?null===this._cubemapMaterial&&(this._cubemapMaterial=_getCubemapMaterial(texture)):null===this._equirectMaterial&&(this._equirectMaterial=_getEquirectMaterial(texture));const material=isCubeTexture?this._cubemapMaterial:this._equirectMaterial;material.fragmentNode.value=texture;const mesh=this._lodMeshes[0];mesh.material=material;const size=this._cubeSize;_setViewport(cubeUVRenderTarget,0,0,3*size,2*size),renderer.setRenderTarget(cubeUVRenderTarget),renderer.render(mesh,_flatCamera)}_applyPMREM(cubeUVRenderTarget){const renderer=this._renderer,autoClear=renderer.autoClear;renderer.autoClear=!1;const n=this._lodMeshes.length;for(let i=1;i<n;i++)this._applyGGXFilter(cubeUVRenderTarget,i-1,i);renderer.autoClear=autoClear}_applyGGXFilter(cubeUVRenderTarget,lodIn,lodOut){const renderer=this._renderer,pingPongRenderTarget=this._pingPongRenderTarget,ggxMaterial=this._ggxMaterial,ggxMesh=this._lodMeshes[lodOut];ggxMesh.material=ggxMaterial;const ggxUniforms=_uniformsMap.get(ggxMaterial),targetRoughness=lodOut/(this._lodMeshes.length-1),sourceRoughness=lodIn/(this._lodMeshes.length-1),adjustedRoughness=Math.sqrt(targetRoughness*targetRoughness-sourceRoughness*sourceRoughness)*(0+1.25*targetRoughness),{_lodMax:_lodMax}=this,outputSize=this._sizeLods[lodOut],x=3*outputSize*(lodOut>_lodMax-4?lodOut-_lodMax+4:0),y=4*(this._cubeSize-outputSize);cubeUVRenderTarget.texture.frame=(cubeUVRenderTarget.texture.frame||0)+1,ggxUniforms.envMap.value=cubeUVRenderTarget.texture,ggxUniforms.roughness.value=adjustedRoughness,ggxUniforms.mipInt.value=_lodMax-lodIn,_setViewport(pingPongRenderTarget,x,y,3*outputSize,2*outputSize),renderer.setRenderTarget(pingPongRenderTarget),renderer.render(ggxMesh,_flatCamera),pingPongRenderTarget.texture.frame=(pingPongRenderTarget.texture.frame||0)+1,ggxUniforms.envMap.value=pingPongRenderTarget.texture,ggxUniforms.roughness.value=0,ggxUniforms.mipInt.value=_lodMax-lodOut,_setViewport(cubeUVRenderTarget,x,y,3*outputSize,2*outputSize),renderer.setRenderTarget(cubeUVRenderTarget),renderer.render(ggxMesh,_flatCamera)}_blur(cubeUVRenderTarget,lodIn,lodOut,sigma,poleAxis){const pingPongRenderTarget=this._pingPongRenderTarget;this._halfBlur(cubeUVRenderTarget,pingPongRenderTarget,lodIn,lodOut,sigma,"latitudinal",poleAxis),this._halfBlur(pingPongRenderTarget,cubeUVRenderTarget,lodOut,lodOut,sigma,"longitudinal",poleAxis)}_halfBlur(targetIn,targetOut,lodIn,lodOut,sigmaRadians,direction,poleAxis){const renderer=this._renderer,blurMaterial=this._blurMaterial;"latitudinal"!==direction&&"longitudinal"!==direction&&error("blur direction must be either latitudinal or longitudinal!");const blurMesh=this._lodMeshes[lodOut];blurMesh.material=blurMaterial;const blurUniforms=_uniformsMap.get(blurMaterial),pixels=this._sizeLods[lodIn]-1,radiansPerPixel=isFinite(sigmaRadians)?Math.PI/(2*pixels):2*Math.PI/39,sigmaPixels=sigmaRadians/radiansPerPixel,samples=isFinite(sigmaRadians)?1+Math.floor(3*sigmaPixels):20;samples>20&&warn(`sigmaRadians, ${sigmaRadians}, is too large and will clip, as it requested ${samples} samples when the maximum is set to 20`);const weights=[];let sum=0;for(let i=0;i<20;++i){const x=i/sigmaPixels,weight=Math.exp(-x*x/2);weights.push(weight),0===i?sum+=weight:i<samples&&(sum+=2*weight)}for(let i=0;i<weights.length;i++)weights[i]=weights[i]/sum;targetIn.texture.frame=(targetIn.texture.frame||0)+1,blurUniforms.envMap.value=targetIn.texture,blurUniforms.samples.value=samples,blurUniforms.weights.array=weights,blurUniforms.latitudinal.value="latitudinal"===direction?1:0,poleAxis&&(blurUniforms.poleAxis.value=poleAxis);const{_lodMax:_lodMax}=this;blurUniforms.dTheta.value=radiansPerPixel,blurUniforms.mipInt.value=_lodMax-lodIn;const outputSize=this._sizeLods[lodOut];_setViewport(targetOut,3*outputSize*(lodOut>_lodMax-4?lodOut-_lodMax+4:0),4*(this._cubeSize-outputSize),3*outputSize,2*outputSize),renderer.setRenderTarget(targetOut),renderer.render(blurMesh,_flatCamera)}}function _createRenderTarget(width,height){const cubeUVRenderTarget=new RenderTarget(width,height,{magFilter:1006,minFilter:1006,generateMipmaps:!1,type:HalfFloatType,format:1023,colorSpace:"srgb-linear"});return cubeUVRenderTarget.texture.mapping=306,cubeUVRenderTarget.texture.name="PMREM.cubeUv",cubeUVRenderTarget.texture.isPMREMTexture=!0,cubeUVRenderTarget.scissorTest=!0,cubeUVRenderTarget}function _setViewport(target,x,y,width,height){target.viewport.set(x,y,width,height),target.scissor.set(x,y,width,height)}function _getMaterial(type){const material=new NodeMaterial;return material.depthTest=!1,material.depthWrite=!1,material.blending=0,material.name=`PMREM_${type}`,material}function _getCubemapMaterial(envTexture){const material=_getMaterial("cubemap");return material.fragmentNode=cubeTexture(envTexture,_outputDirection),material}function _getEquirectMaterial(envTexture){const material=_getMaterial("equirect");return material.fragmentNode=texture(envTexture,equirectUV(_outputDirection),0),material}const _cache=new WeakMap;function _getPMREMFromTexture(texture,renderer,generator){const cache=function _getCache(renderer){let rendererCache=_cache.get(renderer);void 0===rendererCache&&(rendererCache=new WeakMap,_cache.set(renderer,rendererCache));return rendererCache}(renderer);let cacheTexture=cache.get(texture);if((void 0!==cacheTexture?cacheTexture.pmremVersion:-1)!==texture.pmremVersion){const image=texture.image;if(texture.isCubeTexture){if(!function isCubeMapReady(image){if(null==image)return!1;let count=0;const length=6;for(let i=0;i<length;i++)void 0!==image[i]&&count++;return count===length}(image))return null;cacheTexture=generator.fromCubemap(texture,cacheTexture)}else{if(!function isEquirectangularMapReady(image){return null!=image&&image.height>0}(image))return null;cacheTexture=generator.fromEquirectangular(texture,cacheTexture)}cacheTexture.pmremVersion=texture.pmremVersion,cache.set(texture,cacheTexture)}return cacheTexture.texture}class PMREMNode extends TempNode{static get type(){return"PMREMNode"}constructor(value,uvNode=null,levelNode=null){super("vec3"),this._value=value,this._pmrem=null,this.uvNode=uvNode,this.levelNode=levelNode,this._generator=null;const defaultTexture=new Texture;defaultTexture.isRenderTargetTexture=!0,this._texture=texture(defaultTexture),this._width=uniform(0),this._height=uniform(0),this._maxMip=uniform(0),this.updateBeforeType=NodeUpdateType_RENDER}set value(value){this._value=value,this._pmrem=null}get value(){return this._value}updateFromTexture(texture){const cubeUVSize=function _generateCubeUVSize(imageHeight){const maxMip=Math.log2(imageHeight)-2,texelHeight=1/imageHeight;return{texelWidth:1/(3*Math.max(Math.pow(2,maxMip),112)),texelHeight:texelHeight,maxMip:maxMip}}(texture.image.height);this._texture.value=texture,this._width.value=cubeUVSize.texelWidth,this._height.value=cubeUVSize.texelHeight,this._maxMip.value=cubeUVSize.maxMip}updateBefore(frame){let pmrem=this._pmrem;const pmremVersion=pmrem?pmrem.pmremVersion:-1,texture=this._value;pmremVersion!==texture.pmremVersion&&(pmrem=!0===texture.isPMREMTexture?texture:_getPMREMFromTexture(texture,frame.renderer,this._generator),null!==pmrem&&(this._pmrem=pmrem,this.updateFromTexture(pmrem)))}setup(builder){null===this._generator&&(this._generator=new PMREMGenerator(builder.renderer)),this.updateBefore(builder);let uvNode=this.uvNode;null===uvNode&&builder.context.getUV&&(uvNode=builder.context.getUV(this,builder)),uvNode=materialEnvRotation.mul(vec3(uvNode.x,uvNode.y.negate(),uvNode.z));let levelNode=this.levelNode;return null===levelNode&&builder.context.getTextureLevel&&(levelNode=builder.context.getTextureLevel(this)),textureCubeUV(this._texture,uvNode,levelNode,this._width,this._height,this._maxMip)}dispose(){super.dispose(),null!==this._generator&&this._generator.dispose()}}const pmremTexture=/*@__PURE__*/nodeProxy(PMREMNode).setParameterLength(1,3),_rendererCache=new WeakMap;class EnvironmentNode extends LightingNode{static get type(){return"EnvironmentNode"}constructor(envNode=null){super(),this.envNode=envNode}setup(builder){const{material:material}=builder;let envNode=this.envNode;if(envNode.isTextureNode||envNode.isMaterialReferenceNode){const value=envNode.isTextureNode?envNode.value:material[envNode.property],cache=this._getPMREMNodeCache(builder.renderer);let cacheEnvNode=cache.get(value);void 0===cacheEnvNode&&(cacheEnvNode=pmremTexture(value),cache.set(value,cacheEnvNode)),envNode=cacheEnvNode}const radianceNormalView=!0===material.useAnisotropy||material.anisotropy>0?bentNormalView:normalView,radiance=envNode.context(createRadianceContext(roughness,radianceNormalView)).mul(materialEnvIntensity),irradiance=envNode.context(createIrradianceContext(normalWorld)).mul(Math.PI).mul(materialEnvIntensity),isolateRadiance=isolate(radiance),isolateIrradiance=isolate(irradiance);builder.context.radiance.addAssign(isolateRadiance),builder.context.iblIrradiance.addAssign(isolateIrradiance);const clearcoatRadiance=builder.context.lightingModel.clearcoatRadiance;if(clearcoatRadiance){const clearcoatRadianceContext=envNode.context(createRadianceContext(clearcoatRoughness,clearcoatNormalView)).mul(materialEnvIntensity),isolateClearcoatRadiance=isolate(clearcoatRadianceContext);clearcoatRadiance.addAssign(isolateClearcoatRadiance)}}_getPMREMNodeCache(renderer){let pmremCache=_rendererCache.get(renderer);return void 0===pmremCache&&(pmremCache=new WeakMap,_rendererCache.set(renderer,pmremCache)),pmremCache}}const createRadianceContext=(roughnessNode,normalViewNode)=>{let reflectVec=null;return{getUV:()=>(null===reflectVec&&(reflectVec=positionViewDirection.negate().reflect(normalViewNode),reflectVec=pow4(roughnessNode).mix(reflectVec,normalViewNode).normalize(),reflectVec=reflectVec.transformDirection(cameraViewMatrix)),reflectVec),getTextureLevel:()=>roughnessNode}},createIrradianceContext=normalWorldNode=>({getUV:()=>normalWorldNode,getTextureLevel:()=>float(1)}),_defaultValues$6=/*@__PURE__*/new MeshStandardMaterial;class MeshStandardNodeMaterial extends NodeMaterial{static get type(){return"MeshStandardNodeMaterial"}constructor(parameters){super(),this.isMeshStandardNodeMaterial=!0,this.lights=!0,this.emissiveNode=null,this.metalnessNode=null,this.roughnessNode=null,this.setDefaultValues(_defaultValues$6),this.setValues(parameters)}setupEnvironment(builder){let envNode=super.setupEnvironment(builder);return null===envNode&&builder.environmentNode&&(envNode=builder.environmentNode),envNode?new EnvironmentNode(envNode):null}setupLightingModel(){return new PhysicalLightingModel}setupSpecular(){const specularColorNode=mix(vec3(.04),diffuseColor.rgb,metalness);specularColor.assign(vec3(.04)),specularColorBlended.assign(specularColorNode),specularF90.assign(1)}setupVariants(){const metalnessNode=this.metalnessNode?float(this.metalnessNode):materialMetalness;metalness.assign(metalnessNode);let roughnessNode=this.roughnessNode?float(this.roughnessNode):materialRoughness;roughnessNode=getRoughness({roughness:roughnessNode}),roughness.assign(roughnessNode),this.setupSpecular(),diffuseContribution.assign(diffuseColor.rgb.mul(metalnessNode.oneMinus()))}copy(source){return this.emissiveNode=source.emissiveNode,this.metalnessNode=source.metalnessNode,this.roughnessNode=source.roughnessNode,super.copy(source)}}const _defaultValues$5=/*@__PURE__*/new MeshPhysicalMaterial;class MeshPhysicalNodeMaterial extends MeshStandardNodeMaterial{static get type(){return"MeshPhysicalNodeMaterial"}constructor(parameters){super(),this.isMeshPhysicalNodeMaterial=!0,this.clearcoatNode=null,this.clearcoatRoughnessNode=null,this.clearcoatNormalNode=null,this.sheenNode=null,this.sheenRoughnessNode=null,this.iridescenceNode=null,this.iridescenceIORNode=null,this.iridescenceThicknessNode=null,this.specularIntensityNode=null,this.specularColorNode=null,this.iorNode=null,this.transmissionNode=null,this.thicknessNode=null,this.attenuationDistanceNode=null,this.attenuationColorNode=null,this.dispersionNode=null,this.anisotropyNode=null,this.setDefaultValues(_defaultValues$5),this.setValues(parameters)}get useClearcoat(){return this.clearcoat>0||null!==this.clearcoatNode}get useIridescence(){return this.iridescence>0||null!==this.iridescenceNode}get useSheen(){return this.sheen>0||null!==this.sheenNode}get useAnisotropy(){return this.anisotropy>0||null!==this.anisotropyNode}get useTransmission(){return this.transmission>0||null!==this.transmissionNode}get useDispersion(){return this.dispersion>0||null!==this.dispersionNode}setupSpecular(){const iorNode=this.iorNode?float(this.iorNode):materialIOR;ior.assign(iorNode),specularColor.assign(min$1(pow2(ior.sub(1).div(ior.add(1))).mul(materialSpecularColor),vec3(1)).mul(materialSpecularIntensity)),specularColorBlended.assign(mix(specularColor,diffuseColor.rgb,metalness)),specularF90.assign(mix(materialSpecularIntensity,1,metalness))}setupLightingModel(){return new PhysicalLightingModel(this.useClearcoat,this.useSheen,this.useIridescence,this.useAnisotropy,this.useTransmission,this.useDispersion)}setupVariants(builder){if(super.setupVariants(builder),this.useClearcoat){const clearcoatNode=this.clearcoatNode?float(this.clearcoatNode):materialClearcoat,clearcoatRoughnessNode=this.clearcoatRoughnessNode?float(this.clearcoatRoughnessNode):materialClearcoatRoughness;clearcoat.assign(clearcoatNode),clearcoatRoughness.assign(getRoughness({roughness:clearcoatRoughnessNode}))}if(this.useSheen){const sheenNode=this.sheenNode?vec3(this.sheenNode):materialSheen,sheenRoughnessNode=this.sheenRoughnessNode?float(this.sheenRoughnessNode):materialSheenRoughness;sheen.assign(sheenNode),sheenRoughness.assign(sheenRoughnessNode)}if(this.useIridescence){const iridescenceNode=this.iridescenceNode?float(this.iridescenceNode):materialIridescence,iridescenceIORNode=this.iridescenceIORNode?float(this.iridescenceIORNode):materialIridescenceIOR,iridescenceThicknessNode=this.iridescenceThicknessNode?float(this.iridescenceThicknessNode):materialIridescenceThickness;iridescence.assign(iridescenceNode),iridescenceIOR.assign(iridescenceIORNode),iridescenceThickness.assign(iridescenceThicknessNode)}if(this.useAnisotropy){const anisotropyV=(this.anisotropyNode?vec2(this.anisotropyNode):materialAnisotropy).toVar();anisotropy.assign(anisotropyV.length()),If(anisotropy.equal(0),()=>{anisotropyV.assign(vec2(1,0))}).Else(()=>{anisotropyV.divAssign(vec2(anisotropy)),anisotropy.assign(anisotropy.saturate())}),alphaT.assign(anisotropy.pow2().mix(roughness.pow2(),1)),anisotropyT.assign(TBNViewMatrix[0].mul(anisotropyV.x).add(TBNViewMatrix[1].mul(anisotropyV.y))),anisotropyB.assign(TBNViewMatrix[1].mul(anisotropyV.x).sub(TBNViewMatrix[0].mul(anisotropyV.y)))}if(this.useTransmission){const transmissionNode=this.transmissionNode?float(this.transmissionNode):materialTransmission,thicknessNode=this.thicknessNode?float(this.thicknessNode):materialThickness,attenuationDistanceNode=this.attenuationDistanceNode?float(this.attenuationDistanceNode):materialAttenuationDistance,attenuationColorNode=this.attenuationColorNode?vec3(this.attenuationColorNode):materialAttenuationColor;if(transmission.assign(transmissionNode),thickness.assign(thicknessNode),attenuationDistance.assign(attenuationDistanceNode),attenuationColor.assign(attenuationColorNode),this.useDispersion){const dispersionNode=this.dispersionNode?float(this.dispersionNode):materialDispersion;dispersion.assign(dispersionNode)}}}setupClearcoatNormal(){return this.clearcoatNormalNode?vec3(this.clearcoatNormalNode):materialClearcoatNormal}setup(builder){builder.context.setupClearcoatNormal=()=>subBuild(this.setupClearcoatNormal(builder),"NORMAL","vec3"),super.setup(builder)}copy(source){return this.clearcoatNode=source.clearcoatNode,this.clearcoatRoughnessNode=source.clearcoatRoughnessNode,this.clearcoatNormalNode=source.clearcoatNormalNode,this.sheenNode=source.sheenNode,this.sheenRoughnessNode=source.sheenRoughnessNode,this.iridescenceNode=source.iridescenceNode,this.iridescenceIORNode=source.iridescenceIORNode,this.iridescenceThicknessNode=source.iridescenceThicknessNode,this.specularIntensityNode=source.specularIntensityNode,this.specularColorNode=source.specularColorNode,this.iorNode=source.iorNode,this.transmissionNode=source.transmissionNode,this.thicknessNode=source.thicknessNode,this.attenuationDistanceNode=source.attenuationDistanceNode,this.attenuationColorNode=source.attenuationColorNode,this.dispersionNode=source.dispersionNode,this.anisotropyNode=source.anisotropyNode,super.copy(source)}}const getGradientIrradiance=/*@__PURE__*/Fn(({normal:normal,lightDirection:lightDirection,builder:builder})=>{const dotNL=normal.dot(lightDirection),coord=vec2(dotNL.mul(.5).add(.5),0);if(builder.material.gradientMap){const gradientMap=materialReference("gradientMap","texture").context({getUV:()=>coord});return vec3(gradientMap.r)}{const fw=coord.fwidth().mul(.5);return mix(vec3(.7),vec3(1),smoothstep(float(.7).sub(fw.x),float(.7).add(fw.x),coord.x))}});class ToonLightingModel extends LightingModel{direct({lightDirection:lightDirection,lightColor:lightColor,reflectedLight:reflectedLight},builder){const irradiance=getGradientIrradiance({normal:normalGeometry,lightDirection:lightDirection,builder:builder}).mul(lightColor);reflectedLight.directDiffuse.addAssign(irradiance.mul(BRDF_Lambert({diffuseColor:diffuseColor.rgb})))}indirect(builder){const{ambientOcclusion:ambientOcclusion,irradiance:irradiance,reflectedLight:reflectedLight}=builder.context;reflectedLight.indirectDiffuse.addAssign(irradiance.mul(BRDF_Lambert({diffuseColor:diffuseColor}))),reflectedLight.indirectDiffuse.mulAssign(ambientOcclusion)}}const _defaultValues$4=/*@__PURE__*/new MeshToonMaterial;class MeshToonNodeMaterial extends NodeMaterial{static get type(){return"MeshToonNodeMaterial"}constructor(parameters){super(),this.isMeshToonNodeMaterial=!0,this.lights=!0,this.setDefaultValues(_defaultValues$4),this.setValues(parameters)}setupLightingModel(){return new ToonLightingModel}}const matcapUV=/*@__PURE__*/Fn(()=>{const x=vec3(positionViewDirection.z,0,positionViewDirection.x.negate()).normalize(),y=positionViewDirection.cross(x);return vec2(x.dot(normalView),y.dot(normalView)).mul(.495).add(.5)}).once(["NORMAL","VERTEX"])().toVar("matcapUV"),_defaultValues$3=/*@__PURE__*/new MeshMatcapMaterial;class MeshMatcapNodeMaterial extends NodeMaterial{static get type(){return"MeshMatcapNodeMaterial"}constructor(parameters){super(),this.isMeshMatcapNodeMaterial=!0,this.setDefaultValues(_defaultValues$3),this.setValues(parameters)}setupVariants(builder){const uv=matcapUV;let matcapColor;matcapColor=builder.material.matcap?materialReference("matcap","texture").context({getUV:()=>uv}):vec3(mix(.2,.8,uv.y)),diffuseColor.rgb.mulAssign(matcapColor.rgb)}}class RotateNode extends TempNode{static get type(){return"RotateNode"}constructor(positionNode,rotationNode){super(),this.positionNode=positionNode,this.rotationNode=rotationNode}getNodeType(builder){return this.positionNode.getNodeType(builder)}setup(builder){const{rotationNode:rotationNode,positionNode:positionNode}=this;if("vec2"===this.getNodeType(builder)){const cosAngle=rotationNode.cos(),sinAngle=rotationNode.sin();return mat2(cosAngle,sinAngle,sinAngle.negate(),cosAngle).mul(positionNode)}{const rotation=rotationNode,rotationXMatrix=mat4(vec4(1,0,0,0),vec4(0,cos(rotation.x),sin(rotation.x).negate(),0),vec4(0,sin(rotation.x),cos(rotation.x),0),vec4(0,0,0,1)),rotationYMatrix=mat4(vec4(cos(rotation.y),0,sin(rotation.y),0),vec4(0,1,0,0),vec4(sin(rotation.y).negate(),0,cos(rotation.y),0),vec4(0,0,0,1)),rotationZMatrix=mat4(vec4(cos(rotation.z),sin(rotation.z).negate(),0,0),vec4(sin(rotation.z),cos(rotation.z),0,0),vec4(0,0,1,0),vec4(0,0,0,1));return rotationXMatrix.mul(rotationYMatrix).mul(rotationZMatrix).mul(vec4(positionNode,1)).xyz}}}const rotate=/*@__PURE__*/nodeProxy(RotateNode).setParameterLength(2),_defaultValues$2=/*@__PURE__*/new SpriteMaterial;class SpriteNodeMaterial extends NodeMaterial{static get type(){return"SpriteNodeMaterial"}constructor(parameters){super(),this.isSpriteNodeMaterial=!0,this._useSizeAttenuation=!0,this.positionNode=null,this.rotationNode=null,this.scaleNode=null,this.transparent=!0,this.setDefaultValues(_defaultValues$2),this.setValues(parameters)}setupPositionView(builder){const{object:object,camera:camera}=builder,{positionNode:positionNode,rotationNode:rotationNode,scaleNode:scaleNode,sizeAttenuation:sizeAttenuation}=this,mvPosition=modelViewMatrix.mul(vec3(positionNode||0));let scale=vec2(modelWorldMatrix[0].xyz.length(),modelWorldMatrix[1].xyz.length());null!==scaleNode&&(scale=scale.mul(vec2(scaleNode))),camera.isPerspectiveCamera&&!1===sizeAttenuation&&(scale=scale.mul(mvPosition.z.negate()));let alignedPosition=positionGeometry.xy;if(object.center&&!0===object.center.isVector2){const center=((name,type,object)=>new ReferenceBaseNode(name,type,object))("center","vec2",object);alignedPosition=alignedPosition.sub(center.sub(.5))}alignedPosition=alignedPosition.mul(scale);const rotation=float(rotationNode||materialRotation),rotatedPosition=rotate(alignedPosition,rotation);return vec4(mvPosition.xy.add(rotatedPosition),mvPosition.zw)}copy(source){return this.positionNode=source.positionNode,this.rotationNode=source.rotationNode,this.scaleNode=source.scaleNode,super.copy(source)}get sizeAttenuation(){return this._useSizeAttenuation}set sizeAttenuation(value){this._useSizeAttenuation!==value&&(this._useSizeAttenuation=value,this.needsUpdate=!0)}}const _defaultValues$1=/*@__PURE__*/new PointsMaterial,_size$4=/*@__PURE__*/new Vector2;class PointsNodeMaterial extends SpriteNodeMaterial{static get type(){return"PointsNodeMaterial"}constructor(parameters){super(),this.sizeNode=null,this.isPointsNodeMaterial=!0,this.setDefaultValues(_defaultValues$1),this.setValues(parameters)}setupPositionView(){const{positionNode:positionNode}=this;return modelViewMatrix.mul(vec3(positionNode||positionLocal)).xyz}setupVertexSprite(builder){const{material:material,camera:camera}=builder,{rotationNode:rotationNode,scaleNode:scaleNode,sizeNode:sizeNode,sizeAttenuation:sizeAttenuation}=this;let mvp=super.setupVertex(builder);if(!0!==material.isNodeMaterial)return mvp;let pointSize=null!==sizeNode?vec2(sizeNode):materialPointSize;pointSize=pointSize.mul(screenDPR),camera.isPerspectiveCamera&&!0===sizeAttenuation&&(pointSize=pointSize.mul(scale.div(positionView.z.negate()))),scaleNode&&scaleNode.isNode&&(pointSize=pointSize.mul(vec2(scaleNode)));let offset=positionGeometry.xy;if(rotationNode&&rotationNode.isNode){const rotation=float(rotationNode);offset=rotate(offset,rotation)}return offset=offset.mul(pointSize),offset=offset.div(viewportSize.div(2)),offset=offset.mul(mvp.w),mvp=mvp.add(vec4(offset,0,0)),mvp}setupVertex(builder){return builder.object.isPoints?super.setupVertex(builder):this.setupVertexSprite(builder)}get alphaToCoverage(){return this._useAlphaToCoverage}set alphaToCoverage(value){this._useAlphaToCoverage!==value&&(this._useAlphaToCoverage=value,this.needsUpdate=!0)}}const scale=/*@__PURE__*/uniform(1).onFrameUpdate(function({renderer:renderer}){const size=renderer.getSize(_size$4);this.value=.5*size.y});class ShadowMaskModel extends LightingModel{constructor(){super(),this.shadowNode=float(1).toVar("shadowMask")}direct({lightNode:lightNode}){null!==lightNode.shadowNode&&this.shadowNode.mulAssign(lightNode.shadowNode)}finish({context:context}){diffuseColor.a.mulAssign(this.shadowNode.oneMinus()),context.outgoingLight.rgb.assign(diffuseColor.rgb)}}const _defaultValues=/*@__PURE__*/new ShadowMaterial;class ShadowNodeMaterial extends NodeMaterial{static get type(){return"ShadowNodeMaterial"}constructor(parameters){super(),this.isShadowNodeMaterial=!0,this.lights=!0,this.transparent=!0,this.setDefaultValues(_defaultValues),this.setValues(parameters)}setupLightingModel(){return new ShadowMaskModel}}property("vec3"),property("vec3"),property("vec3");class Animation{constructor(renderer,nodes,info){this.renderer=renderer,this.nodes=nodes,this.info=info,this._context="undefined"!=typeof self?self:null,this._animationLoop=null,this._requestId=null}start(){const update=(time,xrFrame)=>{this._requestId=this._context.requestAnimationFrame(update),!0===this.info.autoReset&&this.info.reset(),this.nodes.nodeFrame.update(),this.info.frame=this.nodes.nodeFrame.frameId,this.renderer._inspector.begin(),null!==this._animationLoop&&this._animationLoop(time,xrFrame),this.renderer._inspector.finish()};update()}stop(){this._context.cancelAnimationFrame(this._requestId),this._requestId=null}getAnimationLoop(){return this._animationLoop}setAnimationLoop(callback){this._animationLoop=callback}getContext(){return this._context}setContext(context){this._context=context}dispose(){this.stop()}}class ChainMap{constructor(){this.weakMaps={}}_getWeakMap(keys){const length=keys.length;let weakMap=this.weakMaps[length];return void 0===weakMap&&(weakMap=new WeakMap,this.weakMaps[length]=weakMap),weakMap}get(keys){let map=this._getWeakMap(keys);for(let i=0;i<keys.length-1;i++)if(map=map.get(keys[i]),void 0===map)return;return map.get(keys[keys.length-1])}set(keys,value){let map=this._getWeakMap(keys);for(let i=0;i<keys.length-1;i++){const key=keys[i];!1===map.has(key)&&map.set(key,new WeakMap),map=map.get(key)}return map.set(keys[keys.length-1],value),this}delete(keys){let map=this._getWeakMap(keys);for(let i=0;i<keys.length-1;i++)if(map=map.get(keys[i]),void 0===map)return!1;return map.delete(keys[keys.length-1])}}let _id$a=0;class RenderObject{constructor(nodes,geometries,renderer,object,material,scene,camera,lightsNode,renderContext,clippingContext){this.id=_id$a++,this._nodes=nodes,this._geometries=geometries,this.renderer=renderer,this.object=object,this.material=material,this.scene=scene,this.camera=camera,this.lightsNode=lightsNode,this.context=renderContext,this.geometry=object.geometry,this.version=material.version,this.drawRange=null,this.attributes=null,this.attributesId=null,this.pipeline=null,this.group=null,this.vertexBuffers=null,this.drawParams=null,this.bundle=null,this.clippingContext=clippingContext,this.clippingContextCacheKey=null!==clippingContext?clippingContext.cacheKey:"",this.initialNodesCacheKey=this.getDynamicCacheKey(),this.initialCacheKey=this.getCacheKey(),this._nodeBuilderState=null,this._bindings=null,this._monitor=null,this.onDispose=null,this.isRenderObject=!0,this.onMaterialDispose=()=>{this.dispose()},this.onGeometryDispose=()=>{this.attributes=null,this.attributesId=null},this.material.addEventListener("dispose",this.onMaterialDispose),this.geometry.addEventListener("dispose",this.onGeometryDispose)}updateClipping(context){this.clippingContext=context}get clippingNeedsUpdate(){return null!==this.clippingContext&&this.clippingContext.cacheKey!==this.clippingContextCacheKey&&(this.clippingContextCacheKey=this.clippingContext.cacheKey,!0)}get hardwareClippingPlanes(){return!0===this.material.hardwareClipping?this.clippingContext.unionClippingCount:0}getNodeBuilderState(){return this._nodeBuilderState||(this._nodeBuilderState=this._nodes.getForRender(this))}getMonitor(){return this._monitor||(this._monitor=this.getNodeBuilderState().observer)}getBindings(){return this._bindings||(this._bindings=this.getNodeBuilderState().createBindings())}getBindingGroup(name){for(const bindingGroup of this.getBindings())if(bindingGroup.name===name)return bindingGroup}getIndex(){return this._geometries.getIndex(this)}getIndirect(){return this._geometries.getIndirect(this)}getIndirectOffset(){return this._geometries.getIndirectOffset(this)}getChainArray(){return[this.object,this.material,this.context,this.lightsNode]}setGeometry(geometry){this.geometry=geometry,this.attributes=null,this.attributesId=null}getAttributes(){if(null!==this.attributes)return this.attributes;const nodeAttributes=this.getNodeBuilderState().nodeAttributes,geometry=this.geometry,attributes=[],vertexBuffers=new Set,attributesId={};for(const nodeAttribute of nodeAttributes){let attribute;if(nodeAttribute.node&&nodeAttribute.node.attribute?attribute=nodeAttribute.node.attribute:(attribute=geometry.getAttribute(nodeAttribute.name),attributesId[nodeAttribute.name]=attribute.id),void 0===attribute)continue;attributes.push(attribute);const bufferAttribute=attribute.isInterleavedBufferAttribute?attribute.data:attribute;vertexBuffers.add(bufferAttribute)}return this.attributes=attributes,this.attributesId=attributesId,this.vertexBuffers=Array.from(vertexBuffers.values()),attributes}getVertexBuffers(){return null===this.vertexBuffers&&this.getAttributes(),this.vertexBuffers}getDrawParameters(){const{object:object,material:material,geometry:geometry,group:group,drawRange:drawRange}=this,drawParams=this.drawParams||(this.drawParams={vertexCount:0,firstVertex:0,instanceCount:0,firstInstance:0}),index=this.getIndex(),hasIndex=null!==index;let instanceCount=1;if(!0===geometry.isInstancedBufferGeometry?instanceCount=geometry.instanceCount:void 0!==object.count&&(instanceCount=Math.max(0,object.count)),0===instanceCount)return null;if(drawParams.instanceCount=instanceCount,!0===object.isBatchedMesh)return drawParams;let rangeFactor=1;!0!==material.wireframe||object.isPoints||object.isLineSegments||object.isLine||object.isLineLoop||(rangeFactor=2);let firstVertex=drawRange.start*rangeFactor,lastVertex=(drawRange.start+drawRange.count)*rangeFactor;null!==group&&(firstVertex=Math.max(firstVertex,group.start*rangeFactor),lastVertex=Math.min(lastVertex,(group.start+group.count)*rangeFactor));const position=geometry.attributes.position;let itemCount=Infinity;hasIndex?itemCount=index.count:null!=position&&(itemCount=position.count),firstVertex=Math.max(firstVertex,0),lastVertex=Math.min(lastVertex,itemCount);const count=lastVertex-firstVertex;return count<0||Infinity===count?null:(drawParams.vertexCount=count,drawParams.firstVertex=firstVertex,drawParams)}getGeometryCacheKey(){const{geometry:geometry}=this;let cacheKey="";for(const name of Object.keys(geometry.attributes).sort()){const attribute=geometry.attributes[name];cacheKey+=name+",",attribute.data&&(cacheKey+=attribute.data.stride+","),attribute.offset&&(cacheKey+=attribute.offset+","),attribute.itemSize&&(cacheKey+=attribute.itemSize+","),attribute.normalized&&(cacheKey+="n,")}for(const name of Object.keys(geometry.morphAttributes).sort()){const targets=geometry.morphAttributes[name];cacheKey+="morph-"+name+",";for(let i=0,l=targets.length;i<l;i++){cacheKey+=targets[i].id+","}}return geometry.index&&(cacheKey+="index,"),cacheKey}getMaterialCacheKey(){const{object:object,material:material,renderer:renderer}=this;let cacheKey=material.customProgramCacheKey();for(const property of function getKeys(obj){const keys=Object.keys(obj);let proto=Object.getPrototypeOf(obj);for(;proto;){const descriptors=Object.getOwnPropertyDescriptors(proto);for(const key in descriptors)if(void 0!==descriptors[key]){const descriptor=descriptors[key];descriptor&&"function"==typeof descriptor.get&&keys.push(key)}proto=Object.getPrototypeOf(proto)}return keys}(material)){if(/^(is[A-Z]|_)|^(visible|version|uuid|name|opacity|userData)$/.test(property))continue;const value=material[property];let valueKey;if(null!==value){const type=typeof value;"number"===type?valueKey=0!==value?"1":"0":"object"===type?(valueKey="{",value.isTexture&&(valueKey+=value.mapping,!0===renderer.backend.isWebGPUBackend&&(valueKey+=value.magFilter,valueKey+=value.minFilter,valueKey+=value.wrapS,valueKey+=value.wrapT,valueKey+=value.wrapR)),valueKey+="}"):valueKey=String(value)}else valueKey=String(value);cacheKey+=valueKey+","}return cacheKey+=this.clippingContextCacheKey+",",object.geometry&&(cacheKey+=this.getGeometryCacheKey()),object.skeleton&&(cacheKey+=object.skeleton.bones.length+","),object.isBatchedMesh&&(cacheKey+=object._matricesTexture.uuid+",",null!==object._colorsTexture&&(cacheKey+=object._colorsTexture.uuid+",")),(object.isInstancedMesh||object.count>1||Array.isArray(object.morphTargetInfluences))&&(cacheKey+=object.uuid+","),cacheKey+=this.context.id+",",cacheKey+=object.receiveShadow+",",hashString(cacheKey)}get needsGeometryUpdate(){if(this.geometry.id!==this.object.geometry.id)return!0;if(null!==this.attributes){const attributesId=this.attributesId;for(const name in attributesId){const attribute=this.geometry.getAttribute(name);if(void 0===attribute||attributesId[name]!==attribute.id)return!0}}return!1}get needsUpdate(){return this.initialNodesCacheKey!==this.getDynamicCacheKey()||this.clippingNeedsUpdate}getDynamicCacheKey(){let cacheKey=0;return!0!==this.material.isShadowPassMaterial&&(cacheKey=this._nodes.getCacheKey(this.scene,this.lightsNode)),this.camera.isArrayCamera&&(cacheKey=hash$1(cacheKey,this.camera.cameras.length)),this.object.receiveShadow&&(cacheKey=hash$1(cacheKey,1)),cacheKey=hash$1(cacheKey,this.renderer.contextNode.id,this.renderer.contextNode.version),cacheKey}getCacheKey(){return this.getMaterialCacheKey()+this.getDynamicCacheKey()}dispose(){this.material.removeEventListener("dispose",this.onMaterialDispose),this.geometry.removeEventListener("dispose",this.onGeometryDispose),this.onDispose()}}const _chainKeys$3=[];class RenderObjects{constructor(renderer,nodes,geometries,pipelines,bindings,info){this.renderer=renderer,this.nodes=nodes,this.geometries=geometries,this.pipelines=pipelines,this.bindings=bindings,this.info=info,this.chainMaps={}}get(object,material,scene,camera,lightsNode,renderContext,clippingContext,passId){const chainMap=this.getChainMap(passId);_chainKeys$3[0]=object,_chainKeys$3[1]=material,_chainKeys$3[2]=renderContext,_chainKeys$3[3]=lightsNode;let renderObject=chainMap.get(_chainKeys$3);return void 0===renderObject?(renderObject=this.createRenderObject(this.nodes,this.geometries,this.renderer,object,material,scene,camera,lightsNode,renderContext,clippingContext,passId),chainMap.set(_chainKeys$3,renderObject)):(renderObject.camera=camera,renderObject.updateClipping(clippingContext),renderObject.needsGeometryUpdate&&renderObject.setGeometry(object.geometry),(renderObject.version!==material.version||renderObject.needsUpdate)&&(renderObject.initialCacheKey!==renderObject.getCacheKey()?(renderObject.dispose(),renderObject=this.get(object,material,scene,camera,lightsNode,renderContext,clippingContext,passId)):renderObject.version=material.version)),_chainKeys$3[0]=null,_chainKeys$3[1]=null,_chainKeys$3[2]=null,_chainKeys$3[3]=null,renderObject}getChainMap(passId="default"){return this.chainMaps[passId]||(this.chainMaps[passId]=new ChainMap)}dispose(){this.chainMaps={}}createRenderObject(nodes,geometries,renderer,object,material,scene,camera,lightsNode,renderContext,clippingContext,passId){const chainMap=this.getChainMap(passId),renderObject=new RenderObject(nodes,geometries,renderer,object,material,scene,camera,lightsNode,renderContext,clippingContext);return renderObject.onDispose=()=>{this.pipelines.delete(renderObject),this.bindings.deleteForRender(renderObject),this.nodes.delete(renderObject),chainMap.delete(renderObject.getChainArray())},renderObject}}class DataMap{constructor(){this.data=new WeakMap}get(object){let map=this.data.get(object);return void 0===map&&(map={},this.data.set(object,map)),map}delete(object){let map=null;return this.data.has(object)&&(map=this.data.get(object),this.data.delete(object)),map}has(object){return this.data.has(object)}dispose(){this.data=new WeakMap}}const AttributeType_VERTEX=1,AttributeType_INDEX=2,AttributeType_STORAGE=3,AttributeType_INDIRECT=4;class Attributes extends DataMap{constructor(backend){super(),this.backend=backend}delete(attribute){const attributeData=super.delete(attribute);return null!==attributeData&&this.backend.destroyAttribute(attribute),attributeData}update(attribute,type){const data=this.get(attribute);if(void 0===data.version)type===AttributeType_VERTEX?this.backend.createAttribute(attribute):type===AttributeType_INDEX?this.backend.createIndexAttribute(attribute):type===AttributeType_STORAGE?this.backend.createStorageAttribute(attribute):type===AttributeType_INDIRECT&&this.backend.createIndirectStorageAttribute(attribute),data.version=this._getBufferAttribute(attribute).version;else{const bufferAttribute=this._getBufferAttribute(attribute);(data.version<bufferAttribute.version||35048===bufferAttribute.usage)&&(this.backend.updateAttribute(attribute),data.version=bufferAttribute.version)}}_getBufferAttribute(attribute){return attribute.isInterleavedBufferAttribute&&(attribute=attribute.data),attribute}}function getWireframeVersion(geometry){return null!==geometry.index?geometry.index.version:geometry.attributes.position.version}function getWireframeId(geometry){return null!==geometry.index?geometry.index.id:geometry.attributes.position.id}function getWireframeIndex(geometry){const indices=[],geometryIndex=geometry.index,geometryPosition=geometry.attributes.position;if(null!==geometryIndex){const array=geometryIndex.array;for(let i=0,l=array.length;i<l;i+=3){const a=array[i+0],b=array[i+1],c=array[i+2];indices.push(a,b,b,c,c,a)}}else{for(let i=0,l=geometryPosition.array.length/3-1;i<l;i+=3){const a=i+0,b=i+1,c=i+2;indices.push(a,b,b,c,c,a)}}const attribute=new(geometryPosition.count>=65535?Uint32BufferAttribute:Uint16BufferAttribute)(indices,1);return attribute.version=getWireframeVersion(geometry),attribute.__id=getWireframeId(geometry),attribute}class Geometries extends DataMap{constructor(attributes,info){super(),this.attributes=attributes,this.info=info,this.wireframes=new WeakMap,this.attributeCall=new WeakMap,this._geometryDisposeListeners=new Map}has(renderObject){const geometry=renderObject.geometry;return super.has(geometry)&&!0===this.get(geometry).initialized}updateForRender(renderObject){!1===this.has(renderObject)&&this.initGeometry(renderObject),this.updateAttributes(renderObject)}initGeometry(renderObject){const geometry=renderObject.geometry;this.get(geometry).initialized=!0,this.info.memory.geometries++;const onDispose=()=>{this.info.memory.geometries--;const index=geometry.index,geometryAttributes=renderObject.getAttributes();null!==index&&this.attributes.delete(index);for(const geometryAttribute of geometryAttributes)this.attributes.delete(geometryAttribute);const wireframeAttribute=this.wireframes.get(geometry);void 0!==wireframeAttribute&&this.attributes.delete(wireframeAttribute),geometry.removeEventListener("dispose",onDispose),this._geometryDisposeListeners.delete(geometry)};geometry.addEventListener("dispose",onDispose),this._geometryDisposeListeners.set(geometry,onDispose)}updateAttributes(renderObject){const attributes=renderObject.getAttributes();for(const attribute of attributes)attribute.isStorageBufferAttribute||attribute.isStorageInstancedBufferAttribute?this.updateAttribute(attribute,AttributeType_STORAGE):this.updateAttribute(attribute,AttributeType_VERTEX);const index=this.getIndex(renderObject);null!==index&&this.updateAttribute(index,AttributeType_INDEX);const indirect=renderObject.geometry.indirect;null!==indirect&&this.updateAttribute(indirect,AttributeType_INDIRECT)}updateAttribute(attribute,type){const callId=this.info.render.calls;attribute.isInterleavedBufferAttribute?void 0===this.attributeCall.get(attribute)?(this.attributes.update(attribute,type),this.attributeCall.set(attribute,callId)):this.attributeCall.get(attribute.data)!==callId&&(this.attributes.update(attribute,type),this.attributeCall.set(attribute.data,callId),this.attributeCall.set(attribute,callId)):this.attributeCall.get(attribute)!==callId&&(this.attributes.update(attribute,type),this.attributeCall.set(attribute,callId))}getIndirect(renderObject){return renderObject.geometry.indirect}getIndirectOffset(renderObject){return renderObject.geometry.indirectOffset}getIndex(renderObject){const{geometry:geometry,material:material}=renderObject;let index=geometry.index;if(!0===material.wireframe){const wireframes=this.wireframes;let wireframeAttribute=wireframes.get(geometry);void 0===wireframeAttribute?(wireframeAttribute=getWireframeIndex(geometry),wireframes.set(geometry,wireframeAttribute)):wireframeAttribute.version===getWireframeVersion(geometry)&&wireframeAttribute.__id===getWireframeId(geometry)||(this.attributes.delete(wireframeAttribute),wireframeAttribute=getWireframeIndex(geometry),wireframes.set(geometry,wireframeAttribute)),index=wireframeAttribute}return index}dispose(){for(const[geometry,onDispose]of this._geometryDisposeListeners.entries())geometry.removeEventListener("dispose",onDispose);this._geometryDisposeListeners.clear()}}class Info{constructor(){this.autoReset=!0,this.frame=0,this.calls=0,this.render={calls:0,frameCalls:0,drawCalls:0,triangles:0,points:0,lines:0,timestamp:0},this.compute={calls:0,frameCalls:0,timestamp:0},this.memory={geometries:0,textures:0}}update(object,count,instanceCount){this.render.drawCalls++,object.isMesh||object.isSprite?this.render.triangles+=instanceCount*(count/3):object.isPoints?this.render.points+=instanceCount*count:object.isLineSegments?this.render.lines+=instanceCount*(count/2):object.isLine?this.render.lines+=instanceCount*(count-1):error("WebGPUInfo: Unknown object type.")}reset(){this.render.drawCalls=0,this.render.frameCalls=0,this.compute.frameCalls=0,this.render.triangles=0,this.render.points=0,this.render.lines=0}dispose(){this.reset(),this.calls=0,this.render.calls=0,this.compute.calls=0,this.render.timestamp=0,this.compute.timestamp=0,this.memory.geometries=0,this.memory.textures=0}}class Pipeline{constructor(cacheKey){this.cacheKey=cacheKey,this.usedTimes=0}}class RenderObjectPipeline extends Pipeline{constructor(cacheKey,vertexProgram,fragmentProgram){super(cacheKey),this.vertexProgram=vertexProgram,this.fragmentProgram=fragmentProgram}}class ComputePipeline extends Pipeline{constructor(cacheKey,computeProgram){super(cacheKey),this.computeProgram=computeProgram,this.isComputePipeline=!0}}let _id$9=0;class ProgrammableStage{constructor(code,stage,name,transforms=null,attributes=null){this.id=_id$9++,this.code=code,this.stage=stage,this.name=name,this.transforms=transforms,this.attributes=attributes,this.usedTimes=0}}class Pipelines extends DataMap{constructor(backend,nodes){super(),this.backend=backend,this.nodes=nodes,this.bindings=null,this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}getForCompute(computeNode,bindings){const{backend:backend}=this,data=this.get(computeNode);if(this._needsComputeUpdate(computeNode)){const previousPipeline=data.pipeline;previousPipeline&&(previousPipeline.usedTimes--,previousPipeline.computeProgram.usedTimes--);const nodeBuilderState=this.nodes.getForCompute(computeNode);let stageCompute=this.programs.compute.get(nodeBuilderState.computeShader);void 0===stageCompute&&(previousPipeline&&0===previousPipeline.computeProgram.usedTimes&&this._releaseProgram(previousPipeline.computeProgram),stageCompute=new ProgrammableStage(nodeBuilderState.computeShader,"compute",computeNode.name,nodeBuilderState.transforms,nodeBuilderState.nodeAttributes),this.programs.compute.set(nodeBuilderState.computeShader,stageCompute),backend.createProgram(stageCompute));const cacheKey=this._getComputeCacheKey(computeNode,stageCompute);let pipeline=this.caches.get(cacheKey);void 0===pipeline&&(previousPipeline&&0===previousPipeline.usedTimes&&this._releasePipeline(previousPipeline),pipeline=this._getComputePipeline(computeNode,stageCompute,cacheKey,bindings)),pipeline.usedTimes++,stageCompute.usedTimes++,data.version=computeNode.version,data.pipeline=pipeline}return data.pipeline}getForRender(renderObject,promises=null){const{backend:backend}=this,data=this.get(renderObject);if(this._needsRenderUpdate(renderObject)){const previousPipeline=data.pipeline;previousPipeline&&(previousPipeline.usedTimes--,previousPipeline.vertexProgram.usedTimes--,previousPipeline.fragmentProgram.usedTimes--);const nodeBuilderState=renderObject.getNodeBuilderState(),name=renderObject.material?renderObject.material.name:"";let stageVertex=this.programs.vertex.get(nodeBuilderState.vertexShader);void 0===stageVertex&&(previousPipeline&&0===previousPipeline.vertexProgram.usedTimes&&this._releaseProgram(previousPipeline.vertexProgram),stageVertex=new ProgrammableStage(nodeBuilderState.vertexShader,"vertex",name),this.programs.vertex.set(nodeBuilderState.vertexShader,stageVertex),backend.createProgram(stageVertex));let stageFragment=this.programs.fragment.get(nodeBuilderState.fragmentShader);void 0===stageFragment&&(previousPipeline&&0===previousPipeline.fragmentProgram.usedTimes&&this._releaseProgram(previousPipeline.fragmentProgram),stageFragment=new ProgrammableStage(nodeBuilderState.fragmentShader,"fragment",name),this.programs.fragment.set(nodeBuilderState.fragmentShader,stageFragment),backend.createProgram(stageFragment));const cacheKey=this._getRenderCacheKey(renderObject,stageVertex,stageFragment);let pipeline=this.caches.get(cacheKey);void 0===pipeline?(previousPipeline&&0===previousPipeline.usedTimes&&this._releasePipeline(previousPipeline),pipeline=this._getRenderPipeline(renderObject,stageVertex,stageFragment,cacheKey,promises)):renderObject.pipeline=pipeline,pipeline.usedTimes++,stageVertex.usedTimes++,stageFragment.usedTimes++,data.pipeline=pipeline}return data.pipeline}delete(object){const pipeline=this.get(object).pipeline;return pipeline&&(pipeline.usedTimes--,0===pipeline.usedTimes&&this._releasePipeline(pipeline),pipeline.isComputePipeline?(pipeline.computeProgram.usedTimes--,0===pipeline.computeProgram.usedTimes&&this._releaseProgram(pipeline.computeProgram)):(pipeline.fragmentProgram.usedTimes--,pipeline.vertexProgram.usedTimes--,0===pipeline.vertexProgram.usedTimes&&this._releaseProgram(pipeline.vertexProgram),0===pipeline.fragmentProgram.usedTimes&&this._releaseProgram(pipeline.fragmentProgram))),super.delete(object)}dispose(){super.dispose(),this.caches=new Map,this.programs={vertex:new Map,fragment:new Map,compute:new Map}}updateForRender(renderObject){this.getForRender(renderObject)}_getComputePipeline(computeNode,stageCompute,cacheKey,bindings){cacheKey=cacheKey||this._getComputeCacheKey(computeNode,stageCompute);let pipeline=this.caches.get(cacheKey);return void 0===pipeline&&(pipeline=new ComputePipeline(cacheKey,stageCompute),this.caches.set(cacheKey,pipeline),this.backend.createComputePipeline(pipeline,bindings)),pipeline}_getRenderPipeline(renderObject,stageVertex,stageFragment,cacheKey,promises){cacheKey=cacheKey||this._getRenderCacheKey(renderObject,stageVertex,stageFragment);let pipeline=this.caches.get(cacheKey);return void 0===pipeline&&(pipeline=new RenderObjectPipeline(cacheKey,stageVertex,stageFragment),this.caches.set(cacheKey,pipeline),renderObject.pipeline=pipeline,this.backend.createRenderPipeline(renderObject,promises)),pipeline}_getComputeCacheKey(computeNode,stageCompute){return computeNode.id+","+stageCompute.id}_getRenderCacheKey(renderObject,stageVertex,stageFragment){return stageVertex.id+","+stageFragment.id+","+this.backend.getRenderCacheKey(renderObject)}_releasePipeline(pipeline){this.caches.delete(pipeline.cacheKey)}_releaseProgram(program){const code=program.code,stage=program.stage;this.programs[stage].delete(code)}_needsComputeUpdate(computeNode){const data=this.get(computeNode);return void 0===data.pipeline||data.version!==computeNode.version}_needsRenderUpdate(renderObject){return void 0===this.get(renderObject).pipeline||this.backend.needsRenderUpdate(renderObject)}}class Bindings extends DataMap{constructor(backend,nodes,textures,attributes,pipelines,info){super(),this.backend=backend,this.textures=textures,this.pipelines=pipelines,this.attributes=attributes,this.nodes=nodes,this.info=info,this.pipelines.bindings=this}getForRender(renderObject){const bindings=renderObject.getBindings();for(const bindGroup of bindings){const groupData=this.get(bindGroup);void 0===groupData.bindGroup&&(this._init(bindGroup),this.backend.createBindings(bindGroup,bindings,0),groupData.bindGroup=bindGroup)}return bindings}getForCompute(computeNode){const bindings=this.nodes.getForCompute(computeNode).bindings;for(const bindGroup of bindings){const groupData=this.get(bindGroup);void 0===groupData.bindGroup&&(this._init(bindGroup),this.backend.createBindings(bindGroup,bindings,0),groupData.bindGroup=bindGroup)}return bindings}updateForCompute(computeNode){this._updateBindings(this.getForCompute(computeNode))}updateForRender(renderObject){this._updateBindings(this.getForRender(renderObject))}deleteForCompute(computeNode){const bindings=this.nodes.getForCompute(computeNode).bindings;for(const bindGroup of bindings)this.backend.deleteBindGroupData(bindGroup),this.delete(bindGroup)}deleteForRender(renderObject){const bindings=renderObject.getBindings();for(const bindGroup of bindings)this.backend.deleteBindGroupData(bindGroup),this.delete(bindGroup)}_updateBindings(bindings){for(const bindGroup of bindings)this._update(bindGroup,bindings)}_init(bindGroup){for(const binding of bindGroup.bindings)if(binding.isSampledTexture)this.textures.updateTexture(binding.texture);else if(binding.isSampler)this.textures.updateSampler(binding.texture);else if(binding.isStorageBuffer){const attribute=binding.attribute,attributeType=attribute.isIndirectStorageBufferAttribute?AttributeType_INDIRECT:AttributeType_STORAGE;this.attributes.update(attribute,attributeType)}}_update(bindGroup,bindings){const{backend:backend}=this;let needsBindingsUpdate=!1,cacheBindings=!0,cacheIndex=0,version=0;for(const binding of bindGroup.bindings){if(!1!==this.nodes.updateGroup(binding)){if(binding.isStorageBuffer){const attribute=binding.attribute,attributeType=attribute.isIndirectStorageBufferAttribute?AttributeType_INDIRECT:AttributeType_STORAGE,bindingData=backend.get(binding);this.attributes.update(attribute,attributeType),bindingData.attribute!==attribute&&(bindingData.attribute=attribute,needsBindingsUpdate=!0)}if(binding.isUniformBuffer){binding.update()&&backend.updateBinding(binding)}else if(binding.isSampledTexture){const updated=binding.update(),texture=binding.texture,texturesTextureData=this.textures.get(texture);updated&&(this.textures.updateTexture(texture),binding.generation!==texturesTextureData.generation&&(binding.generation=texturesTextureData.generation,needsBindingsUpdate=!0,cacheBindings=!1));if(void 0!==backend.get(texture).externalTexture||texturesTextureData.isDefaultTexture?cacheBindings=!1:(cacheIndex=10*cacheIndex+texture.id,version+=texture.version),!0===texture.isStorageTexture&&!0===texture.mipmapsAutoUpdate){const textureData=this.get(texture);!0===binding.store?textureData.needsMipmap=!0:this.textures.needsMipmaps(texture)&&!0===textureData.needsMipmap&&(this.backend.generateMipmaps(texture),textureData.needsMipmap=!1)}}else if(binding.isSampler){if(binding.update()){const samplerKey=this.textures.updateSampler(binding.texture);binding.samplerKey!==samplerKey&&(binding.samplerKey=samplerKey,needsBindingsUpdate=!0,cacheBindings=!1)}}binding.isBuffer&&binding.updateRanges.length>0&&binding.clearUpdateRanges()}}!0===needsBindingsUpdate&&this.backend.updateBindings(bindGroup,bindings,cacheBindings?cacheIndex:0,version)}}function painterSortStable(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?a.z-b.z:a.id-b.id}function reversePainterSortStable(a,b){return a.groupOrder!==b.groupOrder?a.groupOrder-b.groupOrder:a.renderOrder!==b.renderOrder?a.renderOrder-b.renderOrder:a.z!==b.z?b.z-a.z:a.id-b.id}function needsDoublePass(material){return(material.transmission>0||material.transmissionNode&&material.transmissionNode.isNode)&&2===material.side&&!1===material.forceSinglePass}class RenderList{constructor(lighting,scene,camera){this.renderItems=[],this.renderItemsIndex=0,this.opaque=[],this.transparentDoublePass=[],this.transparent=[],this.bundles=[],this.lightsNode=lighting.getNode(scene,camera),this.lightsArray=[],this.scene=scene,this.camera=camera,this.occlusionQueryCount=0}begin(){return this.renderItemsIndex=0,this.opaque.length=0,this.transparentDoublePass.length=0,this.transparent.length=0,this.bundles.length=0,this.lightsArray.length=0,this.occlusionQueryCount=0,this}getNextRenderItem(object,geometry,material,groupOrder,z,group,clippingContext){let renderItem=this.renderItems[this.renderItemsIndex];return void 0===renderItem?(renderItem={id:object.id,object:object,geometry:geometry,material:material,groupOrder:groupOrder,renderOrder:object.renderOrder,z:z,group:group,clippingContext:clippingContext},this.renderItems[this.renderItemsIndex]=renderItem):(renderItem.id=object.id,renderItem.object=object,renderItem.geometry=geometry,renderItem.material=material,renderItem.groupOrder=groupOrder,renderItem.renderOrder=object.renderOrder,renderItem.z=z,renderItem.group=group,renderItem.clippingContext=clippingContext),this.renderItemsIndex++,renderItem}push(object,geometry,material,groupOrder,z,group,clippingContext){const renderItem=this.getNextRenderItem(object,geometry,material,groupOrder,z,group,clippingContext);!0===object.occlusionTest&&this.occlusionQueryCount++,!0===material.transparent||material.transmission>0||material.transmissionNode&&material.transmissionNode.isNode||material.backdropNode&&material.backdropNode.isNode?(needsDoublePass(material)&&this.transparentDoublePass.push(renderItem),this.transparent.push(renderItem)):this.opaque.push(renderItem)}unshift(object,geometry,material,groupOrder,z,group,clippingContext){const renderItem=this.getNextRenderItem(object,geometry,material,groupOrder,z,group,clippingContext);!0===material.transparent||material.transmission>0||material.transmissionNode&&material.transmissionNode.isNode||material.backdropNode&&material.backdropNode.isNode?(needsDoublePass(material)&&this.transparentDoublePass.unshift(renderItem),this.transparent.unshift(renderItem)):this.opaque.unshift(renderItem)}pushBundle(group){this.bundles.push(group)}pushLight(light){this.lightsArray.push(light)}sort(customOpaqueSort,customTransparentSort){this.opaque.length>1&&this.opaque.sort(customOpaqueSort||painterSortStable),this.transparentDoublePass.length>1&&this.transparentDoublePass.sort(customTransparentSort||reversePainterSortStable),this.transparent.length>1&&this.transparent.sort(customTransparentSort||reversePainterSortStable)}finish(){this.lightsNode.setLights(this.lightsArray);for(let i=this.renderItemsIndex,il=this.renderItems.length;i<il;i++){const renderItem=this.renderItems[i];if(null===renderItem.id)break;renderItem.id=null,renderItem.object=null,renderItem.geometry=null,renderItem.material=null,renderItem.groupOrder=null,renderItem.renderOrder=null,renderItem.z=null,renderItem.group=null,renderItem.clippingContext=null}}}const _chainKeys$2=[];class RenderLists{constructor(lighting){this.lighting=lighting,this.lists=new ChainMap}get(scene,camera){const lists=this.lists;_chainKeys$2[0]=scene,_chainKeys$2[1]=camera;let list=lists.get(_chainKeys$2);return void 0===list&&(list=new RenderList(this.lighting,scene,camera),lists.set(_chainKeys$2,list)),_chainKeys$2[0]=null,_chainKeys$2[1]=null,list}dispose(){this.lists=new ChainMap}}let _id$8=0;class RenderContext{constructor(){this.id=_id$8++,this.mrt=null,this.color=!0,this.clearColor=!0,this.clearColorValue={r:0,g:0,b:0,a:1},this.depth=!0,this.clearDepth=!0,this.clearDepthValue=1,this.stencil=!1,this.clearStencil=!0,this.clearStencilValue=1,this.viewport=!1,this.viewportValue=new Vector4,this.scissor=!1,this.scissorValue=new Vector4,this.renderTarget=null,this.textures=null,this.depthTexture=null,this.activeCubeFace=0,this.activeMipmapLevel=0,this.sampleCount=1,this.width=0,this.height=0,this.occlusionQueryCount=0,this.clippingContext=null,this.camera=null,this.isRenderContext=!0}getCacheKey(){return getCacheKey(this)}}function getCacheKey(renderContext){const{textures:textures,activeCubeFace:activeCubeFace,activeMipmapLevel:activeMipmapLevel}=renderContext,values=[activeCubeFace,activeMipmapLevel];for(const texture of textures)values.push(texture.id);return hashArray(values)}class RenderContexts{constructor(){this._renderContexts={}}get(renderTarget=null,mrt=null,callDepth=0){let attachmentState;if(null===renderTarget)attachmentState="default";else{const format=renderTarget.texture.format,type=renderTarget.texture.type;attachmentState=`${renderTarget.textures.length}:${format}:${type}:${renderTarget.samples}:${renderTarget.depthBuffer}:${renderTarget.stencilBuffer}`}const renderStateKey=attachmentState+"-"+(null!==mrt?mrt.id:"default")+"-"+callDepth;let renderState=this._renderContexts[renderStateKey];return void 0===renderState&&(renderState=new RenderContext,renderState.mrt=mrt,this._renderContexts[renderStateKey]=renderState),null!==renderTarget&&(renderState.sampleCount=0===renderTarget.samples?1:renderTarget.samples),renderState}dispose(){this._renderContexts={}}}const _size$3=/*@__PURE__*/new Vector3;class Textures extends DataMap{constructor(renderer,backend,info){super(),this.renderer=renderer,this.backend=backend,this.info=info}updateRenderTarget(renderTarget,activeMipmapLevel=0){const renderTargetData=this.get(renderTarget),sampleCount=0===renderTarget.samples?1:renderTarget.samples,depthTextureMips=renderTargetData.depthTextureMips||(renderTargetData.depthTextureMips={}),textures=renderTarget.textures,size=this.getSize(textures[0]),mipWidth=size.width>>activeMipmapLevel,mipHeight=size.height>>activeMipmapLevel;let depthTexture=renderTarget.depthTexture||depthTextureMips[activeMipmapLevel];const useDepthTexture=!0===renderTarget.depthBuffer||!0===renderTarget.stencilBuffer;let textureNeedsUpdate=!1;void 0===depthTexture&&useDepthTexture&&(depthTexture=new DepthTexture,depthTexture.format=renderTarget.stencilBuffer?1027:1026,depthTexture.type=renderTarget.stencilBuffer?1020:1014,depthTexture.image.width=mipWidth,depthTexture.image.height=mipHeight,depthTexture.image.depth=size.depth,depthTexture.renderTarget=renderTarget,depthTexture.isArrayTexture=!0===renderTarget.multiview&&size.depth>1,depthTextureMips[activeMipmapLevel]=depthTexture),renderTargetData.width===size.width&&size.height===renderTargetData.height||(textureNeedsUpdate=!0,depthTexture&&(depthTexture.needsUpdate=!0,depthTexture.image.width=mipWidth,depthTexture.image.height=mipHeight,depthTexture.image.depth=depthTexture.isArrayTexture?depthTexture.image.depth:1)),renderTargetData.width=size.width,renderTargetData.height=size.height,renderTargetData.textures=textures,renderTargetData.depthTexture=depthTexture||null,renderTargetData.depth=renderTarget.depthBuffer,renderTargetData.stencil=renderTarget.stencilBuffer,renderTargetData.renderTarget=renderTarget,renderTargetData.sampleCount!==sampleCount&&(textureNeedsUpdate=!0,depthTexture&&(depthTexture.needsUpdate=!0),renderTargetData.sampleCount=sampleCount);const options={sampleCount:sampleCount};if(!0!==renderTarget.isXRRenderTarget){for(let i=0;i<textures.length;i++){const texture=textures[i];textureNeedsUpdate&&(texture.needsUpdate=!0),this.updateTexture(texture,options)}depthTexture&&this.updateTexture(depthTexture,options)}!0!==renderTargetData.initialized&&(renderTargetData.initialized=!0,renderTargetData.onDispose=()=>{this._destroyRenderTarget(renderTarget)},renderTarget.addEventListener("dispose",renderTargetData.onDispose))}updateTexture(texture,options={}){const textureData=this.get(texture);if(!0===textureData.initialized&&textureData.version===texture.version)return;const isRenderTarget=texture.isRenderTargetTexture||texture.isDepthTexture||texture.isFramebufferTexture,backend=this.backend;if(isRenderTarget&&!0===textureData.initialized&&backend.destroyTexture(texture),texture.isFramebufferTexture){const renderTarget=this.renderer.getRenderTarget();texture.type=renderTarget?renderTarget.texture.type:1009}const{width:width,height:height,depth:depth}=this.getSize(texture);if(options.width=width,options.height=height,options.depth=depth,options.needsMipmaps=this.needsMipmaps(texture),options.levels=options.needsMipmaps?this.getMipLevels(texture,width,height):1,texture.isCubeTexture&&texture.mipmaps.length>0&&options.levels++,isRenderTarget||!0===texture.isStorageTexture||!0===texture.isExternalTexture)backend.createTexture(texture,options),textureData.generation=texture.version;else if(texture.version>0){const image=texture.image;if(void 0===image)warn("Renderer: Texture marked for update but image is undefined.");else if(!1===image.complete)warn("Renderer: Texture marked for update but image is incomplete.");else{if(texture.images){const images=[];for(const image of texture.images)images.push(image);options.images=images}else options.image=image;void 0!==textureData.isDefaultTexture&&!0!==textureData.isDefaultTexture||(backend.createTexture(texture,options),textureData.isDefaultTexture=!1,textureData.generation=texture.version),!0===texture.source.dataReady&&backend.updateTexture(texture,options);const skipAutoGeneration=!0===texture.isStorageTexture&&!1===texture.mipmapsAutoUpdate;options.needsMipmaps&&0===texture.mipmaps.length&&!skipAutoGeneration&&backend.generateMipmaps(texture),texture.onUpdate&&texture.onUpdate(texture)}}else backend.createDefaultTexture(texture),textureData.isDefaultTexture=!0,textureData.generation=texture.version;!0!==textureData.initialized&&(textureData.initialized=!0,textureData.generation=texture.version,this.info.memory.textures++,texture.isVideoTexture&&!0===ColorManagement.enabled&&"srgb"!==ColorManagement.getTransfer(texture.colorSpace)&&warn("WebGPURenderer: Video textures must use a color space with a sRGB transfer function, e.g. SRGBColorSpace."),textureData.onDispose=()=>{this._destroyTexture(texture)},texture.addEventListener("dispose",textureData.onDispose)),textureData.version=texture.version}updateSampler(texture){return this.backend.updateSampler(texture)}getSize(texture,target=_size$3){let image=texture.images?texture.images[0]:texture.image;return image?(void 0!==image.image&&(image=image.image),"undefined"!=typeof HTMLVideoElement&&image instanceof HTMLVideoElement?(target.width=image.videoWidth||1,target.height=image.videoHeight||1,target.depth=1):"undefined"!=typeof VideoFrame&&image instanceof VideoFrame?(target.width=image.displayWidth||1,target.height=image.displayHeight||1,target.depth=1):(target.width=image.width||1,target.height=image.height||1,target.depth=texture.isCubeTexture?6:image.depth||1)):target.width=target.height=target.depth=1,target}getMipLevels(texture,width,height){let mipLevelCount;return mipLevelCount=texture.mipmaps.length>0?texture.mipmaps.length:!0===texture.isCompressedTexture?1:Math.floor(Math.log2(Math.max(width,height)))+1,mipLevelCount}needsMipmaps(texture){return!0===texture.generateMipmaps||texture.mipmaps.length>0}_destroyRenderTarget(renderTarget){if(!0===this.has(renderTarget)){const renderTargetData=this.get(renderTarget),textures=renderTargetData.textures,depthTexture=renderTargetData.depthTexture;renderTarget.removeEventListener("dispose",renderTargetData.onDispose);for(let i=0;i<textures.length;i++)this._destroyTexture(textures[i]);depthTexture&&this._destroyTexture(depthTexture),this.delete(renderTarget),this.backend.delete(renderTarget)}}_destroyTexture(texture){if(!0===this.has(texture)){const textureData=this.get(texture);texture.removeEventListener("dispose",textureData.onDispose);const isDefaultTexture=textureData.isDefaultTexture;this.backend.destroyTexture(texture,isDefaultTexture),this.delete(texture),this.info.memory.textures--}}}class Color4 extends Color{constructor(r,g,b,a=1){super(r,g,b),this.a=a}set(r,g,b,a=1){return this.a=a,super.set(r,g,b)}copy(color){return void 0!==color.a&&(this.a=color.a),super.copy(color)}clone(){return new this.constructor(this.r,this.g,this.b,this.a)}}class ParameterNode extends PropertyNode{static get type(){return"ParameterNode"}constructor(nodeType,name=null){super(nodeType,name),this.isParameterNode=!0}getMemberType(builder,name){const type=this.getNodeType(builder),struct=builder.getStructTypeNode(type);let memberType;return null!==struct?memberType=struct.getMemberType(builder,name):(error(`TSL: Member "${name}" not found in struct "${type}".`,new StackTrace),memberType="float"),memberType}getHash(){return this.uuid}generate(){return this.name}}class StackNode extends Node$1{static get type(){return"StackNode"}constructor(parent=null){super(),this.nodes=[],this.outputNode=null,this.parent=parent,this._currentCond=null,this._expressionNode=null,this._currentNode=null,this.isStackNode=!0}getElementType(builder){return this.hasOutput(builder)?this.outputNode.getElementType(builder):"void"}getNodeType(builder){return this.hasOutput(builder)?this.outputNode.getNodeType(builder):"void"}getMemberType(builder,name){return this.hasOutput(builder)?this.outputNode.getMemberType(builder,name):"void"}addToStack(node,index=this.nodes.length){return!0!==node.isNode?(error("TSL: Invalid node added to stack.",new StackTrace),this):(this.nodes.splice(index,0,node),this)}addToStackBefore(node){const index=this._currentNode?this.nodes.indexOf(this._currentNode):0;return this.addToStack(node,index)}If(boolNode,method){const methodNode=new ShaderNode(method);return this._currentCond=select(boolNode,methodNode),this.addToStack(this._currentCond)}ElseIf(boolNode,method){const methodNode=new ShaderNode(method),ifNode=select(boolNode,methodNode);return this._currentCond.elseNode=ifNode,this._currentCond=ifNode,this}Else(method){return this._currentCond.elseNode=new ShaderNode(method),this}Switch(expression){return this._expressionNode=nodeObject(expression),this}Case(...params){const caseNodes=[];if(params.length>=2)for(let i=0;i<params.length-1;i++)caseNodes.push(this._expressionNode.equal(nodeObject(params[i])));else error("TSL: Invalid parameter length. Case() requires at least two parameters.",new StackTrace);const methodNode=new ShaderNode(params[params.length-1]);let caseNode=caseNodes[0];for(let i=1;i<caseNodes.length;i++)caseNode=caseNode.or(caseNodes[i]);const condNode=select(caseNode,methodNode);return null===this._currentCond?(this._currentCond=condNode,this.addToStack(this._currentCond)):(this._currentCond.elseNode=condNode,this._currentCond=condNode,this)}Default(method){return this.Else(method),this}setup(builder){const nodeProperties=builder.getNodeProperties(this);let index=0;for(const childNode of this.getChildren())childNode.isVarNode&&childNode.isIntent(builder)&&!0!==childNode.isAssign(builder)||(nodeProperties["node"+index++]=childNode);return nodeProperties.outputNode||null}hasOutput(builder){return this.outputNode&&this.outputNode.isNode&&"void"!==this.outputNode.getNodeType(builder)}build(builder,...params){const previousStack=getCurrentStack(),buildStage=builder.buildStage;setCurrentStack(this),builder.setActiveStack(this);const buildNode=node=>{if(this._currentNode=node,!node.isVarNode||!node.isIntent(builder)||!0===node.isAssign(builder))if("setup"===buildStage)node.build(builder);else if("analyze"===buildStage)node.build(builder,this);else if("generate"===buildStage){const stages=builder.getDataFromNode(node,"any").stages,parents=stages&&stages[builder.shaderStage];if(node.isVarNode&&parents&&1===parents.length&&parents[0]&&parents[0].isStackNode)return;node.build(builder,"void")}},nodes=[...this.nodes];for(const node of nodes)buildNode(node);this._currentNode=null;const newNodes=this.nodes.filter(node=>-1===nodes.indexOf(node));for(const node of newNodes)buildNode(node);let result;return result=this.hasOutput(builder)?this.outputNode.build(builder,...params):super.build(builder,...params),setCurrentStack(previousStack),builder.removeActiveStack(this),result}}const stack=/*@__PURE__*/nodeProxy(StackNode).setParameterLength(0,1);class BitcastNode extends TempNode{static get type(){return"BitcastNode"}constructor(valueNode,conversionType,inputType=null){super(),this.valueNode=valueNode,this.conversionType=conversionType,this.inputType=inputType,this.isBitcastNode=!0}getNodeType(builder){if(null!==this.inputType){const valueType=this.valueNode.getNodeType(builder),valueLength=builder.getTypeLength(valueType);return builder.getTypeFromLength(valueLength,this.conversionType)}return this.conversionType}generate(builder){const type=this.getNodeType(builder);let inputType="";if(null!==this.inputType){const valueType=this.valueNode.getNodeType(builder);inputType=1===builder.getTypeLength(valueType)?this.inputType:builder.changeComponentType(valueType,this.inputType)}else inputType=this.valueNode.getNodeType(builder);return`${builder.getBitcastMethod(type,inputType)}( ${this.valueNode.build(builder,inputType)} )`}}const bitcast=/*@__PURE__*/nodeProxyIntent(BitcastNode).setParameterLength(2),registeredBitcountFunctions={};class BitcountNode extends MathNode{static get type(){return"BitcountNode"}constructor(method,aNode){super(method,aNode),this.isBitcountNode=!0}_resolveElementType(inputNode,outputNode,elementType){"int"===elementType?outputNode.assign(bitcast(inputNode,"uint")):outputNode.assign(inputNode)}_returnDataNode(inputType){switch(inputType){case"uint":return uint;case"int":return int;case"uvec2":return uvec2;case"uvec3":return uvec3;case"uvec4":return uvec4;case"ivec2":return ivec2;case"ivec3":return ivec3;case"ivec4":return ivec4}}_createTrailingZerosBaseLayout(method,elementType){const outputConvertNode=this._returnDataNode(elementType);return Fn(([value])=>{const v=uint(0);this._resolveElementType(value,v,elementType);const uintBits=(value=>new BitcastNode(value,"uint","float"))(float(v.bitAnd(negate(v)))),numTrailingZeros=uintBits.shiftRight(23).sub(127);return outputConvertNode(numTrailingZeros)}).setLayout({name:method,type:elementType,inputs:[{name:"value",type:elementType}]})}_createLeadingZerosBaseLayout(method,elementType){const outputConvertNode=this._returnDataNode(elementType);return Fn(([value])=>{If(value.equal(uint(0)),()=>uint(32));const v=uint(0),n=uint(0);return this._resolveElementType(value,v,elementType),If(v.shiftRight(16).equal(0),()=>{n.addAssign(16),v.shiftLeftAssign(16)}),If(v.shiftRight(24).equal(0),()=>{n.addAssign(8),v.shiftLeftAssign(8)}),If(v.shiftRight(28).equal(0),()=>{n.addAssign(4),v.shiftLeftAssign(4)}),If(v.shiftRight(30).equal(0),()=>{n.addAssign(2),v.shiftLeftAssign(2)}),If(v.shiftRight(31).equal(0),()=>{n.addAssign(1)}),outputConvertNode(n)}).setLayout({name:method,type:elementType,inputs:[{name:"value",type:elementType}]})}_createOneBitsBaseLayout(method,elementType){const outputConvertNode=this._returnDataNode(elementType);return Fn(([value])=>{const v=uint(0);this._resolveElementType(value,v,elementType),v.assign(v.sub(v.shiftRight(uint(1)).bitAnd(uint(1431655765)))),v.assign(v.bitAnd(uint(858993459)).add(v.shiftRight(uint(2)).bitAnd(uint(858993459))));const numBits=v.add(v.shiftRight(uint(4))).bitAnd(uint(252645135)).mul(uint(16843009)).shiftRight(uint(24));return outputConvertNode(numBits)}).setLayout({name:method,type:elementType,inputs:[{name:"value",type:elementType}]})}_createMainLayout(method,inputType,typeLength,baseFn){const outputConvertNode=this._returnDataNode(inputType);return Fn(([value])=>{if(1===typeLength)return outputConvertNode(baseFn(value));{const vec=outputConvertNode(0),components=["x","y","z","w"];for(let i=0;i<typeLength;i++){const component=components[i];vec[component].assign(baseFn(value[component]))}return vec}}).setLayout({name:method,type:inputType,inputs:[{name:"value",type:inputType}]})}setup(builder){const{method:method,aNode:aNode}=this,{renderer:renderer}=builder;if(renderer.backend.isWebGPUBackend)return super.setup(builder);const inputType=this.getInputType(builder),elementType=builder.getElementType(inputType),typeLength=builder.getTypeLength(inputType),baseMethod=`${method}_base_${elementType}`,newMethod=`${method}_${inputType}`;let baseFn=registeredBitcountFunctions[baseMethod];if(void 0===baseFn){switch(method){case BitcountNode.COUNT_LEADING_ZEROS:baseFn=this._createLeadingZerosBaseLayout(baseMethod,elementType);break;case BitcountNode.COUNT_TRAILING_ZEROS:baseFn=this._createTrailingZerosBaseLayout(baseMethod,elementType);break;case BitcountNode.COUNT_ONE_BITS:baseFn=this._createOneBitsBaseLayout(baseMethod,elementType)}registeredBitcountFunctions[baseMethod]=baseFn}let fn=registeredBitcountFunctions[newMethod];void 0===fn&&(fn=this._createMainLayout(newMethod,inputType,typeLength,baseFn),registeredBitcountFunctions[newMethod]=fn);return Fn(()=>fn(aNode))()}}BitcountNode.COUNT_TRAILING_ZEROS="countTrailingZeros",BitcountNode.COUNT_LEADING_ZEROS="countLeadingZeros",BitcountNode.COUNT_ONE_BITS="countOneBits",new Plane,new Vector3,new Vector3,new Vector3,new Matrix4,new Vector3(0,0,-1),new Vector4,new Vector3,new Vector3,new Vector4,new Vector2;const _defaultRT=new RenderTarget;screenUV.flipX(),_defaultRT.depthTexture=new DepthTexture(1,1);const _camera=/*@__PURE__*/new OrthographicCamera(-1,1,1,-1,0,1);class QuadGeometry extends BufferGeometry{constructor(flipY=!1){super();const uv=!1===flipY?[0,-1,0,1,2,1]:[0,2,0,0,2,0];this.setAttribute("position",new Float32BufferAttribute([-1,3,0,-1,-1,0,3,-1,0],3)),this.setAttribute("uv",new Float32BufferAttribute(uv,2))}}const _geometry=/*@__PURE__*/new QuadGeometry;class QuadMesh extends Mesh{constructor(material=null){super(_geometry,material),this.camera=_camera,this.isQuadMesh=!0}async renderAsync(renderer){warnOnce('QuadMesh: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.'),await renderer.init(),renderer.render(this,_camera)}render(renderer){renderer.render(this,_camera)}}const interleavedGradientNoise=Fn(([position])=>fract(float(52.9829189).mul(fract(dot(position,vec2(.06711056,.00583715)))))).setLayout({name:"interleavedGradientNoise",type:"float",inputs:[{name:"position",type:"vec2"}]}),vogelDiskSample=Fn(([sampleIndex,samplesCount,phi])=>{const goldenAngle=float(2.399963229728653),r=sqrt(float(sampleIndex).add(.5).div(float(samplesCount))),theta=float(sampleIndex).mul(goldenAngle).add(phi);return vec2(cos(theta),sin(theta)).mul(r)}).setLayout({name:"vogelDiskSample",type:"vec2",inputs:[{name:"sampleIndex",type:"int"},{name:"samplesCount",type:"int"},{name:"phi",type:"float"}]});class EventNode extends Node$1{static get type(){return"EventNode"}constructor(eventType,callback){super("void"),this.eventType=eventType,this.callback=callback,eventType===EventNode.OBJECT?this.updateType=NodeUpdateType_OBJECT:eventType===EventNode.MATERIAL?this.updateType=NodeUpdateType_RENDER:eventType===EventNode.BEFORE_OBJECT?this.updateBeforeType=NodeUpdateType_OBJECT:eventType===EventNode.BEFORE_MATERIAL&&(this.updateBeforeType=NodeUpdateType_RENDER)}update(frame){this.callback(frame)}updateBefore(frame){this.callback(frame)}}EventNode.OBJECT="object",EventNode.MATERIAL="material",EventNode.BEFORE_OBJECT="beforeObject",EventNode.BEFORE_MATERIAL="beforeMaterial";const _e1=/*@__PURE__*/new Euler,_m1=/*@__PURE__*/new Matrix4,backgroundBlurriness=/*@__PURE__*/uniform(0).setGroup(renderGroup).onRenderUpdate(({scene:scene})=>scene.backgroundBlurriness),backgroundIntensity=/*@__PURE__*/uniform(1).setGroup(renderGroup).onRenderUpdate(({scene:scene})=>scene.backgroundIntensity),backgroundRotation=/*@__PURE__*/uniform(new Matrix4).setGroup(renderGroup).onRenderUpdate(({scene:scene})=>{const background=scene.background;return null!==background&&background.isTexture&&300!==background.mapping?(_e1.copy(scene.backgroundRotation),_e1.x*=-1,_e1.y*=-1,_e1.z*=-1,_m1.makeRotationFromEuler(_e1)):_m1.identity(),_m1}),normal=Fn(({texture:texture,uv:uv})=>{const ret=vec3().toVar();return If(uv.x.lessThan(1e-4),()=>{ret.assign(vec3(1,0,0))}).ElseIf(uv.y.lessThan(1e-4),()=>{ret.assign(vec3(0,1,0))}).ElseIf(uv.z.lessThan(1e-4),()=>{ret.assign(vec3(0,0,1))}).ElseIf(uv.x.greaterThan(.9999),()=>{ret.assign(vec3(-1,0,0))}).ElseIf(uv.y.greaterThan(.9999),()=>{ret.assign(vec3(0,-1,0))}).ElseIf(uv.z.greaterThan(.9999),()=>{ret.assign(vec3(0,0,-1))}).Else(()=>{const x=texture.sample(uv.add(vec3(-.01,0,0))).r.sub(texture.sample(uv.add(vec3(.01,0,0))).r),y=texture.sample(uv.add(vec3(0,-.01,0))).r.sub(texture.sample(uv.add(vec3(0,.01,0))).r),z=texture.sample(uv.add(vec3(0,0,-.01))).r.sub(texture.sample(uv.add(vec3(0,0,.01))).r);ret.assign(vec3(x,y,z))}),ret.normalize()});class Texture3DNode extends TextureNode{static get type(){return"Texture3DNode"}constructor(value,uvNode=null,levelNode=null){super(value,uvNode,levelNode),this.isTexture3DNode=!0}getInputType(){return"texture3D"}getDefaultUV(){return vec3(.5,.5,.5)}setUpdateMatrix(){}generateUV(builder,uvNode){return uvNode.build(builder,!0===this.sampler?"vec3":"ivec3")}generateOffset(builder,offsetNode){return offsetNode.build(builder,"ivec3")}normal(uvNode){return normal({texture:this,uv:uvNode})}}const texture3D=/*@__PURE__*/nodeProxy(Texture3DNode).setParameterLength(1,3);Fn(([source,steps])=>source.mul(steps).floor().div(steps));const _size=/*@__PURE__*/new Vector2;class PassTextureNode extends TextureNode{static get type(){return"PassTextureNode"}constructor(passNode,texture){super(texture),this.passNode=passNode,this.setUpdateMatrix(!1)}setup(builder){return this.passNode.build(builder),super.setup(builder)}clone(){return new this.constructor(this.passNode,this.value)}}class PassMultipleTextureNode extends PassTextureNode{static get type(){return"PassMultipleTextureNode"}constructor(passNode,textureName,previousTexture=!1){super(passNode,null),this.textureName=textureName,this.previousTexture=previousTexture}updateTexture(){this.value=this.previousTexture?this.passNode.getPreviousTexture(this.textureName):this.passNode.getTexture(this.textureName)}setup(builder){return this.updateTexture(),super.setup(builder)}clone(){const newNode=new this.constructor(this.passNode,this.textureName,this.previousTexture);return newNode.uvNode=this.uvNode,newNode.levelNode=this.levelNode,newNode.biasNode=this.biasNode,newNode.sampler=this.sampler,newNode.depthNode=this.depthNode,newNode.compareNode=this.compareNode,newNode.gradNode=this.gradNode,newNode.offsetNode=this.offsetNode,newNode}}class PassNode extends TempNode{static get type(){return"PassNode"}constructor(scope,scene,camera,options={}){super("vec4"),this.scope=scope,this.scene=scene,this.camera=camera,this.options=options,this._pixelRatio=1,this._width=1,this._height=1;const depthTexture=new DepthTexture;depthTexture.isRenderTargetTexture=!0,depthTexture.name="depth";const renderTarget=new RenderTarget(this._width*this._pixelRatio,this._height*this._pixelRatio,{type:HalfFloatType,...options});renderTarget.texture.name="output",renderTarget.depthTexture=depthTexture,this.renderTarget=renderTarget,this.overrideMaterial=null,this.transparent=!0,this.opaque=!0,this.contextNode=null,this._contextNodeCache=null,this._textures={output:renderTarget.texture,depth:depthTexture},this._textureNodes={},this._linearDepthNodes={},this._viewZNodes={},this._previousTextures={},this._previousTextureNodes={},this._cameraNear=uniform(0),this._cameraFar=uniform(0),this._mrt=null,this._layers=null,this._resolutionScale=1,this._viewport=null,this._scissor=null,this.isPassNode=!0,this.updateBeforeType=NodeUpdateType_FRAME,this.global=!0}setResolutionScale(resolutionScale){return this._resolutionScale=resolutionScale,this}getResolutionScale(){return this._resolutionScale}setResolution(resolution){return warn("PassNode: .setResolution() is deprecated. Use .setResolutionScale() instead."),this.setResolutionScale(resolution)}getResolution(){return warn("PassNode: .getResolution() is deprecated. Use .getResolutionScale() instead."),this.getResolutionScale()}setLayers(layers){return this._layers=layers,this}getLayers(){return this._layers}setMRT(mrt){return this._mrt=mrt,this}getMRT(){return this._mrt}getTexture(name){let texture=this._textures[name];if(void 0===texture){texture=this.renderTarget.texture.clone(),texture.name=name,this._textures[name]=texture,this.renderTarget.textures.push(texture)}return texture}getPreviousTexture(name){let texture=this._previousTextures[name];return void 0===texture&&(texture=this.getTexture(name).clone(),this._previousTextures[name]=texture),texture}toggleTexture(name){const prevTexture=this._previousTextures[name];if(void 0!==prevTexture){const texture=this._textures[name],index=this.renderTarget.textures.indexOf(texture);this.renderTarget.textures[index]=prevTexture,this._textures[name]=prevTexture,this._previousTextures[name]=texture,this._textureNodes[name].updateTexture(),this._previousTextureNodes[name].updateTexture()}}getTextureNode(name="output"){let textureNode=this._textureNodes[name];return void 0===textureNode&&(textureNode=new PassMultipleTextureNode(this,name),textureNode.updateTexture(),this._textureNodes[name]=textureNode),textureNode}getPreviousTextureNode(name="output"){let textureNode=this._previousTextureNodes[name];return void 0===textureNode&&(void 0===this._textureNodes[name]&&this.getTextureNode(name),textureNode=new PassMultipleTextureNode(this,name,!0),textureNode.updateTexture(),this._previousTextureNodes[name]=textureNode),textureNode}getViewZNode(name="depth"){let viewZNode=this._viewZNodes[name];if(void 0===viewZNode){const cameraNear=this._cameraNear,cameraFar=this._cameraFar;this._viewZNodes[name]=viewZNode=perspectiveDepthToViewZ(this.getTextureNode(name),cameraNear,cameraFar)}return viewZNode}getLinearDepthNode(name="depth"){let linearDepthNode=this._linearDepthNodes[name];if(void 0===linearDepthNode){const cameraNear=this._cameraNear,cameraFar=this._cameraFar,viewZNode=this.getViewZNode(name);this._linearDepthNodes[name]=linearDepthNode=viewZToOrthographicDepth(viewZNode,cameraNear,cameraFar)}return linearDepthNode}async compileAsync(renderer){const currentRenderTarget=renderer.getRenderTarget(),currentMRT=renderer.getMRT();renderer.setRenderTarget(this.renderTarget),renderer.setMRT(this._mrt),await renderer.compileAsync(this.scene,this.camera),renderer.setRenderTarget(currentRenderTarget),renderer.setMRT(currentMRT)}setup({renderer:renderer}){return this.renderTarget.samples=void 0===this.options.samples?renderer.samples:this.options.samples,this.renderTarget.texture.type=renderer.getOutputBufferType(),this.scope===PassNode.COLOR?this.getTextureNode():this.getLinearDepthNode()}updateBefore(frame){const{renderer:renderer}=frame,{scene:scene}=this;let camera,pixelRatio;const outputRenderTarget=renderer.getOutputRenderTarget();outputRenderTarget&&!0===outputRenderTarget.isXRRenderTarget?(pixelRatio=1,camera=renderer.xr.getCamera(),renderer.xr.updateCamera(camera),_size.set(outputRenderTarget.width,outputRenderTarget.height)):(camera=this.camera,pixelRatio=renderer.getPixelRatio(),renderer.getSize(_size)),this._pixelRatio=pixelRatio,this.setSize(_size.width,_size.height);const currentRenderTarget=renderer.getRenderTarget(),currentMRT=renderer.getMRT(),currentAutoClear=renderer.autoClear,currentTransparent=renderer.transparent,currentOpaque=renderer.opaque,currentMask=camera.layers.mask,currentContextNode=renderer.contextNode,currentOverrideMaterial=scene.overrideMaterial;this._cameraNear.value=camera.near,this._cameraFar.value=camera.far,null!==this._layers&&(camera.layers.mask=this._layers.mask);for(const name in this._previousTextures)this.toggleTexture(name);null!==this.overrideMaterial&&(scene.overrideMaterial=this.overrideMaterial),renderer.setRenderTarget(this.renderTarget),renderer.setMRT(this._mrt),renderer.autoClear=!0,renderer.transparent=this.transparent,renderer.opaque=this.opaque,null!==this.contextNode&&(null!==this._contextNodeCache&&this._contextNodeCache.version===this.version||(this._contextNodeCache={version:this.version,context:context({...renderer.contextNode.getFlowContextData(),...this.contextNode.getFlowContextData()})}),renderer.contextNode=this._contextNodeCache.context);const currentSceneName=scene.name;scene.name=this.name?this.name:scene.name,renderer.render(scene,camera),scene.name=currentSceneName,scene.overrideMaterial=currentOverrideMaterial,renderer.setRenderTarget(currentRenderTarget),renderer.setMRT(currentMRT),renderer.autoClear=currentAutoClear,renderer.transparent=currentTransparent,renderer.opaque=currentOpaque,renderer.contextNode=currentContextNode,camera.layers.mask=currentMask}setSize(width,height){this._width=width,this._height=height;const effectiveWidth=Math.floor(this._width*this._pixelRatio*this._resolutionScale),effectiveHeight=Math.floor(this._height*this._pixelRatio*this._resolutionScale);this.renderTarget.setSize(effectiveWidth,effectiveHeight),null!==this._scissor&&this.renderTarget.scissor.copy(this._scissor),null!==this._viewport&&this.renderTarget.viewport.copy(this._viewport)}setScissor(x,y,width,height){null===x?this._scissor=null:(null===this._scissor&&(this._scissor=new Vector4),x.isVector4?this._scissor.copy(x):this._scissor.set(x,y,width,height),this._scissor.multiplyScalar(this._pixelRatio*this._resolutionScale).floor())}setViewport(x,y,width,height){null===x?this._viewport=null:(null===this._viewport&&(this._viewport=new Vector4),x.isVector4?this._viewport.copy(x):this._viewport.set(x,y,width,height),this._viewport.multiplyScalar(this._pixelRatio*this._resolutionScale).floor())}setPixelRatio(pixelRatio){this._pixelRatio=pixelRatio,this.setSize(this._width,this._height)}dispose(){this.renderTarget.dispose()}}PassNode.COLOR="color",PassNode.DEPTH="depth";const linearToneMapping=/*@__PURE__*/Fn(([color,exposure])=>color.mul(exposure).clamp()).setLayout({name:"linearToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),reinhardToneMapping=/*@__PURE__*/Fn(([color,exposure])=>(color=color.mul(exposure)).div(color.add(1)).clamp()).setLayout({name:"reinhardToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),cineonToneMapping=/*@__PURE__*/Fn(([color,exposure])=>{const a=(color=(color=color.mul(exposure)).sub(.004).max(0)).mul(color.mul(6.2).add(.5)),b=color.mul(color.mul(6.2).add(1.7)).add(.06);return a.div(b).pow(2.2)}).setLayout({name:"cineonToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),RRTAndODTFit=/*@__PURE__*/Fn(([color])=>{const a=color.mul(color.add(.0245786)).sub(90537e-9),b=color.mul(color.add(.432951).mul(.983729)).add(.238081);return a.div(b)}),acesFilmicToneMapping=/*@__PURE__*/Fn(([color,exposure])=>{const ACESInputMat=mat3(.59719,.35458,.04823,.076,.90834,.01566,.0284,.13383,.83777),ACESOutputMat=mat3(1.60475,-.53108,-.07367,-.10208,1.10813,-.00605,-.00327,-.07276,1.07602);return color=color.mul(exposure).div(.6),color=ACESInputMat.mul(color),color=RRTAndODTFit(color),(color=ACESOutputMat.mul(color)).clamp()}).setLayout({name:"acesFilmicToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),LINEAR_REC2020_TO_LINEAR_SRGB=/*@__PURE__*/mat3(vec3(1.6605,-.1246,-.0182),vec3(-.5876,1.1329,-.1006),vec3(-.0728,-.0083,1.1187)),LINEAR_SRGB_TO_LINEAR_REC2020=/*@__PURE__*/mat3(vec3(.6274,.0691,.0164),vec3(.3293,.9195,.088),vec3(.0433,.0113,.8956)),agxDefaultContrastApprox=/*@__PURE__*/Fn(([x_immutable])=>{const x=vec3(x_immutable).toVar(),x2=vec3(x.mul(x)).toVar(),x4=vec3(x2.mul(x2)).toVar();return float(15.5).mul(x4.mul(x2)).sub(mul(40.14,x4.mul(x))).add(mul(31.96,x4).sub(mul(6.868,x2.mul(x))).add(mul(.4298,x2).add(mul(.1191,x).sub(.00232))))}),agxToneMapping=/*@__PURE__*/Fn(([color,exposure])=>{const colortone=vec3(color).toVar(),AgXInsetMatrix=mat3(vec3(.856627153315983,.137318972929847,.11189821299995),vec3(.0951212405381588,.761241990602591,.0767994186031903),vec3(.0482516061458583,.101439036467562,.811302368396859)),AgXOutsetMatrix=mat3(vec3(1.1271005818144368,-.1413297634984383,-.14132976349843826),vec3(-.11060664309660323,1.157823702216272,-.11060664309660294),vec3(-.016493938717834573,-.016493938717834257,1.2519364065950405)),AgxMinEv=float(-12.47393),AgxMaxEv=float(4.026069);return colortone.mulAssign(exposure),colortone.assign(LINEAR_SRGB_TO_LINEAR_REC2020.mul(colortone)),colortone.assign(AgXInsetMatrix.mul(colortone)),colortone.assign(max$1(colortone,1e-10)),colortone.assign(log2(colortone)),colortone.assign(colortone.sub(AgxMinEv).div(AgxMaxEv.sub(AgxMinEv))),colortone.assign(clamp$2(colortone,0,1)),colortone.assign(agxDefaultContrastApprox(colortone)),colortone.assign(AgXOutsetMatrix.mul(colortone)),colortone.assign(pow(max$1(vec3(0),colortone),vec3(2.2))),colortone.assign(LINEAR_REC2020_TO_LINEAR_SRGB.mul(colortone)),colortone.assign(clamp$2(colortone,0,1)),colortone}).setLayout({name:"agxToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]}),neutralToneMapping=/*@__PURE__*/Fn(([color,exposure])=>{const StartCompression=float(.76),Desaturation=float(.15);color=color.mul(exposure);const x=min$1(color.r,min$1(color.g,color.b)),offset=select(x.lessThan(.08),x.sub(mul(6.25,x.mul(x))),.04);color.subAssign(offset);const peak=max$1(color.r,max$1(color.g,color.b));If(peak.lessThan(StartCompression),()=>color);const d=sub(1,StartCompression),newPeak=sub(1,d.mul(d).div(peak.add(d.sub(StartCompression))));color.mulAssign(newPeak.div(peak));const g=sub(1,div(1,Desaturation.mul(peak.sub(newPeak)).add(1)));return mix(color,vec3(newPeak),g)}).setLayout({name:"neutralToneMapping",type:"vec3",inputs:[{name:"color",type:"vec3"},{name:"exposure",type:"float"}]});class CodeNode extends Node$1{static get type(){return"CodeNode"}constructor(code="",includes=[],language=""){super("code"),this.isCodeNode=!0,this.global=!0,this.code=code,this.includes=includes,this.language=language}setIncludes(includes){return this.includes=includes,this}getIncludes(){return this.includes}generate(builder){const includes=this.getIncludes(builder);for(const include of includes)include.build(builder);const nodeCode=builder.getCodeFromNode(this,this.getNodeType(builder));return nodeCode.code=this.code,nodeCode.code}serialize(data){super.serialize(data),data.code=this.code,data.language=this.language}deserialize(data){super.deserialize(data),this.code=data.code,this.language=data.language}}class FunctionNode extends CodeNode{static get type(){return"FunctionNode"}constructor(code="",includes=[],language=""){super(code,includes,language)}getNodeType(builder){return this.getNodeFunction(builder).type}getMemberType(builder,name){const type=this.getNodeType(builder);return builder.getStructTypeNode(type).getMemberType(builder,name)}getInputs(builder){return this.getNodeFunction(builder).inputs}getNodeFunction(builder){const nodeData=builder.getDataFromNode(this);let nodeFunction=nodeData.nodeFunction;return void 0===nodeFunction&&(nodeFunction=builder.parser.parseFunction(this.code),nodeData.nodeFunction=nodeFunction),nodeFunction}generate(builder,output){super.generate(builder);const nodeFunction=this.getNodeFunction(builder),name=nodeFunction.name,type=nodeFunction.type,nodeCode=builder.getCodeFromNode(this,type);""!==name&&(nodeCode.name=name);const propertyName=builder.getPropertyName(nodeCode),code=this.getNodeFunction(builder).getCode(propertyName);return nodeCode.code=code+"\n","property"===output?propertyName:builder.format(`${propertyName}()`,type,output)}}function getViewZNode(builder){let viewZ;const getViewZ=builder.context.getViewZ;return void 0!==getViewZ&&(viewZ=getViewZ(this)),(viewZ||positionView.z).negate()}const rangeFogFactor=Fn(([near,far],builder)=>{const viewZ=getViewZNode(builder);return smoothstep(near,far,viewZ)}),densityFogFactor=Fn(([density],builder)=>{const viewZ=getViewZNode(builder);return density.mul(density,viewZ,viewZ).negate().exp().oneMinus()});Fn(([density,height],builder)=>{const viewZ=getViewZNode(builder),m=height.sub(positionWorld.y).max(0).toConst().mul(viewZ).toConst();return density.mul(density,m,m).negate().exp().oneMinus()});const fog=Fn(([color,factor])=>vec4(factor.toFloat().mix(output.rgb,color.toVec3()),output.a));nodeProxy(class BarrierNode extends Node$1{constructor(scope){super(),this.scope=scope}generate(builder){const{scope:scope}=this,{renderer:renderer}=builder;!0===renderer.backend.isWebGLBackend?builder.addFlowCode(`\t// ${scope}Barrier \n`):builder.addLineFlowCode(`${scope}Barrier()`,this)}});class AtomicFunctionNode extends Node$1{static get type(){return"AtomicFunctionNode"}constructor(method,pointerNode,valueNode){super("uint"),this.method=method,this.pointerNode=pointerNode,this.valueNode=valueNode,this.parents=!0}getInputType(builder){return this.pointerNode.getNodeType(builder)}getNodeType(builder){return this.getInputType(builder)}generate(builder){const properties=builder.getNodeProperties(this),parents=properties.parents,method=this.method,type=this.getNodeType(builder),inputType=this.getInputType(builder),a=this.pointerNode,b=this.valueNode,params=[];params.push(`&${a.build(builder,inputType)}`),null!==b&&params.push(b.build(builder,inputType));const methodSnippet=`${builder.getMethod(method,type)}( ${params.join(", ")} )`;if(!(!!parents&&(1===parents.length&&!0===parents[0].isStackNode)))return void 0===properties.constNode&&(properties.constNode=expression(methodSnippet,type).toConst()),properties.constNode.build(builder);builder.addLineFlowCode(methodSnippet,this)}}AtomicFunctionNode.ATOMIC_LOAD="atomicLoad",AtomicFunctionNode.ATOMIC_STORE="atomicStore",AtomicFunctionNode.ATOMIC_ADD="atomicAdd",AtomicFunctionNode.ATOMIC_SUB="atomicSub",AtomicFunctionNode.ATOMIC_MAX="atomicMax",AtomicFunctionNode.ATOMIC_MIN="atomicMin",AtomicFunctionNode.ATOMIC_AND="atomicAnd",AtomicFunctionNode.ATOMIC_OR="atomicOr",AtomicFunctionNode.ATOMIC_XOR="atomicXor",nodeProxy(AtomicFunctionNode);class SubgroupFunctionNode extends TempNode{static get type(){return"SubgroupFunctionNode"}constructor(method,aNode=null,bNode=null){super(),this.method=method,this.aNode=aNode,this.bNode=bNode}getInputType(builder){const aType=this.aNode?this.aNode.getNodeType(builder):null,bType=this.bNode?this.bNode.getNodeType(builder):null;return(builder.isMatrix(aType)?0:builder.getTypeLength(aType))>(builder.isMatrix(bType)?0:builder.getTypeLength(bType))?aType:bType}getNodeType(builder){const method=this.method;return method===SubgroupFunctionNode.SUBGROUP_ELECT?"bool":method===SubgroupFunctionNode.SUBGROUP_BALLOT?"uvec4":this.getInputType(builder)}generate(builder,output){const method=this.method,type=this.getNodeType(builder),inputType=this.getInputType(builder),a=this.aNode,b=this.bNode,params=[];if(method===SubgroupFunctionNode.SUBGROUP_BROADCAST||method===SubgroupFunctionNode.SUBGROUP_SHUFFLE||method===SubgroupFunctionNode.QUAD_BROADCAST){const bType=b.getNodeType(builder);params.push(a.build(builder,type),b.build(builder,"float"===bType?"int":type))}else method===SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR||method===SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN||method===SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP?params.push(a.build(builder,type),b.build(builder,"uint")):(null!==a&&params.push(a.build(builder,inputType)),null!==b&&params.push(b.build(builder,inputType)));const paramsString=0===params.length?"()":`( ${params.join(", ")} )`;return builder.format(`${builder.getMethod(method,type)}${paramsString}`,type,output)}serialize(data){super.serialize(data),data.method=this.method}deserialize(data){super.deserialize(data),this.method=data.method}}let uniformsLib;function getLightData(light){uniformsLib=uniformsLib||new WeakMap;let uniforms=uniformsLib.get(light);return void 0===uniforms&&uniformsLib.set(light,uniforms={}),uniforms}function lightShadowMatrix(light){const data=getLightData(light);return data.shadowMatrix||(data.shadowMatrix=uniform("mat4").setGroup(renderGroup).onRenderUpdate(frame=>(!0===light.castShadow&&!1!==frame.renderer.shadowMap.enabled||(light.shadow.camera.coordinateSystem!==frame.camera.coordinateSystem&&(light.shadow.camera.coordinateSystem=frame.camera.coordinateSystem,light.shadow.camera.updateProjectionMatrix()),light.shadow.updateMatrices(light)),light.shadow.matrix)))}function lightPosition(light){const data=getLightData(light);return data.position||(data.position=uniform(new Vector3).setGroup(renderGroup).onRenderUpdate((_,self)=>self.value.setFromMatrixPosition(light.matrixWorld)))}function lightViewPosition(light){const data=getLightData(light);return data.viewPosition||(data.viewPosition=uniform(new Vector3).setGroup(renderGroup).onRenderUpdate(({camera:camera},self)=>{self.value=self.value||new Vector3,self.value.setFromMatrixPosition(light.matrixWorld),self.value.applyMatrix4(camera.matrixWorldInverse)}))}SubgroupFunctionNode.SUBGROUP_ELECT="subgroupElect",SubgroupFunctionNode.SUBGROUP_BALLOT="subgroupBallot",SubgroupFunctionNode.SUBGROUP_ADD="subgroupAdd",SubgroupFunctionNode.SUBGROUP_INCLUSIVE_ADD="subgroupInclusiveAdd",SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_AND="subgroupExclusiveAdd",SubgroupFunctionNode.SUBGROUP_MUL="subgroupMul",SubgroupFunctionNode.SUBGROUP_INCLUSIVE_MUL="subgroupInclusiveMul",SubgroupFunctionNode.SUBGROUP_EXCLUSIVE_MUL="subgroupExclusiveMul",SubgroupFunctionNode.SUBGROUP_AND="subgroupAnd",SubgroupFunctionNode.SUBGROUP_OR="subgroupOr",SubgroupFunctionNode.SUBGROUP_XOR="subgroupXor",SubgroupFunctionNode.SUBGROUP_MIN="subgroupMin",SubgroupFunctionNode.SUBGROUP_MAX="subgroupMax",SubgroupFunctionNode.SUBGROUP_ALL="subgroupAll",SubgroupFunctionNode.SUBGROUP_ANY="subgroupAny",SubgroupFunctionNode.SUBGROUP_BROADCAST_FIRST="subgroupBroadcastFirst",SubgroupFunctionNode.QUAD_SWAP_X="quadSwapX",SubgroupFunctionNode.QUAD_SWAP_Y="quadSwapY",SubgroupFunctionNode.QUAD_SWAP_DIAGONAL="quadSwapDiagonal",SubgroupFunctionNode.SUBGROUP_BROADCAST="subgroupBroadcast",SubgroupFunctionNode.SUBGROUP_SHUFFLE="subgroupShuffle",SubgroupFunctionNode.SUBGROUP_SHUFFLE_XOR="subgroupShuffleXor",SubgroupFunctionNode.SUBGROUP_SHUFFLE_UP="subgroupShuffleUp",SubgroupFunctionNode.SUBGROUP_SHUFFLE_DOWN="subgroupShuffleDown",SubgroupFunctionNode.QUAD_BROADCAST="quadBroadcast";const lightTargetDirection=light=>cameraViewMatrix.transformDirection(lightPosition(light).sub(function lightTargetPosition(light){const data=getLightData(light);return data.targetPosition||(data.targetPosition=uniform(new Vector3).setGroup(renderGroup).onRenderUpdate((_,self)=>self.value.setFromMatrixPosition(light.target.matrixWorld)))}(light))),getLightNodeById=(id,lightNodes)=>{for(const lightNode of lightNodes)if(lightNode.isAnalyticLightNode&&lightNode.light.id===id)return lightNode;return null},_lightsNodeRef=/*@__PURE__*/new WeakMap,_hashData=[];class LightsNode extends Node$1{static get type(){return"LightsNode"}constructor(){super("vec3"),this.totalDiffuseNode=property("vec3","totalDiffuse"),this.totalSpecularNode=property("vec3","totalSpecular"),this.outgoingLightNode=property("vec3","outgoingLight"),this._lights=[],this._lightNodes=null,this._lightNodesHash=null,this.global=!0}customCacheKey(){const lights=this._lights;for(let i=0;i<lights.length;i++){const light=lights[i];if(_hashData.push(light.id),_hashData.push(light.castShadow?1:0),!0===light.isSpotLight){const hashMap=null!==light.map?light.map.id:-1,hashColorNode=light.colorNode?light.colorNode.getCacheKey():-1;_hashData.push(hashMap,hashColorNode)}}const cacheKey=hashArray(_hashData);return _hashData.length=0,cacheKey}getHash(builder){if(null===this._lightNodesHash){null===this._lightNodes&&this.setupLightsNode(builder);const hash=[];for(const lightNode of this._lightNodes)hash.push(lightNode.getHash());this._lightNodesHash="lights-"+hash.join(",")}return this._lightNodesHash}analyze(builder){const properties=builder.getNodeProperties(this);for(const node of properties.nodes)node.build(builder);properties.outputNode.build(builder)}setupLightsNode(builder){const lightNodes=[],previousLightNodes=this._lightNodes,lights=(lights=>lights.sort((a,b)=>a.id-b.id))(this._lights),nodeLibrary=builder.renderer.library;for(const light of lights)if(light.isNode)lightNodes.push(nodeObject(light));else{let lightNode=null;if(null!==previousLightNodes&&(lightNode=getLightNodeById(light.id,previousLightNodes)),null===lightNode){const lightNodeClass=nodeLibrary.getLightNodeClass(light.constructor);if(null===lightNodeClass){warn(`LightsNode.setupNodeLights: Light node not found for ${light.constructor.name}`);continue}let lightNode=null;_lightsNodeRef.has(light)?lightNode=_lightsNodeRef.get(light):(lightNode=new lightNodeClass(light),_lightsNodeRef.set(light,lightNode)),lightNodes.push(lightNode)}}this._lightNodes=lightNodes}setupDirectLight(builder,lightNode,lightData){const{lightingModel:lightingModel,reflectedLight:reflectedLight}=builder.context;lightingModel.direct({...lightData,lightNode:lightNode,reflectedLight:reflectedLight},builder)}setupDirectRectAreaLight(builder,lightNode,lightData){const{lightingModel:lightingModel,reflectedLight:reflectedLight}=builder.context;lightingModel.directRectArea({...lightData,lightNode:lightNode,reflectedLight:reflectedLight},builder)}setupLights(builder,lightNodes){for(const lightNode of lightNodes)lightNode.build(builder)}getLightNodes(builder){return null===this._lightNodes&&this.setupLightsNode(builder),this._lightNodes}setup(builder){const currentLightsNode=builder.lightsNode;builder.lightsNode=this;let outgoingLightNode=this.outgoingLightNode;const context=builder.context,lightingModel=context.lightingModel,properties=builder.getNodeProperties(this);if(lightingModel){const{totalDiffuseNode:totalDiffuseNode,totalSpecularNode:totalSpecularNode}=this;context.outgoingLight=outgoingLightNode;const stack=builder.addStack();properties.nodes=stack.nodes,lightingModel.start(builder);const{backdrop:backdrop,backdropAlpha:backdropAlpha}=context,{directDiffuse:directDiffuse,directSpecular:directSpecular,indirectDiffuse:indirectDiffuse,indirectSpecular:indirectSpecular}=context.reflectedLight;let totalDiffuse=directDiffuse.add(indirectDiffuse);null!==backdrop&&(totalDiffuse=vec3(null!==backdropAlpha?backdropAlpha.mix(totalDiffuse,backdrop):backdrop)),totalDiffuseNode.assign(totalDiffuse),totalSpecularNode.assign(directSpecular.add(indirectSpecular)),outgoingLightNode.assign(totalDiffuseNode.add(totalSpecularNode)),lightingModel.finish(builder),outgoingLightNode=outgoingLightNode.bypass(builder.removeStack())}else properties.nodes=[];return builder.lightsNode=currentLightsNode,outgoingLightNode}setLights(lights){return this._lights=lights,this._lightNodes=null,this._lightNodesHash=null,this}getLights(){return this._lights}get hasLights(){return this._lights.length>0}}class ShadowBaseNode extends Node$1{static get type(){return"ShadowBaseNode"}constructor(light){super(),this.light=light,this.updateBeforeType=NodeUpdateType_RENDER,this.isShadowBaseNode=!0}setupShadowPosition({context:context,material:material}){shadowPositionWorld.assign(material.receivedShadowPositionNode||context.shadowPositionWorld||positionWorld)}}const shadowPositionWorld=/*@__PURE__*/property("vec3","shadowPositionWorld");function resetRendererState(renderer,state){return state=function saveRendererState(renderer,state={}){return state.toneMapping=renderer.toneMapping,state.toneMappingExposure=renderer.toneMappingExposure,state.outputColorSpace=renderer.outputColorSpace,state.renderTarget=renderer.getRenderTarget(),state.activeCubeFace=renderer.getActiveCubeFace(),state.activeMipmapLevel=renderer.getActiveMipmapLevel(),state.renderObjectFunction=renderer.getRenderObjectFunction(),state.pixelRatio=renderer.getPixelRatio(),state.mrt=renderer.getMRT(),state.clearColor=renderer.getClearColor(state.clearColor||new Color),state.clearAlpha=renderer.getClearAlpha(),state.autoClear=renderer.autoClear,state.scissorTest=renderer.getScissorTest(),state}(renderer,state),renderer.setMRT(null),renderer.setRenderObjectFunction(null),renderer.setClearColor(0,1),renderer.autoClear=!0,state}const shadowMaterialLib=/*@__PURE__*/new WeakMap,BasicShadowFilter=/*@__PURE__*/Fn(({depthTexture:depthTexture,shadowCoord:shadowCoord,depthLayer:depthLayer})=>{let basic=texture(depthTexture,shadowCoord.xy).setName("t_basic");return depthTexture.isArrayTexture&&(basic=basic.depth(depthLayer)),basic.compare(shadowCoord.z)}),PCFShadowFilter=/*@__PURE__*/Fn(({depthTexture:depthTexture,shadowCoord:shadowCoord,shadow:shadow,depthLayer:depthLayer})=>{const depthCompare=(uv,compare)=>{let depth=texture(depthTexture,uv);return depthTexture.isArrayTexture&&(depth=depth.depth(depthLayer)),depth.compare(compare)},mapSize=reference("mapSize","vec2",shadow).setGroup(renderGroup),radius=reference("radius","float",shadow).setGroup(renderGroup),texelSize=vec2(1).div(mapSize),radiusScaled=radius.mul(texelSize.x),phi=interleavedGradientNoise(screenCoordinate.xy).mul(6.28318530718);return add(depthCompare(shadowCoord.xy.add(vogelDiskSample(0,5,phi).mul(radiusScaled)),shadowCoord.z),depthCompare(shadowCoord.xy.add(vogelDiskSample(1,5,phi).mul(radiusScaled)),shadowCoord.z),depthCompare(shadowCoord.xy.add(vogelDiskSample(2,5,phi).mul(radiusScaled)),shadowCoord.z),depthCompare(shadowCoord.xy.add(vogelDiskSample(3,5,phi).mul(radiusScaled)),shadowCoord.z),depthCompare(shadowCoord.xy.add(vogelDiskSample(4,5,phi).mul(radiusScaled)),shadowCoord.z)).mul(.2)}),PCFSoftShadowFilter=/*@__PURE__*/Fn(({depthTexture:depthTexture,shadowCoord:shadowCoord,shadow:shadow,depthLayer:depthLayer})=>{const depthCompare=(uv,compare)=>{let depth=texture(depthTexture,uv);return depthTexture.isArrayTexture&&(depth=depth.depth(depthLayer)),depth.compare(compare)},mapSize=reference("mapSize","vec2",shadow).setGroup(renderGroup),texelSize=vec2(1).div(mapSize),dx=texelSize.x,dy=texelSize.y,uv=shadowCoord.xy,f=fract(uv.mul(mapSize).add(.5));return uv.subAssign(f.mul(texelSize)),add(depthCompare(uv,shadowCoord.z),depthCompare(uv.add(vec2(dx,0)),shadowCoord.z),depthCompare(uv.add(vec2(0,dy)),shadowCoord.z),depthCompare(uv.add(texelSize),shadowCoord.z),mix(depthCompare(uv.add(vec2(dx.negate(),0)),shadowCoord.z),depthCompare(uv.add(vec2(dx.mul(2),0)),shadowCoord.z),f.x),mix(depthCompare(uv.add(vec2(dx.negate(),dy)),shadowCoord.z),depthCompare(uv.add(vec2(dx.mul(2),dy)),shadowCoord.z),f.x),mix(depthCompare(uv.add(vec2(0,dy.negate())),shadowCoord.z),depthCompare(uv.add(vec2(0,dy.mul(2))),shadowCoord.z),f.y),mix(depthCompare(uv.add(vec2(dx,dy.negate())),shadowCoord.z),depthCompare(uv.add(vec2(dx,dy.mul(2))),shadowCoord.z),f.y),mix(mix(depthCompare(uv.add(vec2(dx.negate(),dy.negate())),shadowCoord.z),depthCompare(uv.add(vec2(dx.mul(2),dy.negate())),shadowCoord.z),f.x),mix(depthCompare(uv.add(vec2(dx.negate(),dy.mul(2))),shadowCoord.z),depthCompare(uv.add(vec2(dx.mul(2),dy.mul(2))),shadowCoord.z),f.x),f.y)).mul(1/9)}),VSMShadowFilter=/*@__PURE__*/Fn(({depthTexture:depthTexture,shadowCoord:shadowCoord,depthLayer:depthLayer})=>{let distribution=texture(depthTexture).sample(shadowCoord.xy);depthTexture.isArrayTexture&&(distribution=distribution.depth(depthLayer)),distribution=distribution.rg;const mean=distribution.x,variance=max$1(1e-7,distribution.y.mul(distribution.y)),hardShadow=step(shadowCoord.z,mean),output=float(1).toVar();return If(hardShadow.notEqual(1),()=>{const d=shadowCoord.z.sub(mean);let p_max=variance.div(variance.add(d.mul(d)));p_max=clamp$2(sub(p_max,.3).div(.65)),output.assign(max$1(hardShadow,p_max))}),output}),_shadowRenderObjectLibrary=/*@__PURE__*/new ChainMap,_shadowRenderObjectKeys=[],VSMPassVertical=/*@__PURE__*/Fn(({samples:samples,radius:radius,size:size,shadowPass:shadowPass,depthLayer:depthLayer})=>{const mean=float(0).toVar("meanVertical"),squaredMean=float(0).toVar("squareMeanVertical"),uvStride=samples.lessThanEqual(float(1)).select(float(0),float(2).div(samples.sub(1))),uvStart=samples.lessThanEqual(float(1)).select(float(0),float(-1));Loop({start:int(0),end:int(samples),type:"int",condition:"<"},({i:i})=>{const uvOffset=uvStart.add(float(i).mul(uvStride));let depth=shadowPass.sample(add(screenCoordinate.xy,vec2(0,uvOffset).mul(radius)).div(size));shadowPass.value.isArrayTexture&&(depth=depth.depth(depthLayer)),depth=depth.x,mean.addAssign(depth),squaredMean.addAssign(depth.mul(depth))}),mean.divAssign(samples),squaredMean.divAssign(samples);const std_dev=sqrt(squaredMean.sub(mean.mul(mean)).max(0));return vec2(mean,std_dev)}),VSMPassHorizontal=/*@__PURE__*/Fn(({samples:samples,radius:radius,size:size,shadowPass:shadowPass,depthLayer:depthLayer})=>{const mean=float(0).toVar("meanHorizontal"),squaredMean=float(0).toVar("squareMeanHorizontal"),uvStride=samples.lessThanEqual(float(1)).select(float(0),float(2).div(samples.sub(1))),uvStart=samples.lessThanEqual(float(1)).select(float(0),float(-1));Loop({start:int(0),end:int(samples),type:"int",condition:"<"},({i:i})=>{const uvOffset=uvStart.add(float(i).mul(uvStride));let distribution=shadowPass.sample(add(screenCoordinate.xy,vec2(uvOffset,0).mul(radius)).div(size));shadowPass.value.isArrayTexture&&(distribution=distribution.depth(depthLayer)),mean.addAssign(distribution.x),squaredMean.addAssign(add(distribution.y.mul(distribution.y),distribution.x.mul(distribution.x)))}),mean.divAssign(samples),squaredMean.divAssign(samples);const std_dev=sqrt(squaredMean.sub(mean.mul(mean)).max(0));return vec2(mean,std_dev)}),_shadowFilterLib=[BasicShadowFilter,PCFShadowFilter,PCFSoftShadowFilter,VSMShadowFilter];let _rendererState;const _quadMesh=/*@__PURE__*/new QuadMesh;class ShadowNode extends ShadowBaseNode{static get type(){return"ShadowNode"}constructor(light,shadow=null){super(light),this.shadow=shadow||light.shadow,this.shadowMap=null,this.vsmShadowMapVertical=null,this.vsmShadowMapHorizontal=null,this.vsmMaterialVertical=null,this.vsmMaterialHorizontal=null,this._node=null,this._currentShadowType=null,this._cameraFrameId=new WeakMap,this.isShadowNode=!0,this.depthLayer=0}setupShadowFilter(builder,{filterFn:filterFn,depthTexture:depthTexture,shadowCoord:shadowCoord,shadow:shadow,depthLayer:depthLayer}){const frustumTest=shadowCoord.x.greaterThanEqual(0).and(shadowCoord.x.lessThanEqual(1)).and(shadowCoord.y.greaterThanEqual(0)).and(shadowCoord.y.lessThanEqual(1)).and(shadowCoord.z.lessThanEqual(1)),shadowNode=filterFn({depthTexture:depthTexture,shadowCoord:shadowCoord,shadow:shadow,depthLayer:depthLayer});return frustumTest.select(shadowNode,float(1))}setupShadowCoord(builder,shadowPosition){const{shadow:shadow}=this,{renderer:renderer}=builder,bias=shadow.biasNode||reference("bias","float",shadow).setGroup(renderGroup);let coordZ,shadowCoord=shadowPosition;if(shadow.camera.isOrthographicCamera||!0!==renderer.logarithmicDepthBuffer)shadowCoord=shadowCoord.xyz.div(shadowCoord.w),coordZ=shadowCoord.z,2001===renderer.coordinateSystem&&(coordZ=coordZ.mul(2).sub(1));else{const w=shadowCoord.w;shadowCoord=shadowCoord.xy.div(w);const cameraNearLocal=reference("near","float",shadow.camera).setGroup(renderGroup),cameraFarLocal=reference("far","float",shadow.camera).setGroup(renderGroup);coordZ=viewZToLogarithmicDepth(w.negate(),cameraNearLocal,cameraFarLocal)}return shadowCoord=vec3(shadowCoord.x,shadowCoord.y.oneMinus(),coordZ.add(bias)),shadowCoord}getShadowFilterFn(type){return _shadowFilterLib[type]}setupRenderTarget(shadow,builder){const depthTexture=new DepthTexture(shadow.mapSize.width,shadow.mapSize.height);depthTexture.name="ShadowDepthTexture",depthTexture.compareFunction=515;const shadowMap=builder.createRenderTarget(shadow.mapSize.width,shadow.mapSize.height);return shadowMap.texture.name="ShadowMap",shadowMap.texture.type=shadow.mapType,shadowMap.depthTexture=depthTexture,{shadowMap:shadowMap,depthTexture:depthTexture}}setupShadow(builder){const{renderer:renderer,camera:camera}=builder,{light:light,shadow:shadow}=this,{depthTexture:depthTexture,shadowMap:shadowMap}=this.setupRenderTarget(shadow,builder),shadowMapType=renderer.shadowMap.type;if(1===shadowMapType||2===shadowMapType?(depthTexture.minFilter=1006,depthTexture.magFilter=1006):(depthTexture.minFilter=1003,depthTexture.magFilter=1003),shadow.camera.coordinateSystem=camera.coordinateSystem,shadow.camera.updateProjectionMatrix(),3===shadowMapType&&!0!==shadow.isPointLightShadow){depthTexture.compareFunction=null,shadowMap.depth>1?(shadowMap._vsmShadowMapVertical||(shadowMap._vsmShadowMapVertical=builder.createRenderTarget(shadow.mapSize.width,shadow.mapSize.height,{format:1030,type:HalfFloatType,depth:shadowMap.depth,depthBuffer:!1}),shadowMap._vsmShadowMapVertical.texture.name="VSMVertical"),this.vsmShadowMapVertical=shadowMap._vsmShadowMapVertical,shadowMap._vsmShadowMapHorizontal||(shadowMap._vsmShadowMapHorizontal=builder.createRenderTarget(shadow.mapSize.width,shadow.mapSize.height,{format:1030,type:HalfFloatType,depth:shadowMap.depth,depthBuffer:!1}),shadowMap._vsmShadowMapHorizontal.texture.name="VSMHorizontal"),this.vsmShadowMapHorizontal=shadowMap._vsmShadowMapHorizontal):(this.vsmShadowMapVertical=builder.createRenderTarget(shadow.mapSize.width,shadow.mapSize.height,{format:1030,type:HalfFloatType,depthBuffer:!1}),this.vsmShadowMapHorizontal=builder.createRenderTarget(shadow.mapSize.width,shadow.mapSize.height,{format:1030,type:HalfFloatType,depthBuffer:!1}));let shadowPassVertical=texture(depthTexture);depthTexture.isArrayTexture&&(shadowPassVertical=shadowPassVertical.depth(this.depthLayer));let shadowPassHorizontal=texture(this.vsmShadowMapVertical.texture);depthTexture.isArrayTexture&&(shadowPassHorizontal=shadowPassHorizontal.depth(this.depthLayer));const samples=reference("blurSamples","float",shadow).setGroup(renderGroup),radius=reference("radius","float",shadow).setGroup(renderGroup),size=reference("mapSize","vec2",shadow).setGroup(renderGroup);let material=this.vsmMaterialVertical||(this.vsmMaterialVertical=new NodeMaterial);material.fragmentNode=VSMPassVertical({samples:samples,radius:radius,size:size,shadowPass:shadowPassVertical,depthLayer:this.depthLayer}).context(builder.getSharedContext()),material.name="VSMVertical",material=this.vsmMaterialHorizontal||(this.vsmMaterialHorizontal=new NodeMaterial),material.fragmentNode=VSMPassHorizontal({samples:samples,radius:radius,size:size,shadowPass:shadowPassHorizontal,depthLayer:this.depthLayer}).context(builder.getSharedContext()),material.name="VSMHorizontal"}const shadowIntensity=reference("intensity","float",shadow).setGroup(renderGroup),normalBias=reference("normalBias","float",shadow).setGroup(renderGroup),shadowPosition=lightShadowMatrix(light).mul(shadowPositionWorld.add(normalWorld.mul(normalBias))),shadowCoord=this.setupShadowCoord(builder,shadowPosition),filterFn=shadow.filterNode||this.getShadowFilterFn(renderer.shadowMap.type)||null;if(null===filterFn)throw new Error("THREE.WebGPURenderer: Shadow map type not supported yet.");const shadowDepthTexture=3===shadowMapType&&!0!==shadow.isPointLightShadow?this.vsmShadowMapHorizontal.texture:depthTexture,shadowNode=this.setupShadowFilter(builder,{filterFn:filterFn,shadowTexture:shadowMap.texture,depthTexture:shadowDepthTexture,shadowCoord:shadowCoord,shadow:shadow,depthLayer:this.depthLayer});let shadowColor,shadowOutput;!0===renderer.shadowMap.transmitted&&(shadowMap.texture.isCubeTexture?shadowColor=cubeTexture(shadowMap.texture,shadowCoord.xyz):(shadowColor=texture(shadowMap.texture,shadowCoord),depthTexture.isArrayTexture&&(shadowColor=shadowColor.depth(this.depthLayer)))),shadowOutput=shadowColor?mix(1,shadowNode.rgb.mix(shadowColor,1),shadowIntensity.mul(shadowColor.a)).toVar():mix(1,shadowNode,shadowIntensity).toVar(),this.shadowMap=shadowMap,this.shadow.map=shadowMap;const inspectName=`${this.light.type} Shadow [ ${this.light.name||"ID: "+this.light.id} ]`;return shadowColor&&shadowOutput.toInspector(`${inspectName} / Color`,()=>this.shadowMap.texture.isCubeTexture?cubeTexture(this.shadowMap.texture):texture(this.shadowMap.texture)),shadowOutput.toInspector(`${inspectName} / Depth`,()=>this.shadowMap.texture.isCubeTexture?cubeTexture(this.shadowMap.texture).r.oneMinus():textureLoad(this.shadowMap.depthTexture,uv$1().mul(textureSize(texture(this.shadowMap.depthTexture)))).r.oneMinus())}setup(builder){if(!1!==builder.renderer.shadowMap.enabled)return Fn(()=>{const currentShadowType=builder.renderer.shadowMap.type;this._currentShadowType!==currentShadowType&&(this._reset(),this._node=null);let node=this._node;return this.setupShadowPosition(builder),null===node&&(this._node=node=this.setupShadow(builder),this._currentShadowType=currentShadowType),builder.material.receivedShadowNode&&(node=builder.material.receivedShadowNode(node)),node})()}renderShadow(frame){const{shadow:shadow,shadowMap:shadowMap,light:light}=this,{renderer:renderer,scene:scene}=frame;shadow.updateMatrices(light),shadowMap.setSize(shadow.mapSize.width,shadow.mapSize.height,shadowMap.depth);const currentSceneName=scene.name;scene.name=`Shadow Map [ ${light.name||"ID: "+light.id} ]`,renderer.render(scene,shadow.camera),scene.name=currentSceneName}updateShadow(frame){const{shadowMap:shadowMap,light:light,shadow:shadow}=this,{renderer:renderer,scene:scene,camera:camera}=frame,shadowType=renderer.shadowMap.type,depthVersion=shadowMap.depthTexture.version;this._depthVersionCached=depthVersion;const _shadowCameraLayer=shadow.camera.layers.mask;4294967294&shadow.camera.layers.mask||(shadow.camera.layers.mask=camera.layers.mask);const currentRenderObjectFunction=renderer.getRenderObjectFunction(),currentMRT=renderer.getMRT(),useVelocity=!!currentMRT&&currentMRT.has("velocity");_rendererState=function resetRendererAndSceneState(renderer,scene,state){return state=function resetSceneState(scene,state){return state=function saveSceneState(scene,state={}){return state.background=scene.background,state.backgroundNode=scene.backgroundNode,state.overrideMaterial=scene.overrideMaterial,state}(scene,state),scene.background=null,scene.backgroundNode=null,scene.overrideMaterial=null,state}(scene,state=resetRendererState(renderer,state)),state}(renderer,scene,_rendererState),scene.overrideMaterial=(light=>{let material=shadowMaterialLib.get(light);return void 0===material&&(material=new NodeMaterial,material.colorNode=vec4(0,0,0,1),material.isShadowPassMaterial=!0,material.name="ShadowMaterial",material.blending=0,material.fog=!1,shadowMaterialLib.set(light,material)),material})(light),renderer.setRenderObjectFunction(((renderer,shadow,shadowType,useVelocity)=>{_shadowRenderObjectKeys[0]=renderer,_shadowRenderObjectKeys[1]=shadow;let renderObjectFunction=_shadowRenderObjectLibrary.get(_shadowRenderObjectKeys);return void 0!==renderObjectFunction&&renderObjectFunction.shadowType===shadowType&&renderObjectFunction.useVelocity===useVelocity||(renderObjectFunction=(object,scene,_camera,geometry,material,group,...params)=>{(!0===object.castShadow||object.receiveShadow&&3===shadowType)&&(useVelocity&&(getDataFromObject(object).useVelocity=!0),object.onBeforeShadow(renderer,object,_camera,shadow.camera,geometry,scene.overrideMaterial,group),renderer.renderObject(object,scene,_camera,geometry,material,group,...params),object.onAfterShadow(renderer,object,_camera,shadow.camera,geometry,scene.overrideMaterial,group))},renderObjectFunction.shadowType=shadowType,renderObjectFunction.useVelocity=useVelocity,_shadowRenderObjectLibrary.set(_shadowRenderObjectKeys,renderObjectFunction)),_shadowRenderObjectKeys[0]=null,_shadowRenderObjectKeys[1]=null,renderObjectFunction})(renderer,shadow,shadowType,useVelocity)),renderer.setClearColor(0,0),renderer.setRenderTarget(shadowMap),this.renderShadow(frame),renderer.setRenderObjectFunction(currentRenderObjectFunction),3===shadowType&&!0!==shadow.isPointLightShadow&&this.vsmPass(renderer),shadow.camera.layers.mask=_shadowCameraLayer,function restoreRendererAndSceneState(renderer,scene,state){!function restoreRendererState(renderer,state){renderer.toneMapping=state.toneMapping,renderer.toneMappingExposure=state.toneMappingExposure,renderer.outputColorSpace=state.outputColorSpace,renderer.setRenderTarget(state.renderTarget,state.activeCubeFace,state.activeMipmapLevel),renderer.setRenderObjectFunction(state.renderObjectFunction),renderer.setPixelRatio(state.pixelRatio),renderer.setMRT(state.mrt),renderer.setClearColor(state.clearColor,state.clearAlpha),renderer.autoClear=state.autoClear,renderer.setScissorTest(state.scissorTest)}(renderer,state),function restoreSceneState(scene,state){scene.background=state.background,scene.backgroundNode=state.backgroundNode,scene.overrideMaterial=state.overrideMaterial}(scene,state)}(renderer,scene,_rendererState)}vsmPass(renderer){const{shadow:shadow}=this,depth=this.shadowMap.depth;this.vsmShadowMapVertical.setSize(shadow.mapSize.width,shadow.mapSize.height,depth),this.vsmShadowMapHorizontal.setSize(shadow.mapSize.width,shadow.mapSize.height,depth),renderer.setRenderTarget(this.vsmShadowMapVertical),_quadMesh.material=this.vsmMaterialVertical,_quadMesh.render(renderer),renderer.setRenderTarget(this.vsmShadowMapHorizontal),_quadMesh.material=this.vsmMaterialHorizontal,_quadMesh.render(renderer)}dispose(){this._reset(),super.dispose()}_reset(){this._currentShadowType=null,(light=>{const material=shadowMaterialLib.get(light);void 0!==material&&(material.dispose(),shadowMaterialLib.delete(light))})(this.light),this.shadowMap&&(this.shadowMap.dispose(),this.shadowMap=null),null!==this.vsmShadowMapVertical&&(this.vsmShadowMapVertical.dispose(),this.vsmShadowMapVertical=null,this.vsmMaterialVertical.dispose(),this.vsmMaterialVertical=null),null!==this.vsmShadowMapHorizontal&&(this.vsmShadowMapHorizontal.dispose(),this.vsmShadowMapHorizontal=null,this.vsmMaterialHorizontal.dispose(),this.vsmMaterialHorizontal=null)}updateBefore(frame){const{shadow:shadow}=this;let needsUpdate=shadow.needsUpdate||shadow.autoUpdate;needsUpdate&&(this._cameraFrameId[frame.camera]===frame.frameId&&(needsUpdate=!1),this._cameraFrameId[frame.camera]=frame.frameId),needsUpdate&&(this.updateShadow(frame),this.shadowMap.depthTexture.version===this._depthVersionCached&&(shadow.needsUpdate=!1))}}const _clearColor$1=/*@__PURE__*/new Color,_projScreenMatrix$1=/*@__PURE__*/new Matrix4,_lightPositionWorld=/*@__PURE__*/new Vector3,_lookTarget=/*@__PURE__*/new Vector3,_cubeDirectionsWebGPU=[
/*@__PURE__*/new Vector3(1,0,0),/*@__PURE__*/new Vector3(-1,0,0),/*@__PURE__*/new Vector3(0,-1,0),
/*@__PURE__*/new Vector3(0,1,0),/*@__PURE__*/new Vector3(0,0,1),/*@__PURE__*/new Vector3(0,0,-1)],_cubeUpsWebGPU=[
/*@__PURE__*/new Vector3(0,-1,0),/*@__PURE__*/new Vector3(0,-1,0),/*@__PURE__*/new Vector3(0,0,-1),
/*@__PURE__*/new Vector3(0,0,1),/*@__PURE__*/new Vector3(0,-1,0),/*@__PURE__*/new Vector3(0,-1,0)],_cubeDirectionsWebGL=[
/*@__PURE__*/new Vector3(1,0,0),/*@__PURE__*/new Vector3(-1,0,0),/*@__PURE__*/new Vector3(0,1,0),
/*@__PURE__*/new Vector3(0,-1,0),/*@__PURE__*/new Vector3(0,0,1),/*@__PURE__*/new Vector3(0,0,-1)],_cubeUpsWebGL=[
/*@__PURE__*/new Vector3(0,-1,0),/*@__PURE__*/new Vector3(0,-1,0),/*@__PURE__*/new Vector3(0,0,1),
/*@__PURE__*/new Vector3(0,0,-1),/*@__PURE__*/new Vector3(0,-1,0),/*@__PURE__*/new Vector3(0,-1,0)],BasicPointShadowFilter=/*@__PURE__*/Fn(({depthTexture:depthTexture,bd3D:bd3D,dp:dp})=>cubeTexture(depthTexture,bd3D).compare(dp)),PointShadowFilter=/*@__PURE__*/Fn(({depthTexture:depthTexture,bd3D:bd3D,dp:dp,shadow:shadow})=>{const radius=reference("radius","float",shadow).setGroup(renderGroup),mapSize=reference("mapSize","vec2",shadow).setGroup(renderGroup),texelSize=radius.div(mapSize.x),absDir=abs(bd3D),tangent=normalize(cross(bd3D,absDir.x.greaterThan(absDir.z).select(vec3(0,1,0),vec3(1,0,0)))),bitangent=cross(bd3D,tangent),phi=interleavedGradientNoise(screenCoordinate.xy).mul(6.28318530718),sample0=vogelDiskSample(0,5,phi),sample1=vogelDiskSample(1,5,phi),sample2=vogelDiskSample(2,5,phi),sample3=vogelDiskSample(3,5,phi),sample4=vogelDiskSample(4,5,phi);return cubeTexture(depthTexture,bd3D.add(tangent.mul(sample0.x).add(bitangent.mul(sample0.y)).mul(texelSize))).compare(dp).add(cubeTexture(depthTexture,bd3D.add(tangent.mul(sample1.x).add(bitangent.mul(sample1.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture,bd3D.add(tangent.mul(sample2.x).add(bitangent.mul(sample2.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture,bd3D.add(tangent.mul(sample3.x).add(bitangent.mul(sample3.y)).mul(texelSize))).compare(dp)).add(cubeTexture(depthTexture,bd3D.add(tangent.mul(sample4.x).add(bitangent.mul(sample4.y)).mul(texelSize))).compare(dp)).mul(.2)}),pointShadowFilter=/*@__PURE__*/Fn(({filterFn:filterFn,depthTexture:depthTexture,shadowCoord:shadowCoord,shadow:shadow})=>{const shadowPosition=shadowCoord.xyz.toConst(),shadowPositionAbs=shadowPosition.abs().toConst(),viewZ=shadowPositionAbs.x.max(shadowPositionAbs.y).max(shadowPositionAbs.z),shadowCameraNear=uniform("float").setGroup(renderGroup).onRenderUpdate(()=>shadow.camera.near),shadowCameraFar=uniform("float").setGroup(renderGroup).onRenderUpdate(()=>shadow.camera.far),bias=reference("bias","float",shadow).setGroup(renderGroup),result=float(1).toVar();return If(viewZ.sub(shadowCameraFar).lessThanEqual(0).and(viewZ.sub(shadowCameraNear).greaterThanEqual(0)),()=>{const dp=viewZToPerspectiveDepth(viewZ.negate(),shadowCameraNear,shadowCameraFar);dp.addAssign(bias);const bd3D=shadowPosition.normalize();result.assign(filterFn({depthTexture:depthTexture,bd3D:bd3D,dp:dp,shadow:shadow}))}),result});class PointShadowNode extends ShadowNode{static get type(){return"PointShadowNode"}constructor(light,shadow=null){super(light,shadow)}getShadowFilterFn(type){return 0===type?BasicPointShadowFilter:PointShadowFilter}setupShadowCoord(builder,shadowPosition){return shadowPosition}setupShadowFilter(builder,{filterFn:filterFn,depthTexture:depthTexture,shadowCoord:shadowCoord,shadow:shadow}){return pointShadowFilter({filterFn:filterFn,depthTexture:depthTexture,shadowCoord:shadowCoord,shadow:shadow})}setupRenderTarget(shadow,builder){const depthTexture=new CubeDepthTexture(shadow.mapSize.width);depthTexture.name="PointShadowDepthTexture",depthTexture.compareFunction=515;const shadowMap=builder.createCubeRenderTarget(shadow.mapSize.width);return shadowMap.texture.name="PointShadowMap",shadowMap.depthTexture=depthTexture,{shadowMap:shadowMap,depthTexture:depthTexture}}renderShadow(frame){const{shadow:shadow,shadowMap:shadowMap,light:light}=this,{renderer:renderer,scene:scene}=frame,camera=shadow.camera,shadowMatrix=shadow.matrix,isWebGPU=2001===renderer.coordinateSystem,cubeDirections=isWebGPU?_cubeDirectionsWebGPU:_cubeDirectionsWebGL,cubeUps=isWebGPU?_cubeUpsWebGPU:_cubeUpsWebGL;shadowMap.setSize(shadow.mapSize.width,shadow.mapSize.width);const previousAutoClear=renderer.autoClear,previousClearColor=renderer.getClearColor(_clearColor$1),previousClearAlpha=renderer.getClearAlpha();renderer.autoClear=!1,renderer.setClearColor(shadow.clearColor,shadow.clearAlpha);for(let face=0;face<6;face++){renderer.setRenderTarget(shadowMap,face),renderer.clear();const far=light.distance||camera.far;far!==camera.far&&(camera.far=far,camera.updateProjectionMatrix()),_lightPositionWorld.setFromMatrixPosition(light.matrixWorld),camera.position.copy(_lightPositionWorld),_lookTarget.copy(camera.position),_lookTarget.add(cubeDirections[face]),camera.up.copy(cubeUps[face]),camera.lookAt(_lookTarget),camera.updateMatrixWorld(),shadowMatrix.makeTranslation(-_lightPositionWorld.x,-_lightPositionWorld.y,-_lightPositionWorld.z),_projScreenMatrix$1.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),shadow._frustum.setFromProjectionMatrix(_projScreenMatrix$1,camera.coordinateSystem,camera.reversedDepth);const currentSceneName=scene.name;scene.name=`Point Light Shadow [ ${light.name||"ID: "+light.id} ] - Face ${face+1}`,renderer.render(scene,camera),scene.name=currentSceneName}renderer.autoClear=previousAutoClear,renderer.setClearColor(previousClearColor,previousClearAlpha)}}class AnalyticLightNode extends LightingNode{static get type(){return"AnalyticLightNode"}constructor(light=null){super(),this.light=light,this.color=new Color,this.colorNode=light&&light.colorNode||uniform(this.color).setGroup(renderGroup),this.baseColorNode=null,this.shadowNode=null,this.shadowColorNode=null,this.isAnalyticLightNode=!0,this.updateType=NodeUpdateType_FRAME,light&&light.shadow&&(this._shadowDisposeListener=()=>{this.disposeShadow()},light.addEventListener("dispose",this._shadowDisposeListener))}dispose(){this._shadowDisposeListener&&this.light.removeEventListener("dispose",this._shadowDisposeListener),super.dispose()}disposeShadow(){null!==this.shadowNode&&(this.shadowNode.dispose(),this.shadowNode=null),this.shadowColorNode=null,null!==this.baseColorNode&&(this.colorNode=this.baseColorNode,this.baseColorNode=null)}getHash(){return this.light.uuid}getLightVector(builder){return lightViewPosition(this.light).sub(builder.context.positionView||positionView)}setupDirect(){}setupDirectRectArea(){}setupShadowNode(){return((light,shadow)=>new ShadowNode(light,shadow))(this.light)}setupShadow(builder){const{renderer:renderer}=builder;if(!1===renderer.shadowMap.enabled)return;let shadowColorNode=this.shadowColorNode;if(null===shadowColorNode){const customShadowNode=this.light.shadow.shadowNode;let shadowNode;shadowNode=void 0!==customShadowNode?nodeObject(customShadowNode):this.setupShadowNode(),this.shadowNode=shadowNode,this.shadowColorNode=shadowColorNode=this.colorNode.mul(shadowNode),this.baseColorNode=this.colorNode}builder.context.getShadow&&(shadowColorNode=builder.context.getShadow(this,builder)),this.colorNode=shadowColorNode}setup(builder){this.colorNode=this.baseColorNode||this.colorNode,this.light.castShadow?builder.object.receiveShadow&&this.setupShadow(builder):null!==this.shadowNode&&(this.shadowNode.dispose(),this.shadowNode=null,this.shadowColorNode=null);const directLightData=this.setupDirect(builder),directRectAreaLightData=this.setupDirectRectArea(builder);directLightData&&builder.lightsNode.setupDirectLight(builder,this,directLightData),directRectAreaLightData&&builder.lightsNode.setupDirectRectAreaLight(builder,this,directRectAreaLightData)}update(){const{light:light}=this;this.color.copy(light.color).multiplyScalar(light.intensity)}}const getDistanceAttenuation=/*@__PURE__*/Fn(({lightDistance:lightDistance,cutoffDistance:cutoffDistance,decayExponent:decayExponent})=>{const distanceFalloff=lightDistance.pow(decayExponent).max(.01).reciprocal();return cutoffDistance.greaterThan(0).select(distanceFalloff.mul(lightDistance.div(cutoffDistance).pow4().oneMinus().clamp().pow2()),distanceFalloff)});class PointLightNode extends AnalyticLightNode{static get type(){return"PointLightNode"}constructor(light=null){super(light),this.cutoffDistanceNode=uniform(0).setGroup(renderGroup),this.decayExponentNode=uniform(2).setGroup(renderGroup)}update(frame){const{light:light}=this;super.update(frame),this.cutoffDistanceNode.value=light.distance,this.decayExponentNode.value=light.decay}setupShadowNode(){return((light,shadow)=>new PointShadowNode(light,shadow))(this.light)}setupDirect(builder){return(({color:color,lightVector:lightVector,cutoffDistance:cutoffDistance,decayExponent:decayExponent})=>{const lightDirection=lightVector.normalize(),lightDistance=lightVector.length(),attenuation=getDistanceAttenuation({lightDistance:lightDistance,cutoffDistance:cutoffDistance,decayExponent:decayExponent});return{lightDirection:lightDirection,lightColor:color.mul(attenuation)}})({color:this.colorNode,lightVector:this.getLightVector(builder),cutoffDistance:this.cutoffDistanceNode,decayExponent:this.decayExponentNode})}}Fn(([coord=uv$1()],{renderer:renderer,material:material})=>{const len2=lengthSq(coord.mul(2).sub(1));let alpha;if(material.alphaToCoverage&&renderer.currentSamples>0){const dlen=float(len2.fwidth()).toVar();alpha=smoothstep(dlen.oneMinus(),dlen.add(1),len2).oneMinus()}else alpha=select(len2.greaterThan(1),0,1);return alpha});const getShIrradianceAt=/*@__PURE__*/Fn(([normal,shCoefficients])=>{const x=normal.x,y=normal.y,z=normal.z;let result=shCoefficients.element(0).mul(.886227);return result=result.add(shCoefficients.element(1).mul(1.023328).mul(y)),result=result.add(shCoefficients.element(2).mul(1.023328).mul(z)),result=result.add(shCoefficients.element(3).mul(1.023328).mul(x)),result=result.add(shCoefficients.element(4).mul(.858086).mul(x).mul(y)),result=result.add(shCoefficients.element(5).mul(.858086).mul(y).mul(z)),result=result.add(shCoefficients.element(6).mul(z.mul(z).mul(.743125).sub(.247708))),result=result.add(shCoefficients.element(7).mul(.858086).mul(x).mul(z)),result=result.add(shCoefficients.element(8).mul(.429043).mul(mul(x,x).sub(mul(y,y)))),result}),_clearColor=/*@__PURE__*/new Color4;class Background extends DataMap{constructor(renderer,nodes){super(),this.renderer=renderer,this.nodes=nodes}update(scene,renderList,renderContext){const renderer=this.renderer,background=this.nodes.getBackgroundNode(scene)||scene.background;let forceClear=!1;if(null===background)renderer._clearColor.getRGB(_clearColor),_clearColor.a=renderer._clearColor.a;else if(!0===background.isColor)background.getRGB(_clearColor),_clearColor.a=1,forceClear=!0;else if(!0===background.isNode){const sceneData=this.get(scene),backgroundNode=background;_clearColor.copy(renderer._clearColor);let backgroundMesh=sceneData.backgroundMesh;if(void 0===backgroundMesh){const backgroundMeshNode=vec4(backgroundNode).mul(backgroundIntensity).context({getUV:()=>backgroundRotation.mul(normalWorldGeometry),getTextureLevel:()=>backgroundBlurriness}),isOrtho=cameraProjectionMatrix.element(3).element(3).equal(1),orthoScale=div(1,cameraProjectionMatrix.element(1).element(1)).mul(3),modifiedPosition=isOrtho.select(positionLocal.mul(orthoScale),positionLocal),viewPosition=modelViewMatrix.mul(vec4(modifiedPosition,0));let viewProj=cameraProjectionMatrix.mul(vec4(viewPosition.xyz,1));viewProj=viewProj.setZ(viewProj.w);const nodeMaterial=new NodeMaterial;function onBackgroundDispose(){background.removeEventListener("dispose",onBackgroundDispose),backgroundMesh.material.dispose(),backgroundMesh.geometry.dispose()}nodeMaterial.name="Background.material",nodeMaterial.side=1,nodeMaterial.depthTest=!1,nodeMaterial.depthWrite=!1,nodeMaterial.allowOverride=!1,nodeMaterial.fog=!1,nodeMaterial.lights=!1,nodeMaterial.vertexNode=viewProj,nodeMaterial.colorNode=backgroundMeshNode,sceneData.backgroundMeshNode=backgroundMeshNode,sceneData.backgroundMesh=backgroundMesh=new Mesh(new SphereGeometry(1,32,32),nodeMaterial),backgroundMesh.frustumCulled=!1,backgroundMesh.name="Background.mesh",background.addEventListener("dispose",onBackgroundDispose)}const backgroundCacheKey=backgroundNode.getCacheKey();sceneData.backgroundCacheKey!==backgroundCacheKey&&(sceneData.backgroundMeshNode.node=vec4(backgroundNode).mul(backgroundIntensity),sceneData.backgroundMeshNode.needsUpdate=!0,backgroundMesh.material.needsUpdate=!0,sceneData.backgroundCacheKey=backgroundCacheKey),renderList.unshift(backgroundMesh,backgroundMesh.geometry,backgroundMesh.material,0,0,null,null)}else error("Renderer: Unsupported background configuration.",background);const environmentBlendMode=renderer.xr.getEnvironmentBlendMode();if("additive"===environmentBlendMode?_clearColor.set(0,0,0,1):"alpha-blend"===environmentBlendMode&&_clearColor.set(0,0,0,0),!0===renderer.autoClear||!0===forceClear){const clearColorValue=renderContext.clearColorValue;clearColorValue.r=_clearColor.r,clearColorValue.g=_clearColor.g,clearColorValue.b=_clearColor.b,clearColorValue.a=_clearColor.a,!0!==renderer.backend.isWebGLBackend&&!0!==renderer.alpha||(clearColorValue.r*=clearColorValue.a,clearColorValue.g*=clearColorValue.a,clearColorValue.b*=clearColorValue.a),renderContext.depthClearValue=renderer._clearDepth,renderContext.stencilClearValue=renderer._clearStencil,renderContext.clearColor=!0===renderer.autoClearColor,renderContext.clearDepth=!0===renderer.autoClearDepth,renderContext.clearStencil=!0===renderer.autoClearStencil}else renderContext.clearColor=!1,renderContext.clearDepth=!1,renderContext.clearStencil=!1}}let _id$7=0;class BindGroup{constructor(name="",bindings=[],index=0){this.name=name,this.bindings=bindings,this.index=index,this.id=_id$7++}}class NodeBuilderState{constructor(vertexShader,fragmentShader,computeShader,nodeAttributes,bindings,updateNodes,updateBeforeNodes,updateAfterNodes,observer,transforms=[]){this.vertexShader=vertexShader,this.fragmentShader=fragmentShader,this.computeShader=computeShader,this.transforms=transforms,this.nodeAttributes=nodeAttributes,this.bindings=bindings,this.updateNodes=updateNodes,this.updateBeforeNodes=updateBeforeNodes,this.updateAfterNodes=updateAfterNodes,this.observer=observer,this.usedTimes=0}createBindings(){const bindings=[];for(const instanceGroup of this.bindings){if(!0!==instanceGroup.bindings[0].groupNode.shared){const bindingsGroup=new BindGroup(instanceGroup.name,[],instanceGroup.index);bindings.push(bindingsGroup);for(const instanceBinding of instanceGroup.bindings)bindingsGroup.bindings.push(instanceBinding.clone())}else bindings.push(instanceGroup)}return bindings}}class NodeAttribute{constructor(name,type,node=null){this.isNodeAttribute=!0,this.name=name,this.type=type,this.node=node}}class NodeUniform{constructor(name,type,node){this.isNodeUniform=!0,this.name=name,this.type=type,this.node=node}get value(){return this.node.value}set value(val){this.node.value=val}get id(){return this.node.id}get groupNode(){return this.node.groupNode}}class NodeVar{constructor(name,type,readOnly=!1,count=null){this.isNodeVar=!0,this.name=name,this.type=type,this.readOnly=readOnly,this.count=count}}class NodeVarying extends NodeVar{constructor(name,type,interpolationType=null,interpolationSampling=null){super(name,type),this.needsInterpolation=!1,this.isNodeVarying=!0,this.interpolationType=interpolationType,this.interpolationSampling=interpolationSampling}}class NodeCode{constructor(name,type,code=""){this.name=name,this.type=type,this.code=code,Object.defineProperty(this,"isNodeCode",{value:!0})}}let _id$6=0;class NodeCache{constructor(parent=null){this.id=_id$6++,this.nodesData=new WeakMap,this.parent=parent}getData(node){let data=this.nodesData.get(node);return void 0===data&&null!==this.parent&&(data=this.parent.getData(node)),data}setData(node,data){this.nodesData.set(node,data)}}class StructType{constructor(name,members){this.name=name,this.members=members,this.output=!1}}class Uniform{constructor(name,value){this.name=name,this.value=value,this.boundary=0,this.itemSize=0,this.offset=0,this.index=-1}setValue(value){this.value=value}getValue(){return this.value}}class NumberUniform extends Uniform{constructor(name,value=0){super(name,value),this.isNumberUniform=!0,this.boundary=4,this.itemSize=1}}class Vector2Uniform extends Uniform{constructor(name,value=new Vector2){super(name,value),this.isVector2Uniform=!0,this.boundary=8,this.itemSize=2}}class Vector3Uniform extends Uniform{constructor(name,value=new Vector3){super(name,value),this.isVector3Uniform=!0,this.boundary=16,this.itemSize=3}}class Vector4Uniform extends Uniform{constructor(name,value=new Vector4){super(name,value),this.isVector4Uniform=!0,this.boundary=16,this.itemSize=4}}class ColorUniform extends Uniform{constructor(name,value=new Color){super(name,value),this.isColorUniform=!0,this.boundary=16,this.itemSize=3}}class Matrix2Uniform extends Uniform{constructor(name,value=new Matrix2){super(name,value),this.isMatrix2Uniform=!0,this.boundary=8,this.itemSize=4}}class Matrix3Uniform extends Uniform{constructor(name,value=new Matrix3){super(name,value),this.isMatrix3Uniform=!0,this.boundary=48,this.itemSize=12}}class Matrix4Uniform extends Uniform{constructor(name,value=new Matrix4){super(name,value),this.isMatrix4Uniform=!0,this.boundary=64,this.itemSize=16}}class NumberNodeUniform extends NumberUniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Vector2NodeUniform extends Vector2Uniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Vector3NodeUniform extends Vector3Uniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Vector4NodeUniform extends Vector4Uniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class ColorNodeUniform extends ColorUniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Matrix2NodeUniform extends Matrix2Uniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Matrix3NodeUniform extends Matrix3Uniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}class Matrix4NodeUniform extends Matrix4Uniform{constructor(nodeUniform){super(nodeUniform.name,nodeUniform.value),this.nodeUniform=nodeUniform}getValue(){return this.nodeUniform.value}getType(){return this.nodeUniform.type}}let _id$5=0;const sharedNodeData=new WeakMap,rendererCache=new WeakMap,typeFromArray=new Map([[Int8Array,"int"],[Int16Array,"int"],[Int32Array,"int"],[Uint8Array,"uint"],[Uint16Array,"uint"],[Uint32Array,"uint"],[Float32Array,"float"]]),toFloat=value=>/e/g.test(value)?String(value).replace(/\+/g,""):(value=Number(value))+(value%1?"":".0");class NodeBuilder{constructor(object,renderer,parser){this.object=object,this.material=object&&object.material||null,this.geometry=object&&object.geometry||null,this.renderer=renderer,this.parser=parser,this.scene=null,this.camera=null,this.nodes=[],this.sequentialNodes=[],this.updateNodes=[],this.updateBeforeNodes=[],this.updateAfterNodes=[],this.hashNodes={},this.observer=null,this.lightsNode=null,this.environmentNode=null,this.fogNode=null,this.clippingContext=null,this.vertexShader=null,this.fragmentShader=null,this.computeShader=null,this.flowNodes={vertex:[],fragment:[],compute:[]},this.flowCode={vertex:"",fragment:"",compute:""},this.uniforms={vertex:[],fragment:[],compute:[],index:0},this.structs={vertex:[],fragment:[],compute:[],index:0},this.types={vertex:[],fragment:[],compute:[],index:0},this.bindings={vertex:{},fragment:{},compute:{}},this.bindingsIndexes={},this.bindGroups=null,this.attributes=[],this.bufferAttributes=[],this.varyings=[],this.codes={},this.vars={},this.declarations={},this.flow={code:""},this.chaining=[],this.stack=stack(),this.stacks=[],this.tab="\t",this.currentFunctionNode=null,this.context={material:this.material},this.cache=new NodeCache,this.globalCache=this.cache,this.flowsData=new WeakMap,this.shaderStage=null,this.buildStage=null,this.subBuildLayers=[],this.activeStacks=[],this.subBuildFn=null,this.fnCall=null,Object.defineProperty(this,"id",{value:_id$5++})}isFlatShading(){return!0===this.material.flatShading||!1===this.geometry.hasAttribute("normal")}isOpaque(){const material=this.material;return!1===material.transparent&&1===material.blending&&!1===material.alphaToCoverage}getBindGroupsCache(){let bindGroupsCache=rendererCache.get(this.renderer);return void 0===bindGroupsCache&&(bindGroupsCache=new ChainMap,rendererCache.set(this.renderer,bindGroupsCache)),bindGroupsCache}createRenderTarget(width,height,options){return new RenderTarget(width,height,options)}createCubeRenderTarget(size,options){return new CubeRenderTarget(size,options)}includes(node){return this.nodes.includes(node)}getOutputStructName(){}_getBindGroup(groupName,bindings){const bindGroupsCache=this.getBindGroupsCache(),bindingsArray=[];let bindGroup,sharedGroup=!0;for(const binding of bindings)bindingsArray.push(binding),sharedGroup=sharedGroup&&binding.groupNode.shared;return sharedGroup?(bindGroup=bindGroupsCache.get(bindingsArray),void 0===bindGroup&&(bindGroup=new BindGroup(groupName,bindingsArray,this.bindingsIndexes[groupName].group),bindGroupsCache.set(bindingsArray,bindGroup))):bindGroup=new BindGroup(groupName,bindingsArray,this.bindingsIndexes[groupName].group),bindGroup}getBindGroupArray(groupName,shaderStage){const bindings=this.bindings[shaderStage];let bindGroup=bindings[groupName];return void 0===bindGroup&&(void 0===this.bindingsIndexes[groupName]&&(this.bindingsIndexes[groupName]={binding:0,group:Object.keys(this.bindingsIndexes).length}),bindings[groupName]=bindGroup=[]),bindGroup}getBindings(){let bindingsGroups=this.bindGroups;if(null===bindingsGroups){const groups={},bindings=this.bindings;for(const shaderStage of shaderStages)for(const groupName in bindings[shaderStage]){const uniforms=bindings[shaderStage][groupName],groupUniforms=groups[groupName]||(groups[groupName]=[]);for(const uniform of uniforms)!1===groupUniforms.includes(uniform)&&groupUniforms.push(uniform)}bindingsGroups=[];for(const groupName in groups){const group=groups[groupName],bindingsGroup=this._getBindGroup(groupName,group);bindingsGroups.push(bindingsGroup)}this.bindGroups=bindingsGroups}return bindingsGroups}sortBindingGroups(){const bindingsGroups=this.getBindings();bindingsGroups.sort((a,b)=>a.bindings[0].groupNode.order-b.bindings[0].groupNode.order);for(let i=0;i<bindingsGroups.length;i++){const bindingGroup=bindingsGroups[i];this.bindingsIndexes[bindingGroup.name].group=i,bindingGroup.index=i}}setHashNode(node,hash){this.hashNodes[hash]=node}addNode(node){!1===this.nodes.includes(node)&&(this.nodes.push(node),this.setHashNode(node,node.getHash(this)))}addSequentialNode(node){!1===this.sequentialNodes.includes(node)&&this.sequentialNodes.push(node)}buildUpdateNodes(){for(const node of this.nodes){node.getUpdateType()!==NodeUpdateType_NONE&&this.updateNodes.push(node)}for(const node of this.sequentialNodes){const updateBeforeType=node.getUpdateBeforeType(),updateAfterType=node.getUpdateAfterType();updateBeforeType!==NodeUpdateType_NONE&&this.updateBeforeNodes.push(node),updateAfterType!==NodeUpdateType_NONE&&this.updateAfterNodes.push(node)}}get currentNode(){return this.chaining[this.chaining.length-1]}isFilteredTexture(texture){return 1006===texture.magFilter||1007===texture.magFilter||1005===texture.magFilter||1008===texture.magFilter||1006===texture.minFilter||1007===texture.minFilter||1005===texture.minFilter||1008===texture.minFilter}getUniformBufferLimit(){return 16384}addChain(node){this.chaining.push(node)}removeChain(node){if(this.chaining.pop()!==node)throw new Error("NodeBuilder: Invalid node chaining!")}getMethod(method){return method}getTernary(){return null}getNodeFromHash(hash){return this.hashNodes[hash]}addFlow(shaderStage,node){return this.flowNodes[shaderStage].push(node),node}setContext(context){this.context=context}getContext(){return this.context}addContext(context){const previousContext=this.getContext();return this.setContext({...this.context,...context}),previousContext}getSharedContext(){const context={...this.context};return delete context.material,delete context.getUV,delete context.getOutput,delete context.getTextureLevel,delete context.getAO,delete context.getShadow,context}setCache(cache){this.cache=cache}getCache(){return this.cache}getCacheFromNode(node,parent=!0){const data=this.getDataFromNode(node);return void 0===data.cache&&(data.cache=new NodeCache(parent?this.getCache():null)),data.cache}isAvailable(){return!1}getVertexIndex(){warn("Abstract function.")}getInstanceIndex(){warn("Abstract function.")}getDrawIndex(){warn("Abstract function.")}getFrontFacing(){warn("Abstract function.")}getFragCoord(){warn("Abstract function.")}isFlipY(){return!1}increaseUsage(node){const nodeData=this.getDataFromNode(node);return nodeData.usageCount=void 0===nodeData.usageCount?1:nodeData.usageCount+1,nodeData.usageCount}generateTexture(){warn("Abstract function.")}generateTextureLod(){warn("Abstract function.")}generateArrayDeclaration(type,count){return this.getType(type)+"[ "+count+" ]"}generateArray(type,count,values=null){let snippet=this.generateArrayDeclaration(type,count)+"( ";for(let i=0;i<count;i++){const value=values?values[i]:null;snippet+=null!==value?value.build(this,type):this.generateConst(type),i<count-1&&(snippet+=", ")}return snippet+=" )",snippet}generateStruct(type,membersLayout,values=null){const snippets=[];for(const member of membersLayout){const{name:name,type:type}=member;values&&values[name]&&values[name].isNode?snippets.push(values[name].build(this,type)):snippets.push(this.generateConst(type))}return type+"( "+snippets.join(", ")+" )"}generateConst(type,value=null){if(null===value&&("float"===type||"int"===type||"uint"===type?value=0:"bool"===type?value=!1:"color"===type?value=new Color:"vec2"===type||"uvec2"===type||"ivec2"===type?value=new Vector2:"vec3"===type||"uvec3"===type||"ivec3"===type?value=new Vector3:"vec4"!==type&&"uvec4"!==type&&"ivec4"!==type||(value=new Vector4)),"float"===type)return toFloat(value);if("int"===type)return`${Math.round(value)}`;if("uint"===type)return value>=0?`${Math.round(value)}u`:"0u";if("bool"===type)return value?"true":"false";if("color"===type)return`${this.getType("vec3")}( ${toFloat(value.r)}, ${toFloat(value.g)}, ${toFloat(value.b)} )`;const typeLength=this.getTypeLength(type),componentType=this.getComponentType(type),generateConst=value=>this.generateConst(componentType,value);if(2===typeLength)return`${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)} )`;if(3===typeLength)return`${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)} )`;if(4===typeLength&&"mat2"!==type)return`${this.getType(type)}( ${generateConst(value.x)}, ${generateConst(value.y)}, ${generateConst(value.z)}, ${generateConst(value.w)} )`;if(typeLength>=4&&value&&(value.isMatrix2||value.isMatrix3||value.isMatrix4))return`${this.getType(type)}( ${value.elements.map(generateConst).join(", ")} )`;if(typeLength>4)return`${this.getType(type)}()`;throw new Error(`NodeBuilder: Type '${type}' not found in generate constant attempt.`)}getType(type){return"color"===type?"vec3":type}hasGeometryAttribute(name){return this.geometry&&void 0!==this.geometry.getAttribute(name)}getAttribute(name,type){const attributes=this.attributes;for(const attribute of attributes)if(attribute.name===name)return attribute;const attribute=new NodeAttribute(name,type);return this.registerDeclaration(attribute),attributes.push(attribute),attribute}getPropertyName(node){return node.name}isVector(type){return/vec\d/.test(type)}isMatrix(type){return/mat\d/.test(type)}isReference(type){return"void"===type||"property"===type||"sampler"===type||"samplerComparison"===type||"texture"===type||"cubeTexture"===type||"storageTexture"===type||"depthTexture"===type||"texture3D"===type}needsToWorkingColorSpace(){return!1}getComponentTypeFromTexture(texture){const type=texture.type;if(texture.isDataTexture){if(1013===type)return"int";if(1014===type)return"uint"}return"float"}getElementType(type){return"mat2"===type?"vec2":"mat3"===type?"vec3":"mat4"===type?"vec4":this.getComponentType(type)}getComponentType(type){if("float"===(type=this.getVectorType(type))||"bool"===type||"int"===type||"uint"===type)return type;const componentType=/(b|i|u|)(vec|mat)([2-4])/.exec(type);return null===componentType?null:"b"===componentType[1]?"bool":"i"===componentType[1]?"int":"u"===componentType[1]?"uint":"float"}getVectorType(type){return"color"===type?"vec3":"texture"===type||"cubeTexture"===type||"storageTexture"===type||"texture3D"===type?"vec4":type}getTypeFromLength(length,componentType="float"){if(1===length)return componentType;let baseType=getTypeFromLength(length);const prefix="float"===componentType?"":componentType[0];return!0===/mat2/.test(componentType)&&(baseType=baseType.replace("vec","mat")),prefix+baseType}getTypeFromArray(array){return typeFromArray.get(array.constructor)}isInteger(type){return/int|uint|(i|u)vec/.test(type)}getTypeFromAttribute(attribute){let dataAttribute=attribute;attribute.isInterleavedBufferAttribute&&(dataAttribute=attribute.data);const array=dataAttribute.array,itemSize=attribute.itemSize,normalized=attribute.normalized;let arrayType;return attribute instanceof Float16BufferAttribute||!0===normalized||(arrayType=this.getTypeFromArray(array)),this.getTypeFromLength(itemSize,arrayType)}getTypeLength(type){const vecType=this.getVectorType(type),vecNum=/vec([2-4])/.exec(vecType);return null!==vecNum?Number(vecNum[1]):"float"===vecType||"bool"===vecType||"int"===vecType||"uint"===vecType?1:!0===/mat2/.test(type)?4:!0===/mat3/.test(type)?9:!0===/mat4/.test(type)?16:0}getVectorFromMatrix(type){return type.replace("mat","vec")}changeComponentType(type,newComponentType){return this.getTypeFromLength(this.getTypeLength(type),newComponentType)}getIntegerType(type){const componentType=this.getComponentType(type);return"int"===componentType||"uint"===componentType?type:this.changeComponentType(type,"int")}setActiveStack(stack){this.activeStacks.push(stack)}removeActiveStack(stack){if(this.activeStacks[this.activeStacks.length-1]!==stack)throw new Error("NodeBuilder: Invalid active stack removal.");this.activeStacks.pop()}getActiveStack(){return this.activeStacks[this.activeStacks.length-1]}getBaseStack(){return this.activeStacks[0]}addStack(){this.stack=stack(this.stack);const previousStack=getCurrentStack();return this.stacks.push(previousStack),setCurrentStack(this.stack),this.stack}removeStack(){const lastStack=this.stack;for(const node of lastStack.nodes){this.getDataFromNode(node).stack=lastStack}return this.stack=lastStack.parent,setCurrentStack(this.stacks.pop()),lastStack}getDataFromNode(node,shaderStage=this.shaderStage,cache=null){let nodeData=(cache=null===cache?node.isGlobal(this)?this.globalCache:this.cache:cache).getData(node);void 0===nodeData&&(nodeData={},cache.setData(node,nodeData)),void 0===nodeData[shaderStage]&&(nodeData[shaderStage]={});let data=nodeData[shaderStage];const subBuilds=nodeData.any?nodeData.any.subBuilds:null,subBuild=this.getClosestSubBuild(subBuilds);return subBuild&&(void 0===data.subBuildsCache&&(data.subBuildsCache={}),data=data.subBuildsCache[subBuild]||(data.subBuildsCache[subBuild]={}),data.subBuilds=subBuilds),data}getNodeProperties(node,shaderStage="any"){const nodeData=this.getDataFromNode(node,shaderStage);return nodeData.properties||(nodeData.properties={outputNode:null})}getBufferAttributeFromNode(node,type){const nodeData=this.getDataFromNode(node,"vertex");let bufferAttribute=nodeData.bufferAttribute;if(void 0===bufferAttribute){const index=this.uniforms.index++;bufferAttribute=new NodeAttribute("nodeAttribute"+index,type,node),this.bufferAttributes.push(bufferAttribute),nodeData.bufferAttribute=bufferAttribute}return bufferAttribute}getStructTypeNode(name,shaderStage=this.shaderStage){return this.types[shaderStage][name]||null}getStructTypeFromNode(node,membersLayout,name=null,shaderStage=this.shaderStage){const nodeData=this.getDataFromNode(node,shaderStage,this.globalCache);let structType=nodeData.structType;if(void 0===structType){const index=this.structs.index++;null===name&&(name="StructType"+index),structType=new StructType(name,membersLayout),this.structs[shaderStage].push(structType),this.types[shaderStage][name]=node,nodeData.structType=structType}return structType}getOutputStructTypeFromNode(node,membersLayout){const structType=this.getStructTypeFromNode(node,membersLayout,"OutputType","fragment");return structType.output=!0,structType}getUniformFromNode(node,type,shaderStage=this.shaderStage,name=null){const nodeData=this.getDataFromNode(node,shaderStage,this.globalCache);let nodeUniform=nodeData.uniform;if(void 0===nodeUniform){const index=this.uniforms.index++;nodeUniform=new NodeUniform(name||"nodeUniform"+index,type,node),this.uniforms[shaderStage].push(nodeUniform),this.registerDeclaration(nodeUniform),nodeData.uniform=nodeUniform}return nodeUniform}getVarFromNode(node,name=null,type=node.getNodeType(this),shaderStage=this.shaderStage,readOnly=!1){const nodeData=this.getDataFromNode(node,shaderStage),subBuildVariable=this.getSubBuildProperty("variable",nodeData.subBuilds);let nodeVar=nodeData[subBuildVariable];if(void 0===nodeVar){const idNS=readOnly?"_const":"_var",vars=this.vars[shaderStage]||(this.vars[shaderStage]=[]),id=this.vars[idNS]||(this.vars[idNS]=0);null===name&&(name=(readOnly?"nodeConst":"nodeVar")+id,this.vars[idNS]++),"variable"!==subBuildVariable&&(name=this.getSubBuildProperty(name,nodeData.subBuilds));const count=node.getArrayCount(this);nodeVar=new NodeVar(name,type,readOnly,count),readOnly||vars.push(nodeVar),this.registerDeclaration(nodeVar),nodeData[subBuildVariable]=nodeVar}return nodeVar}isDeterministic(node){if(node.isMathNode)return this.isDeterministic(node.aNode)&&(!node.bNode||this.isDeterministic(node.bNode))&&(!node.cNode||this.isDeterministic(node.cNode));if(node.isOperatorNode)return this.isDeterministic(node.aNode)&&(!node.bNode||this.isDeterministic(node.bNode));if(node.isArrayNode){if(null!==node.values)for(const n of node.values)if(!this.isDeterministic(n))return!1;return!0}return!!node.isConstNode}getVaryingFromNode(node,name=null,type=node.getNodeType(this),interpolationType=null,interpolationSampling=null){const nodeData=this.getDataFromNode(node,"any"),subBuildVarying=this.getSubBuildProperty("varying",nodeData.subBuilds);let nodeVarying=nodeData[subBuildVarying];if(void 0===nodeVarying){const varyings=this.varyings,index=varyings.length;null===name&&(name="nodeVarying"+index),"varying"!==subBuildVarying&&(name=this.getSubBuildProperty(name,nodeData.subBuilds)),nodeVarying=new NodeVarying(name,type,interpolationType,interpolationSampling),varyings.push(nodeVarying),this.registerDeclaration(nodeVarying),nodeData[subBuildVarying]=nodeVarying}return nodeVarying}registerDeclaration(node){const shaderStage=this.shaderStage,declarations=this.declarations[shaderStage]||(this.declarations[shaderStage]={}),property=this.getPropertyName(node);let index=1,name=property;for(;void 0!==declarations[name];)name=property+"_"+index++;index>1&&(node.name=name,warn(`TSL: Declaration name '${property}' of '${node.type}' already in use. Renamed to '${name}'.`)),declarations[name]=node}getCodeFromNode(node,type,shaderStage=this.shaderStage){const nodeData=this.getDataFromNode(node);let nodeCode=nodeData.code;if(void 0===nodeCode){const codes=this.codes[shaderStage]||(this.codes[shaderStage]=[]),index=codes.length;nodeCode=new NodeCode("nodeCode"+index,type),codes.push(nodeCode),nodeData.code=nodeCode}return nodeCode}addFlowCodeHierarchy(node,nodeBlock){const{flowCodes:flowCodes,flowCodeBlock:flowCodeBlock}=this.getDataFromNode(node);let needsFlowCode=!0,nodeBlockHierarchy=nodeBlock;for(;nodeBlockHierarchy;){if(!0===flowCodeBlock.get(nodeBlockHierarchy)){needsFlowCode=!1;break}nodeBlockHierarchy=this.getDataFromNode(nodeBlockHierarchy).parentNodeBlock}if(needsFlowCode)for(const flowCode of flowCodes)this.addLineFlowCode(flowCode)}addLineFlowCodeBlock(node,code,nodeBlock){const nodeData=this.getDataFromNode(node),flowCodes=nodeData.flowCodes||(nodeData.flowCodes=[]),codeBlock=nodeData.flowCodeBlock||(nodeData.flowCodeBlock=new WeakMap);flowCodes.push(code),codeBlock.set(nodeBlock,!0)}addLineFlowCode(code,node=null){return""===code||(null!==node&&this.context.nodeBlock&&this.addLineFlowCodeBlock(node,code,this.context.nodeBlock),code=this.tab+code,/;\s*$/.test(code)||(code+=";\n"),this.flow.code+=code),this}addFlowCode(code){return this.flow.code+=code,this}addFlowTab(){return this.tab+="\t",this}removeFlowTab(){return this.tab=this.tab.slice(0,-1),this}getFlowData(node){return this.flowsData.get(node)}flowNode(node){const output=node.getNodeType(this),flowData=this.flowChildNode(node,output);return this.flowsData.set(node,flowData),flowData}addInclude(node){null!==this.currentFunctionNode&&this.currentFunctionNode.includes.push(node)}buildFunctionNode(shaderNode){const fn=new FunctionNode,previous=this.currentFunctionNode;return this.currentFunctionNode=fn,fn.code=this.buildFunctionCode(shaderNode),this.currentFunctionNode=previous,fn}flowShaderNode(shaderNode){const layout=shaderNode.layout,inputs={[Symbol.iterator](){let index=0;const values=Object.values(this);return{next:()=>({value:values[index],done:index++>=values.length})}}};for(const input of layout.inputs)inputs[input.name]=new ParameterNode(input.type,input.name);shaderNode.layout=null;const callNode=shaderNode.call(inputs),flowData=this.flowStagesNode(callNode,layout.type);return shaderNode.layout=layout,flowData}flowBuildStage(node,buildStage,output=null){const previousBuildStage=this.getBuildStage();this.setBuildStage(buildStage);const result=node.build(this,output);return this.setBuildStage(previousBuildStage),result}flowStagesNode(node,output=null){const previousFlow=this.flow,previousVars=this.vars,previousDeclarations=this.declarations,previousCache=this.cache,previousBuildStage=this.buildStage,previousStack=this.stack,flow={code:""};this.flow=flow,this.vars={},this.declarations={},this.cache=new NodeCache,this.stack=stack();for(const buildStage of defaultBuildStages)this.setBuildStage(buildStage),flow.result=node.build(this,output);return flow.vars=this.getVars(this.shaderStage),this.flow=previousFlow,this.vars=previousVars,this.declarations=previousDeclarations,this.cache=previousCache,this.stack=previousStack,this.setBuildStage(previousBuildStage),flow}getFunctionOperator(){return null}buildFunctionCode(){warn("Abstract function.")}flowChildNode(node,output=null){const previousFlow=this.flow,flow={code:""};return this.flow=flow,flow.result=node.build(this,output),this.flow=previousFlow,flow}flowNodeFromShaderStage(shaderStage,node,output=null,propertyName=null){const previousTab=this.tab,previousCache=this.cache,previousShaderStage=this.shaderStage,previousContext=this.context;this.setShaderStage(shaderStage);const context={...this.context};delete context.nodeBlock,this.cache=this.globalCache,this.tab="\t",this.context=context;let result=null;if("generate"===this.buildStage){const flowData=this.flowChildNode(node,output);null!==propertyName&&(flowData.code+=`${this.tab+propertyName} = ${flowData.result};\n`),this.flowCode[shaderStage]=this.flowCode[shaderStage]+flowData.code,result=flowData}else result=node.build(this);return this.setShaderStage(previousShaderStage),this.cache=previousCache,this.tab=previousTab,this.context=previousContext,result}getAttributesArray(){return this.attributes.concat(this.bufferAttributes)}getAttributes(){warn("Abstract function.")}getVaryings(){warn("Abstract function.")}getVar(type,name,count=null){return`${null!==count?this.generateArrayDeclaration(type,count):this.getType(type)} ${name}`}getVars(shaderStage){let snippet="";const vars=this.vars[shaderStage];if(void 0!==vars)for(const variable of vars)snippet+=`${this.getVar(variable.type,variable.name)}; `;return snippet}getUniforms(){warn("Abstract function.")}getCodes(shaderStage){const codes=this.codes[shaderStage];let code="";if(void 0!==codes)for(const nodeCode of codes)code+=nodeCode.code+"\n";return code}getHash(){return this.vertexShader+this.fragmentShader+this.computeShader}setShaderStage(shaderStage){this.shaderStage=shaderStage}getShaderStage(){return this.shaderStage}setBuildStage(buildStage){this.buildStage=buildStage}getBuildStage(){return this.buildStage}buildCode(){warn("Abstract function.")}get subBuild(){return this.subBuildLayers[this.subBuildLayers.length-1]||null}addSubBuild(subBuild){this.subBuildLayers.push(subBuild)}removeSubBuild(){return this.subBuildLayers.pop()}getClosestSubBuild(data){let subBuilds;if(subBuilds=data&&data.isNode?data.isShaderCallNodeInternal?data.shaderNode.subBuilds:data.isStackNode?[data.subBuild]:this.getDataFromNode(data,"any").subBuilds:data instanceof Set?[...data]:data,!subBuilds)return null;const subBuildLayers=this.subBuildLayers;for(let i=subBuilds.length-1;i>=0;i--){const subBuild=subBuilds[i];if(subBuildLayers.includes(subBuild))return subBuild}return null}getSubBuildOutput(node){return this.getSubBuildProperty("outputNode",node)}getSubBuildProperty(property="",node=null){let subBuild,result;return subBuild=null!==node?this.getClosestSubBuild(node):this.subBuildFn,result=subBuild?property?subBuild+"_"+property:subBuild:property,result}build(){const{object:object,material:material,renderer:renderer}=this;if(null!==material){let nodeMaterial=renderer.library.fromMaterial(material);null===nodeMaterial&&(error(`NodeMaterial: Material "${material.type}" is not compatible.`),nodeMaterial=new NodeMaterial),nodeMaterial.build(this)}else this.addFlow("compute",object);for(const buildStage of defaultBuildStages){this.setBuildStage(buildStage),this.context.position&&this.context.position.isNode&&this.flowNodeFromShaderStage("vertex",this.context.position);for(const shaderStage of shaderStages){this.setShaderStage(shaderStage);const flowNodes=this.flowNodes[shaderStage];for(const node of flowNodes)"generate"===buildStage?this.flowNode(node):node.build(this)}}return this.setBuildStage(null),this.setShaderStage(null),this.buildCode(),this.buildUpdateNodes(),this}getSharedDataFromNode(node){let data=sharedNodeData.get(node);return void 0===data&&(data={}),data}getNodeUniform(uniformNode,type){const nodeData=this.getSharedDataFromNode(uniformNode);let node=nodeData.cache;if(void 0===node){if("float"===type||"int"===type||"uint"===type)node=new NumberNodeUniform(uniformNode);else if("vec2"===type||"ivec2"===type||"uvec2"===type)node=new Vector2NodeUniform(uniformNode);else if("vec3"===type||"ivec3"===type||"uvec3"===type)node=new Vector3NodeUniform(uniformNode);else if("vec4"===type||"ivec4"===type||"uvec4"===type)node=new Vector4NodeUniform(uniformNode);else if("color"===type)node=new ColorNodeUniform(uniformNode);else if("mat2"===type)node=new Matrix2NodeUniform(uniformNode);else if("mat3"===type)node=new Matrix3NodeUniform(uniformNode);else{if("mat4"!==type)throw new Error(`Uniform "${type}" not implemented.`);node=new Matrix4NodeUniform(uniformNode)}nodeData.cache=node}return node}format(snippet,fromType,toType){if((fromType=this.getVectorType(fromType))===(toType=this.getVectorType(toType))||null===toType||this.isReference(toType))return snippet;const fromTypeLength=this.getTypeLength(fromType),toTypeLength=this.getTypeLength(toType);return 16===fromTypeLength&&9===toTypeLength?`${this.getType(toType)}( ${snippet}[ 0 ].xyz, ${snippet}[ 1 ].xyz, ${snippet}[ 2 ].xyz )`:9===fromTypeLength&&4===toTypeLength?`${this.getType(toType)}( ${snippet}[ 0 ].xy, ${snippet}[ 1 ].xy )`:fromTypeLength>4||toTypeLength>4||0===toTypeLength?snippet:fromTypeLength===toTypeLength?`${this.getType(toType)}( ${snippet} )`:fromTypeLength>toTypeLength?(snippet="bool"===toType?`all( ${snippet} )`:`${snippet}.${"xyz".slice(0,toTypeLength)}`,this.format(snippet,this.getTypeFromLength(toTypeLength,this.getComponentType(fromType)),toType)):4===toTypeLength&&fromTypeLength>1?`${this.getType(toType)}( ${this.format(snippet,fromType,"vec3")}, 1.0 )`:2===fromTypeLength?`${this.getType(toType)}( ${this.format(snippet,fromType,"vec2")}, 0.0 )`:(1===fromTypeLength&&toTypeLength>1&&fromType!==this.getComponentType(toType)&&(snippet=`${this.getType(this.getComponentType(toType))}( ${snippet} )`),`${this.getType(toType)}( ${snippet} )`)}getSignature(){return"// Three.js r183dev - Node System\n"}needsPreviousData(){const mrt=this.renderer.getMRT();return mrt&&mrt.has("velocity")||!0===getDataFromObject(this.object).useVelocity}}class NodeFrame{constructor(){this.time=0,this.deltaTime=0,this.frameId=0,this.renderId=0,this.updateMap=new WeakMap,this.updateBeforeMap=new WeakMap,this.updateAfterMap=new WeakMap,this.renderer=null,this.material=null,this.camera=null,this.object=null,this.scene=null}_getMaps(referenceMap,nodeRef){let maps=referenceMap.get(nodeRef);return void 0===maps&&(maps={renderId:0,frameId:0},referenceMap.set(nodeRef,maps)),maps}updateBeforeNode(node){const updateType=node.getUpdateBeforeType(),reference=node.updateReference(this);if(updateType===NodeUpdateType_FRAME){const nodeUpdateBeforeMap=this._getMaps(this.updateBeforeMap,reference);if(nodeUpdateBeforeMap.frameId!==this.frameId){const previousFrameId=nodeUpdateBeforeMap.frameId;nodeUpdateBeforeMap.frameId=this.frameId,!1===node.updateBefore(this)&&(nodeUpdateBeforeMap.frameId=previousFrameId)}}else if(updateType===NodeUpdateType_RENDER){const nodeUpdateBeforeMap=this._getMaps(this.updateBeforeMap,reference);if(nodeUpdateBeforeMap.renderId!==this.renderId){const previousRenderId=nodeUpdateBeforeMap.renderId;nodeUpdateBeforeMap.renderId=this.renderId,!1===node.updateBefore(this)&&(nodeUpdateBeforeMap.renderId=previousRenderId)}}else updateType===NodeUpdateType_OBJECT&&node.updateBefore(this)}updateAfterNode(node){const updateType=node.getUpdateAfterType(),reference=node.updateReference(this);if(updateType===NodeUpdateType_FRAME){const nodeUpdateAfterMap=this._getMaps(this.updateAfterMap,reference);nodeUpdateAfterMap.frameId!==this.frameId&&!1!==node.updateAfter(this)&&(nodeUpdateAfterMap.frameId=this.frameId)}else if(updateType===NodeUpdateType_RENDER){const nodeUpdateAfterMap=this._getMaps(this.updateAfterMap,reference);nodeUpdateAfterMap.renderId!==this.renderId&&!1!==node.updateAfter(this)&&(nodeUpdateAfterMap.renderId=this.renderId)}else updateType===NodeUpdateType_OBJECT&&node.updateAfter(this)}updateNode(node){const updateType=node.getUpdateType(),reference=node.updateReference(this);if(updateType===NodeUpdateType_FRAME){const nodeUpdateMap=this._getMaps(this.updateMap,reference);nodeUpdateMap.frameId!==this.frameId&&!1!==node.update(this)&&(nodeUpdateMap.frameId=this.frameId)}else if(updateType===NodeUpdateType_RENDER){const nodeUpdateMap=this._getMaps(this.updateMap,reference);nodeUpdateMap.renderId!==this.renderId&&!1!==node.update(this)&&(nodeUpdateMap.renderId=this.renderId)}else updateType===NodeUpdateType_OBJECT&&node.update(this)}update(){this.frameId++,void 0===this.lastTime&&(this.lastTime=performance.now()),this.deltaTime=(performance.now()-this.lastTime)/1e3,this.lastTime=performance.now(),this.time+=this.deltaTime}}class NodeFunctionInput{constructor(type,name,count=null,qualifier="",isConst=!1){this.type=type,this.name=name,this.count=count,this.qualifier=qualifier,this.isConst=isConst}}NodeFunctionInput.isNodeFunctionInput=!0;class AmbientLightNode extends AnalyticLightNode{static get type(){return"AmbientLightNode"}constructor(light=null){super(light)}setup({context:context}){context.irradiance.addAssign(this.colorNode)}}class DirectionalLightNode extends AnalyticLightNode{static get type(){return"DirectionalLightNode"}constructor(light=null){super(light)}setupDirect(){const lightColor=this.colorNode;return{lightDirection:lightTargetDirection(this.light),lightColor:lightColor}}}class HemisphereLightNode extends AnalyticLightNode{static get type(){return"HemisphereLightNode"}constructor(light=null){super(light),this.lightPositionNode=lightPosition(light),this.lightDirectionNode=this.lightPositionNode.normalize(),this.groundColorNode=uniform(new Color).setGroup(renderGroup)}update(frame){const{light:light}=this;super.update(frame),this.lightPositionNode.object3d=light,this.groundColorNode.value.copy(light.groundColor).multiplyScalar(light.intensity)}setup(builder){const{colorNode:colorNode,groundColorNode:groundColorNode,lightDirectionNode:lightDirectionNode}=this,hemiDiffuseWeight=normalWorld.dot(lightDirectionNode).mul(.5).add(.5),irradiance=mix(groundColorNode,colorNode,hemiDiffuseWeight);builder.context.irradiance.addAssign(irradiance)}}class SpotLightNode extends AnalyticLightNode{static get type(){return"SpotLightNode"}constructor(light=null){super(light),this.coneCosNode=uniform(0).setGroup(renderGroup),this.penumbraCosNode=uniform(0).setGroup(renderGroup),this.cutoffDistanceNode=uniform(0).setGroup(renderGroup),this.decayExponentNode=uniform(0).setGroup(renderGroup),this.colorNode=uniform(this.color).setGroup(renderGroup)}update(frame){super.update(frame);const{light:light}=this;this.coneCosNode.value=Math.cos(light.angle),this.penumbraCosNode.value=Math.cos(light.angle*(1-light.penumbra)),this.cutoffDistanceNode.value=light.distance,this.decayExponentNode.value=light.decay}getSpotAttenuation(builder,angleCosine){const{coneCosNode:coneCosNode,penumbraCosNode:penumbraCosNode}=this;return smoothstep(coneCosNode,penumbraCosNode,angleCosine)}getLightCoord(builder){const properties=builder.getNodeProperties(this);let projectionUV=properties.projectionUV;return void 0===projectionUV&&(projectionUV=function lightProjectionUV(light,position=positionWorld){const spotLightCoord=lightShadowMatrix(light).mul(position);return spotLightCoord.xyz.div(spotLightCoord.w)}(this.light,builder.context.positionWorld),properties.projectionUV=projectionUV),projectionUV}setupDirect(builder){const{colorNode:colorNode,cutoffDistanceNode:cutoffDistanceNode,decayExponentNode:decayExponentNode,light:light}=this,lightVector=this.getLightVector(builder),lightDirection=lightVector.normalize(),angleCos=lightDirection.dot(lightTargetDirection(light)),spotAttenuation=this.getSpotAttenuation(builder,angleCos),lightDistance=lightVector.length(),lightAttenuation=getDistanceAttenuation({lightDistance:lightDistance,cutoffDistance:cutoffDistanceNode,decayExponent:decayExponentNode});let projected,lightCoord,lightColor=colorNode.mul(spotAttenuation).mul(lightAttenuation);if(light.colorNode?(lightCoord=this.getLightCoord(builder),projected=light.colorNode(lightCoord)):light.map&&(lightCoord=this.getLightCoord(builder),projected=texture(light.map,lightCoord.xy).onRenderUpdate(()=>light.map)),projected){lightColor=lightCoord.mul(2).sub(1).abs().lessThan(1).all().select(lightColor.mul(projected),lightColor)}return{lightColor:lightColor,lightDirection:lightDirection}}}class IESSpotLightNode extends SpotLightNode{static get type(){return"IESSpotLightNode"}getSpotAttenuation(builder,angleCosine){const iesMap=this.light.iesMap;let spotAttenuation=null;if(iesMap&&!0===iesMap.isTexture){const angle=angleCosine.acos().mul(1/Math.PI);spotAttenuation=texture(iesMap,vec2(angle,0),0).r}else spotAttenuation=super.getSpotAttenuation(angleCosine);return spotAttenuation}}class LightProbeNode extends AnalyticLightNode{static get type(){return"LightProbeNode"}constructor(light=null){super(light);const array=[];for(let i=0;i<9;i++)array.push(new Vector3);this.lightProbe=uniformArray(array)}update(frame){const{light:light}=this;super.update(frame);for(let i=0;i<9;i++)this.lightProbe.array[i].copy(light.sh.coefficients[i]).multiplyScalar(light.intensity)}setup(builder){const irradiance=getShIrradianceAt(normalWorld,this.lightProbe);builder.context.irradiance.addAssign(irradiance)}}const sdBox=/*@__PURE__*/Fn(([p,b])=>{const d=p.abs().sub(b);return length(max$1(d,0)).add(min$1(max$1(d.x,d.y),0))});class ProjectorLightNode extends SpotLightNode{static get type(){return"ProjectorLightNode"}update(frame){super.update(frame);const light=this.light;if(this.penumbraCosNode.value=Math.min(Math.cos(light.angle*(1-light.penumbra)),.99999),null===light.aspect){let aspect=1;null!==light.map&&(aspect=light.map.width/light.map.height),light.shadow.aspect=aspect}else light.shadow.aspect=light.aspect}getSpotAttenuation(builder){const attenuation=float(0),penumbraCos=this.penumbraCosNode,spotLightCoord=lightShadowMatrix(this.light).mul(builder.context.positionWorld||positionWorld);return If(spotLightCoord.w.greaterThan(0),()=>{const projectionUV=spotLightCoord.xyz.div(spotLightCoord.w),boxDist=sdBox(projectionUV.xy.sub(vec2(.5)),vec2(.5)),angleFactor=div(-1,sub(1,acos(penumbraCos)).sub(1));attenuation.assign(saturate(boxDist.mul(-2).mul(angleFactor)))}),attenuation}}const _matrix41=/*@__PURE__*/new Matrix4,_matrix42=/*@__PURE__*/new Matrix4;let _ltcLib=null;class RectAreaLightNode extends AnalyticLightNode{static get type(){return"RectAreaLightNode"}constructor(light=null){super(light),this.halfHeight=uniform(new Vector3).setGroup(renderGroup),this.halfWidth=uniform(new Vector3).setGroup(renderGroup),this.updateType=NodeUpdateType_RENDER}update(frame){super.update(frame);const{light:light}=this,viewMatrix=frame.camera.matrixWorldInverse;_matrix42.identity(),_matrix41.copy(light.matrixWorld),_matrix41.premultiply(viewMatrix),_matrix42.extractRotation(_matrix41),this.halfWidth.value.set(.5*light.width,0,0),this.halfHeight.value.set(0,.5*light.height,0),this.halfWidth.value.applyMatrix4(_matrix42),this.halfHeight.value.applyMatrix4(_matrix42)}setupDirectRectArea(builder){let ltc_1,ltc_2;builder.isAvailable("float32Filterable")?(ltc_1=texture(_ltcLib.LTC_FLOAT_1),ltc_2=texture(_ltcLib.LTC_FLOAT_2)):(ltc_1=texture(_ltcLib.LTC_HALF_1),ltc_2=texture(_ltcLib.LTC_HALF_2));const{colorNode:colorNode,light:light}=this;return{lightColor:colorNode,lightPosition:lightViewPosition(light),halfWidth:this.halfWidth,halfHeight:this.halfHeight,ltc_1:ltc_1,ltc_2:ltc_2}}static setLTC(ltc){_ltcLib=ltc}}class NodeParser{parseFunction(){warn("Abstract function.")}}class NodeFunction{constructor(type,inputs,name="",precision=""){this.type=type,this.inputs=inputs,this.name=name,this.precision=precision}getCode(){warn("Abstract function.")}}NodeFunction.isNodeFunction=!0;const declarationRegexp$1=/^\s*(highp|mediump|lowp)?\s*([a-z_0-9]+)\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)/i,propertiesRegexp$1=/[a-z_0-9]+/gi;class GLSLNodeFunction extends NodeFunction{constructor(source){const{type:type,inputs:inputs,name:name,precision:precision,inputsCode:inputsCode,blockCode:blockCode,headerCode:headerCode}=(source=>{const pragmaMainIndex=(source=source.trim()).indexOf("#pragma main"),mainCode=-1!==pragmaMainIndex?source.slice(pragmaMainIndex+12):source,declaration=mainCode.match(declarationRegexp$1);if(null!==declaration&&5===declaration.length){const inputsCode=declaration[4],propsMatches=[];let nameMatch=null;for(;null!==(nameMatch=propertiesRegexp$1.exec(inputsCode));)propsMatches.push(nameMatch);const inputs=[];let i=0;for(;i<propsMatches.length;){const isConst="const"===propsMatches[i][0];!0===isConst&&i++;let qualifier=propsMatches[i][0];"in"===qualifier||"out"===qualifier||"inout"===qualifier?i++:qualifier="";const type=propsMatches[i++][0];let count=Number.parseInt(propsMatches[i][0]);!1===Number.isNaN(count)?i++:count=null;const name=propsMatches[i++][0];inputs.push(new NodeFunctionInput(type,name,count,qualifier,isConst))}const blockCode=mainCode.substring(declaration[0].length),name=void 0!==declaration[3]?declaration[3]:"";return{type:declaration[2],inputs:inputs,name:name,precision:void 0!==declaration[1]?declaration[1]:"",inputsCode:inputsCode,blockCode:blockCode,headerCode:-1!==pragmaMainIndex?source.slice(0,pragmaMainIndex):""}}throw new Error("FunctionNode: Function is not a GLSL code.")})(source);super(type,inputs,name,precision),this.inputsCode=inputsCode,this.blockCode=blockCode,this.headerCode=headerCode}getCode(name=this.name){let code;const blockCode=this.blockCode;if(""!==blockCode){const{type:type,inputsCode:inputsCode,headerCode:headerCode,precision:precision}=this;let declarationCode=`${type} ${name} ( ${inputsCode.trim()} )`;""!==precision&&(declarationCode=`${precision} ${declarationCode}`),code=headerCode+declarationCode+blockCode}else code="";return code}}class GLSLNodeParser extends NodeParser{parseFunction(source){return new GLSLNodeFunction(source)}}const _outputNodeMap=new WeakMap,_chainKeys$1=[],_cacheKeyValues=[];class NodeManager extends DataMap{constructor(renderer,backend){super(),this.renderer=renderer,this.backend=backend,this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map,this.callHashCache=new ChainMap,this.groupsData=new ChainMap,this.cacheLib={}}updateGroup(nodeUniformsGroup){const groupNode=nodeUniformsGroup.groupNode,name=groupNode.name;if(name===objectGroup.name)return!0;if(name===renderGroup.name){const uniformsGroupData=this.get(nodeUniformsGroup),renderId=this.nodeFrame.renderId;return uniformsGroupData.renderId!==renderId&&(uniformsGroupData.renderId=renderId,!0)}if(name===frameGroup.name){const uniformsGroupData=this.get(nodeUniformsGroup),frameId=this.nodeFrame.frameId;return uniformsGroupData.frameId!==frameId&&(uniformsGroupData.frameId=frameId,!0)}_chainKeys$1[0]=groupNode,_chainKeys$1[1]=nodeUniformsGroup;let groupData=this.groupsData.get(_chainKeys$1);return void 0===groupData&&this.groupsData.set(_chainKeys$1,groupData={}),_chainKeys$1[0]=null,_chainKeys$1[1]=null,groupData.version!==groupNode.version&&(groupData.version=groupNode.version,!0)}getForRenderCacheKey(renderObject){return renderObject.initialCacheKey}getForRender(renderObject){const renderObjectData=this.get(renderObject);let nodeBuilderState=renderObjectData.nodeBuilderState;if(void 0===nodeBuilderState){const{nodeBuilderCache:nodeBuilderCache}=this,cacheKey=this.getForRenderCacheKey(renderObject);if(nodeBuilderState=nodeBuilderCache.get(cacheKey),void 0===nodeBuilderState){const createNodeBuilder=material=>{const nodeBuilder=this.backend.createNodeBuilder(renderObject.object,this.renderer);return nodeBuilder.scene=renderObject.scene,nodeBuilder.material=material,nodeBuilder.camera=renderObject.camera,nodeBuilder.context.material=material,nodeBuilder.lightsNode=renderObject.lightsNode,nodeBuilder.environmentNode=this.getEnvironmentNode(renderObject.scene),nodeBuilder.fogNode=this.getFogNode(renderObject.scene),nodeBuilder.clippingContext=renderObject.clippingContext,this.renderer.getOutputRenderTarget()&&this.renderer.getOutputRenderTarget().multiview&&nodeBuilder.enableMultiview(),nodeBuilder};let nodeBuilder=createNodeBuilder(renderObject.material);try{nodeBuilder.build()}catch(e){nodeBuilder=createNodeBuilder(new NodeMaterial),nodeBuilder.build();let stackTrace=e.stackTrace;!stackTrace&&e.stack&&(stackTrace=new StackTrace(e.stack)),error("TSL: "+e,stackTrace)}nodeBuilderState=this._createNodeBuilderState(nodeBuilder),nodeBuilderCache.set(cacheKey,nodeBuilderState)}nodeBuilderState.usedTimes++,renderObjectData.nodeBuilderState=nodeBuilderState}return nodeBuilderState}delete(object){if(object.isRenderObject){const nodeBuilderState=this.get(object).nodeBuilderState;nodeBuilderState.usedTimes--,0===nodeBuilderState.usedTimes&&this.nodeBuilderCache.delete(this.getForRenderCacheKey(object))}return super.delete(object)}getForCompute(computeNode){const computeData=this.get(computeNode);let nodeBuilderState=computeData.nodeBuilderState;if(void 0===nodeBuilderState){const nodeBuilder=this.backend.createNodeBuilder(computeNode,this.renderer);nodeBuilder.build(),nodeBuilderState=this._createNodeBuilderState(nodeBuilder),computeData.nodeBuilderState=nodeBuilderState}return nodeBuilderState}_createNodeBuilderState(nodeBuilder){return new NodeBuilderState(nodeBuilder.vertexShader,nodeBuilder.fragmentShader,nodeBuilder.computeShader,nodeBuilder.getAttributesArray(),nodeBuilder.getBindings(),nodeBuilder.updateNodes,nodeBuilder.updateBeforeNodes,nodeBuilder.updateAfterNodes,nodeBuilder.observer,nodeBuilder.transforms)}getEnvironmentNode(scene){this.updateEnvironment(scene);let environmentNode=null;if(scene.environmentNode&&scene.environmentNode.isNode)environmentNode=scene.environmentNode;else{const sceneData=this.get(scene);sceneData.environmentNode&&(environmentNode=sceneData.environmentNode)}return environmentNode}getBackgroundNode(scene){this.updateBackground(scene);let backgroundNode=null;if(scene.backgroundNode&&scene.backgroundNode.isNode)backgroundNode=scene.backgroundNode;else{const sceneData=this.get(scene);sceneData.backgroundNode&&(backgroundNode=sceneData.backgroundNode)}return backgroundNode}getFogNode(scene){return this.updateFog(scene),scene.fogNode||this.get(scene).fogNode||null}getCacheKey(scene,lightsNode){_chainKeys$1[0]=scene,_chainKeys$1[1]=lightsNode;const callId=this.renderer.info.calls,cacheKeyData=this.callHashCache.get(_chainKeys$1)||{};if(cacheKeyData.callId!==callId){const environmentNode=this.getEnvironmentNode(scene),fogNode=this.getFogNode(scene);lightsNode&&_cacheKeyValues.push(lightsNode.getCacheKey(!0)),environmentNode&&_cacheKeyValues.push(environmentNode.getCacheKey()),fogNode&&_cacheKeyValues.push(fogNode.getCacheKey()),_cacheKeyValues.push(this.renderer.getOutputRenderTarget()&&this.renderer.getOutputRenderTarget().multiview?1:0),_cacheKeyValues.push(this.renderer.shadowMap.enabled?1:0),_cacheKeyValues.push(this.renderer.shadowMap.type),cacheKeyData.callId=callId,cacheKeyData.cacheKey=hashArray(_cacheKeyValues),this.callHashCache.set(_chainKeys$1,cacheKeyData),_cacheKeyValues.length=0}return _chainKeys$1[0]=null,_chainKeys$1[1]=null,cacheKeyData.cacheKey}get isToneMappingState(){return!this.renderer.getRenderTarget()}updateBackground(scene){const sceneData=this.get(scene),background=scene.background;if(background){const forceUpdate=0===scene.backgroundBlurriness&&sceneData.backgroundBlurriness>0||scene.backgroundBlurriness>0&&0===sceneData.backgroundBlurriness;if(sceneData.background!==background||forceUpdate){const backgroundNode=this.getCacheNode("background",background,()=>{if(!0===background.isCubeTexture||303===background.mapping||304===background.mapping||306===background.mapping){if(scene.backgroundBlurriness>0||306===background.mapping)return pmremTexture(background);{let envMap;return envMap=!0===background.isCubeTexture?cubeTexture(background):texture(background),cubeMapNode(envMap)}}if(!0===background.isTexture)return texture(background,screenUV.flipY()).setUpdateMatrix(!0);!0!==background.isColor&&error("WebGPUNodes: Unsupported background configuration.",background)},forceUpdate);sceneData.backgroundNode=backgroundNode,sceneData.background=background,sceneData.backgroundBlurriness=scene.backgroundBlurriness}}else sceneData.backgroundNode&&(delete sceneData.backgroundNode,delete sceneData.background)}getCacheNode(type,object,callback,forceUpdate=!1){const nodeCache=this.cacheLib[type]||(this.cacheLib[type]=new WeakMap);let node=nodeCache.get(object);return(void 0===node||forceUpdate)&&(node=callback(),nodeCache.set(object,node)),node}updateFog(scene){const sceneData=this.get(scene),sceneFog=scene.fog;if(sceneFog){if(sceneData.fog!==sceneFog){const fogNode=this.getCacheNode("fog",sceneFog,()=>{if(sceneFog.isFogExp2){const color=reference("color","color",sceneFog).setGroup(renderGroup),density=reference("density","float",sceneFog).setGroup(renderGroup);return fog(color,densityFogFactor(density))}if(sceneFog.isFog){const color=reference("color","color",sceneFog).setGroup(renderGroup),near=reference("near","float",sceneFog).setGroup(renderGroup),far=reference("far","float",sceneFog).setGroup(renderGroup);return fog(color,rangeFogFactor(near,far))}error("Renderer: Unsupported fog configuration.",sceneFog)});sceneData.fogNode=fogNode,sceneData.fog=sceneFog}}else delete sceneData.fogNode,delete sceneData.fog}updateEnvironment(scene){const sceneData=this.get(scene),environment=scene.environment;if(environment){if(sceneData.environment!==environment){const environmentNode=this.getCacheNode("environment",environment,()=>!0===environment.isCubeTexture?cubeTexture(environment):!0===environment.isTexture?texture(environment):void error("Nodes: Unsupported environment configuration.",environment));sceneData.environmentNode=environmentNode,sceneData.environment=environment}}else sceneData.environmentNode&&(delete sceneData.environmentNode,delete sceneData.environment)}getNodeFrame(renderer=this.renderer,scene=null,object=null,camera=null,material=null){const nodeFrame=this.nodeFrame;return nodeFrame.renderer=renderer,nodeFrame.scene=scene,nodeFrame.object=object,nodeFrame.camera=camera,nodeFrame.material=material,nodeFrame}getNodeFrameForRender(renderObject){return this.getNodeFrame(renderObject.renderer,renderObject.scene,renderObject.object,renderObject.camera,renderObject.material)}getOutputCacheKey(){const renderer=this.renderer;return renderer.toneMapping+","+renderer.currentColorSpace+","+renderer.xr.isPresenting}hasOutputChange(outputTarget){return _outputNodeMap.get(outputTarget)!==this.getOutputCacheKey()}getOutputNode(outputTarget){const renderer=this.renderer,cacheKey=this.getOutputCacheKey(),output=outputTarget.isArrayTexture?texture3D(outputTarget,vec3(screenUV,builtin("gl_ViewID_OVR"))).renderOutput(renderer.toneMapping,renderer.currentColorSpace):texture(outputTarget,screenUV).renderOutput(renderer.toneMapping,renderer.currentColorSpace);return _outputNodeMap.set(outputTarget,cacheKey),output}updateBefore(renderObject){const nodeBuilder=renderObject.getNodeBuilderState();for(const node of nodeBuilder.updateBeforeNodes)this.getNodeFrameForRender(renderObject).updateBeforeNode(node)}updateAfter(renderObject){const nodeBuilder=renderObject.getNodeBuilderState();for(const node of nodeBuilder.updateAfterNodes)this.getNodeFrameForRender(renderObject).updateAfterNode(node)}updateForCompute(computeNode){const nodeFrame=this.getNodeFrame(),nodeBuilder=this.getForCompute(computeNode);for(const node of nodeBuilder.updateNodes)nodeFrame.updateNode(node)}updateForRender(renderObject){const nodeFrame=this.getNodeFrameForRender(renderObject),nodeBuilder=renderObject.getNodeBuilderState();for(const node of nodeBuilder.updateNodes)nodeFrame.updateNode(node)}needsRefresh(renderObject){const nodeFrame=this.getNodeFrameForRender(renderObject);return renderObject.getMonitor().needsRefresh(renderObject,nodeFrame)}dispose(){super.dispose(),this.nodeFrame=new NodeFrame,this.nodeBuilderCache=new Map,this.cacheLib={}}}const _plane$1=/*@__PURE__*/new Plane;class ClippingContext{constructor(parentContext=null){this.version=0,this.clipIntersection=null,this.cacheKey="",this.shadowPass=!1,this.viewNormalMatrix=new Matrix3,this.clippingGroupContexts=new WeakMap,this.intersectionPlanes=[],this.unionPlanes=[],this.parentVersion=null,null!==parentContext&&(this.viewNormalMatrix=parentContext.viewNormalMatrix,this.clippingGroupContexts=parentContext.clippingGroupContexts,this.shadowPass=parentContext.shadowPass,this.viewMatrix=parentContext.viewMatrix)}projectPlanes(source,destination,offset){const l=source.length;for(let i=0;i<l;i++){_plane$1.copy(source[i]).applyMatrix4(this.viewMatrix,this.viewNormalMatrix);const v=destination[offset+i],normal=_plane$1.normal;v.x=-normal.x,v.y=-normal.y,v.z=-normal.z,v.w=_plane$1.constant}}updateGlobal(scene,camera){this.shadowPass=null!==scene.overrideMaterial&&scene.overrideMaterial.isShadowPassMaterial,this.viewMatrix=camera.matrixWorldInverse,this.viewNormalMatrix.getNormalMatrix(this.viewMatrix)}update(parentContext,clippingGroup){let update=!1;parentContext.version!==this.parentVersion&&(this.intersectionPlanes=Array.from(parentContext.intersectionPlanes),this.unionPlanes=Array.from(parentContext.unionPlanes),this.parentVersion=parentContext.version),this.clipIntersection!==clippingGroup.clipIntersection&&(this.clipIntersection=clippingGroup.clipIntersection,this.clipIntersection?this.unionPlanes.length=parentContext.unionPlanes.length:this.intersectionPlanes.length=parentContext.intersectionPlanes.length);const srcClippingPlanes=clippingGroup.clippingPlanes,l=srcClippingPlanes.length;let dstClippingPlanes,offset;if(this.clipIntersection?(dstClippingPlanes=this.intersectionPlanes,offset=parentContext.intersectionPlanes.length):(dstClippingPlanes=this.unionPlanes,offset=parentContext.unionPlanes.length),dstClippingPlanes.length!==offset+l){dstClippingPlanes.length=offset+l;for(let i=0;i<l;i++)dstClippingPlanes[offset+i]=new Vector4;update=!0}this.projectPlanes(srcClippingPlanes,dstClippingPlanes,offset),update&&(this.version++,this.cacheKey=`${this.intersectionPlanes.length}:${this.unionPlanes.length}`)}getGroupContext(clippingGroup){if(this.shadowPass&&!clippingGroup.clipShadows)return this;let context=this.clippingGroupContexts.get(clippingGroup);return void 0===context&&(context=new ClippingContext(this),this.clippingGroupContexts.set(clippingGroup,context)),context.update(this,clippingGroup),context}get unionClippingCount(){return this.unionPlanes.length}}class RenderBundle{constructor(bundleGroup,camera){this.bundleGroup=bundleGroup,this.camera=camera}}const _chainKeys=[];class RenderBundles{constructor(){this.bundles=new ChainMap}get(bundleGroup,camera){const bundles=this.bundles;_chainKeys[0]=bundleGroup,_chainKeys[1]=camera;let bundle=bundles.get(_chainKeys);return void 0===bundle&&(bundle=new RenderBundle(bundleGroup,camera),bundles.set(_chainKeys,bundle)),_chainKeys[0]=null,_chainKeys[1]=null,bundle}dispose(){this.bundles=new ChainMap}}class NodeLibrary{constructor(){this.lightNodes=new WeakMap,this.materialNodes=new Map,this.toneMappingNodes=new Map}fromMaterial(material){if(material.isNodeMaterial)return material;let nodeMaterial=null;const nodeMaterialClass=this.getMaterialNodeClass(material.type);if(null!==nodeMaterialClass){nodeMaterial=new nodeMaterialClass;for(const key in material)nodeMaterial[key]=material[key]}return nodeMaterial}addToneMapping(toneMappingNode,toneMapping){this.addType(toneMappingNode,toneMapping,this.toneMappingNodes)}getToneMappingFunction(toneMapping){return this.toneMappingNodes.get(toneMapping)||null}getMaterialNodeClass(materialType){return this.materialNodes.get(materialType)||null}addMaterial(materialNodeClass,materialClassType){this.addType(materialNodeClass,materialClassType,this.materialNodes)}getLightNodeClass(light){return this.lightNodes.get(light)||null}addLight(lightNodeClass,lightClass){this.addClass(lightNodeClass,lightClass,this.lightNodes)}addType(nodeClass,type,library){if(library.has(type))warn(`Redefinition of node ${type}`);else{if("function"!=typeof nodeClass)throw new Error(`Node class ${nodeClass.name} is not a class.`);if("function"==typeof type||"object"==typeof type)throw new Error(`Base class ${type} is not a class.`);library.set(type,nodeClass)}}addClass(nodeClass,baseClass,library){if(library.has(baseClass))warn(`Redefinition of node ${baseClass.name}`);else{if("function"!=typeof nodeClass)throw new Error(`Node class ${nodeClass.name} is not a class.`);if("function"!=typeof baseClass)throw new Error(`Base class ${baseClass.name} is not a class.`);library.set(baseClass,nodeClass)}}}const _defaultLights=/*@__PURE__*/new LightsNode,_weakMap=/*@__PURE__*/new WeakMap;class Lighting{createNode(lights=[]){return(new LightsNode).setLights(lights)}getNode(scene){if(scene.isQuadMesh)return _defaultLights;let node=_weakMap.get(scene);return void 0===node&&(node=this.createNode(),_weakMap.set(scene,node)),node}}class XRRenderTarget extends RenderTarget{constructor(width=1,height=1,options={}){super(width,height,options),this.isXRRenderTarget=!0,this._hasExternalTextures=!1,this._autoAllocateDepthBuffer=!0,this._isOpaqueFramebuffer=!1}copy(source){return super.copy(source),this._hasExternalTextures=source._hasExternalTextures,this._autoAllocateDepthBuffer=source._autoAllocateDepthBuffer,this._isOpaqueFramebuffer=source._isOpaqueFramebuffer,this}}const _cameraLPos=/*@__PURE__*/new Vector3,_cameraRPos=/*@__PURE__*/new Vector3;class XRManager extends EventDispatcher{constructor(renderer,multiview=!1){super(),this.enabled=!1,this.isPresenting=!1,this.cameraAutoUpdate=!0,this._renderer=renderer,this._cameraL=new PerspectiveCamera,this._cameraL.viewport=new Vector4,this._cameraR=new PerspectiveCamera,this._cameraR.viewport=new Vector4,this._cameras=[this._cameraL,this._cameraR],this._cameraXR=new ArrayCamera,this._currentDepthNear=null,this._currentDepthFar=null,this._controllers=[],this._controllerInputSources=[],this._xrRenderTarget=null,this._layers=[],this._sessionUsesLayers=!1,this._supportsGlBinding="undefined"!=typeof XRWebGLBinding,this._frameBufferTargets=null,this._createXRLayer=createXRLayer.bind(this),this._gl=null,this._currentAnimationContext=null,this._currentAnimationLoop=null,this._currentPixelRatio=null,this._currentSize=new Vector2,this._onSessionEvent=onSessionEvent.bind(this),this._onSessionEnd=onSessionEnd.bind(this),this._onInputSourcesChange=onInputSourcesChange.bind(this),this._onAnimationFrame=onAnimationFrame.bind(this),this._referenceSpace=null,this._referenceSpaceType="local-floor",this._customReferenceSpace=null,this._framebufferScaleFactor=1,this._foveation=1,this._session=null,this._glBaseLayer=null,this._glBinding=null,this._glProjLayer=null,this._xrFrame=null,this._supportsLayers=this._supportsGlBinding&&"createProjectionLayer"in XRWebGLBinding.prototype,this._useMultiviewIfPossible=multiview,this._useMultiview=!1}getController(index){return this._getController(index).getTargetRaySpace()}getControllerGrip(index){return this._getController(index).getGripSpace()}getHand(index){return this._getController(index).getHandSpace()}getFoveation(){if(null!==this._glProjLayer||null!==this._glBaseLayer)return this._foveation}setFoveation(foveation){this._foveation=foveation,null!==this._glProjLayer&&(this._glProjLayer.fixedFoveation=foveation),null!==this._glBaseLayer&&void 0!==this._glBaseLayer.fixedFoveation&&(this._glBaseLayer.fixedFoveation=foveation)}getFramebufferScaleFactor(){return this._framebufferScaleFactor}setFramebufferScaleFactor(factor){this._framebufferScaleFactor=factor,!0===this.isPresenting&&warn("XRManager: Cannot change framebuffer scale while presenting.")}getReferenceSpaceType(){return this._referenceSpaceType}setReferenceSpaceType(type){this._referenceSpaceType=type,!0===this.isPresenting&&warn("XRManager: Cannot change reference space type while presenting.")}getReferenceSpace(){return this._customReferenceSpace||this._referenceSpace}setReferenceSpace(space){this._customReferenceSpace=space}getCamera(){return this._cameraXR}getEnvironmentBlendMode(){if(null!==this._session)return this._session.environmentBlendMode}getBinding(){return null===this._glBinding&&this._supportsGlBinding&&(this._glBinding=new XRWebGLBinding(this._session,this._gl)),this._glBinding}getFrame(){return this._xrFrame}useMultiview(){return this._useMultiview}createQuadLayer(width,height,translation,quaternion,pixelwidth,pixelheight,rendercall,attributes={}){const geometry=new PlaneGeometry(width,height),renderTarget=new XRRenderTarget(pixelwidth,pixelheight,{format:1023,type:1009,depthTexture:new DepthTexture(pixelwidth,pixelheight,attributes.stencil?1020:1014,void 0,void 0,void 0,void 0,void 0,void 0,attributes.stencil?1027:1026),stencilBuffer:attributes.stencil,resolveDepthBuffer:!1,resolveStencilBuffer:!1});renderTarget._autoAllocateDepthBuffer=!0;const material=new MeshBasicMaterial({color:16777215,side:0});material.map=renderTarget.texture,material.map.offset.y=1,material.map.repeat.y=-1;const plane=new Mesh(geometry,material);plane.position.copy(translation),plane.quaternion.copy(quaternion);const layer={type:"quad",width:width,height:height,translation:translation,quaternion:quaternion,pixelwidth:pixelwidth,pixelheight:pixelheight,plane:plane,material:material,rendercall:rendercall,renderTarget:renderTarget};if(this._layers.push(layer),null!==this._session){layer.plane.material=new MeshBasicMaterial({color:16777215,side:0}),layer.plane.material.blending=5,layer.plane.material.blendEquation=100,layer.plane.material.blendSrc=200,layer.plane.material.blendDst=200,layer.xrlayer=this._createXRLayer(layer);const xrlayers=this._session.renderState.layers;xrlayers.unshift(layer.xrlayer),this._session.updateRenderState({layers:xrlayers})}else renderTarget.isXRRenderTarget=!1;return plane}createCylinderLayer(radius,centralAngle,aspectratio,translation,quaternion,pixelwidth,pixelheight,rendercall,attributes={}){const geometry=new CylinderGeometry(radius,radius,radius*centralAngle/aspectratio,64,64,!0,Math.PI-centralAngle/2,centralAngle),renderTarget=new XRRenderTarget(pixelwidth,pixelheight,{format:1023,type:1009,depthTexture:new DepthTexture(pixelwidth,pixelheight,attributes.stencil?1020:1014,void 0,void 0,void 0,void 0,void 0,void 0,attributes.stencil?1027:1026),stencilBuffer:attributes.stencil,resolveDepthBuffer:!1,resolveStencilBuffer:!1});renderTarget._autoAllocateDepthBuffer=!0;const material=new MeshBasicMaterial({color:16777215,side:1});material.map=renderTarget.texture,material.map.offset.y=1,material.map.repeat.y=-1;const plane=new Mesh(geometry,material);plane.position.copy(translation),plane.quaternion.copy(quaternion);const layer={type:"cylinder",radius:radius,centralAngle:centralAngle,aspectratio:aspectratio,translation:translation,quaternion:quaternion,pixelwidth:pixelwidth,pixelheight:pixelheight,plane:plane,material:material,rendercall:rendercall,renderTarget:renderTarget};if(this._layers.push(layer),null!==this._session){layer.plane.material=new MeshBasicMaterial({color:16777215,side:1}),layer.plane.material.blending=5,layer.plane.material.blendEquation=100,layer.plane.material.blendSrc=200,layer.plane.material.blendDst=200,layer.xrlayer=this._createXRLayer(layer);const xrlayers=this._session.renderState.layers;xrlayers.unshift(layer.xrlayer),this._session.updateRenderState({layers:xrlayers})}else renderTarget.isXRRenderTarget=!1;return plane}renderLayers(){const translationObject=new Vector3,quaternionObject=new Quaternion,renderer=this._renderer,wasPresenting=this.isPresenting,rendererOutputTarget=renderer.getOutputRenderTarget(),rendererFramebufferTarget=renderer._frameBufferTarget;this.isPresenting=!1;const rendererSize=new Vector2;renderer.getSize(rendererSize);const rendererQuad=renderer._quad;for(const layer of this._layers)if(layer.renderTarget.isXRRenderTarget=null!==this._session,layer.renderTarget._hasExternalTextures=layer.renderTarget.isXRRenderTarget,layer.renderTarget.isXRRenderTarget&&this._sessionUsesLayers){layer.xrlayer.transform=new XRRigidTransform(layer.plane.getWorldPosition(translationObject),layer.plane.getWorldQuaternion(quaternionObject));const glSubImage=this._glBinding.getSubImage(layer.xrlayer,this._xrFrame);renderer.backend.setXRRenderTargetTextures(layer.renderTarget,glSubImage.colorTexture,void 0),renderer._setXRLayerSize(layer.renderTarget.width,layer.renderTarget.height),renderer.setOutputRenderTarget(layer.renderTarget),renderer.setRenderTarget(null),renderer._frameBufferTarget=null,this._frameBufferTargets||(this._frameBufferTargets=new WeakMap);const{frameBufferTarget:frameBufferTarget,quad:quad}=this._frameBufferTargets.get(layer.renderTarget)||{frameBufferTarget:null,quad:null};frameBufferTarget?(renderer._frameBufferTarget=frameBufferTarget,renderer._quad=quad):(renderer._quad=new QuadMesh(new NodeMaterial),this._frameBufferTargets.set(layer.renderTarget,{frameBufferTarget:renderer._getFrameBufferTarget(),quad:renderer._quad})),layer.rendercall(),renderer._frameBufferTarget=null}else renderer.setRenderTarget(layer.renderTarget),layer.rendercall();renderer.setRenderTarget(null),renderer.setOutputRenderTarget(rendererOutputTarget),renderer._frameBufferTarget=rendererFramebufferTarget,renderer._setXRLayerSize(rendererSize.x,rendererSize.y),renderer._quad=rendererQuad,this.isPresenting=wasPresenting}getSession(){return this._session}async setSession(session){const renderer=this._renderer,backend=renderer.backend;this._gl=renderer.getContext();const gl=this._gl,attributes=gl.getContextAttributes();if(this._session=session,null!==session){if(!0===backend.isWebGPUBackend)throw new Error('THREE.XRManager: XR is currently not supported with a WebGPU backend. Use WebGL by passing "{ forceWebGL: true }" to the constructor of the renderer.');if(session.addEventListener("select",this._onSessionEvent),session.addEventListener("selectstart",this._onSessionEvent),session.addEventListener("selectend",this._onSessionEvent),session.addEventListener("squeeze",this._onSessionEvent),session.addEventListener("squeezestart",this._onSessionEvent),session.addEventListener("squeezeend",this._onSessionEvent),session.addEventListener("end",this._onSessionEnd),session.addEventListener("inputsourceschange",this._onInputSourcesChange),await backend.makeXRCompatible(),this._currentPixelRatio=renderer.getPixelRatio(),renderer.getSize(this._currentSize),this._currentAnimationContext=renderer._animation.getContext(),this._currentAnimationLoop=renderer._animation.getAnimationLoop(),renderer._animation.stop(),!0===this._supportsLayers){let depthFormat=null,depthType=null,glDepthFormat=null;renderer.depth&&(glDepthFormat=renderer.stencil?gl.DEPTH24_STENCIL8:gl.DEPTH_COMPONENT24,depthFormat=renderer.stencil?1027:1026,depthType=renderer.stencil?1020:1014);const projectionlayerInit={colorFormat:gl.RGBA8,depthFormat:glDepthFormat,scaleFactor:this._framebufferScaleFactor,clearOnAccess:!1};this._useMultiviewIfPossible&&renderer.hasFeature("OVR_multiview2")&&(projectionlayerInit.textureType="texture-array",this._useMultiview=!0),this._glBinding=this.getBinding();const glProjLayer=this._glBinding.createProjectionLayer(projectionlayerInit),layersArray=[glProjLayer];this._glProjLayer=glProjLayer,renderer.setPixelRatio(1),renderer._setXRLayerSize(glProjLayer.textureWidth,glProjLayer.textureHeight);const depth=this._useMultiview?2:1,depthTexture=new DepthTexture(glProjLayer.textureWidth,glProjLayer.textureHeight,depthType,void 0,void 0,void 0,void 0,void 0,void 0,depthFormat,depth);if(this._xrRenderTarget=new XRRenderTarget(glProjLayer.textureWidth,glProjLayer.textureHeight,{format:1023,type:1009,colorSpace:renderer.outputColorSpace,depthTexture:depthTexture,stencilBuffer:renderer.stencil,samples:attributes.antialias?4:0,resolveDepthBuffer:!1===glProjLayer.ignoreDepthValues,resolveStencilBuffer:!1===glProjLayer.ignoreDepthValues,depth:this._useMultiview?2:1,multiview:this._useMultiview}),this._xrRenderTarget._hasExternalTextures=!0,this._xrRenderTarget.depth=this._useMultiview?2:1,this._sessionUsesLayers=session.enabledFeatures.includes("layers"),this._referenceSpace=await session.requestReferenceSpace(this.getReferenceSpaceType()),this._sessionUsesLayers)for(const layer of this._layers)layer.plane.material=new MeshBasicMaterial({color:16777215,side:"cylinder"===layer.type?1:0}),layer.plane.material.blending=5,layer.plane.material.blendEquation=100,layer.plane.material.blendSrc=200,layer.plane.material.blendDst=200,layer.xrlayer=this._createXRLayer(layer),layersArray.unshift(layer.xrlayer);session.updateRenderState({layers:layersArray})}else{const layerInit={antialias:renderer.currentSamples>0,alpha:!0,depth:renderer.depth,stencil:renderer.stencil,framebufferScaleFactor:this.getFramebufferScaleFactor()},glBaseLayer=new XRWebGLLayer(session,gl,layerInit);this._glBaseLayer=glBaseLayer,session.updateRenderState({baseLayer:glBaseLayer}),renderer.setPixelRatio(1),renderer._setXRLayerSize(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight),this._xrRenderTarget=new XRRenderTarget(glBaseLayer.framebufferWidth,glBaseLayer.framebufferHeight,{format:1023,type:1009,colorSpace:renderer.outputColorSpace,stencilBuffer:renderer.stencil,resolveDepthBuffer:!1===glBaseLayer.ignoreDepthValues,resolveStencilBuffer:!1===glBaseLayer.ignoreDepthValues}),this._xrRenderTarget._isOpaqueFramebuffer=!0,this._referenceSpace=await session.requestReferenceSpace(this.getReferenceSpaceType())}this.setFoveation(this.getFoveation()),renderer._animation.setAnimationLoop(this._onAnimationFrame),renderer._animation.setContext(session),renderer._animation.start(),this.isPresenting=!0,this.dispatchEvent({type:"sessionstart"})}}updateCamera(camera){const session=this._session;if(null===session)return;const depthNear=camera.near,depthFar=camera.far,cameraXR=this._cameraXR,cameraL=this._cameraL,cameraR=this._cameraR;cameraXR.near=cameraR.near=cameraL.near=depthNear,cameraXR.far=cameraR.far=cameraL.far=depthFar,cameraXR.isMultiViewCamera=this._useMultiview,this._currentDepthNear===cameraXR.near&&this._currentDepthFar===cameraXR.far||(session.updateRenderState({depthNear:cameraXR.near,depthFar:cameraXR.far}),this._currentDepthNear=cameraXR.near,this._currentDepthFar=cameraXR.far),cameraXR.layers.mask=6|camera.layers.mask,cameraL.layers.mask=-5&cameraXR.layers.mask,cameraR.layers.mask=-3&cameraXR.layers.mask;const parent=camera.parent,cameras=cameraXR.cameras;updateCamera(cameraXR,parent);for(let i=0;i<cameras.length;i++)updateCamera(cameras[i],parent);2===cameras.length?function setProjectionFromUnion(camera,cameraL,cameraR){_cameraLPos.setFromMatrixPosition(cameraL.matrixWorld),_cameraRPos.setFromMatrixPosition(cameraR.matrixWorld);const ipd=_cameraLPos.distanceTo(_cameraRPos),projL=cameraL.projectionMatrix.elements,projR=cameraR.projectionMatrix.elements,near=projL[14]/(projL[10]-1),far=projL[14]/(projL[10]+1),topFov=(projL[9]+1)/projL[5],bottomFov=(projL[9]-1)/projL[5],leftFov=(projL[8]-1)/projL[0],rightFov=(projR[8]+1)/projR[0],left=near*leftFov,right=near*rightFov,zOffset=ipd/(-leftFov+rightFov),xOffset=zOffset*-leftFov;if(cameraL.matrixWorld.decompose(camera.position,camera.quaternion,camera.scale),camera.translateX(xOffset),camera.translateZ(zOffset),camera.matrixWorld.compose(camera.position,camera.quaternion,camera.scale),camera.matrixWorldInverse.copy(camera.matrixWorld).invert(),-1===projL[10])camera.projectionMatrix.copy(cameraL.projectionMatrix),camera.projectionMatrixInverse.copy(cameraL.projectionMatrixInverse);else{const near2=near+zOffset,far2=far+zOffset,left2=left-xOffset,right2=right+(ipd-xOffset),top2=topFov*far/far2*near2,bottom2=bottomFov*far/far2*near2;camera.projectionMatrix.makePerspective(left2,right2,top2,bottom2,near2,far2),camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert()}}(cameraXR,cameraL,cameraR):cameraXR.projectionMatrix.copy(cameraL.projectionMatrix),function updateUserCamera(camera,cameraXR,parent){null===parent?camera.matrix.copy(cameraXR.matrixWorld):(camera.matrix.copy(parent.matrixWorld),camera.matrix.invert(),camera.matrix.multiply(cameraXR.matrixWorld));camera.matrix.decompose(camera.position,camera.quaternion,camera.scale),camera.updateMatrixWorld(!0),camera.projectionMatrix.copy(cameraXR.projectionMatrix),camera.projectionMatrixInverse.copy(cameraXR.projectionMatrixInverse),camera.isPerspectiveCamera&&(camera.fov=2*RAD2DEG*Math.atan(1/camera.projectionMatrix.elements[5]),camera.zoom=1)}(camera,cameraXR,parent)}_getController(index){let controller=this._controllers[index];return void 0===controller&&(controller=new WebXRController,this._controllers[index]=controller),controller}}function updateCamera(camera,parent){null===parent?camera.matrixWorld.copy(camera.matrix):camera.matrixWorld.multiplyMatrices(parent.matrixWorld,camera.matrix),camera.matrixWorldInverse.copy(camera.matrixWorld).invert()}function onSessionEvent(event){const controllerIndex=this._controllerInputSources.indexOf(event.inputSource);if(-1===controllerIndex)return;const controller=this._controllers[controllerIndex];if(void 0!==controller){const referenceSpace=this.getReferenceSpace();controller.update(event.inputSource,event.frame,referenceSpace),controller.dispatchEvent({type:event.type,data:event.inputSource})}}function onSessionEnd(){const session=this._session,renderer=this._renderer;session.removeEventListener("select",this._onSessionEvent),session.removeEventListener("selectstart",this._onSessionEvent),session.removeEventListener("selectend",this._onSessionEvent),session.removeEventListener("squeeze",this._onSessionEvent),session.removeEventListener("squeezestart",this._onSessionEvent),session.removeEventListener("squeezeend",this._onSessionEvent),session.removeEventListener("end",this._onSessionEnd),session.removeEventListener("inputsourceschange",this._onInputSourcesChange);for(let i=0;i<this._controllers.length;i++){const inputSource=this._controllerInputSources[i];null!==inputSource&&(this._controllerInputSources[i]=null,this._controllers[i].disconnect(inputSource))}if(this._currentDepthNear=null,this._currentDepthFar=null,renderer._resetXRState(),this._session=null,this._xrRenderTarget=null,this._glBinding=null,this._glBaseLayer=null,this._glProjLayer=null,!0===this._sessionUsesLayers)for(const layer of this._layers)layer.renderTarget=new XRRenderTarget(layer.pixelwidth,layer.pixelheight,{format:1023,type:1009,depthTexture:new DepthTexture(layer.pixelwidth,layer.pixelheight,layer.stencilBuffer?1020:1014,void 0,void 0,void 0,void 0,void 0,void 0,layer.stencilBuffer?1027:1026),stencilBuffer:layer.stencilBuffer,resolveDepthBuffer:!1,resolveStencilBuffer:!1}),layer.renderTarget.isXRRenderTarget=!1,layer.plane.material=layer.material,layer.material.map=layer.renderTarget.texture,layer.material.map.offset.y=1,layer.material.map.repeat.y=-1,delete layer.xrlayer;this.isPresenting=!1,this._useMultiview=!1,renderer._animation.stop(),renderer._animation.setAnimationLoop(this._currentAnimationLoop),renderer._animation.setContext(this._currentAnimationContext),renderer._animation.start(),renderer.setPixelRatio(this._currentPixelRatio),renderer.setSize(this._currentSize.width,this._currentSize.height,!1),this.dispatchEvent({type:"sessionend"})}function onInputSourcesChange(event){const controllers=this._controllers,controllerInputSources=this._controllerInputSources;for(let i=0;i<event.removed.length;i++){const inputSource=event.removed[i],index=controllerInputSources.indexOf(inputSource);index>=0&&(controllerInputSources[index]=null,controllers[index].disconnect(inputSource))}for(let i=0;i<event.added.length;i++){const inputSource=event.added[i];let controllerIndex=controllerInputSources.indexOf(inputSource);if(-1===controllerIndex){for(let i=0;i<controllers.length;i++){if(i>=controllerInputSources.length){controllerInputSources.push(inputSource),controllerIndex=i;break}if(null===controllerInputSources[i]){controllerInputSources[i]=inputSource,controllerIndex=i;break}}if(-1===controllerIndex)break}const controller=controllers[controllerIndex];controller&&controller.connect(inputSource)}}function createXRLayer(layer){return"quad"===layer.type?this._glBinding.createQuadLayer({transform:new XRRigidTransform(layer.translation,layer.quaternion),width:layer.width/2,height:layer.height/2,space:this._referenceSpace,viewPixelWidth:layer.pixelwidth,viewPixelHeight:layer.pixelheight,clearOnAccess:!1}):this._glBinding.createCylinderLayer({transform:new XRRigidTransform(layer.translation,layer.quaternion),radius:layer.radius,centralAngle:layer.centralAngle,aspectRatio:layer.aspectRatio,space:this._referenceSpace,viewPixelWidth:layer.pixelwidth,viewPixelHeight:layer.pixelheight,clearOnAccess:!1})}function onAnimationFrame(time,frame){if(void 0===frame)return;const cameraXR=this._cameraXR,renderer=this._renderer,backend=renderer.backend,glBaseLayer=this._glBaseLayer,referenceSpace=this.getReferenceSpace(),pose=frame.getViewerPose(referenceSpace);if(this._xrFrame=frame,null!==pose){const views=pose.views;null!==this._glBaseLayer&&backend.setXRTarget(glBaseLayer.framebuffer);let cameraXRNeedsUpdate=!1;views.length!==cameraXR.cameras.length&&(cameraXR.cameras.length=0,cameraXRNeedsUpdate=!0);for(let i=0;i<views.length;i++){const view=views[i];let viewport;if(!0===this._supportsLayers){const glSubImage=this._glBinding.getViewSubImage(this._glProjLayer,view);viewport=glSubImage.viewport,0===i&&backend.setXRRenderTargetTextures(this._xrRenderTarget,glSubImage.colorTexture,this._glProjLayer.ignoreDepthValues&&!this._useMultiview?void 0:glSubImage.depthStencilTexture)}else viewport=glBaseLayer.getViewport(view);let camera=this._cameras[i];void 0===camera&&(camera=new PerspectiveCamera,camera.layers.enable(i),camera.viewport=new Vector4,this._cameras[i]=camera),camera.matrix.fromArray(view.transform.matrix),camera.matrix.decompose(camera.position,camera.quaternion,camera.scale),camera.projectionMatrix.fromArray(view.projectionMatrix),camera.projectionMatrixInverse.copy(camera.projectionMatrix).invert(),camera.viewport.set(viewport.x,viewport.y,viewport.width,viewport.height),0===i&&(cameraXR.matrix.copy(camera.matrix),cameraXR.matrix.decompose(cameraXR.position,cameraXR.quaternion,cameraXR.scale)),!0===cameraXRNeedsUpdate&&cameraXR.cameras.push(camera)}renderer.setOutputRenderTarget(this._xrRenderTarget)}for(let i=0;i<this._controllers.length;i++){const inputSource=this._controllerInputSources[i],controller=this._controllers[i];null!==inputSource&&void 0!==controller&&controller.update(inputSource,frame,referenceSpace)}this._currentAnimationLoop&&this._currentAnimationLoop(time,frame),frame.detectedPlanes&&this.dispatchEvent({type:"planesdetected",data:frame}),this._xrFrame=null}class CanvasTarget extends EventDispatcher{constructor(domElement){super(),this.domElement=domElement,this._pixelRatio=1,this._width=this.domElement.width,this._height=this.domElement.height,this._viewport=new Vector4(0,0,this._width,this._height),this._scissor=new Vector4(0,0,this._width,this._height),this._scissorTest=!1,this.colorTexture=new FramebufferTexture,this.depthTexture=new DepthTexture}getPixelRatio(){return this._pixelRatio}getDrawingBufferSize(target){return target.set(this._width*this._pixelRatio,this._height*this._pixelRatio).floor()}getSize(target){return target.set(this._width,this._height)}setPixelRatio(value=1){this._pixelRatio!==value&&(this._pixelRatio=value,this.setSize(this._width,this._height,!1))}setDrawingBufferSize(width,height,pixelRatio){this.xr&&this.xr.isPresenting||(this._width=width,this._height=height,this._pixelRatio=pixelRatio,this.domElement.width=Math.floor(width*pixelRatio),this.domElement.height=Math.floor(height*pixelRatio),this.setViewport(0,0,width,height),this._dispatchResize())}setSize(width,height,updateStyle=!0){this.xr&&this.xr.isPresenting||(this._width=width,this._height=height,this.domElement.width=Math.floor(width*this._pixelRatio),this.domElement.height=Math.floor(height*this._pixelRatio),!0===updateStyle&&(this.domElement.style.width=width+"px",this.domElement.style.height=height+"px"),this.setViewport(0,0,width,height),this._dispatchResize())}getScissor(target){const scissor=this._scissor;return target.x=scissor.x,target.y=scissor.y,target.width=scissor.width,target.height=scissor.height,target}setScissor(x,y,width,height){const scissor=this._scissor;x.isVector4?scissor.copy(x):scissor.set(x,y,width,height)}getScissorTest(){return this._scissorTest}setScissorTest(boolean){this._scissorTest=boolean}getViewport(target){return target.copy(this._viewport)}setViewport(x,y,width,height,minDepth=0,maxDepth=1){const viewport=this._viewport;x.isVector4?viewport.copy(x):viewport.set(x,y,width,height),viewport.minDepth=minDepth,viewport.maxDepth=maxDepth}_dispatchResize(){this.dispatchEvent({type:"resize"})}dispose(){this.dispatchEvent({type:"dispose"})}}const _scene=/*@__PURE__*/new Scene,_drawingBufferSize=/*@__PURE__*/new Vector2,_screen=/*@__PURE__*/new Vector4,_frustum=/*@__PURE__*/new Frustum,_frustumArray=/*@__PURE__*/new FrustumArray,_projScreenMatrix=/*@__PURE__*/new Matrix4,_vector4=/*@__PURE__*/new Vector4,_shadowSide={[FrontSide]:1,[BackSide]:0,[DoubleSide]:2};class Renderer{constructor(backend,parameters={}){this.isRenderer=!0;const{logarithmicDepthBuffer:logarithmicDepthBuffer=!1,alpha:alpha=!0,depth:depth=!0,stencil:stencil=!1,antialias:antialias=!1,samples:samples=0,getFallback:getFallback=null,outputBufferType:outputBufferType=HalfFloatType,multiview:multiview=!1}=parameters;this.backend=backend,this.autoClear=!0,this.autoClearColor=!0,this.autoClearDepth=!0,this.autoClearStencil=!0,this.alpha=alpha,this.logarithmicDepthBuffer=logarithmicDepthBuffer,this.outputColorSpace="srgb",this.toneMapping=0,this.toneMappingExposure=1,this.sortObjects=!0,this.depth=depth,this.stencil=stencil,this.info=new Info,this.contextNode=context(),this.library=new NodeLibrary,this.lighting=new Lighting,this._samples=samples||!0===antialias?4:0,this._onCanvasTargetResize=this._onCanvasTargetResize.bind(this),this._canvasTarget=new CanvasTarget(backend.getDomElement()),this._canvasTarget.addEventListener("resize",this._onCanvasTargetResize),this._canvasTarget.isDefaultCanvasTarget=!0,this._inspector=new InspectorBase,this._inspector.setRenderer(this),this._getFallback=getFallback,this._attributes=null,this._geometries=null,this._nodes=null,this._animation=null,this._bindings=null,this._objects=null,this._pipelines=null,this._bundles=null,this._renderLists=null,this._renderContexts=null,this._textures=null,this._background=null,this._quad=new QuadMesh(new NodeMaterial),this._quad.name="Output Color Transform",this._quad.material.name="outputColorTransform",this._currentRenderContext=null,this._opaqueSort=null,this._transparentSort=null,this._frameBufferTarget=null;const alphaClear=!0===this.alpha?0:1;this._clearColor=new Color4(0,0,0,alphaClear),this._clearDepth=1,this._clearStencil=0,this._renderTarget=null,this._activeCubeFace=0,this._activeMipmapLevel=0,this._outputRenderTarget=null,this._mrt=null,this._renderObjectFunction=null,this._currentRenderObjectFunction=null,this._currentRenderBundle=null,this._handleObjectFunction=this._renderObjectDirect,this._isDeviceLost=!1,this.onDeviceLost=this._onDeviceLost,this._outputBufferType=outputBufferType,this._cacheShadowNodes=new WeakMap,this._initialized=!1,this._callDepth=-1,this._initPromise=null,this._compilationPromises=null,this.transparent=!0,this.opaque=!0,this.shadowMap={enabled:!1,transmitted:!1,type:1},this.xr=new XRManager(this,multiview),this.debug={checkShaderErrors:!0,onShaderError:null,getShaderAsync:async(scene,camera,object)=>{await this.compileAsync(scene,camera);const renderList=this._renderLists.get(scene,camera),renderContext=this._renderContexts.get(this._renderTarget,this._mrt),material=scene.overrideMaterial||object.material,renderObject=this._objects.get(object,material,scene,camera,renderList.lightsNode,renderContext,renderContext.clippingContext),{fragmentShader:fragmentShader,vertexShader:vertexShader}=renderObject.getNodeBuilderState();return{fragmentShader:fragmentShader,vertexShader:vertexShader}}}}async init(){return null!==this._initPromise||(this._initPromise=new Promise(async(resolve,reject)=>{let backend=this.backend;try{await backend.init(this)}catch(error){if(null===this._getFallback)return void reject(error);try{this.backend=backend=this._getFallback(error),await backend.init(this)}catch(error){return void reject(error)}}this._nodes=new NodeManager(this,backend),this._animation=new Animation(this,this._nodes,this.info),this._attributes=new Attributes(backend),this._background=new Background(this,this._nodes),this._geometries=new Geometries(this._attributes,this.info),this._textures=new Textures(this,backend,this.info),this._pipelines=new Pipelines(backend,this._nodes),this._bindings=new Bindings(backend,this._nodes,this._textures,this._attributes,this._pipelines,this.info),this._objects=new RenderObjects(this,this._nodes,this._geometries,this._pipelines,this._bindings,this.info),this._renderLists=new RenderLists(this.lighting),this._bundles=new RenderBundles,this._renderContexts=new RenderContexts,this._animation.start(),this._initialized=!0,this._inspector.init(),resolve(this)})),this._initPromise}get domElement(){return this._canvasTarget.domElement}get coordinateSystem(){return this.backend.coordinateSystem}async compileAsync(scene,camera,targetScene=null){if(!0===this._isDeviceLost)return;!1===this._initialized&&await this.init();const nodeFrame=this._nodes.nodeFrame,previousRenderId=nodeFrame.renderId,previousRenderContext=this._currentRenderContext,previousRenderObjectFunction=this._currentRenderObjectFunction,previousHandleObjectFunction=this._handleObjectFunction,previousCompilationPromises=this._compilationPromises,sceneRef=!0===scene.isScene?scene:_scene;null===targetScene&&(targetScene=scene);const renderTarget=this._renderTarget,renderContext=this._renderContexts.get(renderTarget,this._mrt),activeMipmapLevel=this._activeMipmapLevel,compilationPromises=[];this._currentRenderContext=renderContext,this._currentRenderObjectFunction=this.renderObject,this._handleObjectFunction=this._createObjectPipeline,this._compilationPromises=compilationPromises,nodeFrame.renderId++,nodeFrame.update(),renderContext.depth=this.depth,renderContext.stencil=this.stencil,renderContext.clippingContext||(renderContext.clippingContext=new ClippingContext),renderContext.clippingContext.updateGlobal(sceneRef,camera),sceneRef.onBeforeRender(this,scene,camera,renderTarget);const renderList=this._renderLists.get(scene,camera);if(renderList.begin(),this._projectObject(scene,camera,0,renderList,renderContext.clippingContext),targetScene!==scene&&targetScene.traverseVisible(function(object){object.isLight&&object.layers.test(camera.layers)&&renderList.pushLight(object)}),renderList.finish(),null!==renderTarget){this._textures.updateRenderTarget(renderTarget,activeMipmapLevel);const renderTargetData=this._textures.get(renderTarget);renderContext.textures=renderTargetData.textures,renderContext.depthTexture=renderTargetData.depthTexture}else renderContext.textures=null,renderContext.depthTexture=null;targetScene!==scene?this._background.update(targetScene,renderList,renderContext):this._background.update(sceneRef,renderList,renderContext);const opaqueObjects=renderList.opaque,transparentObjects=renderList.transparent,transparentDoublePassObjects=renderList.transparentDoublePass,lightsNode=renderList.lightsNode;!0===this.opaque&&opaqueObjects.length>0&&this._renderObjects(opaqueObjects,camera,sceneRef,lightsNode),!0===this.transparent&&transparentObjects.length>0&&this._renderTransparents(transparentObjects,transparentDoublePassObjects,camera,sceneRef,lightsNode),nodeFrame.renderId=previousRenderId,this._currentRenderContext=previousRenderContext,this._currentRenderObjectFunction=previousRenderObjectFunction,this._handleObjectFunction=previousHandleObjectFunction,this._compilationPromises=previousCompilationPromises,await Promise.all(compilationPromises)}async renderAsync(scene,camera){warnOnce('Renderer: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.'),await this.init(),this.render(scene,camera)}async waitForGPU(){error("Renderer: waitForGPU() has been removed. Read https://github.com/mrdoob/three.js/issues/32012 for more information.")}set inspector(value){null!==this._inspector&&this._inspector.setRenderer(null),this._inspector=value,this._inspector.setRenderer(this)}get inspector(){return this._inspector}set highPrecision(value){const contextNodeData=this.contextNode.value;!0===value?(contextNodeData.modelViewMatrix=highpModelViewMatrix,contextNodeData.modelNormalViewMatrix=highpModelNormalViewMatrix):this.highPrecision&&(delete contextNodeData.modelViewMatrix,delete contextNodeData.modelNormalViewMatrix)}get highPrecision(){const contextNodeData=this.contextNode.value;return contextNodeData.modelViewMatrix===highpModelViewMatrix&&contextNodeData.modelNormalViewMatrix===highpModelNormalViewMatrix}setMRT(mrt){return this._mrt=mrt,this}getMRT(){return this._mrt}getOutputBufferType(){return this._outputBufferType}getColorBufferType(){return warnOnce('Renderer: ".getColorBufferType()" has been renamed to ".getOutputBufferType()".'),this.getOutputBufferType()}_onDeviceLost(info){let errorMessage=`THREE.WebGPURenderer: ${info.api} Device Lost:\n\nMessage: ${info.message}`;info.reason&&(errorMessage+=`\nReason: ${info.reason}`),error(errorMessage),this._isDeviceLost=!0}_renderBundle(bundle,sceneRef,lightsNode){const{bundleGroup:bundleGroup,camera:camera,renderList:renderList}=bundle,renderContext=this._currentRenderContext,renderBundle=this._bundles.get(bundleGroup,camera),renderBundleData=this.backend.get(renderBundle);void 0===renderBundleData.renderContexts&&(renderBundleData.renderContexts=new Set);const needsUpdate=bundleGroup.version!==renderBundleData.version,renderBundleNeedsUpdate=!1===renderBundleData.renderContexts.has(renderContext)||needsUpdate;if(renderBundleData.renderContexts.add(renderContext),renderBundleNeedsUpdate){this.backend.beginBundle(renderContext),(void 0===renderBundleData.renderObjects||needsUpdate)&&(renderBundleData.renderObjects=[]),this._currentRenderBundle=renderBundle;const{transparentDoublePass:transparentDoublePassObjects,transparent:transparentObjects,opaque:opaqueObjects}=renderList;!0===this.opaque&&opaqueObjects.length>0&&this._renderObjects(opaqueObjects,camera,sceneRef,lightsNode),!0===this.transparent&&transparentObjects.length>0&&this._renderTransparents(transparentObjects,transparentDoublePassObjects,camera,sceneRef,lightsNode),this._currentRenderBundle=null,this.backend.finishBundle(renderContext,renderBundle),renderBundleData.version=bundleGroup.version}else{const{renderObjects:renderObjects}=renderBundleData;for(let i=0,l=renderObjects.length;i<l;i++){const renderObject=renderObjects[i];this._nodes.needsRefresh(renderObject)&&(this._nodes.updateBefore(renderObject),this._nodes.updateForRender(renderObject),this._bindings.updateForRender(renderObject),this._nodes.updateAfter(renderObject))}}this.backend.addBundle(renderContext,renderBundle)}render(scene,camera){if(!1===this._initialized)throw new Error('Renderer: .render() called before the backend is initialized. Use "await renderer.init();" before rendering.');this._renderScene(scene,camera)}get initialized(){return this._initialized}_getFrameBufferTarget(){const{currentToneMapping:currentToneMapping,currentColorSpace:currentColorSpace}=this,useToneMapping=0!==currentToneMapping,useColorSpace=currentColorSpace!==ColorManagement.workingColorSpace;if(!1===useToneMapping&&!1===useColorSpace)return null;const{width:width,height:height}=this.getDrawingBufferSize(_drawingBufferSize),{depth:depth,stencil:stencil}=this;let frameBufferTarget=this._frameBufferTarget;null===frameBufferTarget&&(frameBufferTarget=new RenderTarget(width,height,{depthBuffer:depth,stencilBuffer:stencil,type:this._outputBufferType,format:1023,colorSpace:ColorManagement.workingColorSpace,generateMipmaps:!1,minFilter:1006,magFilter:1006,samples:this.samples}),frameBufferTarget.isPostProcessingRenderTarget=!0,this._frameBufferTarget=frameBufferTarget);const outputRenderTarget=this.getOutputRenderTarget();frameBufferTarget.depthBuffer=depth,frameBufferTarget.stencilBuffer=stencil,null!==outputRenderTarget?frameBufferTarget.setSize(outputRenderTarget.width,outputRenderTarget.height,outputRenderTarget.depth):frameBufferTarget.setSize(width,height,1);const canvasTarget=this._canvasTarget;return frameBufferTarget.viewport.copy(canvasTarget._viewport),frameBufferTarget.scissor.copy(canvasTarget._scissor),frameBufferTarget.viewport.multiplyScalar(canvasTarget._pixelRatio),frameBufferTarget.scissor.multiplyScalar(canvasTarget._pixelRatio),frameBufferTarget.scissorTest=canvasTarget._scissorTest,frameBufferTarget.multiview=null!==outputRenderTarget&&outputRenderTarget.multiview,frameBufferTarget.resolveDepthBuffer=null===outputRenderTarget||outputRenderTarget.resolveDepthBuffer,frameBufferTarget._autoAllocateDepthBuffer=null!==outputRenderTarget&&outputRenderTarget._autoAllocateDepthBuffer,frameBufferTarget}_renderScene(scene,camera,useFrameBufferTarget=!0){if(!0===this._isDeviceLost)return;const frameBufferTarget=useFrameBufferTarget?this._getFrameBufferTarget():null,nodeFrame=this._nodes.nodeFrame,previousRenderId=nodeFrame.renderId,previousRenderContext=this._currentRenderContext,previousRenderObjectFunction=this._currentRenderObjectFunction,previousHandleObjectFunction=this._handleObjectFunction;this._callDepth++;const sceneRef=!0===scene.isScene?scene:_scene,outputRenderTarget=this._renderTarget||this._outputRenderTarget,activeCubeFace=this._activeCubeFace,activeMipmapLevel=this._activeMipmapLevel;let renderTarget;null!==frameBufferTarget?(renderTarget=frameBufferTarget,this.setRenderTarget(renderTarget)):renderTarget=outputRenderTarget;const renderContext=this._renderContexts.get(renderTarget,this._mrt,this._callDepth);this._currentRenderContext=renderContext,this._currentRenderObjectFunction=this._renderObjectFunction||this.renderObject,this._handleObjectFunction=this._renderObjectDirect,this.info.calls++,this.info.render.calls++,this.info.render.frameCalls++,nodeFrame.renderId=this.info.calls,this.backend.updateTimeStampUID(renderContext),this.inspector.beginRender(this.backend.getTimestampUID(renderContext),scene,camera,renderTarget);const coordinateSystem=this.coordinateSystem,xr=this.xr;if(camera.coordinateSystem!==coordinateSystem&&!1===xr.isPresenting&&(camera.coordinateSystem=coordinateSystem,camera.updateProjectionMatrix(),camera.isArrayCamera))for(const subCamera of camera.cameras)subCamera.coordinateSystem=coordinateSystem,subCamera.updateProjectionMatrix();!0===scene.matrixWorldAutoUpdate&&scene.updateMatrixWorld(),null===camera.parent&&!0===camera.matrixWorldAutoUpdate&&camera.updateMatrixWorld(),!0===xr.enabled&&!0===xr.isPresenting&&(!0===xr.cameraAutoUpdate&&xr.updateCamera(camera),camera=xr.getCamera());const canvasTarget=this._canvasTarget;let viewport=canvasTarget._viewport,scissor=canvasTarget._scissor,pixelRatio=canvasTarget._pixelRatio;null!==renderTarget&&(viewport=renderTarget.viewport,scissor=renderTarget.scissor,pixelRatio=1),this.getDrawingBufferSize(_drawingBufferSize),_screen.set(0,0,_drawingBufferSize.width,_drawingBufferSize.height);const minDepth=void 0===viewport.minDepth?0:viewport.minDepth,maxDepth=void 0===viewport.maxDepth?1:viewport.maxDepth;renderContext.viewportValue.copy(viewport).multiplyScalar(pixelRatio).floor(),renderContext.viewportValue.width>>=activeMipmapLevel,renderContext.viewportValue.height>>=activeMipmapLevel,renderContext.viewportValue.minDepth=minDepth,renderContext.viewportValue.maxDepth=maxDepth,renderContext.viewport=!1===renderContext.viewportValue.equals(_screen),renderContext.scissorValue.copy(scissor).multiplyScalar(pixelRatio).floor(),renderContext.scissor=canvasTarget._scissorTest&&!1===renderContext.scissorValue.equals(_screen),renderContext.scissorValue.width>>=activeMipmapLevel,renderContext.scissorValue.height>>=activeMipmapLevel,renderContext.clippingContext||(renderContext.clippingContext=new ClippingContext),renderContext.clippingContext.updateGlobal(sceneRef,camera),sceneRef.onBeforeRender(this,scene,camera,renderTarget);const frustum=camera.isArrayCamera?_frustumArray:_frustum;camera.isArrayCamera||(_projScreenMatrix.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse),frustum.setFromProjectionMatrix(_projScreenMatrix,camera.coordinateSystem,camera.reversedDepth));const renderList=this._renderLists.get(scene,camera);if(renderList.begin(),this._projectObject(scene,camera,0,renderList,renderContext.clippingContext),renderList.finish(),!0===this.sortObjects&&renderList.sort(this._opaqueSort,this._transparentSort),null!==renderTarget){this._textures.updateRenderTarget(renderTarget,activeMipmapLevel);const renderTargetData=this._textures.get(renderTarget);renderContext.textures=renderTargetData.textures,renderContext.depthTexture=renderTargetData.depthTexture,renderContext.width=renderTargetData.width,renderContext.height=renderTargetData.height,renderContext.renderTarget=renderTarget,renderContext.depth=renderTarget.depthBuffer,renderContext.stencil=renderTarget.stencilBuffer}else renderContext.textures=null,renderContext.depthTexture=null,renderContext.width=_drawingBufferSize.width,renderContext.height=_drawingBufferSize.height,renderContext.depth=this.depth,renderContext.stencil=this.stencil;renderContext.width>>=activeMipmapLevel,renderContext.height>>=activeMipmapLevel,renderContext.activeCubeFace=activeCubeFace,renderContext.activeMipmapLevel=activeMipmapLevel,renderContext.occlusionQueryCount=renderList.occlusionQueryCount,renderContext.scissorValue.max(_vector4.set(0,0,0,0)),renderContext.scissorValue.x+renderContext.scissorValue.width>renderContext.width&&(renderContext.scissorValue.width=Math.max(renderContext.width-renderContext.scissorValue.x,0)),renderContext.scissorValue.y+renderContext.scissorValue.height>renderContext.height&&(renderContext.scissorValue.height=Math.max(renderContext.height-renderContext.scissorValue.y,0)),this._background.update(sceneRef,renderList,renderContext),renderContext.camera=camera,this.backend.beginRender(renderContext);const{bundles:bundles,lightsNode:lightsNode,transparentDoublePass:transparentDoublePassObjects,transparent:transparentObjects,opaque:opaqueObjects}=renderList;return bundles.length>0&&this._renderBundles(bundles,sceneRef,lightsNode),!0===this.opaque&&opaqueObjects.length>0&&this._renderObjects(opaqueObjects,camera,sceneRef,lightsNode),!0===this.transparent&&transparentObjects.length>0&&this._renderTransparents(transparentObjects,transparentDoublePassObjects,camera,sceneRef,lightsNode),this.backend.finishRender(renderContext),nodeFrame.renderId=previousRenderId,this._currentRenderContext=previousRenderContext,this._currentRenderObjectFunction=previousRenderObjectFunction,this._handleObjectFunction=previousHandleObjectFunction,this._callDepth--,null!==frameBufferTarget&&(this.setRenderTarget(outputRenderTarget,activeCubeFace,activeMipmapLevel),this._renderOutput(renderTarget)),sceneRef.onAfterRender(this,scene,camera,renderTarget),this.inspector.finishRender(this.backend.getTimestampUID(renderContext)),renderContext}_setXRLayerSize(width,height){this._canvasTarget._width=width,this._canvasTarget._height=height,this.setViewport(0,0,width,height)}_renderOutput(renderTarget){const quad=this._quad;this._nodes.hasOutputChange(renderTarget.texture)&&(quad.material.fragmentNode=this._nodes.getOutputNode(renderTarget.texture),quad.material.needsUpdate=!0);const currentAutoClear=this.autoClear,currentXR=this.xr.enabled;this.autoClear=!1,this.xr.enabled=!1,this._renderScene(quad,quad.camera,!1),this.autoClear=currentAutoClear,this.xr.enabled=currentXR}getMaxAnisotropy(){return this.backend.getMaxAnisotropy()}getActiveCubeFace(){return this._activeCubeFace}getActiveMipmapLevel(){return this._activeMipmapLevel}async setAnimationLoop(callback){!1===this._initialized&&await this.init(),this._animation.setAnimationLoop(callback)}getAnimationLoop(){return this._animation.getAnimationLoop()}async getArrayBufferAsync(attribute){return await this.backend.getArrayBufferAsync(attribute)}getContext(){return this.backend.getContext()}getPixelRatio(){return this._canvasTarget.getPixelRatio()}getDrawingBufferSize(target){return this._canvasTarget.getDrawingBufferSize(target)}getSize(target){return this._canvasTarget.getSize(target)}setPixelRatio(value=1){this._canvasTarget.setPixelRatio(value)}setDrawingBufferSize(width,height,pixelRatio){this.xr&&this.xr.isPresenting||this._canvasTarget.setDrawingBufferSize(width,height,pixelRatio)}setSize(width,height,updateStyle=!0){this.xr&&this.xr.isPresenting||this._canvasTarget.setSize(width,height,updateStyle)}setOpaqueSort(method){this._opaqueSort=method}setTransparentSort(method){this._transparentSort=method}getScissor(target){return this._canvasTarget.getScissor(target)}setScissor(x,y,width,height){this._canvasTarget.setScissor(x,y,width,height)}getScissorTest(){return this._canvasTarget.getScissorTest()}setScissorTest(boolean){this._canvasTarget.setScissorTest(boolean),this.backend.setScissorTest(boolean)}getViewport(target){return this._canvasTarget.getViewport(target)}setViewport(x,y,width,height,minDepth=0,maxDepth=1){this._canvasTarget.setViewport(x,y,width,height,minDepth,maxDepth)}getClearColor(target){return target.copy(this._clearColor)}setClearColor(color,alpha=1){this._clearColor.set(color),this._clearColor.a=alpha}getClearAlpha(){return this._clearColor.a}setClearAlpha(alpha){this._clearColor.a=alpha}getClearDepth(){return this._clearDepth}setClearDepth(depth){this._clearDepth=depth}getClearStencil(){return this._clearStencil}setClearStencil(stencil){this._clearStencil=stencil}isOccluded(object){const renderContext=this._currentRenderContext;return renderContext&&this.backend.isOccluded(renderContext,object)}clear(color=!0,depth=!0,stencil=!0){if(!1===this._initialized)throw new Error('Renderer: .clear() called before the backend is initialized. Use "await renderer.init();" before before using this method.');const renderTarget=this._renderTarget||this._getFrameBufferTarget();let renderContext=null;if(null!==renderTarget){this._textures.updateRenderTarget(renderTarget);const renderTargetData=this._textures.get(renderTarget);renderContext=this._renderContexts.get(renderTarget),renderContext.textures=renderTargetData.textures,renderContext.depthTexture=renderTargetData.depthTexture,renderContext.width=renderTargetData.width,renderContext.height=renderTargetData.height,renderContext.renderTarget=renderTarget,renderContext.depth=renderTarget.depthBuffer,renderContext.stencil=renderTarget.stencilBuffer;const color=this.backend.getClearColor();renderContext.clearColorValue.r=color.r,renderContext.clearColorValue.g=color.g,renderContext.clearColorValue.b=color.b,renderContext.clearColorValue.a=color.a,renderContext.activeCubeFace=this.getActiveCubeFace(),renderContext.activeMipmapLevel=this.getActiveMipmapLevel()}this.backend.clear(color,depth,stencil,renderContext),null!==renderTarget&&null===this._renderTarget&&this._renderOutput(renderTarget)}clearColor(){this.clear(!0,!1,!1)}clearDepth(){this.clear(!1,!0,!1)}clearStencil(){this.clear(!1,!1,!0)}async clearAsync(color=!0,depth=!0,stencil=!0){warnOnce('Renderer: "clearAsync()" has been deprecated. Use "clear()" and "await renderer.init();" when creating the renderer.'),await this.init(),this.clear(color,depth,stencil)}async clearColorAsync(){warnOnce('Renderer: "clearColorAsync()" has been deprecated. Use "clearColor()" and "await renderer.init();" when creating the renderer.'),this.clear(!0,!1,!1)}async clearDepthAsync(){warnOnce('Renderer: "clearDepthAsync()" has been deprecated. Use "clearDepth()" and "await renderer.init();" when creating the renderer.'),this.clear(!1,!0,!1)}async clearStencilAsync(){warnOnce('Renderer: "clearStencilAsync()" has been deprecated. Use "clearStencil()" and "await renderer.init();" when creating the renderer.'),this.clear(!1,!1,!0)}get needsFrameBufferTarget(){const useToneMapping=0!==this.currentToneMapping,useColorSpace=this.currentColorSpace!==ColorManagement.workingColorSpace;return useToneMapping||useColorSpace}get samples(){return this._samples}get currentSamples(){let samples=this._samples;return null!==this._renderTarget?samples=this._renderTarget.samples:this.needsFrameBufferTarget&&(samples=0),samples}get currentToneMapping(){return this.isOutputTarget?this.toneMapping:0}get currentColorSpace(){return this.isOutputTarget?this.outputColorSpace:ColorManagement.workingColorSpace}get isOutputTarget(){return this._renderTarget===this._outputRenderTarget||null===this._renderTarget}dispose(){!0===this._initialized&&(this.info.dispose(),this.backend.dispose(),this._animation.dispose(),this._objects.dispose(),this._geometries.dispose(),this._pipelines.dispose(),this._nodes.dispose(),this._bindings.dispose(),this._renderLists.dispose(),this._renderContexts.dispose(),this._textures.dispose(),null!==this._frameBufferTarget&&this._frameBufferTarget.dispose(),Object.values(this.backend.timestampQueryPool).forEach(queryPool=>{null!==queryPool&&queryPool.dispose()})),this.setRenderTarget(null),this.setAnimationLoop(null)}setRenderTarget(renderTarget,activeCubeFace=0,activeMipmapLevel=0){this._renderTarget=renderTarget,this._activeCubeFace=activeCubeFace,this._activeMipmapLevel=activeMipmapLevel}getRenderTarget(){return this._renderTarget}setOutputRenderTarget(renderTarget){this._outputRenderTarget=renderTarget}getOutputRenderTarget(){return this._outputRenderTarget}setCanvasTarget(canvasTarget){this._canvasTarget.removeEventListener("resize",this._onCanvasTargetResize),this._canvasTarget=canvasTarget,this._canvasTarget.addEventListener("resize",this._onCanvasTargetResize)}getCanvasTarget(){return this._canvasTarget}_resetXRState(){this.backend.setXRTarget(null),this.setOutputRenderTarget(null),this.setRenderTarget(null),this._frameBufferTarget.dispose(),this._frameBufferTarget=null}setRenderObjectFunction(renderObjectFunction){this._renderObjectFunction=renderObjectFunction}getRenderObjectFunction(){return this._renderObjectFunction}compute(computeNodes,dispatchSize=null){if(!0===this._isDeviceLost)return;if(!1===this._initialized)return warn("Renderer: .compute() called before the backend is initialized. Try using .computeAsync() instead."),this.computeAsync(computeNodes,dispatchSize);const nodeFrame=this._nodes.nodeFrame,previousRenderId=nodeFrame.renderId;this.info.calls++,this.info.compute.calls++,this.info.compute.frameCalls++,nodeFrame.renderId=this.info.calls,this.backend.updateTimeStampUID(computeNodes),this.inspector.beginCompute(this.backend.getTimestampUID(computeNodes),computeNodes);const backend=this.backend,pipelines=this._pipelines,bindings=this._bindings,nodes=this._nodes,computeList=Array.isArray(computeNodes)?computeNodes:[computeNodes];if(void 0===computeList[0]||!0!==computeList[0].isComputeNode)throw new Error("THREE.Renderer: .compute() expects a ComputeNode.");backend.beginCompute(computeNodes);for(const computeNode of computeList){if(!1===pipelines.has(computeNode)){const dispose=()=>{computeNode.removeEventListener("dispose",dispose),pipelines.delete(computeNode),bindings.deleteForCompute(computeNode),nodes.delete(computeNode)};computeNode.addEventListener("dispose",dispose);const onInitFn=computeNode.onInitFunction;null!==onInitFn&&onInitFn.call(computeNode,{renderer:this})}nodes.updateForCompute(computeNode),bindings.updateForCompute(computeNode);const computeBindings=bindings.getForCompute(computeNode),computePipeline=pipelines.getForCompute(computeNode,computeBindings);backend.compute(computeNodes,computeNode,computeBindings,computePipeline,dispatchSize)}backend.finishCompute(computeNodes),nodeFrame.renderId=previousRenderId,this.inspector.finishCompute(this.backend.getTimestampUID(computeNodes))}async computeAsync(computeNodes,dispatchSize=null){!1===this._initialized&&await this.init(),this.compute(computeNodes,dispatchSize)}async hasFeatureAsync(name){return warnOnce('Renderer: "hasFeatureAsync()" has been deprecated. Use "hasFeature()" and "await renderer.init();" when creating the renderer.'),await this.init(),this.hasFeature(name)}async resolveTimestampsAsync(type="render"){return!1===this._initialized&&await this.init(),this.backend.resolveTimestampsAsync(type)}hasFeature(name){if(!1===this._initialized)throw new Error('Renderer: .hasFeature() called before the backend is initialized. Use "await renderer.init();" before before using this method.');return this.backend.hasFeature(name)}hasInitialized(){return this._initialized}async initTextureAsync(texture){warnOnce('Renderer: "initTextureAsync()" has been deprecated. Use "initTexture()" and "await renderer.init();" when creating the renderer.'),await this.init(),this.initTexture(texture)}initTexture(texture){if(!1===this._initialized)throw new Error('Renderer: .initTexture() called before the backend is initialized. Use "await renderer.init();" before before using this method.');this._textures.updateTexture(texture)}initRenderTarget(renderTarget){if(!1===this._initialized)throw new Error('Renderer: .initRenderTarget() called before the backend is initialized. Use "await renderer.init();" before before using this method.');this._textures.updateRenderTarget(renderTarget);const renderTargetData=this._textures.get(renderTarget),renderContext=this._renderContexts.get(renderTarget);renderContext.textures=renderTargetData.textures,renderContext.depthTexture=renderTargetData.depthTexture,renderContext.width=renderTargetData.width,renderContext.height=renderTargetData.height,renderContext.renderTarget=renderTarget,renderContext.depth=renderTarget.depthBuffer,renderContext.stencil=renderTarget.stencilBuffer,this.backend.initRenderTarget(renderContext)}copyFramebufferToTexture(framebufferTexture,rectangle=null){if(null!==rectangle)if(rectangle.isVector2)rectangle=_vector4.set(rectangle.x,rectangle.y,framebufferTexture.image.width,framebufferTexture.image.height).floor();else{if(!rectangle.isVector4)return void error("Renderer.copyFramebufferToTexture: Invalid rectangle.");rectangle=_vector4.copy(rectangle).floor()}else rectangle=_vector4.set(0,0,framebufferTexture.image.width,framebufferTexture.image.height);let renderTarget,renderContext=this._currentRenderContext;null!==renderContext?renderTarget=renderContext.renderTarget:(renderTarget=this._renderTarget||this._getFrameBufferTarget(),null!==renderTarget&&(this._textures.updateRenderTarget(renderTarget),renderContext=this._textures.get(renderTarget))),this._textures.updateTexture(framebufferTexture,{renderTarget:renderTarget}),this.backend.copyFramebufferToTexture(framebufferTexture,renderContext,rectangle),this._inspector.copyFramebufferToTexture(framebufferTexture)}copyTextureToTexture(srcTexture,dstTexture,srcRegion=null,dstPosition=null,srcLevel=0,dstLevel=0){this._textures.updateTexture(srcTexture),this._textures.updateTexture(dstTexture),this.backend.copyTextureToTexture(srcTexture,dstTexture,srcRegion,dstPosition,srcLevel,dstLevel),this._inspector.copyTextureToTexture(srcTexture,dstTexture)}async readRenderTargetPixelsAsync(renderTarget,x,y,width,height,textureIndex=0,faceIndex=0){return this.backend.copyTextureToBuffer(renderTarget.textures[textureIndex],x,y,width,height,faceIndex)}_projectObject(object,camera,groupOrder,renderList,clippingContext){if(!1===object.visible)return;if(object.layers.test(camera.layers))if(object.isGroup)groupOrder=object.renderOrder,object.isClippingGroup&&object.enabled&&(clippingContext=clippingContext.getGroupContext(object));else if(object.isLOD)!0===object.autoUpdate&&object.update(camera);else if(object.isLight)renderList.pushLight(object);else if(object.isSprite){const frustum=camera.isArrayCamera?_frustumArray:_frustum;if(!object.frustumCulled||frustum.intersectsSprite(object,camera)){!0===this.sortObjects&&_vector4.setFromMatrixPosition(object.matrixWorld).applyMatrix4(_projScreenMatrix);const{geometry:geometry,material:material}=object;material.visible&&renderList.push(object,geometry,material,groupOrder,_vector4.z,null,clippingContext)}}else if(object.isLineLoop)error("Renderer: Objects of type THREE.LineLoop are not supported. Please use THREE.Line or THREE.LineSegments.");else if(object.isMesh||object.isLine||object.isPoints){const frustum=camera.isArrayCamera?_frustumArray:_frustum;if(!object.frustumCulled||frustum.intersectsObject(object,camera)){const{geometry:geometry,material:material}=object;if(!0===this.sortObjects&&(null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_vector4.copy(geometry.boundingSphere.center).applyMatrix4(object.matrixWorld).applyMatrix4(_projScreenMatrix)),Array.isArray(material)){const groups=geometry.groups;for(let i=0,l=groups.length;i<l;i++){const group=groups[i],groupMaterial=material[group.materialIndex];groupMaterial&&groupMaterial.visible&&renderList.push(object,geometry,groupMaterial,groupOrder,_vector4.z,group,clippingContext)}}else material.visible&&renderList.push(object,geometry,material,groupOrder,_vector4.z,null,clippingContext)}}if(!0===object.isBundleGroup&&void 0!==this.backend.beginBundle){const baseRenderList=renderList;(renderList=this._renderLists.get(object,camera)).begin(),baseRenderList.pushBundle({bundleGroup:object,camera:camera,renderList:renderList}),renderList.finish()}const children=object.children;for(let i=0,l=children.length;i<l;i++)this._projectObject(children[i],camera,groupOrder,renderList,clippingContext)}_renderBundles(bundles,sceneRef,lightsNode){for(const bundle of bundles)this._renderBundle(bundle,sceneRef,lightsNode)}_renderTransparents(renderList,doublePassList,camera,scene,lightsNode){if(doublePassList.length>0){for(const{material:material}of doublePassList)material.side=1;this._renderObjects(doublePassList,camera,scene,lightsNode,"backSide");for(const{material:material}of doublePassList)material.side=0;this._renderObjects(renderList,camera,scene,lightsNode);for(const{material:material}of doublePassList)material.side=2}else this._renderObjects(renderList,camera,scene,lightsNode)}_renderObjects(renderList,camera,scene,lightsNode,passId=null){for(let i=0,il=renderList.length;i<il;i++){const{object:object,geometry:geometry,material:material,group:group,clippingContext:clippingContext}=renderList[i];this._currentRenderObjectFunction(object,scene,camera,geometry,material,group,lightsNode,clippingContext,passId)}}_getShadowNodes(material){const version=material.version;let cache=this._cacheShadowNodes.get(material);if(void 0===cache||cache.version!==version){const hasMap=null!==material.map,hasColorNode=material.colorNode&&material.colorNode.isNode,hasCastShadowNode=material.castShadowNode&&material.castShadowNode.isNode,hasMaskNode=material.maskShadowNode&&material.maskShadowNode.isNode||material.maskNode&&material.maskNode.isNode;let positionNode=null,colorNode=null,depthNode=null;if(hasMap||hasColorNode||hasCastShadowNode||hasMaskNode){let shadowRGB,shadowAlpha;if(hasCastShadowNode?(shadowRGB=material.castShadowNode.rgb,shadowAlpha=material.castShadowNode.a,!0!==this.shadowMap.transmitted&&warnOnce("Renderer: `shadowMap.transmitted` needs to be set to `true` when using `material.castShadowNode`.")):(shadowRGB=vec3(0),shadowAlpha=float(1)),hasMap&&(shadowAlpha=shadowAlpha.mul(reference("map","texture",material).a)),hasColorNode&&(shadowAlpha=shadowAlpha.mul(material.colorNode.a)),colorNode=vec4(shadowRGB,shadowAlpha),hasMaskNode){const maskNode=material.maskShadowNode||material.maskNode;colorNode=Fn(([color])=>(maskNode.not().discard(),color))(colorNode)}}material.depthNode&&material.depthNode.isNode&&(depthNode=material.depthNode),material.castShadowPositionNode&&material.castShadowPositionNode.isNode?positionNode=material.castShadowPositionNode:material.positionNode&&material.positionNode.isNode&&(positionNode=material.positionNode),cache={version:version,colorNode:colorNode,depthNode:depthNode,positionNode:positionNode},this._cacheShadowNodes.set(material,cache)}return cache}renderObject(object,scene,camera,geometry,material,group,lightsNode,clippingContext=null,passId=null){let materialColorNode,materialDepthNode,materialPositionNode,materialSide,materialOverride=!1;if(object.onBeforeRender(this,scene,camera,geometry,material,group),!0===material.allowOverride&&null!==scene.overrideMaterial){const overrideMaterial=scene.overrideMaterial;if(materialOverride=!0,materialColorNode=overrideMaterial.isNodeMaterial?overrideMaterial.colorNode:null,materialDepthNode=overrideMaterial.isNodeMaterial?overrideMaterial.depthNode:null,materialPositionNode=overrideMaterial.isNodeMaterial?overrideMaterial.positionNode:null,materialSide=scene.overrideMaterial.side,material.positionNode&&material.positionNode.isNode&&(overrideMaterial.positionNode=material.positionNode),overrideMaterial.alphaTest=material.alphaTest,overrideMaterial.alphaMap=material.alphaMap,overrideMaterial.transparent=material.transparent||material.transmission>0||material.transmissionNode&&material.transmissionNode.isNode||material.backdropNode&&material.backdropNode.isNode,overrideMaterial.isShadowPassMaterial){const{colorNode:colorNode,depthNode:depthNode,positionNode:positionNode}=this._getShadowNodes(material);3===this.shadowMap.type?overrideMaterial.side=null!==material.shadowSide?material.shadowSide:material.side:overrideMaterial.side=null!==material.shadowSide?material.shadowSide:_shadowSide[material.side],null!==colorNode&&(overrideMaterial.colorNode=colorNode),null!==depthNode&&(overrideMaterial.depthNode=depthNode),null!==positionNode&&(overrideMaterial.positionNode=positionNode)}material=overrideMaterial}!0===material.transparent&&2===material.side&&!1===material.forceSinglePass?(material.side=1,this._handleObjectFunction(object,material,scene,camera,lightsNode,group,clippingContext,"backSide"),material.side=0,this._handleObjectFunction(object,material,scene,camera,lightsNode,group,clippingContext,passId),material.side=2):this._handleObjectFunction(object,material,scene,camera,lightsNode,group,clippingContext,passId),materialOverride&&(scene.overrideMaterial.colorNode=materialColorNode,scene.overrideMaterial.depthNode=materialDepthNode,scene.overrideMaterial.positionNode=materialPositionNode,scene.overrideMaterial.side=materialSide),object.onAfterRender(this,scene,camera,geometry,material,group)}hasCompatibility(name){return this.backend.hasCompatibility(name)}_renderObjectDirect(object,material,scene,camera,lightsNode,group,clippingContext,passId){const renderObject=this._objects.get(object,material,scene,camera,lightsNode,this._currentRenderContext,clippingContext,passId);if(renderObject.drawRange=object.geometry.drawRange,renderObject.group=group,null!==this._currentRenderBundle){this.backend.get(this._currentRenderBundle).renderObjects.push(renderObject),renderObject.bundle=this._currentRenderBundle.bundleGroup}const needsRefresh=this._nodes.needsRefresh(renderObject);needsRefresh&&(this._nodes.updateBefore(renderObject),this._geometries.updateForRender(renderObject),this._nodes.updateForRender(renderObject),this._bindings.updateForRender(renderObject)),this._pipelines.updateForRender(renderObject),this.backend.draw(renderObject,this.info),needsRefresh&&this._nodes.updateAfter(renderObject)}_createObjectPipeline(object,material,scene,camera,lightsNode,group,clippingContext,passId){const renderObject=this._objects.get(object,material,scene,camera,lightsNode,this._currentRenderContext,clippingContext,passId);renderObject.drawRange=object.geometry.drawRange,renderObject.group=group,this._nodes.updateBefore(renderObject),this._geometries.updateForRender(renderObject),this._nodes.updateForRender(renderObject),this._bindings.updateForRender(renderObject),this._pipelines.getForRender(renderObject,this._compilationPromises),this._nodes.updateAfter(renderObject)}_onCanvasTargetResize(){this._initialized&&this.backend.updateSize()}get compile(){return this.compileAsync}}class Binding{constructor(name=""){this.name=name,this.visibility=0}setVisibility(visibility){this.visibility|=visibility}getVisibility(){return this.visibility}clone(){return Object.assign(new this.constructor,this)}}class Buffer extends Binding{constructor(name,buffer=null){super(name),this.isBuffer=!0,this.bytesPerElement=Float32Array.BYTES_PER_ELEMENT,this._buffer=buffer,this._updateRanges=[]}get updateRanges(){return this._updateRanges}addUpdateRange(start,count){this.updateRanges.push({start:start,count:count})}clearUpdateRanges(){this.updateRanges.length=0}get byteLength(){return function getFloatLength(floatLength){return floatLength+(16-floatLength%16)%16}(this._buffer.byteLength)}get buffer(){return this._buffer}update(){return!0}}class UniformBuffer extends Buffer{constructor(name,buffer=null){super(name,buffer),this.isUniformBuffer=!0}}let _id$4=0;class NodeUniformBuffer extends UniformBuffer{constructor(nodeUniform,groupNode){super("UniformBuffer_"+_id$4++,nodeUniform?nodeUniform.value:null),this.nodeUniform=nodeUniform,this.groupNode=groupNode,this.isNodeUniformBuffer=!0}set updateRanges(value){this.nodeUniform.updateRanges=value}get updateRanges(){return this.nodeUniform.updateRanges}addUpdateRange(start,count){this.nodeUniform.addUpdateRange(start,count)}clearUpdateRanges(){this.nodeUniform.clearUpdateRanges()}get buffer(){return this.nodeUniform.value}}class UniformsGroup extends UniformBuffer{constructor(name){super(name),this.isUniformsGroup=!0,this._values=null,this.uniforms=[],this._updateRangeCache=new Map}addUniformUpdateRange(uniform){const index=uniform.index;if(!0!==this._updateRangeCache.has(index)){const updateRanges=this.updateRanges,range={start:uniform.offset,count:uniform.itemSize};updateRanges.push(range),this._updateRangeCache.set(index,range)}}clearUpdateRanges(){this._updateRangeCache.clear(),super.clearUpdateRanges()}addUniform(uniform){return this.uniforms.push(uniform),this}removeUniform(uniform){const index=this.uniforms.indexOf(uniform);return-1!==index&&this.uniforms.splice(index,1),this}get values(){return null===this._values&&(this._values=Array.from(this.buffer)),this._values}get buffer(){let buffer=this._buffer;if(null===buffer){const byteLength=this.byteLength;buffer=new Float32Array(new ArrayBuffer(byteLength)),this._buffer=buffer}return buffer}get byteLength(){const bytesPerElement=this.bytesPerElement;let offset=0;for(let i=0,l=this.uniforms.length;i<l;i++){const uniform=this.uniforms[i],boundary=uniform.boundary,itemSize=uniform.itemSize*bytesPerElement,chunkOffset=offset%16,chunkPadding=chunkOffset%boundary,chunkStart=chunkOffset+chunkPadding;offset+=chunkPadding,0!==chunkStart&&16-chunkStart<itemSize&&(offset+=16-chunkStart),uniform.offset=offset/bytesPerElement,uniform.index=i,offset+=itemSize}return 16*Math.ceil(offset/16)}update(){let updated=!1;for(const uniform of this.uniforms)!0===this.updateByType(uniform)&&(updated=!0);return updated}updateByType(uniform){return uniform.isNumberUniform?this.updateNumber(uniform):uniform.isVector2Uniform?this.updateVector2(uniform):uniform.isVector3Uniform?this.updateVector3(uniform):uniform.isVector4Uniform?this.updateVector4(uniform):uniform.isColorUniform?this.updateColor(uniform):uniform.isMatrix3Uniform?this.updateMatrix3(uniform):uniform.isMatrix4Uniform?this.updateMatrix4(uniform):void error("WebGPUUniformsGroup: Unsupported uniform type.",uniform)}updateNumber(uniform){let updated=!1;const a=this.values,v=uniform.getValue(),offset=uniform.offset,type=uniform.getType();if(a[offset]!==v){this._getBufferForType(type)[offset]=a[offset]=v,updated=!0,this.addUniformUpdateRange(uniform)}return updated}updateVector2(uniform){let updated=!1;const a=this.values,v=uniform.getValue(),offset=uniform.offset,type=uniform.getType();if(a[offset+0]!==v.x||a[offset+1]!==v.y){const b=this._getBufferForType(type);b[offset+0]=a[offset+0]=v.x,b[offset+1]=a[offset+1]=v.y,updated=!0,this.addUniformUpdateRange(uniform)}return updated}updateVector3(uniform){let updated=!1;const a=this.values,v=uniform.getValue(),offset=uniform.offset,type=uniform.getType();if(a[offset+0]!==v.x||a[offset+1]!==v.y||a[offset+2]!==v.z){const b=this._getBufferForType(type);b[offset+0]=a[offset+0]=v.x,b[offset+1]=a[offset+1]=v.y,b[offset+2]=a[offset+2]=v.z,updated=!0,this.addUniformUpdateRange(uniform)}return updated}updateVector4(uniform){let updated=!1;const a=this.values,v=uniform.getValue(),offset=uniform.offset,type=uniform.getType();if(a[offset+0]!==v.x||a[offset+1]!==v.y||a[offset+2]!==v.z||a[offset+4]!==v.w){const b=this._getBufferForType(type);b[offset+0]=a[offset+0]=v.x,b[offset+1]=a[offset+1]=v.y,b[offset+2]=a[offset+2]=v.z,b[offset+3]=a[offset+3]=v.w,updated=!0,this.addUniformUpdateRange(uniform)}return updated}updateColor(uniform){let updated=!1;const a=this.values,c=uniform.getValue(),offset=uniform.offset;if(a[offset+0]!==c.r||a[offset+1]!==c.g||a[offset+2]!==c.b){const b=this.buffer;b[offset+0]=a[offset+0]=c.r,b[offset+1]=a[offset+1]=c.g,b[offset+2]=a[offset+2]=c.b,updated=!0,this.addUniformUpdateRange(uniform)}return updated}updateMatrix3(uniform){let updated=!1;const a=this.values,e=uniform.getValue().elements,offset=uniform.offset;if(a[offset+0]!==e[0]||a[offset+1]!==e[1]||a[offset+2]!==e[2]||a[offset+4]!==e[3]||a[offset+5]!==e[4]||a[offset+6]!==e[5]||a[offset+8]!==e[6]||a[offset+9]!==e[7]||a[offset+10]!==e[8]){const b=this.buffer;b[offset+0]=a[offset+0]=e[0],b[offset+1]=a[offset+1]=e[1],b[offset+2]=a[offset+2]=e[2],b[offset+4]=a[offset+4]=e[3],b[offset+5]=a[offset+5]=e[4],b[offset+6]=a[offset+6]=e[5],b[offset+8]=a[offset+8]=e[6],b[offset+9]=a[offset+9]=e[7],b[offset+10]=a[offset+10]=e[8],updated=!0,this.addUniformUpdateRange(uniform)}return updated}updateMatrix4(uniform){let updated=!1;const a=this.values,e=uniform.getValue().elements,offset=uniform.offset;if(!1===function arraysEqual(a,b,offset){for(let i=0,l=b.length;i<l;i++)if(a[offset+i]!==b[i])return!1;return!0}(a,e,offset)){this.buffer.set(e,offset),function setArray(a,b,offset){for(let i=0,l=b.length;i<l;i++)a[offset+i]=b[i]}(a,e,offset),updated=!0,this.addUniformUpdateRange(uniform)}return updated}_getBufferForType(type){return"int"===type||"ivec2"===type||"ivec3"===type||"ivec4"===type?new Int32Array(this.buffer.buffer):"uint"===type||"uvec2"===type||"uvec3"===type||"uvec4"===type?new Uint32Array(this.buffer.buffer):this.buffer}}let _id$3=0;class NodeUniformsGroup extends UniformsGroup{constructor(name,groupNode){super(name),this.id=_id$3++,this.groupNode=groupNode,this.isNodeUniformsGroup=!0}}class Sampler extends Binding{constructor(name,texture){super(name),this._texture=null,this._onTextureDispose=()=>{this.generation=null,this.version=0},this.texture=texture,this.version=texture?texture.version:0,this.generation=null,this.samplerKey="",this.isSampler=!0}set texture(value){this._texture!==value&&(this._texture&&this._texture.removeEventListener("dispose",this._onTextureDispose),this._texture=value,this.generation=null,this.version=0,this._texture&&this._texture.addEventListener("dispose",this._onTextureDispose))}get texture(){return this._texture}update(){const{texture:texture,version:version}=this;return version!==texture.version&&(this.version=texture.version,!0)}clone(){const clonedSampler=super.clone();return clonedSampler._texture=null,clonedSampler._onTextureDispose=()=>{clonedSampler.generation=null,clonedSampler.version=0},clonedSampler.texture=this.texture,clonedSampler}}let _id$2=0;class SampledTexture extends Sampler{constructor(name,texture){super(name,texture),this.id=_id$2++,this.store=!1,this.mipLevel=0,this.isSampledTexture=!0}}class NodeSampledTexture extends SampledTexture{constructor(name,textureNode,groupNode,access=null){super(name,textureNode?textureNode.value:null),this.textureNode=textureNode,this.groupNode=groupNode,this.access=access}update(){const{textureNode:textureNode}=this;return this.texture!==textureNode.value?(this.texture=textureNode.value,!0):super.update()}}class NodeSampledCubeTexture extends NodeSampledTexture{constructor(name,textureNode,groupNode,access=null){super(name,textureNode,groupNode,access),this.isSampledCubeTexture=!0}}class NodeSampledTexture3D extends NodeSampledTexture{constructor(name,textureNode,groupNode,access=null){super(name,textureNode,groupNode,access),this.isSampledTexture3D=!0}}const glslPolyfills={bitcast_int_uint:new CodeNode("uint tsl_bitcast_int_to_uint ( int x ) { return floatBitsToUint( intBitsToFloat ( x ) ); }"),bitcast_uint_int:new CodeNode("uint tsl_bitcast_uint_to_int ( uint x ) { return floatBitsToInt( uintBitsToFloat ( x ) ); }")},glslMethods={textureDimensions:"textureSize",equals:"equal",bitcast_float_int:"floatBitsToInt",bitcast_int_float:"intBitsToFloat",bitcast_uint_float:"uintBitsToFloat",bitcast_float_uint:"floatBitsToUint",bitcast_uint_int:"tsl_bitcast_uint_to_int",bitcast_int_uint:"tsl_bitcast_int_to_uint",floatpack_snorm_2x16:"packSnorm2x16",floatpack_unorm_2x16:"packUnorm2x16",floatpack_float16_2x16:"packHalf2x16",floatunpack_snorm_2x16:"unpackSnorm2x16",floatunpack_unorm_2x16:"unpackUnorm2x16",floatunpack_float16_2x16:"unpackHalf2x16"},precisionLib={low:"lowp",medium:"mediump",high:"highp"},supports$1={swizzleAssign:!0,storageBuffer:!1},interpolationTypeMap={perspective:"smooth",linear:"noperspective"},interpolationModeMap={centroid:"centroid"},defaultPrecisions="\nprecision highp float;\nprecision highp int;\nprecision highp sampler2D;\nprecision highp sampler3D;\nprecision highp samplerCube;\nprecision highp sampler2DArray;\n\nprecision highp usampler2D;\nprecision highp usampler3D;\nprecision highp usamplerCube;\nprecision highp usampler2DArray;\n\nprecision highp isampler2D;\nprecision highp isampler3D;\nprecision highp isamplerCube;\nprecision highp isampler2DArray;\n\nprecision highp sampler2DShadow;\nprecision highp sampler2DArrayShadow;\nprecision highp samplerCubeShadow;\n";class GLSLNodeBuilder extends NodeBuilder{constructor(object,renderer){super(object,renderer,new GLSLNodeParser),this.uniformGroups={},this.transforms=[],this.extensions={},this.builtins={vertex:[],fragment:[],compute:[]}}needsToWorkingColorSpace(texture){return!0===texture.isVideoTexture&&""!==texture.colorSpace}_include(name){const codeNode=glslPolyfills[name];return codeNode.build(this),this.addInclude(codeNode),codeNode}getMethod(method){return void 0!==glslPolyfills[method]&&this._include(method),glslMethods[method]||method}getBitcastMethod(type,inputType){return this.getMethod(`bitcast_${inputType}_${type}`)}getFloatPackingMethod(encoding){return this.getMethod(`floatpack_${encoding}_2x16`)}getFloatUnpackingMethod(encoding){return this.getMethod(`floatunpack_${encoding}_2x16`)}getTernary(condSnippet,ifSnippet,elseSnippet){return`${condSnippet} ? ${ifSnippet} : ${elseSnippet}`}getOutputStructName(){return""}buildFunctionCode(shaderNode){const layout=shaderNode.layout,flowData=this.flowShaderNode(shaderNode),parameters=[];for(const input of layout.inputs)parameters.push(this.getType(input.type)+" "+input.name);return`${this.getType(layout.type)} ${layout.name}( ${parameters.join(", ")} ) {\n\n\t${flowData.vars}\n\n${flowData.code}\n\treturn ${flowData.result};\n\n}`}setupPBO(storageBufferNode){const attribute=storageBufferNode.value;if(void 0===attribute.pbo){const originalArray=attribute.array,numElements=attribute.count*attribute.itemSize,{itemSize:itemSize}=attribute,isInteger=attribute.array.constructor.name.toLowerCase().includes("int");let format=isInteger?1029:1028;2===itemSize?format=isInteger?1031:1030:3===itemSize?format=isInteger?1032:1022:4===itemSize&&(format=isInteger?1033:1023);const typeMap={Float32Array:1015,Uint8Array:1009,Uint16Array:1012,Uint32Array:1014,Int8Array:1010,Int16Array:1011,Int32Array:1013,Uint8ClampedArray:1009},width=Math.pow(2,Math.ceil(Math.log2(Math.sqrt(numElements/itemSize))));let height=Math.ceil(numElements/itemSize/width);width*height*itemSize<numElements&&height++;const newSize=width*height*itemSize,newArray=new originalArray.constructor(newSize);newArray.set(originalArray,0),attribute.array=newArray;const pboTexture=new DataTexture(attribute.array,width,height,format,typeMap[attribute.array.constructor.name]||1015);pboTexture.needsUpdate=!0,pboTexture.isPBOTexture=!0;const pbo=new TextureNode(pboTexture,null,null);pbo.setPrecision("high"),attribute.pboNode=pbo,attribute.pbo=pbo.value,this.getUniformFromNode(attribute.pboNode,"texture",this.shaderStage,this.context.nodeName)}}getPropertyName(node,shaderStage=this.shaderStage){return node.isNodeUniform&&!0!==node.node.isTextureNode&&!0!==node.node.isBufferNode?node.name:super.getPropertyName(node,shaderStage)}generatePBO(storageArrayElementNode){const{node:node,indexNode:indexNode}=storageArrayElementNode,attribute=node.value;if(this.renderer.backend.has(attribute)){this.renderer.backend.get(attribute).pbo=attribute.pbo}const nodeUniform=this.getUniformFromNode(attribute.pboNode,"texture",this.shaderStage,this.context.nodeName),textureName=this.getPropertyName(nodeUniform);this.increaseUsage(indexNode);const indexSnippet=indexNode.build(this,"uint"),elementNodeData=this.getDataFromNode(storageArrayElementNode);let propertyName=elementNodeData.propertyName;if(void 0===propertyName){const nodeVar=this.getVarFromNode(storageArrayElementNode);propertyName=this.getPropertyName(nodeVar);const bufferNodeData=this.getDataFromNode(node);let propertySizeName=bufferNodeData.propertySizeName;void 0===propertySizeName&&(propertySizeName=propertyName+"Size",this.getVarFromNode(node,propertySizeName,"uint"),this.addLineFlowCode(`${propertySizeName} = uint( textureSize( ${textureName}, 0 ).x )`,storageArrayElementNode),bufferNodeData.propertySizeName=propertySizeName);const{itemSize:itemSize}=attribute,channel="."+vectorComponents.join("").slice(0,itemSize),uvSnippet=`ivec2(${indexSnippet} % ${propertySizeName}, ${indexSnippet} / ${propertySizeName})`,snippet=this.generateTextureLoad(null,textureName,uvSnippet,"0",null,null);let prefix="vec4";1014===attribute.pbo.type?prefix="uvec4":1013===attribute.pbo.type&&(prefix="ivec4"),this.addLineFlowCode(`${propertyName} = ${prefix}(${snippet})${channel}`,storageArrayElementNode),elementNodeData.propertyName=propertyName}return propertyName}generateTextureLoad(texture,textureProperty,uvIndexSnippet,levelSnippet,depthSnippet,offsetSnippet){let snippet;return null===levelSnippet&&(levelSnippet="0"),snippet=depthSnippet?offsetSnippet?`texelFetchOffset( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet}, ${offsetSnippet} )`:`texelFetch( ${textureProperty}, ivec3( ${uvIndexSnippet}, ${depthSnippet} ), ${levelSnippet} )`:offsetSnippet?`texelFetchOffset( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet}, ${offsetSnippet} )`:`texelFetch( ${textureProperty}, ${uvIndexSnippet}, ${levelSnippet} )`,null!==texture&&texture.isDepthTexture&&(snippet+=".x"),snippet}generateTexture(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet){return depthSnippet&&(uvSnippet=`vec3( ${uvSnippet}, ${depthSnippet} )`),texture.isDepthTexture?offsetSnippet?`textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} ).x`:`texture( ${textureProperty}, ${uvSnippet} ).x`:offsetSnippet?`textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet} )`:`texture( ${textureProperty}, ${uvSnippet} )`}generateTextureLevel(texture,textureProperty,uvSnippet,levelSnippet,offsetSnippet){return offsetSnippet?`textureLodOffset( ${textureProperty}, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`:`textureLod( ${textureProperty}, ${uvSnippet}, ${levelSnippet} )`}generateTextureBias(texture,textureProperty,uvSnippet,biasSnippet,offsetSnippet){return offsetSnippet?`textureOffset( ${textureProperty}, ${uvSnippet}, ${offsetSnippet}, ${biasSnippet} )`:`texture( ${textureProperty}, ${uvSnippet}, ${biasSnippet} )`}generateTextureGrad(texture,textureProperty,uvSnippet,gradSnippet,offsetSnippet){return offsetSnippet?`textureGradOffset( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`:`textureGrad( ${textureProperty}, ${uvSnippet}, ${gradSnippet[0]}, ${gradSnippet[1]} )`}generateTextureCompare(texture,textureProperty,uvSnippet,compareSnippet,depthSnippet,offsetSnippet,shaderStage=this.shaderStage){if("fragment"===shaderStage)return texture.isCubeTexture?`texture( ${textureProperty}, vec4( ${uvSnippet}, ${compareSnippet} ) )`:depthSnippet?offsetSnippet?`textureOffset( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ), ${offsetSnippet} )`:`texture( ${textureProperty}, vec4( ${uvSnippet}, ${depthSnippet}, ${compareSnippet} ) )`:offsetSnippet?`textureOffset( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ), ${offsetSnippet} )`:`texture( ${textureProperty}, vec3( ${uvSnippet}, ${compareSnippet} ) )`;error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`)}getVars(shaderStage){const snippets=[],vars=this.vars[shaderStage];if(void 0!==vars)for(const variable of vars)snippets.push(`${this.getVar(variable.type,variable.name,variable.count)};`);return snippets.join("\n\t")}getUniforms(shaderStage){const uniforms=this.uniforms[shaderStage],bindingSnippets=[],uniformGroups={};for(const uniform of uniforms){let snippet=null,group=!1;if("texture"===uniform.type||"texture3D"===uniform.type){const texture=uniform.node.value;let typePrefix="";!0!==texture.isDataTexture&&!0!==texture.isData3DTexture||(1014===texture.type?typePrefix="u":1013===texture.type&&(typePrefix="i")),snippet="texture3D"===uniform.type&&!1===texture.isArrayTexture?`${typePrefix}sampler3D ${uniform.name};`:texture.compareFunction?!0===texture.isArrayTexture?`sampler2DArrayShadow ${uniform.name};`:`sampler2DShadow ${uniform.name};`:!0===texture.isArrayTexture||!0===texture.isDataArrayTexture||!0===texture.isCompressedArrayTexture?`${typePrefix}sampler2DArray ${uniform.name};`:`${typePrefix}sampler2D ${uniform.name};`}else if("cubeTexture"===uniform.type)snippet=`samplerCube ${uniform.name};`;else if("cubeDepthTexture"===uniform.type){snippet=uniform.node.value.compareFunction?`samplerCubeShadow ${uniform.name};`:`samplerCube ${uniform.name};`}else if("buffer"===uniform.type){const bufferNode=uniform.node,bufferType=this.getType(bufferNode.bufferType),bufferCount=bufferNode.bufferCount,bufferCountSnippet=bufferCount>0?bufferCount:"";snippet=`${bufferNode.name} {\n\t${bufferType} ${uniform.name}[${bufferCountSnippet}];\n};\n`}else{const groupName=uniform.groupNode.name;if(void 0===uniformGroups[groupName]){const sharedUniformGroup=this.uniformGroups[groupName];if(void 0!==sharedUniformGroup){const snippets=[];for(const sharedUniform of sharedUniformGroup.uniforms){const type=sharedUniform.getType(),vectorType=this.getVectorType(type),precision=sharedUniform.nodeUniform.node.precision;let uniformSnippet=`${vectorType} ${sharedUniform.name};`;null!==precision&&(uniformSnippet=precisionLib[precision]+" "+uniformSnippet),snippets.push("\t"+uniformSnippet)}uniformGroups[groupName]=snippets}}group=!0}if(!group){const precision=uniform.node.precision;null!==precision&&(snippet=precisionLib[precision]+" "+snippet),snippet="uniform "+snippet,bindingSnippets.push(snippet)}}let output="";for(const name in uniformGroups){const groupSnippets=uniformGroups[name];output+=this._getGLSLUniformStruct(name,groupSnippets.join("\n"))+"\n"}return output+=bindingSnippets.join("\n"),output}getTypeFromAttribute(attribute){let nodeType=super.getTypeFromAttribute(attribute);if(/^[iu]/.test(nodeType)&&1013!==attribute.gpuType){let dataAttribute=attribute;attribute.isInterleavedBufferAttribute&&(dataAttribute=attribute.data);const array=dataAttribute.array;!1==(array instanceof Uint32Array||array instanceof Int32Array)&&(nodeType=nodeType.slice(1))}return nodeType}getAttributes(shaderStage){let snippet="";if("vertex"===shaderStage||"compute"===shaderStage){const attributes=this.getAttributesArray();let location=0;for(const attribute of attributes)snippet+=`layout( location = ${location++} ) in ${attribute.type} ${attribute.name};\n`}return snippet}getStructMembers(struct){const snippets=[];for(const member of struct.members)snippets.push(`\t${member.type} ${member.name};`);return snippets.join("\n")}getStructs(shaderStage){const snippets=[],structs=this.structs[shaderStage],outputSnippet=[];for(const struct of structs)if(struct.output)for(const member of struct.members)outputSnippet.push(`layout( location = ${member.index} ) out ${member.type} ${member.name};`);else{let snippet="struct "+struct.name+" {\n";snippet+=this.getStructMembers(struct),snippet+="\n};\n",snippets.push(snippet)}return 0===outputSnippet.length&&outputSnippet.push("layout( location = 0 ) out vec4 fragColor;"),"\n"+outputSnippet.join("\n")+"\n\n"+snippets.join("\n")}getVaryings(shaderStage){let snippet="";const varyings=this.varyings;if("vertex"===shaderStage||"compute"===shaderStage)for(const varying of varyings){"compute"===shaderStage&&(varying.needsInterpolation=!0);const type=this.getType(varying.type);if(varying.needsInterpolation)if(varying.interpolationType){snippet+=`${interpolationTypeMap[varying.interpolationType]||varying.interpolationType} ${interpolationModeMap[varying.interpolationSampling]||""} out ${type} ${varying.name};\n`}else{snippet+=`${type.includes("int")||type.includes("uv")||type.includes("iv")?"flat ":""}out ${type} ${varying.name};\n`}else snippet+=`${type} ${varying.name};\n`}else if("fragment"===shaderStage)for(const varying of varyings)if(varying.needsInterpolation){const type=this.getType(varying.type);if(varying.interpolationType){snippet+=`${interpolationTypeMap[varying.interpolationType]||varying.interpolationType} ${interpolationModeMap[varying.interpolationSampling]||""} in ${type} ${varying.name};\n`}else{snippet+=`${type.includes("int")||type.includes("uv")||type.includes("iv")?"flat ":""}in ${type} ${varying.name};\n`}}for(const builtin of this.builtins[shaderStage])snippet+=`${builtin};\n`;return snippet}getVertexIndex(){return"uint( gl_VertexID )"}getInstanceIndex(){return"uint( gl_InstanceID )"}getInvocationLocalIndex(){return`uint( gl_InstanceID ) % ${this.object.workgroupSize.reduce((acc,curr)=>acc*curr,1)}u`}getSubgroupSize(){error("GLSLNodeBuilder: WebGLBackend does not support the subgroupSize node")}getInvocationSubgroupIndex(){error("GLSLNodeBuilder: WebGLBackend does not support the invocationSubgroupIndex node")}getSubgroupIndex(){error("GLSLNodeBuilder: WebGLBackend does not support the subgroupIndex node")}getDrawIndex(){return this.renderer.backend.extensions.has("WEBGL_multi_draw")?"uint( gl_DrawID )":null}getFrontFacing(){return"gl_FrontFacing"}getFragCoord(){return"gl_FragCoord.xy"}getFragDepth(){return"gl_FragDepth"}enableExtension(name,behavior,shaderStage=this.shaderStage){const map=this.extensions[shaderStage]||(this.extensions[shaderStage]=new Map);!1===map.has(name)&&map.set(name,{name:name,behavior:behavior})}getExtensions(shaderStage){const snippets=[];if("vertex"===shaderStage){const ext=this.renderer.backend.extensions;this.object.isBatchedMesh&&ext.has("WEBGL_multi_draw")&&this.enableExtension("GL_ANGLE_multi_draw","require",shaderStage)}const extensions=this.extensions[shaderStage];if(void 0!==extensions)for(const{name:name,behavior:behavior}of extensions.values())snippets.push(`#extension ${name} : ${behavior}`);return snippets.join("\n")}getClipDistance(){return"gl_ClipDistance"}isAvailable(name){let result=supports$1[name];if(void 0===result){let extensionName;switch(result=!1,name){case"float32Filterable":extensionName="OES_texture_float_linear";break;case"clipDistance":extensionName="WEBGL_clip_cull_distance"}if(void 0!==extensionName){const extensions=this.renderer.backend.extensions;extensions.has(extensionName)&&(extensions.get(extensionName),result=!0)}supports$1[name]=result}return result}isFlipY(){return!0}getUniformBufferLimit(){const gl=this.renderer.backend.gl;return gl.getParameter(gl.MAX_UNIFORM_BLOCK_SIZE)}enableHardwareClipping(planeCount){this.enableExtension("GL_ANGLE_clip_cull_distance","require"),this.builtins.vertex.push(`out float gl_ClipDistance[ ${planeCount} ]`)}enableMultiview(){this.enableExtension("GL_OVR_multiview2","require","fragment"),this.enableExtension("GL_OVR_multiview2","require","vertex"),this.builtins.vertex.push("layout(num_views = 2) in")}registerTransform(varyingName,attributeNode){this.transforms.push({varyingName:varyingName,attributeNode:attributeNode})}getTransforms(){const transforms=this.transforms;let snippet="";for(let i=0;i<transforms.length;i++){const transform=transforms[i],attributeName=this.getPropertyName(transform.attributeNode);attributeName&&(snippet+=`${transform.varyingName} = ${attributeName};\n\t`)}return snippet}_getGLSLUniformStruct(name,vars){return`\nlayout( std140 ) uniform ${name} {\n${vars}\n};`}_getGLSLVertexCode(shaderData){return`#version 300 es\n\n${this.getSignature()}\n\n// extensions\n${shaderData.extensions}\n\n// precision\n${defaultPrecisions}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// attributes\n${shaderData.attributes}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// transforms\n\t${shaderData.transforms}\n\n\t// flow\n\t${shaderData.flow}\n\n\tgl_PointSize = 1.0;\n\n}\n`}_getGLSLFragmentCode(shaderData){return`#version 300 es\n\n${this.getSignature()}\n\n// extensions\n${shaderData.extensions}\n\n// precision\n${defaultPrecisions}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\n\n// codes\n${shaderData.codes}\n\nvoid main() {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`}buildCode(){const shadersData=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const shaderStage in shadersData){let flow="// code\n\n";flow+=this.flowCode[shaderStage];const flowNodes=this.flowNodes[shaderStage],mainNode=flowNodes[flowNodes.length-1];for(const node of flowNodes){const flowSlotData=this.getFlowData(node),slotName=node.name;slotName&&(flow.length>0&&(flow+="\n"),flow+=`\t// flow -> ${slotName}\n\t`),flow+=`${flowSlotData.code}\n\t`,node===mainNode&&"compute"!==shaderStage&&(flow+="// result\n\t","vertex"===shaderStage?(flow+="gl_Position = ",flow+=`${flowSlotData.result};`):"fragment"===shaderStage&&(node.outputNode.isOutputStructNode||(flow+="fragColor = ",flow+=`${flowSlotData.result};`)))}const stageData=shadersData[shaderStage];stageData.extensions=this.getExtensions(shaderStage),stageData.uniforms=this.getUniforms(shaderStage),stageData.attributes=this.getAttributes(shaderStage),stageData.varyings=this.getVaryings(shaderStage),stageData.vars=this.getVars(shaderStage),stageData.structs=this.getStructs(shaderStage),stageData.codes=this.getCodes(shaderStage),stageData.transforms=this.getTransforms(shaderStage),stageData.flow=flow}null!==this.material?(this.vertexShader=this._getGLSLVertexCode(shadersData.vertex),this.fragmentShader=this._getGLSLFragmentCode(shadersData.fragment)):this.computeShader=this._getGLSLVertexCode(shadersData.compute)}getUniformFromNode(node,type,shaderStage,name=null){const uniformNode=super.getUniformFromNode(node,type,shaderStage,name),nodeData=this.getDataFromNode(node,shaderStage,this.globalCache);let uniformGPU=nodeData.uniformGPU;if(void 0===uniformGPU){const group=node.groupNode,groupName=group.name,bindings=this.getBindGroupArray(groupName,shaderStage);if("texture"===type)uniformGPU=new NodeSampledTexture(uniformNode.name,uniformNode.node,group),bindings.push(uniformGPU);else if("cubeTexture"===type||"cubeDepthTexture"===type)uniformGPU=new NodeSampledCubeTexture(uniformNode.name,uniformNode.node,group),bindings.push(uniformGPU);else if("texture3D"===type)uniformGPU=new NodeSampledTexture3D(uniformNode.name,uniformNode.node,group),bindings.push(uniformGPU);else if("buffer"===type){uniformNode.name=`buffer${node.id}`;const sharedData=this.getSharedDataFromNode(node);let buffer=sharedData.buffer;void 0===buffer&&(node.name=`NodeBuffer_${node.id}`,buffer=new NodeUniformBuffer(node,group),buffer.name=node.name,sharedData.buffer=buffer),bindings.push(buffer),uniformGPU=buffer}else{let uniformsGroup=this.uniformGroups[groupName];void 0===uniformsGroup?(uniformsGroup=new NodeUniformsGroup(groupName,group),this.uniformGroups[groupName]=uniformsGroup,bindings.push(uniformsGroup)):-1===bindings.indexOf(uniformsGroup)&&bindings.push(uniformsGroup),uniformGPU=this.getNodeUniform(uniformNode,type);const uniformName=uniformGPU.name;uniformsGroup.uniforms.some(u=>u.name===uniformName)||uniformsGroup.addUniform(uniformGPU)}nodeData.uniformGPU=uniformGPU}return uniformNode}}let _vector2=null,_color4=null;class Backend{constructor(parameters={}){this.parameters=Object.assign({},parameters),this.data=new WeakMap,this.renderer=null,this.domElement=null,this.timestampQueryPool={[TimestampQuery_RENDER]:null,[TimestampQuery_COMPUTE]:null},this.trackTimestamp=!0===parameters.trackTimestamp}async init(renderer){this.renderer=renderer}get coordinateSystem(){}beginRender(){}finishRender(){}beginCompute(){}finishCompute(){}draw(){}compute(){}createProgram(){}destroyProgram(){}createBindings(){}updateBindings(){}updateBinding(){}createRenderPipeline(){}createComputePipeline(){}needsRenderUpdate(){}getRenderCacheKey(){}createNodeBuilder(){}updateSampler(){}createDefaultTexture(){}createTexture(){}updateTexture(){}generateMipmaps(){}destroyTexture(){}async copyTextureToBuffer(){}copyTextureToTexture(){}copyFramebufferToTexture(){}createAttribute(){}createIndexAttribute(){}createStorageAttribute(){}updateAttribute(){}destroyAttribute(){}getContext(){}updateSize(){}updateViewport(){}updateTimeStampUID(abstractRenderContext){const contextData=this.get(abstractRenderContext),frame=this.renderer.info.frame;let prefix;prefix=!0===abstractRenderContext.isComputeNode?"c:"+this.renderer.info.compute.frameCalls:"r:"+this.renderer.info.render.frameCalls,contextData.timestampUID=prefix+":"+abstractRenderContext.id+":f"+frame}getTimestampUID(abstractRenderContext){return this.get(abstractRenderContext).timestampUID}getTimestampFrames(type){const queryPool=this.timestampQueryPool[type];return queryPool?queryPool.getTimestampFrames():[]}_getQueryPool(uid){const type=uid.startsWith("c:")?TimestampQuery_COMPUTE:TimestampQuery_RENDER;return this.timestampQueryPool[type]}getTimestamp(uid){return this._getQueryPool(uid).getTimestamp(uid)}hasTimestamp(uid){return this._getQueryPool(uid).hasTimestamp(uid)}isOccluded(){}async resolveTimestampsAsync(type="render"){if(!this.trackTimestamp)return void warnOnce("WebGPURenderer: Timestamp tracking is disabled.");const queryPool=this.timestampQueryPool[type];if(!queryPool)return;const duration=await queryPool.resolveQueriesAsync();return this.renderer.info[type].timestamp=duration,duration}async getArrayBufferAsync(){}async hasFeatureAsync(){}hasFeature(){}getMaxAnisotropy(){}getDrawingBufferSize(){return _vector2=_vector2||new Vector2,this.renderer.getDrawingBufferSize(_vector2)}setScissorTest(){}getClearColor(){const renderer=this.renderer;return _color4=_color4||new Color4,renderer.getClearColor(_color4),_color4.getRGB(_color4),_color4}getDomElement(){let domElement=this.domElement;return null===domElement&&(domElement=void 0!==this.parameters.canvas?this.parameters.canvas:function createCanvasElement(){const canvas=createElementNS("canvas");return canvas.style.display="block",canvas}(),"setAttribute"in domElement&&domElement.setAttribute("data-engine","three.js r183dev webgpu"),this.domElement=domElement),domElement}hasCompatibility(){return!1}initRenderTarget(){}set(object,value){this.data.set(object,value)}get(object){let map=this.data.get(object);return void 0===map&&(map={},this.data.set(object,map)),map}has(object){return this.data.has(object)}delete(object){this.data.delete(object)}deleteBindGroupData(){}dispose(){}}let equationToGL,factorToGL,_id$1=0;class DualAttributeData{constructor(attributeData,dualBuffer){this.buffers=[attributeData.bufferGPU,dualBuffer],this.type=attributeData.type,this.bufferType=attributeData.bufferType,this.pbo=attributeData.pbo,this.byteLength=attributeData.byteLength,this.bytesPerElement=attributeData.BYTES_PER_ELEMENT,this.version=attributeData.version,this.isInteger=attributeData.isInteger,this.activeBufferIndex=0,this.baseId=attributeData.id}get id(){return`${this.baseId}|${this.activeBufferIndex}`}get bufferGPU(){return this.buffers[this.activeBufferIndex]}get transformBuffer(){return this.buffers[1^this.activeBufferIndex]}switchBuffers(){this.activeBufferIndex^=1}}class WebGLAttributeUtils{constructor(backend){this.backend=backend}createAttribute(attribute,bufferType){const backend=this.backend,{gl:gl}=backend,array=attribute.array,usage=attribute.usage||gl.STATIC_DRAW,bufferAttribute=attribute.isInterleavedBufferAttribute?attribute.data:attribute,bufferData=backend.get(bufferAttribute);let type,bufferGPU=bufferData.bufferGPU;if(void 0===bufferGPU&&(bufferGPU=this._createBuffer(gl,bufferType,array,usage),bufferData.bufferGPU=bufferGPU,bufferData.bufferType=bufferType,bufferData.version=bufferAttribute.version),array instanceof Float32Array)type=gl.FLOAT;else if("undefined"!=typeof Float16Array&&array instanceof Float16Array)type=gl.HALF_FLOAT;else if(array instanceof Uint16Array)type=attribute.isFloat16BufferAttribute?gl.HALF_FLOAT:gl.UNSIGNED_SHORT;else if(array instanceof Int16Array)type=gl.SHORT;else if(array instanceof Uint32Array)type=gl.UNSIGNED_INT;else if(array instanceof Int32Array)type=gl.INT;else if(array instanceof Int8Array)type=gl.BYTE;else if(array instanceof Uint8Array)type=gl.UNSIGNED_BYTE;else{if(!(array instanceof Uint8ClampedArray))throw new Error("THREE.WebGLBackend: Unsupported buffer data format: "+array);type=gl.UNSIGNED_BYTE}let attributeData={bufferGPU:bufferGPU,bufferType:bufferType,type:type,byteLength:array.byteLength,bytesPerElement:array.BYTES_PER_ELEMENT,version:attribute.version,pbo:attribute.pbo,isInteger:type===gl.INT||type===gl.UNSIGNED_INT||1013===attribute.gpuType,id:_id$1++};if(attribute.isStorageBufferAttribute||attribute.isStorageInstancedBufferAttribute){const bufferGPUDual=this._createBuffer(gl,bufferType,array,usage);attributeData=new DualAttributeData(attributeData,bufferGPUDual)}backend.set(attribute,attributeData)}updateAttribute(attribute){const backend=this.backend,{gl:gl}=backend,array=attribute.array,bufferAttribute=attribute.isInterleavedBufferAttribute?attribute.data:attribute,bufferData=backend.get(bufferAttribute),bufferType=bufferData.bufferType,updateRanges=attribute.isInterleavedBufferAttribute?attribute.data.updateRanges:attribute.updateRanges;if(gl.bindBuffer(bufferType,bufferData.bufferGPU),0===updateRanges.length)gl.bufferSubData(bufferType,0,array);else{for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i];gl.bufferSubData(bufferType,range.start*array.BYTES_PER_ELEMENT,array,range.start,range.count)}bufferAttribute.clearUpdateRanges()}gl.bindBuffer(bufferType,null),bufferData.version=bufferAttribute.version}destroyAttribute(attribute){const backend=this.backend,{gl:gl}=backend;attribute.isInterleavedBufferAttribute&&backend.delete(attribute.data);const attributeData=backend.get(attribute);gl.deleteBuffer(attributeData.bufferGPU),backend.delete(attribute)}async getArrayBufferAsync(attribute){const backend=this.backend,{gl:gl}=backend,bufferAttribute=attribute.isInterleavedBufferAttribute?attribute.data:attribute,{bufferGPU:bufferGPU}=backend.get(bufferAttribute),array=attribute.array,byteLength=array.byteLength;gl.bindBuffer(gl.COPY_READ_BUFFER,bufferGPU);const writeBuffer=gl.createBuffer();gl.bindBuffer(gl.COPY_WRITE_BUFFER,writeBuffer),gl.bufferData(gl.COPY_WRITE_BUFFER,byteLength,gl.STREAM_READ),gl.copyBufferSubData(gl.COPY_READ_BUFFER,gl.COPY_WRITE_BUFFER,0,0,byteLength),await backend.utils._clientWaitAsync();const dstBuffer=new attribute.array.constructor(array.length);return gl.bindBuffer(gl.COPY_WRITE_BUFFER,writeBuffer),gl.getBufferSubData(gl.COPY_WRITE_BUFFER,0,dstBuffer),gl.deleteBuffer(writeBuffer),gl.bindBuffer(gl.COPY_READ_BUFFER,null),gl.bindBuffer(gl.COPY_WRITE_BUFFER,null),dstBuffer.buffer}_createBuffer(gl,bufferType,array,usage){const bufferGPU=gl.createBuffer();return gl.bindBuffer(bufferType,bufferGPU),gl.bufferData(bufferType,array,usage),gl.bindBuffer(bufferType,null),bufferGPU}}class WebGLState{constructor(backend){this.backend=backend,this.gl=this.backend.gl,this.enabled={},this.currentFlipSided=null,this.currentCullFace=null,this.currentProgram=null,this.currentBlendingEnabled=!1,this.currentBlending=null,this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentPremultipledAlpha=null,this.currentPolygonOffsetFactor=null,this.currentPolygonOffsetUnits=null,this.currentColorMask=null,this.currentDepthFunc=null,this.currentDepthMask=null,this.currentStencilFunc=null,this.currentStencilRef=null,this.currentStencilFuncMask=null,this.currentStencilFail=null,this.currentStencilZFail=null,this.currentStencilZPass=null,this.currentStencilMask=null,this.currentLineWidth=null,this.currentClippingPlanes=0,this.currentVAO=null,this.currentIndex=null,this.currentBoundFramebuffers={},this.currentDrawbuffers=new WeakMap,this.maxTextures=this.gl.getParameter(this.gl.MAX_TEXTURE_IMAGE_UNITS),this.currentTextureSlot=null,this.currentBoundTextures={},this.currentBoundBufferBases={},this._init()}_init(){const gl=this.gl;equationToGL={[AddEquation]:gl.FUNC_ADD,[SubtractEquation]:gl.FUNC_SUBTRACT,[ReverseSubtractEquation]:gl.FUNC_REVERSE_SUBTRACT},factorToGL={[ZeroFactor]:gl.ZERO,[OneFactor]:gl.ONE,[SrcColorFactor]:gl.SRC_COLOR,[SrcAlphaFactor]:gl.SRC_ALPHA,[SrcAlphaSaturateFactor]:gl.SRC_ALPHA_SATURATE,[DstColorFactor]:gl.DST_COLOR,[DstAlphaFactor]:gl.DST_ALPHA,[OneMinusSrcColorFactor]:gl.ONE_MINUS_SRC_COLOR,[OneMinusSrcAlphaFactor]:gl.ONE_MINUS_SRC_ALPHA,[OneMinusDstColorFactor]:gl.ONE_MINUS_DST_COLOR,[OneMinusDstAlphaFactor]:gl.ONE_MINUS_DST_ALPHA};const scissorParam=gl.getParameter(gl.SCISSOR_BOX),viewportParam=gl.getParameter(gl.VIEWPORT);this.currentScissor=(new Vector4).fromArray(scissorParam),this.currentViewport=(new Vector4).fromArray(viewportParam),this._tempVec4=new Vector4}enable(id){const{enabled:enabled}=this;!0!==enabled[id]&&(this.gl.enable(id),enabled[id]=!0)}disable(id){const{enabled:enabled}=this;!1!==enabled[id]&&(this.gl.disable(id),enabled[id]=!1)}setFlipSided(flipSided){if(this.currentFlipSided!==flipSided){const{gl:gl}=this;flipSided?gl.frontFace(gl.CW):gl.frontFace(gl.CCW),this.currentFlipSided=flipSided}}setCullFace(cullFace){const{gl:gl}=this;0!==cullFace?(this.enable(gl.CULL_FACE),cullFace!==this.currentCullFace&&(1===cullFace?gl.cullFace(gl.BACK):2===cullFace?gl.cullFace(gl.FRONT):gl.cullFace(gl.FRONT_AND_BACK))):this.disable(gl.CULL_FACE),this.currentCullFace=cullFace}setLineWidth(width){const{currentLineWidth:currentLineWidth,gl:gl}=this;width!==currentLineWidth&&(gl.lineWidth(width),this.currentLineWidth=width)}setMRTBlending(textures,mrt,material){const gl=this.gl,drawBuffersIndexedExt=this.backend.drawBuffersIndexedExt;if(drawBuffersIndexedExt)for(let i=0;i<textures.length;i++){const texture=textures[i];let blending=null;if(null!==mrt){const blendMode=mrt.getBlendMode(texture.name);6===blendMode.blending?blending=material:0!==blendMode.blending&&(blending=blendMode)}else blending=material;null!==blending?this._setMRTBlendingIndex(i,blending):drawBuffersIndexedExt.blendFuncSeparateiOES(i,gl.ONE,gl.ZERO,gl.ONE,gl.ZERO)}}_setMRTBlendingIndex(index,blending){const{gl:gl}=this,drawBuffersIndexedExt=this.backend.drawBuffersIndexedExt,blendingType=blending.blending,blendSrc=blending.blendSrc,blendDst=blending.blendDst,blendEquation=blending.blendEquation,premultipliedAlpha=blending.premultipliedAlpha;if(5===blendingType){const blendSrcAlpha=null!==blending.blendSrcAlpha?blending.blendSrcAlpha:blendSrc,blendDstAlpha=null!==blending.blendDstAlpha?blending.blendDstAlpha:blendDst,blendEquationAlpha=null!==blending.blendEquationAlpha?blending.blendEquationAlpha:blendEquation;drawBuffersIndexedExt.blendEquationSeparateiOES(index,equationToGL[blendEquation],equationToGL[blendEquationAlpha]),drawBuffersIndexedExt.blendFuncSeparateiOES(index,factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha])}else if(drawBuffersIndexedExt.blendEquationSeparateiOES(index,gl.FUNC_ADD,gl.FUNC_ADD),premultipliedAlpha)switch(blendingType){case 1:default:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case 2:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.ONE,gl.ONE,gl.ONE,gl.ONE);break;case 3:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case 4:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.DST_COLOR,gl.ONE_MINUS_SRC_ALPHA,gl.ZERO,gl.ONE)}else switch(blendingType){case 1:default:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case 2:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.SRC_ALPHA,gl.ONE,gl.ONE,gl.ONE);break;case 3:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case 4:drawBuffersIndexedExt.blendFuncSeparateiOES(index,gl.DST_COLOR,gl.ONE_MINUS_SRC_ALPHA,gl.ZERO,gl.ONE)}}setBlending(blending,blendEquation,blendSrc,blendDst,blendEquationAlpha,blendSrcAlpha,blendDstAlpha,premultipliedAlpha){const{gl:gl}=this;if(0!==blending){if(!1===this.currentBlendingEnabled&&(this.enable(gl.BLEND),this.currentBlendingEnabled=!0),5===blending)blendEquationAlpha=blendEquationAlpha||blendEquation,blendSrcAlpha=blendSrcAlpha||blendSrc,blendDstAlpha=blendDstAlpha||blendDst,blendEquation===this.currentBlendEquation&&blendEquationAlpha===this.currentBlendEquationAlpha||(gl.blendEquationSeparate(equationToGL[blendEquation],equationToGL[blendEquationAlpha]),this.currentBlendEquation=blendEquation,this.currentBlendEquationAlpha=blendEquationAlpha),blendSrc===this.currentBlendSrc&&blendDst===this.currentBlendDst&&blendSrcAlpha===this.currentBlendSrcAlpha&&blendDstAlpha===this.currentBlendDstAlpha||(gl.blendFuncSeparate(factorToGL[blendSrc],factorToGL[blendDst],factorToGL[blendSrcAlpha],factorToGL[blendDstAlpha]),this.currentBlendSrc=blendSrc,this.currentBlendDst=blendDst,this.currentBlendSrcAlpha=blendSrcAlpha,this.currentBlendDstAlpha=blendDstAlpha),this.currentBlending=blending,this.currentPremultipledAlpha=!1;else if(blending!==this.currentBlending||premultipliedAlpha!==this.currentPremultipledAlpha){if(100===this.currentBlendEquation&&100===this.currentBlendEquationAlpha||(gl.blendEquation(gl.FUNC_ADD),this.currentBlendEquation=100,this.currentBlendEquationAlpha=100),premultipliedAlpha)switch(blending){case 1:gl.blendFuncSeparate(gl.ONE,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case 2:gl.blendFunc(gl.ONE,gl.ONE);break;case 3:gl.blendFuncSeparate(gl.ZERO,gl.ONE_MINUS_SRC_COLOR,gl.ZERO,gl.ONE);break;case 4:gl.blendFuncSeparate(gl.DST_COLOR,gl.ONE_MINUS_SRC_ALPHA,gl.ZERO,gl.ONE);break;default:error("WebGLState: Invalid blending: ",blending)}else switch(blending){case 1:gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE_MINUS_SRC_ALPHA,gl.ONE,gl.ONE_MINUS_SRC_ALPHA);break;case 2:gl.blendFuncSeparate(gl.SRC_ALPHA,gl.ONE,gl.ONE,gl.ONE);break;case 3:error("WebGLState: SubtractiveBlending requires material.premultipliedAlpha = true");break;case 4:error("WebGLState: MultiplyBlending requires material.premultipliedAlpha = true");break;default:error("WebGLState: Invalid blending: ",blending)}this.currentBlendSrc=null,this.currentBlendDst=null,this.currentBlendSrcAlpha=null,this.currentBlendDstAlpha=null,this.currentBlending=blending,this.currentPremultipledAlpha=premultipliedAlpha}}else!0===this.currentBlendingEnabled&&(this.disable(gl.BLEND),this.currentBlendingEnabled=!1)}setColorMask(colorMask){this.currentColorMask!==colorMask&&(this.gl.colorMask(colorMask,colorMask,colorMask,colorMask),this.currentColorMask=colorMask)}setDepthTest(depthTest){const{gl:gl}=this;depthTest?this.enable(gl.DEPTH_TEST):this.disable(gl.DEPTH_TEST)}setDepthMask(depthMask){this.currentDepthMask!==depthMask&&(this.gl.depthMask(depthMask),this.currentDepthMask=depthMask)}setDepthFunc(depthFunc){if(this.currentDepthFunc!==depthFunc){const{gl:gl}=this;switch(depthFunc){case 0:gl.depthFunc(gl.NEVER);break;case 1:gl.depthFunc(gl.ALWAYS);break;case 2:gl.depthFunc(gl.LESS);break;case 3:default:gl.depthFunc(gl.LEQUAL);break;case 4:gl.depthFunc(gl.EQUAL);break;case 5:gl.depthFunc(gl.GEQUAL);break;case 6:gl.depthFunc(gl.GREATER);break;case 7:gl.depthFunc(gl.NOTEQUAL)}this.currentDepthFunc=depthFunc}}scissor(x,y,width,height){const scissor=this._tempVec4.set(x,y,width,height);if(!1===this.currentScissor.equals(scissor)){const{gl:gl}=this;gl.scissor(scissor.x,scissor.y,scissor.z,scissor.w),this.currentScissor.copy(scissor)}}viewport(x,y,width,height){const viewport=this._tempVec4.set(x,y,width,height);if(!1===this.currentViewport.equals(viewport)){const{gl:gl}=this;gl.viewport(viewport.x,viewport.y,viewport.z,viewport.w),this.currentViewport.copy(viewport)}}setScissorTest(boolean){const gl=this.gl;boolean?this.enable(gl.SCISSOR_TEST):this.disable(gl.SCISSOR_TEST)}setStencilTest(stencilTest){const{gl:gl}=this;stencilTest?this.enable(gl.STENCIL_TEST):this.disable(gl.STENCIL_TEST)}setStencilMask(stencilMask){this.currentStencilMask!==stencilMask&&(this.gl.stencilMask(stencilMask),this.currentStencilMask=stencilMask)}setStencilFunc(stencilFunc,stencilRef,stencilMask){this.currentStencilFunc===stencilFunc&&this.currentStencilRef===stencilRef&&this.currentStencilFuncMask===stencilMask||(this.gl.stencilFunc(stencilFunc,stencilRef,stencilMask),this.currentStencilFunc=stencilFunc,this.currentStencilRef=stencilRef,this.currentStencilFuncMask=stencilMask)}setStencilOp(stencilFail,stencilZFail,stencilZPass){this.currentStencilFail===stencilFail&&this.currentStencilZFail===stencilZFail&&this.currentStencilZPass===stencilZPass||(this.gl.stencilOp(stencilFail,stencilZFail,stencilZPass),this.currentStencilFail=stencilFail,this.currentStencilZFail=stencilZFail,this.currentStencilZPass=stencilZPass)}setMaterial(material,frontFaceCW,hardwareClippingPlanes){const{gl:gl}=this;2===material.side?this.disable(gl.CULL_FACE):this.enable(gl.CULL_FACE);let flipSided=1===material.side;frontFaceCW&&(flipSided=!flipSided),this.setFlipSided(flipSided),1===material.blending&&!1===material.transparent?this.setBlending(0):this.setBlending(material.blending,material.blendEquation,material.blendSrc,material.blendDst,material.blendEquationAlpha,material.blendSrcAlpha,material.blendDstAlpha,material.premultipliedAlpha),this.setDepthFunc(material.depthFunc),this.setDepthTest(material.depthTest),this.setDepthMask(material.depthWrite),this.setColorMask(material.colorWrite);const stencilWrite=material.stencilWrite;if(this.setStencilTest(stencilWrite),stencilWrite&&(this.setStencilMask(material.stencilWriteMask),this.setStencilFunc(material.stencilFunc,material.stencilRef,material.stencilFuncMask),this.setStencilOp(material.stencilFail,material.stencilZFail,material.stencilZPass)),this.setPolygonOffset(material.polygonOffset,material.polygonOffsetFactor,material.polygonOffsetUnits),!0===material.alphaToCoverage&&this.backend.renderer.currentSamples>0?this.enable(gl.SAMPLE_ALPHA_TO_COVERAGE):this.disable(gl.SAMPLE_ALPHA_TO_COVERAGE),hardwareClippingPlanes>0&&this.currentClippingPlanes!==hardwareClippingPlanes){const CLIP_DISTANCE0_WEBGL=12288;for(let i=0;i<8;i++)i<hardwareClippingPlanes?this.enable(CLIP_DISTANCE0_WEBGL+i):this.disable(CLIP_DISTANCE0_WEBGL+i)}}setPolygonOffset(polygonOffset,factor,units){const{gl:gl}=this;polygonOffset?(this.enable(gl.POLYGON_OFFSET_FILL),this.currentPolygonOffsetFactor===factor&&this.currentPolygonOffsetUnits===units||(gl.polygonOffset(factor,units),this.currentPolygonOffsetFactor=factor,this.currentPolygonOffsetUnits=units)):this.disable(gl.POLYGON_OFFSET_FILL)}useProgram(program){return this.currentProgram!==program&&(this.gl.useProgram(program),this.currentProgram=program,!0)}setVertexState(vao,indexBuffer=null){const gl=this.gl;return(this.currentVAO!==vao||this.currentIndex!==indexBuffer)&&(gl.bindVertexArray(vao),null!==indexBuffer&&gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,indexBuffer),this.currentVAO=vao,this.currentIndex=indexBuffer,!0)}resetVertexState(){const gl=this.gl;gl.bindVertexArray(null),gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,null),this.currentVAO=null,this.currentIndex=null}bindFramebuffer(target,framebuffer){const{gl:gl,currentBoundFramebuffers:currentBoundFramebuffers}=this;return currentBoundFramebuffers[target]!==framebuffer&&(gl.bindFramebuffer(target,framebuffer),currentBoundFramebuffers[target]=framebuffer,target===gl.DRAW_FRAMEBUFFER&&(currentBoundFramebuffers[gl.FRAMEBUFFER]=framebuffer),target===gl.FRAMEBUFFER&&(currentBoundFramebuffers[gl.DRAW_FRAMEBUFFER]=framebuffer),!0)}drawBuffers(renderContext,framebuffer){const{gl:gl}=this;let drawBuffers=[],needsUpdate=!1;if(null!==renderContext.textures){drawBuffers=this.currentDrawbuffers.get(framebuffer),void 0===drawBuffers&&(drawBuffers=[],this.currentDrawbuffers.set(framebuffer,drawBuffers));const textures=renderContext.textures;if(drawBuffers.length!==textures.length||drawBuffers[0]!==gl.COLOR_ATTACHMENT0){for(let i=0,il=textures.length;i<il;i++)drawBuffers[i]=gl.COLOR_ATTACHMENT0+i;drawBuffers.length=textures.length,needsUpdate=!0}}else drawBuffers[0]!==gl.BACK&&(drawBuffers[0]=gl.BACK,needsUpdate=!0);needsUpdate&&gl.drawBuffers(drawBuffers)}activeTexture(webglSlot){const{gl:gl,currentTextureSlot:currentTextureSlot,maxTextures:maxTextures}=this;void 0===webglSlot&&(webglSlot=gl.TEXTURE0+maxTextures-1),currentTextureSlot!==webglSlot&&(gl.activeTexture(webglSlot),this.currentTextureSlot=webglSlot)}bindTexture(webglType,webglTexture,webglSlot){const{gl:gl,currentTextureSlot:currentTextureSlot,currentBoundTextures:currentBoundTextures,maxTextures:maxTextures}=this;void 0===webglSlot&&(webglSlot=null===currentTextureSlot?gl.TEXTURE0+maxTextures-1:currentTextureSlot);let boundTexture=currentBoundTextures[webglSlot];void 0===boundTexture&&(boundTexture={type:void 0,texture:void 0},currentBoundTextures[webglSlot]=boundTexture),boundTexture.type===webglType&&boundTexture.texture===webglTexture||(currentTextureSlot!==webglSlot&&(gl.activeTexture(webglSlot),this.currentTextureSlot=webglSlot),gl.bindTexture(webglType,webglTexture),boundTexture.type=webglType,boundTexture.texture=webglTexture)}bindBufferBase(target,index,buffer){const{gl:gl}=this,key=`${target}-${index}`;return this.currentBoundBufferBases[key]!==buffer&&(gl.bindBufferBase(target,index,buffer),this.currentBoundBufferBases[key]=buffer,!0)}unbindTexture(){const{gl:gl,currentTextureSlot:currentTextureSlot,currentBoundTextures:currentBoundTextures}=this,boundTexture=currentBoundTextures[currentTextureSlot];void 0!==boundTexture&&void 0!==boundTexture.type&&(gl.bindTexture(boundTexture.type,null),boundTexture.type=void 0,boundTexture.texture=void 0)}}class WebGLUtils{constructor(backend){this.backend=backend,this.gl=this.backend.gl,this.extensions=backend.extensions}convert(p,colorSpace=""){const{gl:gl,extensions:extensions}=this;let extension;const transfer=ColorManagement.getTransfer(colorSpace);if(1009===p)return gl.UNSIGNED_BYTE;if(1017===p)return gl.UNSIGNED_SHORT_4_4_4_4;if(1018===p)return gl.UNSIGNED_SHORT_5_5_5_1;if(35902===p)return gl.UNSIGNED_INT_5_9_9_9_REV;if(35899===p)return gl.UNSIGNED_INT_10F_11F_11F_REV;if(1010===p)return gl.BYTE;if(1011===p)return gl.SHORT;if(1012===p)return gl.UNSIGNED_SHORT;if(1013===p)return gl.INT;if(1014===p)return gl.UNSIGNED_INT;if(1015===p)return gl.FLOAT;if(p===HalfFloatType)return gl.HALF_FLOAT;if(1021===p)return gl.ALPHA;if(1022===p)return gl.RGB;if(1023===p)return gl.RGBA;if(1026===p)return gl.DEPTH_COMPONENT;if(1027===p)return gl.DEPTH_STENCIL;if(1028===p)return gl.RED;if(1029===p)return gl.RED_INTEGER;if(1030===p)return gl.RG;if(1031===p)return gl.RG_INTEGER;if(1033===p)return gl.RGBA_INTEGER;if(33776===p||33777===p||33778===p||33779===p)if("srgb"===transfer){if(extension=extensions.get("WEBGL_compressed_texture_s3tc_srgb"),null===extension)return null;if(33776===p)return extension.COMPRESSED_SRGB_S3TC_DXT1_EXT;if(33777===p)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;if(33778===p)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;if(33779===p)return extension.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT}else{if(extension=extensions.get("WEBGL_compressed_texture_s3tc"),null===extension)return null;if(33776===p)return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;if(33777===p)return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;if(33778===p)return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;if(33779===p)return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT}if(35840===p||35841===p||35842===p||35843===p){if(extension=extensions.get("WEBGL_compressed_texture_pvrtc"),null===extension)return null;if(35840===p)return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;if(35841===p)return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;if(35842===p)return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;if(35843===p)return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG}if(36196===p||37492===p||37496===p||37488===p||37489===p||37490===p||37491===p){if(extension=extensions.get("WEBGL_compressed_texture_etc"),null===extension)return null;if(36196===p||37492===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ETC2:extension.COMPRESSED_RGB8_ETC2;if(37496===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC:extension.COMPRESSED_RGBA8_ETC2_EAC;if(37488===p)return extension.COMPRESSED_R11_EAC;if(37489===p)return extension.COMPRESSED_SIGNED_R11_EAC;if(37490===p)return extension.COMPRESSED_RG11_EAC;if(37491===p)return extension.COMPRESSED_SIGNED_RG11_EAC}if(37808===p||37809===p||37810===p||37811===p||37812===p||37813===p||37814===p||37815===p||37816===p||37817===p||37818===p||37819===p||37820===p||37821===p){if(extension=extensions.get("WEBGL_compressed_texture_astc"),null===extension)return null;if(37808===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR:extension.COMPRESSED_RGBA_ASTC_4x4_KHR;if(37809===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR:extension.COMPRESSED_RGBA_ASTC_5x4_KHR;if(37810===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR:extension.COMPRESSED_RGBA_ASTC_5x5_KHR;if(37811===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR:extension.COMPRESSED_RGBA_ASTC_6x5_KHR;if(37812===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR:extension.COMPRESSED_RGBA_ASTC_6x6_KHR;if(37813===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR:extension.COMPRESSED_RGBA_ASTC_8x5_KHR;if(37814===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR:extension.COMPRESSED_RGBA_ASTC_8x6_KHR;if(37815===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR:extension.COMPRESSED_RGBA_ASTC_8x8_KHR;if(37816===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR:extension.COMPRESSED_RGBA_ASTC_10x5_KHR;if(37817===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR:extension.COMPRESSED_RGBA_ASTC_10x6_KHR;if(37818===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR:extension.COMPRESSED_RGBA_ASTC_10x8_KHR;if(37819===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR:extension.COMPRESSED_RGBA_ASTC_10x10_KHR;if(37820===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR:extension.COMPRESSED_RGBA_ASTC_12x10_KHR;if(37821===p)return"srgb"===transfer?extension.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR:extension.COMPRESSED_RGBA_ASTC_12x12_KHR}if(36492===p){if(extension=extensions.get("EXT_texture_compression_bptc"),null===extension)return null;if(36492===p)return"srgb"===transfer?extension.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT:extension.COMPRESSED_RGBA_BPTC_UNORM_EXT}if(36283===p||36284===p||36285===p||36286===p){if(extension=extensions.get("EXT_texture_compression_rgtc"),null===extension)return null;if(36283===p)return extension.COMPRESSED_RED_RGTC1_EXT;if(36284===p)return extension.COMPRESSED_SIGNED_RED_RGTC1_EXT;if(36285===p)return extension.COMPRESSED_RED_GREEN_RGTC2_EXT;if(36286===p)return extension.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT}return 1020===p?gl.UNSIGNED_INT_24_8:void 0!==gl[p]?gl[p]:null}_clientWaitAsync(){const{gl:gl}=this,sync=gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE,0);return gl.flush(),new Promise((resolve,reject)=>{!function test(){const res=gl.clientWaitSync(sync,gl.SYNC_FLUSH_COMMANDS_BIT,0);if(res===gl.WAIT_FAILED)return gl.deleteSync(sync),void reject();res!==gl.TIMEOUT_EXPIRED?(gl.deleteSync(sync),resolve()):requestAnimationFrame(test)}()})}}let wrappingToGL,filterToGL,compareToGL,initialized=!1;class WebGLTextureUtils{constructor(backend){this.backend=backend,this.gl=backend.gl,this.extensions=backend.extensions,this.defaultTextures={},this._srcFramebuffer=null,this._dstFramebuffer=null,!1===initialized&&(this._init(),initialized=!0)}_init(){const gl=this.gl;wrappingToGL={[RepeatWrapping]:gl.REPEAT,[ClampToEdgeWrapping]:gl.CLAMP_TO_EDGE,[MirroredRepeatWrapping]:gl.MIRRORED_REPEAT},filterToGL={[NearestFilter]:gl.NEAREST,[NearestMipmapNearestFilter]:gl.NEAREST_MIPMAP_NEAREST,[NearestMipmapLinearFilter]:gl.NEAREST_MIPMAP_LINEAR,[LinearFilter]:gl.LINEAR,[LinearMipmapNearestFilter]:gl.LINEAR_MIPMAP_NEAREST,[LinearMipmapLinearFilter]:gl.LINEAR_MIPMAP_LINEAR},compareToGL={[NeverCompare]:gl.NEVER,[AlwaysCompare]:gl.ALWAYS,[LessCompare]:gl.LESS,[LessEqualCompare]:gl.LEQUAL,[EqualCompare]:gl.EQUAL,[GreaterEqualCompare]:gl.GEQUAL,[GreaterCompare]:gl.GREATER,[NotEqualCompare]:gl.NOTEQUAL}}getGLTextureType(texture){const{gl:gl}=this;let glTextureType;return glTextureType=!0===texture.isCubeTexture?gl.TEXTURE_CUBE_MAP:!0===texture.isArrayTexture||!0===texture.isDataArrayTexture||!0===texture.isCompressedArrayTexture?gl.TEXTURE_2D_ARRAY:!0===texture.isData3DTexture?gl.TEXTURE_3D:gl.TEXTURE_2D,glTextureType}getInternalFormat(internalFormatName,glFormat,glType,colorSpace,forceLinearTransfer=!1){const{gl:gl,extensions:extensions}=this;if(null!==internalFormatName){if(void 0!==gl[internalFormatName])return gl[internalFormatName];warn("WebGLBackend: Attempt to use non-existing WebGL internal format '"+internalFormatName+"'")}let internalFormat=glFormat;if(glFormat===gl.RED&&(glType===gl.FLOAT&&(internalFormat=gl.R32F),glType===gl.HALF_FLOAT&&(internalFormat=gl.R16F),glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.R8),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.R16),glType===gl.UNSIGNED_INT&&(internalFormat=gl.R32UI),glType===gl.BYTE&&(internalFormat=gl.R8I),glType===gl.SHORT&&(internalFormat=gl.R16I),glType===gl.INT&&(internalFormat=gl.R32I)),glFormat===gl.RED_INTEGER&&(glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.R8UI),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.R16UI),glType===gl.UNSIGNED_INT&&(internalFormat=gl.R32UI),glType===gl.BYTE&&(internalFormat=gl.R8I),glType===gl.SHORT&&(internalFormat=gl.R16I),glType===gl.INT&&(internalFormat=gl.R32I)),glFormat===gl.RG&&(glType===gl.FLOAT&&(internalFormat=gl.RG32F),glType===gl.HALF_FLOAT&&(internalFormat=gl.RG16F),glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.RG8),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.RG16),glType===gl.UNSIGNED_INT&&(internalFormat=gl.RG32UI),glType===gl.BYTE&&(internalFormat=gl.RG8I),glType===gl.SHORT&&(internalFormat=gl.RG16I),glType===gl.INT&&(internalFormat=gl.RG32I)),glFormat===gl.RG_INTEGER&&(glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.RG8UI),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.RG16UI),glType===gl.UNSIGNED_INT&&(internalFormat=gl.RG32UI),glType===gl.BYTE&&(internalFormat=gl.RG8I),glType===gl.SHORT&&(internalFormat=gl.RG16I),glType===gl.INT&&(internalFormat=gl.RG32I)),glFormat===gl.RGB){const transfer=forceLinearTransfer?"linear":ColorManagement.getTransfer(colorSpace);glType===gl.FLOAT&&(internalFormat=gl.RGB32F),glType===gl.HALF_FLOAT&&(internalFormat=gl.RGB16F),glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.RGB8),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.RGB16),glType===gl.UNSIGNED_INT&&(internalFormat=gl.RGB32UI),glType===gl.BYTE&&(internalFormat=gl.RGB8I),glType===gl.SHORT&&(internalFormat=gl.RGB16I),glType===gl.INT&&(internalFormat=gl.RGB32I),glType===gl.UNSIGNED_BYTE&&(internalFormat="srgb"===transfer?gl.SRGB8:gl.RGB8),glType===gl.UNSIGNED_SHORT_5_6_5&&(internalFormat=gl.RGB565),glType===gl.UNSIGNED_SHORT_5_5_5_1&&(internalFormat=gl.RGB5_A1),glType===gl.UNSIGNED_SHORT_4_4_4_4&&(internalFormat=gl.RGB4),glType===gl.UNSIGNED_INT_5_9_9_9_REV&&(internalFormat=gl.RGB9_E5),glType===gl.UNSIGNED_INT_10F_11F_11F_REV&&(internalFormat=gl.R11F_G11F_B10F)}if(glFormat===gl.RGB_INTEGER&&(glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.RGB8UI),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.RGB16UI),glType===gl.UNSIGNED_INT&&(internalFormat=gl.RGB32UI),glType===gl.BYTE&&(internalFormat=gl.RGB8I),glType===gl.SHORT&&(internalFormat=gl.RGB16I),glType===gl.INT&&(internalFormat=gl.RGB32I)),glFormat===gl.RGBA){const transfer=forceLinearTransfer?"linear":ColorManagement.getTransfer(colorSpace);glType===gl.FLOAT&&(internalFormat=gl.RGBA32F),glType===gl.HALF_FLOAT&&(internalFormat=gl.RGBA16F),glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.RGBA8),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.RGBA16),glType===gl.UNSIGNED_INT&&(internalFormat=gl.RGBA32UI),glType===gl.BYTE&&(internalFormat=gl.RGBA8I),glType===gl.SHORT&&(internalFormat=gl.RGBA16I),glType===gl.INT&&(internalFormat=gl.RGBA32I),glType===gl.UNSIGNED_BYTE&&(internalFormat="srgb"===transfer?gl.SRGB8_ALPHA8:gl.RGBA8),glType===gl.UNSIGNED_SHORT_4_4_4_4&&(internalFormat=gl.RGBA4),glType===gl.UNSIGNED_SHORT_5_5_5_1&&(internalFormat=gl.RGB5_A1)}return glFormat===gl.RGBA_INTEGER&&(glType===gl.UNSIGNED_BYTE&&(internalFormat=gl.RGBA8UI),glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.RGBA16UI),glType===gl.UNSIGNED_INT&&(internalFormat=gl.RGBA32UI),glType===gl.BYTE&&(internalFormat=gl.RGBA8I),glType===gl.SHORT&&(internalFormat=gl.RGBA16I),glType===gl.INT&&(internalFormat=gl.RGBA32I)),glFormat===gl.DEPTH_COMPONENT&&(glType===gl.UNSIGNED_SHORT&&(internalFormat=gl.DEPTH_COMPONENT16),glType===gl.UNSIGNED_INT&&(internalFormat=gl.DEPTH_COMPONENT24),glType===gl.FLOAT&&(internalFormat=gl.DEPTH_COMPONENT32F)),glFormat===gl.DEPTH_STENCIL&&glType===gl.UNSIGNED_INT_24_8&&(internalFormat=gl.DEPTH24_STENCIL8),internalFormat!==gl.R16F&&internalFormat!==gl.R32F&&internalFormat!==gl.RG16F&&internalFormat!==gl.RG32F&&internalFormat!==gl.RGBA16F&&internalFormat!==gl.RGBA32F||extensions.get("EXT_color_buffer_float"),internalFormat}setTextureParameters(textureType,texture){const{gl:gl,extensions:extensions,backend:backend}=this,workingPrimaries=ColorManagement.getPrimaries(ColorManagement.workingColorSpace),texturePrimaries=""===texture.colorSpace?null:ColorManagement.getPrimaries(texture.colorSpace),unpackConversion=""===texture.colorSpace||workingPrimaries===texturePrimaries?gl.NONE:gl.BROWSER_DEFAULT_WEBGL;gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,texture.flipY),gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,texture.premultiplyAlpha),gl.pixelStorei(gl.UNPACK_ALIGNMENT,texture.unpackAlignment),gl.pixelStorei(gl.UNPACK_COLORSPACE_CONVERSION_WEBGL,unpackConversion),gl.texParameteri(textureType,gl.TEXTURE_WRAP_S,wrappingToGL[texture.wrapS]),gl.texParameteri(textureType,gl.TEXTURE_WRAP_T,wrappingToGL[texture.wrapT]),textureType!==gl.TEXTURE_3D&&textureType!==gl.TEXTURE_2D_ARRAY||texture.isArrayTexture||gl.texParameteri(textureType,gl.TEXTURE_WRAP_R,wrappingToGL[texture.wrapR]),gl.texParameteri(textureType,gl.TEXTURE_MAG_FILTER,filterToGL[texture.magFilter]);const hasMipmaps=void 0!==texture.mipmaps&&texture.mipmaps.length>0,minFilter=1006===texture.minFilter&&hasMipmaps?1008:texture.minFilter;if(gl.texParameteri(textureType,gl.TEXTURE_MIN_FILTER,filterToGL[minFilter]),texture.compareFunction&&(gl.texParameteri(textureType,gl.TEXTURE_COMPARE_MODE,gl.COMPARE_REF_TO_TEXTURE),gl.texParameteri(textureType,gl.TEXTURE_COMPARE_FUNC,compareToGL[texture.compareFunction])),!0===extensions.has("EXT_texture_filter_anisotropic")){if(1003===texture.magFilter)return;if(1005!==texture.minFilter&&1008!==texture.minFilter)return;if(1015===texture.type&&!1===extensions.has("OES_texture_float_linear"))return;if(texture.anisotropy>1){const extension=extensions.get("EXT_texture_filter_anisotropic");gl.texParameterf(textureType,extension.TEXTURE_MAX_ANISOTROPY_EXT,Math.min(texture.anisotropy,backend.getMaxAnisotropy()))}}}createDefaultTexture(texture){const{gl:gl,backend:backend,defaultTextures:defaultTextures}=this,glTextureType=this.getGLTextureType(texture);let textureGPU=defaultTextures[glTextureType];void 0===textureGPU&&(textureGPU=gl.createTexture(),backend.state.bindTexture(glTextureType,textureGPU),gl.texParameteri(glTextureType,gl.TEXTURE_MIN_FILTER,gl.NEAREST),gl.texParameteri(glTextureType,gl.TEXTURE_MAG_FILTER,gl.NEAREST),defaultTextures[glTextureType]=textureGPU),backend.set(texture,{textureGPU:textureGPU,glTextureType:glTextureType})}createTexture(texture,options){const{gl:gl,backend:backend}=this,{levels:levels,width:width,height:height,depth:depth}=options,glFormat=backend.utils.convert(texture.format,texture.colorSpace),glType=backend.utils.convert(texture.type),glInternalFormat=this.getInternalFormat(texture.internalFormat,glFormat,glType,texture.colorSpace,texture.isVideoTexture),textureGPU=gl.createTexture(),glTextureType=this.getGLTextureType(texture);backend.state.bindTexture(glTextureType,textureGPU),this.setTextureParameters(glTextureType,texture),texture.isArrayTexture||texture.isDataArrayTexture||texture.isCompressedArrayTexture?gl.texStorage3D(gl.TEXTURE_2D_ARRAY,levels,glInternalFormat,width,height,depth):texture.isData3DTexture?gl.texStorage3D(gl.TEXTURE_3D,levels,glInternalFormat,width,height,depth):texture.isVideoTexture||gl.texStorage2D(glTextureType,levels,glInternalFormat,width,height),backend.set(texture,{textureGPU:textureGPU,glTextureType:glTextureType,glFormat:glFormat,glType:glType,glInternalFormat:glInternalFormat})}copyBufferToTexture(buffer,texture){const{gl:gl,backend:backend}=this,{textureGPU:textureGPU,glTextureType:glTextureType,glFormat:glFormat,glType:glType}=backend.get(texture),{width:width,height:height}=texture.source.data;gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER,buffer),backend.state.bindTexture(glTextureType,textureGPU),gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,!1),gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,!1),gl.texSubImage2D(glTextureType,0,0,0,width,height,glFormat,glType,0),gl.bindBuffer(gl.PIXEL_UNPACK_BUFFER,null),backend.state.unbindTexture()}updateTexture(texture,options){const{gl:gl}=this,{width:width,height:height}=options,{textureGPU:textureGPU,glTextureType:glTextureType,glFormat:glFormat,glType:glType,glInternalFormat:glInternalFormat}=this.backend.get(texture);if(!texture.isRenderTargetTexture&&void 0!==textureGPU)if(this.backend.state.bindTexture(glTextureType,textureGPU),this.setTextureParameters(glTextureType,texture),texture.isCompressedTexture){const mipmaps=texture.mipmaps,image=options.image;for(let i=0;i<mipmaps.length;i++){const mipmap=mipmaps[i];texture.isCompressedArrayTexture?texture.format!==gl.RGBA?null!==glFormat?gl.compressedTexSubImage3D(gl.TEXTURE_2D_ARRAY,i,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,mipmap.data):warn("WebGLBackend: Attempt to load unsupported compressed texture format in .uploadTexture()"):gl.texSubImage3D(gl.TEXTURE_2D_ARRAY,i,0,0,0,mipmap.width,mipmap.height,image.depth,glFormat,glType,mipmap.data):null!==glFormat?gl.compressedTexSubImage2D(gl.TEXTURE_2D,i,0,0,mipmap.width,mipmap.height,glFormat,mipmap.data):warn("WebGLBackend: Unsupported compressed texture format")}}else if(texture.isCubeTexture){const images=options.images,mipmaps=texture.mipmaps;for(let i=0;i<6;i++){const image=getImage(images[i]);gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,0,0,0,width,height,glFormat,glType,image);for(let j=0;j<mipmaps.length;j++){const image=getImage(mipmaps[j].images[i]);gl.texSubImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X+i,j+1,0,0,image.width,image.height,glFormat,glType,image)}}}else if(texture.isDataArrayTexture||texture.isArrayTexture){const image=options.image;if(texture.layerUpdates.size>0){const layerByteLength=getByteLength(image.width,image.height,texture.format,texture.type);for(const layerIndex of texture.layerUpdates){const layerData=image.data.subarray(layerIndex*layerByteLength/image.data.BYTES_PER_ELEMENT,(layerIndex+1)*layerByteLength/image.data.BYTES_PER_ELEMENT);gl.texSubImage3D(gl.TEXTURE_2D_ARRAY,0,0,0,layerIndex,image.width,image.height,1,glFormat,glType,layerData)}texture.clearLayerUpdates()}else gl.texSubImage3D(gl.TEXTURE_2D_ARRAY,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data)}else if(texture.isData3DTexture){const image=options.image;gl.texSubImage3D(gl.TEXTURE_3D,0,0,0,0,image.width,image.height,image.depth,glFormat,glType,image.data)}else if(texture.isVideoTexture)texture.update(),gl.texImage2D(glTextureType,0,glInternalFormat,glFormat,glType,options.image);else{const mipmaps=texture.mipmaps;if(mipmaps.length>0)for(let i=0,il=mipmaps.length;i<il;i++){const mipmap=mipmaps[i],image=getImage(mipmap);gl.texSubImage2D(glTextureType,i,0,0,mipmap.width,mipmap.height,glFormat,glType,image)}else{const image=getImage(options.image);gl.texSubImage2D(glTextureType,0,0,0,width,height,glFormat,glType,image)}}}generateMipmaps(texture){const{gl:gl,backend:backend}=this,{textureGPU:textureGPU,glTextureType:glTextureType}=backend.get(texture);backend.state.bindTexture(glTextureType,textureGPU),gl.generateMipmap(glTextureType)}deallocateRenderBuffers(renderTarget){const{gl:gl,backend:backend}=this;if(renderTarget){const renderContextData=backend.get(renderTarget);if(renderContextData.renderBufferStorageSetup=void 0,renderContextData.framebuffers){for(const cacheKey in renderContextData.framebuffers)gl.deleteFramebuffer(renderContextData.framebuffers[cacheKey]);delete renderContextData.framebuffers}if(renderContextData.depthRenderbuffer&&(gl.deleteRenderbuffer(renderContextData.depthRenderbuffer),delete renderContextData.depthRenderbuffer),renderContextData.stencilRenderbuffer&&(gl.deleteRenderbuffer(renderContextData.stencilRenderbuffer),delete renderContextData.stencilRenderbuffer),renderContextData.msaaFrameBuffer&&(gl.deleteFramebuffer(renderContextData.msaaFrameBuffer),delete renderContextData.msaaFrameBuffer),renderContextData.msaaRenderbuffers){for(let i=0;i<renderContextData.msaaRenderbuffers.length;i++)gl.deleteRenderbuffer(renderContextData.msaaRenderbuffers[i]);delete renderContextData.msaaRenderbuffers}}}destroyTexture(texture,isDefaultTexture=!1){const{gl:gl,backend:backend}=this,{textureGPU:textureGPU,renderTarget:renderTarget}=backend.get(texture);this.deallocateRenderBuffers(renderTarget),!1===isDefaultTexture&&gl.deleteTexture(textureGPU),backend.delete(texture)}copyTextureToTexture(srcTexture,dstTexture,srcRegion=null,dstPosition=null,srcLevel=0,dstLevel=0){const{gl:gl,backend:backend}=this,{state:state}=this.backend,{textureGPU:dstTextureGPU,glTextureType:glTextureType,glType:glType,glFormat:glFormat}=backend.get(dstTexture);let width,height,depth,minX,minY,minZ,dstX,dstY,dstZ;state.bindTexture(glTextureType,dstTextureGPU);const image=srcTexture.isCompressedTexture?srcTexture.mipmaps[dstLevel]:srcTexture.image;if(null!==srcRegion)width=srcRegion.max.x-srcRegion.min.x,height=srcRegion.max.y-srcRegion.min.y,depth=srcRegion.isBox3?srcRegion.max.z-srcRegion.min.z:1,minX=srcRegion.min.x,minY=srcRegion.min.y,minZ=srcRegion.isBox3?srcRegion.min.z:0;else{const levelScale=Math.pow(2,-srcLevel);width=Math.floor(image.width*levelScale),height=Math.floor(image.height*levelScale),depth=srcTexture.isDataArrayTexture||srcTexture.isArrayTexture?image.depth:srcTexture.isData3DTexture?Math.floor(image.depth*levelScale):1,minX=0,minY=0,minZ=0}null!==dstPosition?(dstX=dstPosition.x,dstY=dstPosition.y,dstZ=dstPosition.z):(dstX=0,dstY=0,dstZ=0),gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,dstTexture.flipY),gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL,dstTexture.premultiplyAlpha),gl.pixelStorei(gl.UNPACK_ALIGNMENT,dstTexture.unpackAlignment);const currentUnpackRowLen=gl.getParameter(gl.UNPACK_ROW_LENGTH),currentUnpackImageHeight=gl.getParameter(gl.UNPACK_IMAGE_HEIGHT),currentUnpackSkipPixels=gl.getParameter(gl.UNPACK_SKIP_PIXELS),currentUnpackSkipRows=gl.getParameter(gl.UNPACK_SKIP_ROWS),currentUnpackSkipImages=gl.getParameter(gl.UNPACK_SKIP_IMAGES);gl.pixelStorei(gl.UNPACK_ROW_LENGTH,image.width),gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT,image.height),gl.pixelStorei(gl.UNPACK_SKIP_PIXELS,minX),gl.pixelStorei(gl.UNPACK_SKIP_ROWS,minY),gl.pixelStorei(gl.UNPACK_SKIP_IMAGES,minZ);const isSrc3D=srcTexture.isDataArrayTexture||srcTexture.isData3DTexture||dstTexture.isArrayTexture,isDst3D=dstTexture.isDataArrayTexture||dstTexture.isData3DTexture||dstTexture.isArrayTexture;if(srcTexture.isDepthTexture){const srcTextureData=backend.get(srcTexture),dstTextureData=backend.get(dstTexture),srcRenderContextData=backend.get(srcTextureData.renderTarget),dstRenderContextData=backend.get(dstTextureData.renderTarget),srcFramebuffer=srcRenderContextData.framebuffers[srcTextureData.cacheKey],dstFramebuffer=dstRenderContextData.framebuffers[dstTextureData.cacheKey];state.bindFramebuffer(gl.READ_FRAMEBUFFER,srcFramebuffer),state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,dstFramebuffer);for(let i=0;i<depth;i++)isSrc3D&&(gl.framebufferTextureLayer(gl.READ_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,srcTextureData.textureGPU,srcLevel,minZ+i),gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,dstTextureGPU,dstLevel,dstZ+i)),gl.blitFramebuffer(minX,minY,width,height,dstX,dstY,width,height,gl.DEPTH_BUFFER_BIT,gl.NEAREST);state.bindFramebuffer(gl.READ_FRAMEBUFFER,null),state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null)}else if(0!==srcLevel||srcTexture.isRenderTargetTexture||backend.has(srcTexture)){const srcTextureData=backend.get(srcTexture);null===this._srcFramebuffer&&(this._srcFramebuffer=gl.createFramebuffer()),null===this._dstFramebuffer&&(this._dstFramebuffer=gl.createFramebuffer()),state.bindFramebuffer(gl.READ_FRAMEBUFFER,this._srcFramebuffer),state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,this._dstFramebuffer);for(let i=0;i<depth;i++)isSrc3D?gl.framebufferTextureLayer(gl.READ_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,srcTextureData.textureGPU,srcLevel,minZ+i):gl.framebufferTexture2D(gl.READ_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,srcTextureData.textureGPU,srcLevel),isDst3D?gl.framebufferTextureLayer(gl.DRAW_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,dstTextureGPU,dstLevel,dstZ+i):gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,dstTextureGPU,dstLevel),0!==srcLevel?gl.blitFramebuffer(minX,minY,width,height,dstX,dstY,width,height,gl.COLOR_BUFFER_BIT,gl.NEAREST):isDst3D?gl.copyTexSubImage3D(glTextureType,dstLevel,dstX,dstY,dstZ+i,minX,minY,width,height):gl.copyTexSubImage2D(glTextureType,dstLevel,dstX,dstY,minX,minY,width,height);state.bindFramebuffer(gl.READ_FRAMEBUFFER,null),state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,null)}else isDst3D?srcTexture.isDataTexture||srcTexture.isData3DTexture?gl.texSubImage3D(glTextureType,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,glType,image.data):dstTexture.isCompressedArrayTexture?gl.compressedTexSubImage3D(glTextureType,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,image.data):gl.texSubImage3D(glTextureType,dstLevel,dstX,dstY,dstZ,width,height,depth,glFormat,glType,image):srcTexture.isDataTexture?gl.texSubImage2D(gl.TEXTURE_2D,dstLevel,dstX,dstY,width,height,glFormat,glType,image.data):srcTexture.isCompressedTexture?gl.compressedTexSubImage2D(gl.TEXTURE_2D,dstLevel,dstX,dstY,image.width,image.height,glFormat,image.data):gl.texSubImage2D(gl.TEXTURE_2D,dstLevel,dstX,dstY,width,height,glFormat,glType,image);gl.pixelStorei(gl.UNPACK_ROW_LENGTH,currentUnpackRowLen),gl.pixelStorei(gl.UNPACK_IMAGE_HEIGHT,currentUnpackImageHeight),gl.pixelStorei(gl.UNPACK_SKIP_PIXELS,currentUnpackSkipPixels),gl.pixelStorei(gl.UNPACK_SKIP_ROWS,currentUnpackSkipRows),gl.pixelStorei(gl.UNPACK_SKIP_IMAGES,currentUnpackSkipImages),0===dstLevel&&dstTexture.generateMipmaps&&gl.generateMipmap(glTextureType),state.unbindTexture()}copyFramebufferToTexture(texture,renderContext,rectangle){const{gl:gl}=this,{state:state}=this.backend,{textureGPU:textureGPU}=this.backend.get(texture),{x:x,y:y,z:width,w:height}=rectangle,requireDrawFrameBuffer=!0===texture.isDepthTexture||renderContext.renderTarget&&renderContext.renderTarget.samples>0,srcHeight=renderContext.renderTarget?renderContext.renderTarget.height:this.backend.getDrawingBufferSize().y;if(requireDrawFrameBuffer){const partial=0!==x||0!==y;let mask,attachment;if(!0===texture.isDepthTexture?(mask=gl.DEPTH_BUFFER_BIT,attachment=gl.DEPTH_ATTACHMENT,renderContext.stencil&&(mask|=gl.STENCIL_BUFFER_BIT)):(mask=gl.COLOR_BUFFER_BIT,attachment=gl.COLOR_ATTACHMENT0),partial){const renderTargetContextData=this.backend.get(renderContext.renderTarget),fb=renderTargetContextData.framebuffers[renderContext.getCacheKey()],msaaFrameBuffer=renderTargetContextData.msaaFrameBuffer;state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,fb),state.bindFramebuffer(gl.READ_FRAMEBUFFER,msaaFrameBuffer);const flippedY=srcHeight-y-height;gl.blitFramebuffer(x,flippedY,x+width,flippedY+height,x,flippedY,x+width,flippedY+height,mask,gl.NEAREST),state.bindFramebuffer(gl.READ_FRAMEBUFFER,fb),state.bindTexture(gl.TEXTURE_2D,textureGPU),gl.copyTexSubImage2D(gl.TEXTURE_2D,0,0,0,x,flippedY,width,height),state.unbindTexture()}else{const fb=gl.createFramebuffer();state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,fb),gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER,attachment,gl.TEXTURE_2D,textureGPU,0),gl.blitFramebuffer(0,0,width,height,0,0,width,height,mask,gl.NEAREST),gl.deleteFramebuffer(fb)}}else state.bindTexture(gl.TEXTURE_2D,textureGPU),gl.copyTexSubImage2D(gl.TEXTURE_2D,0,0,0,x,srcHeight-height-y,width,height),state.unbindTexture();texture.generateMipmaps&&this.generateMipmaps(texture),this.backend._setFramebuffer(renderContext)}setupRenderBufferStorage(renderbuffer,renderContext,samples,useMultisampledRTT=!1){const{gl:gl}=this,renderTarget=renderContext.renderTarget,{depthTexture:depthTexture,depthBuffer:depthBuffer,stencilBuffer:stencilBuffer,width:width,height:height}=renderTarget;if(gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuffer),depthBuffer&&!stencilBuffer){let glInternalFormat=gl.DEPTH_COMPONENT24;if(!0===useMultisampledRTT){this.extensions.get("WEBGL_multisampled_render_to_texture").renderbufferStorageMultisampleEXT(gl.RENDERBUFFER,renderTarget.samples,glInternalFormat,width,height)}else samples>0?(depthTexture&&depthTexture.isDepthTexture&&depthTexture.type===gl.FLOAT&&(glInternalFormat=gl.DEPTH_COMPONENT32F),gl.renderbufferStorageMultisample(gl.RENDERBUFFER,samples,glInternalFormat,width,height)):gl.renderbufferStorage(gl.RENDERBUFFER,glInternalFormat,width,height);gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_ATTACHMENT,gl.RENDERBUFFER,renderbuffer)}else depthBuffer&&stencilBuffer&&(samples>0?gl.renderbufferStorageMultisample(gl.RENDERBUFFER,samples,gl.DEPTH24_STENCIL8,width,height):gl.renderbufferStorage(gl.RENDERBUFFER,gl.DEPTH_STENCIL,width,height),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.DEPTH_STENCIL_ATTACHMENT,gl.RENDERBUFFER,renderbuffer));gl.bindRenderbuffer(gl.RENDERBUFFER,null)}async copyTextureToBuffer(texture,x,y,width,height,faceIndex){const{backend:backend,gl:gl}=this,{textureGPU:textureGPU,glFormat:glFormat,glType:glType}=this.backend.get(texture),fb=gl.createFramebuffer();backend.state.bindFramebuffer(gl.READ_FRAMEBUFFER,fb);const target=texture.isCubeTexture?gl.TEXTURE_CUBE_MAP_POSITIVE_X+faceIndex:gl.TEXTURE_2D;gl.framebufferTexture2D(gl.READ_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,target,textureGPU,0);const typedArrayType=this._getTypedArrayType(glType),byteLength=width*height*this._getBytesPerTexel(glType,glFormat),buffer=gl.createBuffer();gl.bindBuffer(gl.PIXEL_PACK_BUFFER,buffer),gl.bufferData(gl.PIXEL_PACK_BUFFER,byteLength,gl.STREAM_READ),gl.readPixels(x,y,width,height,glFormat,glType,0),gl.bindBuffer(gl.PIXEL_PACK_BUFFER,null),await backend.utils._clientWaitAsync();const dstBuffer=new typedArrayType(byteLength/typedArrayType.BYTES_PER_ELEMENT);return gl.bindBuffer(gl.PIXEL_PACK_BUFFER,buffer),gl.getBufferSubData(gl.PIXEL_PACK_BUFFER,0,dstBuffer),gl.bindBuffer(gl.PIXEL_PACK_BUFFER,null),backend.state.bindFramebuffer(gl.READ_FRAMEBUFFER,null),gl.deleteFramebuffer(fb),dstBuffer}_getTypedArrayType(glType){const{gl:gl}=this;if(glType===gl.UNSIGNED_BYTE)return Uint8Array;if(glType===gl.UNSIGNED_SHORT_4_4_4_4)return Uint16Array;if(glType===gl.UNSIGNED_SHORT_5_5_5_1)return Uint16Array;if(glType===gl.UNSIGNED_SHORT_5_6_5)return Uint16Array;if(glType===gl.UNSIGNED_SHORT)return Uint16Array;if(glType===gl.UNSIGNED_INT)return Uint32Array;if(glType===gl.HALF_FLOAT)return Uint16Array;if(glType===gl.FLOAT)return Float32Array;throw new Error(`Unsupported WebGL type: ${glType}`)}_getBytesPerTexel(glType,glFormat){const{gl:gl}=this;let bytesPerComponent=0;return glType===gl.UNSIGNED_BYTE&&(bytesPerComponent=1),glType!==gl.UNSIGNED_SHORT_4_4_4_4&&glType!==gl.UNSIGNED_SHORT_5_5_5_1&&glType!==gl.UNSIGNED_SHORT_5_6_5&&glType!==gl.UNSIGNED_SHORT&&glType!==gl.HALF_FLOAT||(bytesPerComponent=2),glType!==gl.UNSIGNED_INT&&glType!==gl.FLOAT||(bytesPerComponent=4),glFormat===gl.RGBA?4*bytesPerComponent:glFormat===gl.RGB?3*bytesPerComponent:glFormat===gl.ALPHA?bytesPerComponent:void 0}dispose(){const{gl:gl}=this;null!==this._srcFramebuffer&&gl.deleteFramebuffer(this._srcFramebuffer),null!==this._dstFramebuffer&&gl.deleteFramebuffer(this._dstFramebuffer)}}function getImage(source){return source.isDataTexture?source.image.data:"undefined"!=typeof HTMLImageElement&&source instanceof HTMLImageElement||"undefined"!=typeof HTMLCanvasElement&&source instanceof HTMLCanvasElement||"undefined"!=typeof ImageBitmap&&source instanceof ImageBitmap||"undefined"!=typeof OffscreenCanvas&&source instanceof OffscreenCanvas?source:source.data}class WebGLExtensions{constructor(backend){this.backend=backend,this.gl=this.backend.gl,this.availableExtensions=this.gl.getSupportedExtensions(),this.extensions={}}get(name){let extension=this.extensions[name];return void 0===extension&&(extension=this.gl.getExtension(name),this.extensions[name]=extension),extension}has(name){return this.availableExtensions.includes(name)}}class WebGLCapabilities{constructor(backend){this.backend=backend,this.maxAnisotropy=null}getMaxAnisotropy(){if(null!==this.maxAnisotropy)return this.maxAnisotropy;const gl=this.backend.gl,extensions=this.backend.extensions;if(!0===extensions.has("EXT_texture_filter_anisotropic")){const extension=extensions.get("EXT_texture_filter_anisotropic");this.maxAnisotropy=gl.getParameter(extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT)}else this.maxAnisotropy=0;return this.maxAnisotropy}}const GLFeatureName={WEBGL_multi_draw:"WEBGL_multi_draw",WEBGL_compressed_texture_astc:"texture-compression-astc",WEBGL_compressed_texture_etc:"texture-compression-etc2",WEBGL_compressed_texture_etc1:"texture-compression-etc1",WEBGL_compressed_texture_pvrtc:"texture-compression-pvrtc",WEBGL_compressed_texture_s3tc:"texture-compression-s3tc",EXT_texture_compression_bptc:"texture-compression-bc",EXT_disjoint_timer_query_webgl2:"timestamp-query",OVR_multiview2:"OVR_multiview2"};class WebGLBufferRenderer{constructor(backend){this.gl=backend.gl,this.extensions=backend.extensions,this.info=backend.renderer.info,this.mode=null,this.index=0,this.type=null,this.object=null}render(start,count){const{gl:gl,mode:mode,object:object,type:type,info:info,index:index}=this;0!==index?gl.drawElements(mode,count,type,start):gl.drawArrays(mode,start,count),info.update(object,count,1)}renderInstances(start,count,primcount){const{gl:gl,mode:mode,type:type,index:index,object:object,info:info}=this;0!==primcount&&(0!==index?gl.drawElementsInstanced(mode,count,type,start,primcount):gl.drawArraysInstanced(mode,start,count,primcount),info.update(object,count,primcount))}renderMultiDraw(starts,counts,drawCount){const{extensions:extensions,mode:mode,object:object,info:info}=this;if(0===drawCount)return;const extension=extensions.get("WEBGL_multi_draw");if(null===extension)for(let i=0;i<drawCount;i++)this.render(starts[i],counts[i]);else{0!==this.index?extension.multiDrawElementsWEBGL(mode,counts,0,this.type,starts,0,drawCount):extension.multiDrawArraysWEBGL(mode,starts,0,counts,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++)elementCount+=counts[i];info.update(object,elementCount,1)}}renderMultiDrawInstances(starts,counts,drawCount,primcount){const{extensions:extensions,mode:mode,object:object,info:info}=this;if(0===drawCount)return;const extension=extensions.get("WEBGL_multi_draw");if(null===extension)for(let i=0;i<drawCount;i++)this.renderInstances(starts[i],counts[i],primcount[i]);else{0!==this.index?extension.multiDrawElementsInstancedWEBGL(mode,counts,0,this.type,starts,0,primcount,0,drawCount):extension.multiDrawArraysInstancedWEBGL(mode,starts,0,counts,0,primcount,0,drawCount);let elementCount=0;for(let i=0;i<drawCount;i++)elementCount+=counts[i]*primcount[i];info.update(object,elementCount,1)}}}class TimestampQueryPool{constructor(maxQueries=256){this.trackTimestamp=!0,this.maxQueries=maxQueries,this.currentQueryIndex=0,this.queryOffsets=new Map,this.isDisposed=!1,this.lastValue=0,this.frames=[],this.pendingResolve=!1,this.timestamps=new Map}getTimestampFrames(){return this.frames}getTimestamp(uid){let timestamp=this.timestamps.get(uid);return void 0===timestamp&&(warn(`TimestampQueryPool: No timestamp available for uid ${uid}.`),timestamp=0),timestamp}hasTimestamp(uid){return this.timestamps.has(uid)}allocateQueriesForContext(){}async resolveQueriesAsync(){}dispose(){}}class WebGLTimestampQueryPool extends TimestampQueryPool{constructor(gl,type,maxQueries=2048){if(super(maxQueries),this.gl=gl,this.type=type,this.ext=gl.getExtension("EXT_disjoint_timer_query_webgl2")||gl.getExtension("EXT_disjoint_timer_query"),!this.ext)return warn("EXT_disjoint_timer_query not supported; timestamps will be disabled."),void(this.trackTimestamp=!1);this.queries=[];for(let i=0;i<this.maxQueries;i++)this.queries.push(gl.createQuery());this.activeQuery=null,this.queryStates=new Map}allocateQueriesForContext(uid){if(!this.trackTimestamp)return null;if(this.currentQueryIndex+2>this.maxQueries)return warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`),null;const baseOffset=this.currentQueryIndex;return this.currentQueryIndex+=2,this.queryStates.set(baseOffset,"inactive"),this.queryOffsets.set(uid,baseOffset),baseOffset}beginQuery(uid){if(!this.trackTimestamp||this.isDisposed)return;const baseOffset=this.queryOffsets.get(uid);if(null==baseOffset)return;if(null!==this.activeQuery)return;const query=this.queries[baseOffset];if(query)try{"inactive"===this.queryStates.get(baseOffset)&&(this.gl.beginQuery(this.ext.TIME_ELAPSED_EXT,query),this.activeQuery=baseOffset,this.queryStates.set(baseOffset,"started"))}catch(e){error("Error in beginQuery:",e),this.activeQuery=null,this.queryStates.set(baseOffset,"inactive")}}endQuery(uid){if(!this.trackTimestamp||this.isDisposed)return;const baseOffset=this.queryOffsets.get(uid);if(null!=baseOffset&&this.activeQuery===baseOffset)try{this.gl.endQuery(this.ext.TIME_ELAPSED_EXT),this.queryStates.set(baseOffset,"ended"),this.activeQuery=null}catch(e){error("Error in endQuery:",e),this.queryStates.set(baseOffset,"inactive"),this.activeQuery=null}}async resolveQueriesAsync(){if(!this.trackTimestamp||this.pendingResolve)return this.lastValue;this.pendingResolve=!0;try{const resolvePromises=new Map;for(const[uid,baseOffset]of this.queryOffsets){if("ended"===this.queryStates.get(baseOffset)){const query=this.queries[baseOffset];resolvePromises.set(uid,this.resolveQuery(query))}}if(0===resolvePromises.size)return this.lastValue;const framesDuration={},frames=[];for(const[uid,promise]of resolvePromises){const match=uid.match(/^(.*):f(\d+)$/),frame=parseInt(match[2]);!1===frames.includes(frame)&&frames.push(frame),void 0===framesDuration[frame]&&(framesDuration[frame]=0);const duration=await promise;this.timestamps.set(uid,duration),framesDuration[frame]+=duration}const totalDuration=framesDuration[frames[frames.length-1]];return this.lastValue=totalDuration,this.frames=frames,this.currentQueryIndex=0,this.queryOffsets.clear(),this.queryStates.clear(),this.activeQuery=null,totalDuration}catch(e){return error("Error resolving queries:",e),this.lastValue}finally{this.pendingResolve=!1}}async resolveQuery(query){return new Promise(resolve=>{if(this.isDisposed)return void resolve(this.lastValue);let timeoutId,isResolved=!1;const finalizeResolution=value=>{isResolved||(isResolved=!0,timeoutId&&(clearTimeout(timeoutId),timeoutId=null),resolve(value))},checkQuery=()=>{if(this.isDisposed)finalizeResolution(this.lastValue);else try{if(this.gl.getParameter(this.ext.GPU_DISJOINT_EXT))return void finalizeResolution(this.lastValue);if(!this.gl.getQueryParameter(query,this.gl.QUERY_RESULT_AVAILABLE))return void(timeoutId=setTimeout(checkQuery,1));const elapsed=this.gl.getQueryParameter(query,this.gl.QUERY_RESULT);resolve(Number(elapsed)/1e6)}catch(e){error("Error checking query:",e),resolve(this.lastValue)}};checkQuery()})}dispose(){if(!this.isDisposed&&(this.isDisposed=!0,this.trackTimestamp)){for(const query of this.queries)this.gl.deleteQuery(query);this.queries=[],this.queryStates.clear(),this.queryOffsets.clear(),this.lastValue=0,this.activeQuery=null}}}class WebGLBackend extends Backend{constructor(parameters={}){super(parameters),this.isWebGLBackend=!0,this.attributeUtils=null,this.extensions=null,this.capabilities=null,this.textureUtils=null,this.bufferRenderer=null,this.gl=null,this.state=null,this.utils=null,this.vaoCache={},this.transformFeedbackCache={},this.discard=!1,this.disjoint=null,this.parallel=null,this._currentContext=null,this._knownBindings=new WeakSet,this._supportsInvalidateFramebuffer="undefined"!=typeof navigator&&/OculusBrowser/g.test(navigator.userAgent),this._xrFramebuffer=null}init(renderer){super.init(renderer);const parameters=this.parameters,contextAttributes={antialias:renderer.currentSamples>0,alpha:!0,depth:renderer.depth,stencil:renderer.stencil},glContext=void 0!==parameters.context?parameters.context:renderer.domElement.getContext("webgl2",contextAttributes);function onContextLost(event){event.preventDefault();const contextLossInfo={api:"WebGL",message:event.statusMessage||"Unknown reason",reason:null,originalEvent:event};renderer.onDeviceLost(contextLossInfo)}this._onContextLost=onContextLost,renderer.domElement.addEventListener("webglcontextlost",onContextLost,!1),this.gl=glContext,this.extensions=new WebGLExtensions(this),this.capabilities=new WebGLCapabilities(this),this.attributeUtils=new WebGLAttributeUtils(this),this.textureUtils=new WebGLTextureUtils(this),this.bufferRenderer=new WebGLBufferRenderer(this),this.state=new WebGLState(this),this.utils=new WebGLUtils(this),this.extensions.get("EXT_color_buffer_float"),this.extensions.get("WEBGL_clip_cull_distance"),this.extensions.get("OES_texture_float_linear"),this.extensions.get("EXT_color_buffer_half_float"),this.extensions.get("WEBGL_multisampled_render_to_texture"),this.extensions.get("WEBGL_render_shared_exponent"),this.extensions.get("WEBGL_multi_draw"),this.extensions.get("OVR_multiview2"),this.disjoint=this.extensions.get("EXT_disjoint_timer_query_webgl2"),this.parallel=this.extensions.get("KHR_parallel_shader_compile"),this.drawBuffersIndexedExt=this.extensions.get("OES_draw_buffers_indexed")}get coordinateSystem(){return 2e3}async getArrayBufferAsync(attribute){return await this.attributeUtils.getArrayBufferAsync(attribute)}async makeXRCompatible(){!0!==this.gl.getContextAttributes().xrCompatible&&await this.gl.makeXRCompatible()}setXRTarget(xrFramebuffer){this._xrFramebuffer=xrFramebuffer}setXRRenderTargetTextures(renderTarget,colorTexture,depthTexture=null){const gl=this.gl;if(this.set(renderTarget.texture,{textureGPU:colorTexture,glInternalFormat:gl.RGBA8}),null!==depthTexture){const glInternalFormat=renderTarget.stencilBuffer?gl.DEPTH24_STENCIL8:gl.DEPTH_COMPONENT24;this.set(renderTarget.depthTexture,{textureGPU:depthTexture,glInternalFormat:glInternalFormat}),!0===this.extensions.has("WEBGL_multisampled_render_to_texture")&&!0===renderTarget._autoAllocateDepthBuffer&&!1===renderTarget.multiview&&warn("WebGLBackend: Render-to-texture extension was disabled because an external texture was provided"),renderTarget._autoAllocateDepthBuffer=!1}}initTimestampQuery(type,uid){if(!this.disjoint||!this.trackTimestamp)return;this.timestampQueryPool[type]||(this.timestampQueryPool[type]=new WebGLTimestampQueryPool(this.gl,type,2048));const timestampQueryPool=this.timestampQueryPool[type];null!==timestampQueryPool.allocateQueriesForContext(uid)&&timestampQueryPool.beginQuery(uid)}prepareTimestampBuffer(type,uid){if(!this.disjoint||!this.trackTimestamp)return;this.timestampQueryPool[type].endQuery(uid)}getContext(){return this.gl}beginRender(renderContext){const{state:state}=this,renderContextData=this.get(renderContext);if(renderContext.viewport)this.updateViewport(renderContext);else{const{width:width,height:height}=this.getDrawingBufferSize();state.viewport(0,0,width,height)}if(renderContext.scissor)this.updateScissor(renderContext);else{const{width:width,height:height}=this.getDrawingBufferSize();state.scissor(0,0,width,height)}this.initTimestampQuery(TimestampQuery_RENDER,this.getTimestampUID(renderContext)),renderContextData.previousContext=this._currentContext,this._currentContext=renderContext,this._setFramebuffer(renderContext),this.clear(renderContext.clearColor,renderContext.clearDepth,renderContext.clearStencil,renderContext,!1);const occlusionQueryCount=renderContext.occlusionQueryCount;occlusionQueryCount>0&&(renderContextData.currentOcclusionQueries=renderContextData.occlusionQueries,renderContextData.currentOcclusionQueryObjects=renderContextData.occlusionQueryObjects,renderContextData.lastOcclusionObject=null,renderContextData.occlusionQueries=new Array(occlusionQueryCount),renderContextData.occlusionQueryObjects=new Array(occlusionQueryCount),renderContextData.occlusionQueryIndex=0)}finishRender(renderContext){const{gl:gl,state:state}=this,renderContextData=this.get(renderContext),previousContext=renderContextData.previousContext;state.resetVertexState();const occlusionQueryCount=renderContext.occlusionQueryCount;occlusionQueryCount>0&&(occlusionQueryCount>renderContextData.occlusionQueryIndex&&gl.endQuery(gl.ANY_SAMPLES_PASSED),this.resolveOccludedAsync(renderContext));const textures=renderContext.textures;if(null!==textures)for(let i=0;i<textures.length;i++){const texture=textures[i];texture.generateMipmaps&&this.generateMipmaps(texture)}if(this._currentContext=previousContext,this._resolveRenderTarget(renderContext),null!==previousContext){if(this._setFramebuffer(previousContext),previousContext.viewport)this.updateViewport(previousContext);else{const{width:width,height:height}=this.getDrawingBufferSize();state.viewport(0,0,width,height)}if(previousContext.scissor)this.updateScissor(previousContext);else{const{width:width,height:height}=this.getDrawingBufferSize();state.scissor(0,0,width,height)}}this.prepareTimestampBuffer(TimestampQuery_RENDER,this.getTimestampUID(renderContext))}resolveOccludedAsync(renderContext){const renderContextData=this.get(renderContext),{currentOcclusionQueries:currentOcclusionQueries,currentOcclusionQueryObjects:currentOcclusionQueryObjects}=renderContextData;if(currentOcclusionQueries&&currentOcclusionQueryObjects){const occluded=new WeakSet,{gl:gl}=this;renderContextData.currentOcclusionQueryObjects=null,renderContextData.currentOcclusionQueries=null;const check=()=>{let completed=0;for(let i=0;i<currentOcclusionQueries.length;i++){const query=currentOcclusionQueries[i];null!==query&&(gl.getQueryParameter(query,gl.QUERY_RESULT_AVAILABLE)&&(0===gl.getQueryParameter(query,gl.QUERY_RESULT)&&occluded.add(currentOcclusionQueryObjects[i]),currentOcclusionQueries[i]=null,gl.deleteQuery(query),completed++))}completed<currentOcclusionQueries.length?requestAnimationFrame(check):renderContextData.occluded=occluded};check()}}isOccluded(renderContext,object){const renderContextData=this.get(renderContext);return renderContextData.occluded&&renderContextData.occluded.has(object)}updateViewport(renderContext){const{state:state}=this,{x:x,y:y,width:width,height:height}=renderContext.viewportValue;state.viewport(x,renderContext.height-height-y,width,height)}updateScissor(renderContext){const{state:state}=this,{x:x,y:y,width:width,height:height}=renderContext.scissorValue;state.scissor(x,renderContext.height-height-y,width,height)}setScissorTest(boolean){this.state.setScissorTest(boolean)}getClearColor(){const clearColor=super.getClearColor();return clearColor.r*=clearColor.a,clearColor.g*=clearColor.a,clearColor.b*=clearColor.a,clearColor}clear(color,depth,stencil,descriptor=null,setFrameBuffer=!0,resolveRenderTarget=!0){const{gl:gl,renderer:renderer}=this;if(null===descriptor){descriptor={textures:null,clearColorValue:this.getClearColor()}}let clear=0;if(color&&(clear|=gl.COLOR_BUFFER_BIT),depth&&(clear|=gl.DEPTH_BUFFER_BIT),stencil&&(clear|=gl.STENCIL_BUFFER_BIT),0!==clear){let clearColor;clearColor=descriptor.clearColorValue?descriptor.clearColorValue:this.getClearColor();const clearDepth=renderer.getClearDepth(),clearStencil=renderer.getClearStencil();if(depth&&this.state.setDepthMask(!0),null===descriptor.textures)gl.clearColor(clearColor.r,clearColor.g,clearColor.b,clearColor.a),gl.clear(clear);else{if(setFrameBuffer&&this._setFramebuffer(descriptor),color)for(let i=0;i<descriptor.textures.length;i++)0===i?gl.clearBufferfv(gl.COLOR,i,[clearColor.r,clearColor.g,clearColor.b,clearColor.a]):gl.clearBufferfv(gl.COLOR,i,[0,0,0,1]);depth&&stencil?gl.clearBufferfi(gl.DEPTH_STENCIL,0,clearDepth,clearStencil):depth?gl.clearBufferfv(gl.DEPTH,0,[clearDepth]):stencil&&gl.clearBufferiv(gl.STENCIL,0,[clearStencil]),setFrameBuffer&&resolveRenderTarget&&this._resolveRenderTarget(descriptor)}}}beginCompute(computeGroup){const{state:state,gl:gl}=this;state.bindFramebuffer(gl.FRAMEBUFFER,null),this.initTimestampQuery(TimestampQuery_COMPUTE,this.getTimestampUID(computeGroup))}compute(computeGroup,computeNode,bindings,pipeline,count=null){const{state:state,gl:gl}=this;!1===this.discard&&(state.enable(gl.RASTERIZER_DISCARD),this.discard=!0);const{programGPU:programGPU,transformBuffers:transformBuffers,attributes:attributes}=this.get(pipeline),vaoKey=this._getVaoKey(attributes),vaoGPU=this.vaoCache[vaoKey];void 0===vaoGPU?this.vaoCache[vaoKey]=this._createVao(attributes):state.setVertexState(vaoGPU),state.useProgram(programGPU),this._bindUniforms(bindings);const transformFeedbackGPU=this._getTransformFeedback(transformBuffers);gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,transformFeedbackGPU),gl.beginTransformFeedback(gl.POINTS),count=null!==count?count:computeNode.count,Array.isArray(count)?(warnOnce("WebGLBackend.compute(): The count parameter must be a single number, not an array."),count=count[0]):count&&"object"==typeof count&&count.isIndirectStorageBufferAttribute&&(warnOnce("WebGLBackend.compute(): The count parameter must be a single number, not IndirectStorageBufferAttribute"),count=computeNode.count),attributes[0].isStorageInstancedBufferAttribute?gl.drawArraysInstanced(gl.POINTS,0,1,count):gl.drawArrays(gl.POINTS,0,count),gl.endTransformFeedback(),gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,null);for(let i=0;i<transformBuffers.length;i++){const dualAttributeData=transformBuffers[i];dualAttributeData.pbo&&this.has(dualAttributeData.pbo)&&this.textureUtils.copyBufferToTexture(dualAttributeData.transformBuffer,dualAttributeData.pbo),dualAttributeData.switchBuffers()}}finishCompute(computeGroup){const{state:state,gl:gl}=this;this.discard=!1,state.disable(gl.RASTERIZER_DISCARD),this.prepareTimestampBuffer(TimestampQuery_COMPUTE,this.getTimestampUID(computeGroup)),this._currentContext&&this._setFramebuffer(this._currentContext)}_isRenderCameraDepthArray(renderContext){return renderContext.depthTexture&&renderContext.depthTexture.isArrayTexture&&renderContext.camera.isArrayCamera}draw(renderObject){const{object:object,pipeline:pipeline,material:material,context:context,hardwareClippingPlanes:hardwareClippingPlanes}=renderObject,{programGPU:programGPU}=this.get(pipeline),{gl:gl,state:state}=this,contextData=this.get(context),drawParams=renderObject.getDrawParameters();if(null===drawParams)return;this._bindUniforms(renderObject.getBindings());const frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;state.setMaterial(material,frontFaceCW,hardwareClippingPlanes),null!==context.mrt&&null!==context.textures&&state.setMRTBlending(context.textures,context.mrt,material),state.useProgram(programGPU);const attributes=renderObject.getAttributes(),attributesData=this.get(attributes);let vaoGPU=attributesData.vaoGPU;if(void 0===vaoGPU){const vaoKey=this._getVaoKey(attributes);vaoGPU=this.vaoCache[vaoKey],void 0===vaoGPU&&(vaoGPU=this._createVao(attributes),this.vaoCache[vaoKey]=vaoGPU,attributesData.vaoGPU=vaoGPU)}const index=renderObject.getIndex(),indexGPU=null!==index?this.get(index).bufferGPU:null;state.setVertexState(vaoGPU,indexGPU);const lastObject=contextData.lastOcclusionObject;if(lastObject!==object&&void 0!==lastObject){if(null!==lastObject&&!0===lastObject.occlusionTest&&(gl.endQuery(gl.ANY_SAMPLES_PASSED),contextData.occlusionQueryIndex++),!0===object.occlusionTest){const query=gl.createQuery();gl.beginQuery(gl.ANY_SAMPLES_PASSED,query),contextData.occlusionQueries[contextData.occlusionQueryIndex]=query,contextData.occlusionQueryObjects[contextData.occlusionQueryIndex]=object}contextData.lastOcclusionObject=object}const renderer=this.bufferRenderer;object.isPoints?renderer.mode=gl.POINTS:object.isLineSegments?renderer.mode=gl.LINES:object.isLine?renderer.mode=gl.LINE_STRIP:object.isLineLoop?renderer.mode=gl.LINE_LOOP:!0===material.wireframe?(state.setLineWidth(material.wireframeLinewidth*this.renderer.getPixelRatio()),renderer.mode=gl.LINES):renderer.mode=gl.TRIANGLES;const{vertexCount:vertexCount,instanceCount:instanceCount}=drawParams;let{firstVertex:firstVertex}=drawParams;if(renderer.object=object,null!==index){firstVertex*=index.array.BYTES_PER_ELEMENT;const indexData=this.get(index);renderer.index=index.count,renderer.type=indexData.type}else renderer.index=0;const draw=()=>{object.isBatchedMesh?null!==object._multiDrawInstances?(warnOnce("WebGLBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection."),renderer.renderMultiDrawInstances(object._multiDrawStarts,object._multiDrawCounts,object._multiDrawCount,object._multiDrawInstances)):this.hasFeature("WEBGL_multi_draw")?renderer.renderMultiDraw(object._multiDrawStarts,object._multiDrawCounts,object._multiDrawCount):warnOnce("WebGLBackend: WEBGL_multi_draw not supported."):instanceCount>1?renderer.renderInstances(firstVertex,vertexCount,instanceCount):renderer.render(firstVertex,vertexCount)};if(!0===renderObject.camera.isArrayCamera&&renderObject.camera.cameras.length>0&&!1===renderObject.camera.isMultiViewCamera){const cameraData=this.get(renderObject.camera),cameras=renderObject.camera.cameras,cameraIndex=renderObject.getBindingGroup("cameraIndex").bindings[0];if(void 0===cameraData.indexesGPU||cameraData.indexesGPU.length!==cameras.length){const data=new Uint32Array([0,0,0,0]),indexesGPU=[];for(let i=0,len=cameras.length;i<len;i++){const bufferGPU=gl.createBuffer();data[0]=i,gl.bindBuffer(gl.UNIFORM_BUFFER,bufferGPU),gl.bufferData(gl.UNIFORM_BUFFER,data,gl.STATIC_DRAW),indexesGPU.push(bufferGPU)}cameraData.indexesGPU=indexesGPU}const cameraIndexData=this.get(cameraIndex),pixelRatio=this.renderer.getPixelRatio(),renderTarget=this._currentContext.renderTarget,isRenderCameraDepthArray=this._isRenderCameraDepthArray(this._currentContext),prevActiveCubeFace=this._currentContext.activeCubeFace;if(isRenderCameraDepthArray){const textureData=this.get(renderTarget.depthTexture);if(textureData.clearedRenderId!==this.renderer._nodes.nodeFrame.renderId){textureData.clearedRenderId=this.renderer._nodes.nodeFrame.renderId;const{stencilBuffer:stencilBuffer}=renderTarget;for(let i=0,len=cameras.length;i<len;i++)this.renderer._activeCubeFace=i,this._currentContext.activeCubeFace=i,this._setFramebuffer(this._currentContext),this.clear(!1,!0,stencilBuffer,this._currentContext,!1,!1);this.renderer._activeCubeFace=prevActiveCubeFace,this._currentContext.activeCubeFace=prevActiveCubeFace}}for(let i=0,len=cameras.length;i<len;i++){const subCamera=cameras[i];if(object.layers.test(subCamera.layers)){isRenderCameraDepthArray&&(this.renderer._activeCubeFace=i,this._currentContext.activeCubeFace=i,this._setFramebuffer(this._currentContext));const vp=subCamera.viewport;if(void 0!==vp){const x=vp.x*pixelRatio,y=vp.y*pixelRatio,width=vp.width*pixelRatio,height=vp.height*pixelRatio;state.viewport(Math.floor(x),Math.floor(renderObject.context.height-height-y),Math.floor(width),Math.floor(height))}state.bindBufferBase(gl.UNIFORM_BUFFER,cameraIndexData.index,cameraData.indexesGPU[i]),draw()}this._currentContext.activeCubeFace=prevActiveCubeFace,this.renderer._activeCubeFace=prevActiveCubeFace}}else draw()}needsRenderUpdate(){return!1}getRenderCacheKey(){return""}createDefaultTexture(texture){this.textureUtils.createDefaultTexture(texture)}createTexture(texture,options){this.textureUtils.createTexture(texture,options)}updateTexture(texture,options){this.textureUtils.updateTexture(texture,options)}generateMipmaps(texture){this.textureUtils.generateMipmaps(texture)}destroyTexture(texture,isDefaultTexture=!1){this.textureUtils.destroyTexture(texture,isDefaultTexture)}async copyTextureToBuffer(texture,x,y,width,height,faceIndex){return this.textureUtils.copyTextureToBuffer(texture,x,y,width,height,faceIndex)}updateSampler(){return""}createNodeBuilder(object,renderer){return new GLSLNodeBuilder(object,renderer)}createProgram(program){const gl=this.gl,{stage:stage,code:code}=program,shader="fragment"===stage?gl.createShader(gl.FRAGMENT_SHADER):gl.createShader(gl.VERTEX_SHADER);gl.shaderSource(shader,code),gl.compileShader(shader),this.set(program,{shaderGPU:shader})}destroyProgram(program){this.delete(program)}createRenderPipeline(renderObject,promises){const gl=this.gl,pipeline=renderObject.pipeline,{fragmentProgram:fragmentProgram,vertexProgram:vertexProgram}=pipeline,programGPU=gl.createProgram(),fragmentShader=this.get(fragmentProgram).shaderGPU,vertexShader=this.get(vertexProgram).shaderGPU;if(gl.attachShader(programGPU,fragmentShader),gl.attachShader(programGPU,vertexShader),gl.linkProgram(programGPU),this.set(pipeline,{programGPU:programGPU,fragmentShader:fragmentShader,vertexShader:vertexShader}),null!==promises&&this.parallel){const p=new Promise(resolve=>{const parallel=this.parallel,checkStatus=()=>{gl.getProgramParameter(programGPU,parallel.COMPLETION_STATUS_KHR)?(this._completeCompile(renderObject,pipeline),resolve()):requestAnimationFrame(checkStatus)};checkStatus()});return void promises.push(p)}this._completeCompile(renderObject,pipeline)}_handleSource(string,errorLine){const lines=string.split("\n"),lines2=[],from=Math.max(errorLine-6,0),to=Math.min(errorLine+6,lines.length);for(let i=from;i<to;i++){const line=i+1;lines2.push(`${line===errorLine?">":" "} ${line}: ${lines[i]}`)}return lines2.join("\n")}_getShaderErrors(gl,shader,type){const status=gl.getShaderParameter(shader,gl.COMPILE_STATUS),errors=(gl.getShaderInfoLog(shader)||"").trim();if(status&&""===errors)return"";const errorMatches=/ERROR: 0:(\d+)/.exec(errors);if(errorMatches){const errorLine=parseInt(errorMatches[1]);return type.toUpperCase()+"\n\n"+errors+"\n\n"+this._handleSource(gl.getShaderSource(shader),errorLine)}return errors}_logProgramError(programGPU,glFragmentShader,glVertexShader){if(this.renderer.debug.checkShaderErrors){const gl=this.gl,programLog=(gl.getProgramInfoLog(programGPU)||"").trim();if(!1===gl.getProgramParameter(programGPU,gl.LINK_STATUS))if("function"==typeof this.renderer.debug.onShaderError)this.renderer.debug.onShaderError(gl,programGPU,glVertexShader,glFragmentShader);else{const vertexErrors=this._getShaderErrors(gl,glVertexShader,"vertex"),fragmentErrors=this._getShaderErrors(gl,glFragmentShader,"fragment");error("THREE.WebGLProgram: Shader Error "+gl.getError()+" - VALIDATE_STATUS "+gl.getProgramParameter(programGPU,gl.VALIDATE_STATUS)+"\n\nProgram Info Log: "+programLog+"\n"+vertexErrors+"\n"+fragmentErrors)}else""!==programLog&&warn("WebGLProgram: Program Info Log:",programLog)}}_completeCompile(renderObject,pipeline){const{state:state,gl:gl}=this,pipelineData=this.get(pipeline),{programGPU:programGPU,fragmentShader:fragmentShader,vertexShader:vertexShader}=pipelineData;!1===gl.getProgramParameter(programGPU,gl.LINK_STATUS)&&this._logProgramError(programGPU,fragmentShader,vertexShader),state.useProgram(programGPU);const bindings=renderObject.getBindings();this._setupBindings(bindings,programGPU),this.set(pipeline,{programGPU:programGPU})}createComputePipeline(computePipeline,bindings){const{state:state,gl:gl}=this,fragmentProgram={stage:"fragment",code:"#version 300 es\nprecision highp float;\nvoid main() {}"};this.createProgram(fragmentProgram);const{computeProgram:computeProgram}=computePipeline,programGPU=gl.createProgram(),fragmentShader=this.get(fragmentProgram).shaderGPU,vertexShader=this.get(computeProgram).shaderGPU,transforms=computeProgram.transforms,transformVaryingNames=[],transformAttributeNodes=[];for(let i=0;i<transforms.length;i++){const transform=transforms[i];transformVaryingNames.push(transform.varyingName),transformAttributeNodes.push(transform.attributeNode)}gl.attachShader(programGPU,fragmentShader),gl.attachShader(programGPU,vertexShader),gl.transformFeedbackVaryings(programGPU,transformVaryingNames,gl.SEPARATE_ATTRIBS),gl.linkProgram(programGPU),!1===gl.getProgramParameter(programGPU,gl.LINK_STATUS)&&this._logProgramError(programGPU,fragmentShader,vertexShader),state.useProgram(programGPU),this._setupBindings(bindings,programGPU);const attributeNodes=computeProgram.attributes,attributes=[],transformBuffers=[];for(let i=0;i<attributeNodes.length;i++){const attribute=attributeNodes[i].node.attribute;attributes.push(attribute),this.has(attribute)||this.attributeUtils.createAttribute(attribute,gl.ARRAY_BUFFER)}for(let i=0;i<transformAttributeNodes.length;i++){const attribute=transformAttributeNodes[i].attribute;this.has(attribute)||this.attributeUtils.createAttribute(attribute,gl.ARRAY_BUFFER);const attributeData=this.get(attribute);transformBuffers.push(attributeData)}this.set(computePipeline,{programGPU:programGPU,transformBuffers:transformBuffers,attributes:attributes})}createBindings(bindGroup,bindings){if(!1===this._knownBindings.has(bindings)){this._knownBindings.add(bindings);let uniformBuffers=0,textures=0;for(const bindGroup of bindings){this.set(bindGroup,{textures:textures,uniformBuffers:uniformBuffers});for(const binding of bindGroup.bindings)binding.isUniformBuffer&&uniformBuffers++,binding.isSampledTexture&&textures++}}this.updateBindings(bindGroup,bindings)}updateBindings(bindGroup){const{gl:gl}=this,bindGroupData=this.get(bindGroup);let i=bindGroupData.uniformBuffers,t=bindGroupData.textures;for(const binding of bindGroup.bindings){const map=this.get(binding);if(binding.isUniformsGroup||binding.isUniformBuffer){const array=binding.buffer;let{bufferGPU:bufferGPU}=this.get(array);void 0===bufferGPU?(bufferGPU=gl.createBuffer(),gl.bindBuffer(gl.UNIFORM_BUFFER,bufferGPU),gl.bufferData(gl.UNIFORM_BUFFER,array.byteLength,gl.DYNAMIC_DRAW),this.set(array,{bufferGPU:bufferGPU})):gl.bindBuffer(gl.UNIFORM_BUFFER,bufferGPU);const updateRanges=binding.updateRanges;if(gl.bindBuffer(gl.UNIFORM_BUFFER,bufferGPU),0===updateRanges.length)gl.bufferData(gl.UNIFORM_BUFFER,array,gl.DYNAMIC_DRAW);else{const isTyped=isTypedArray(array),byteOffsetFactor=isTyped?1:array.BYTES_PER_ELEMENT;for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i],dataOffset=range.start*byteOffsetFactor,size=range.count*byteOffsetFactor,bufferOffset=dataOffset*(isTyped?array.BYTES_PER_ELEMENT:1);gl.bufferSubData(gl.UNIFORM_BUFFER,bufferOffset,array,dataOffset,size)}}map.index=i++,map.bufferGPU=bufferGPU,this.set(binding,map)}else if(binding.isSampledTexture){const{textureGPU:textureGPU,glTextureType:glTextureType}=this.get(binding.texture);map.index=t++,map.textureGPU=textureGPU,map.glTextureType=glTextureType,this.set(binding,map)}}}updateBinding(binding){const gl=this.gl;if(binding.isUniformsGroup||binding.isUniformBuffer){const bufferGPU=this.get(binding).bufferGPU,array=binding.buffer,updateRanges=binding.updateRanges;if(gl.bindBuffer(gl.UNIFORM_BUFFER,bufferGPU),0===updateRanges.length)gl.bufferData(gl.UNIFORM_BUFFER,array,gl.DYNAMIC_DRAW);else{const isTyped=isTypedArray(array),byteOffsetFactor=isTyped?1:array.BYTES_PER_ELEMENT;for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i],dataOffset=range.start*byteOffsetFactor,size=range.count*byteOffsetFactor,bufferOffset=dataOffset*(isTyped?array.BYTES_PER_ELEMENT:1);gl.bufferSubData(gl.UNIFORM_BUFFER,bufferOffset,array,dataOffset,size)}}}}createIndexAttribute(attribute){const gl=this.gl;this.attributeUtils.createAttribute(attribute,gl.ELEMENT_ARRAY_BUFFER)}createAttribute(attribute){if(this.has(attribute))return;const gl=this.gl;this.attributeUtils.createAttribute(attribute,gl.ARRAY_BUFFER)}createStorageAttribute(attribute){if(this.has(attribute))return;const gl=this.gl;this.attributeUtils.createAttribute(attribute,gl.ARRAY_BUFFER)}updateAttribute(attribute){this.attributeUtils.updateAttribute(attribute)}destroyAttribute(attribute){this.attributeUtils.destroyAttribute(attribute)}hasFeature(name){const keysMatching=Object.keys(GLFeatureName).filter(key=>GLFeatureName[key]===name),extensions=this.extensions;for(let i=0;i<keysMatching.length;i++)if(extensions.has(keysMatching[i]))return!0;return!1}getMaxAnisotropy(){return this.capabilities.getMaxAnisotropy()}copyTextureToTexture(srcTexture,dstTexture,srcRegion=null,dstPosition=null,srcLevel=0,dstLevel=0){this.textureUtils.copyTextureToTexture(srcTexture,dstTexture,srcRegion,dstPosition,srcLevel,dstLevel)}copyFramebufferToTexture(texture,renderContext,rectangle){this.textureUtils.copyFramebufferToTexture(texture,renderContext,rectangle)}hasCompatibility(name){return name===Compatibility_TEXTURE_COMPARE||super.hasCompatibility(name)}initRenderTarget(renderContext){const{gl:gl,state:state}=this;this._setFramebuffer(renderContext),state.bindFramebuffer(gl.FRAMEBUFFER,null)}_setFramebuffer(descriptor){const{gl:gl,state:state}=this;let currentFrameBuffer=null;if(null!==descriptor.textures){const renderTarget=descriptor.renderTarget,renderTargetContextData=this.get(renderTarget),{samples:samples,depthBuffer:depthBuffer,stencilBuffer:stencilBuffer}=renderTarget,isCube=!0===renderTarget.isCubeRenderTarget,isRenderTarget3D=!0===renderTarget.isRenderTarget3D,isRenderTargetArray=renderTarget.depth>1,isXRRenderTarget=!0===renderTarget.isXRRenderTarget,_hasExternalTextures=!0===isXRRenderTarget&&!0===renderTarget._hasExternalTextures;let msaaFb=renderTargetContextData.msaaFrameBuffer,depthRenderbuffer=renderTargetContextData.depthRenderbuffer;const multisampledRTTExt=this.extensions.get("WEBGL_multisampled_render_to_texture"),multiviewExt=this.extensions.get("OVR_multiview2"),useMultisampledRTT=this._useMultisampledExtension(renderTarget),cacheKey=getCacheKey(descriptor);let fb;if(isCube?(renderTargetContextData.cubeFramebuffers||(renderTargetContextData.cubeFramebuffers={}),fb=renderTargetContextData.cubeFramebuffers[cacheKey]):isXRRenderTarget&&!1===_hasExternalTextures?fb=this._xrFramebuffer:(renderTargetContextData.framebuffers||(renderTargetContextData.framebuffers={}),fb=renderTargetContextData.framebuffers[cacheKey]),void 0===fb){fb=gl.createFramebuffer(),state.bindFramebuffer(gl.FRAMEBUFFER,fb);const textures=descriptor.textures,depthInvalidationArray=[];if(isCube){renderTargetContextData.cubeFramebuffers[cacheKey]=fb;const{textureGPU:textureGPU}=this.get(textures[0]),cubeFace=this.renderer._activeCubeFace,mipLevel=this.renderer._activeMipmapLevel;gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_CUBE_MAP_POSITIVE_X+cubeFace,textureGPU,mipLevel)}else{renderTargetContextData.framebuffers[cacheKey]=fb;for(let i=0;i<textures.length;i++){const texture=textures[i],textureData=this.get(texture);textureData.renderTarget=descriptor.renderTarget,textureData.cacheKey=cacheKey;const attachment=gl.COLOR_ATTACHMENT0+i;if(renderTarget.multiview)multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER,attachment,textureData.textureGPU,0,samples,0,2);else if(isRenderTarget3D||isRenderTargetArray){const layer=this.renderer._activeCubeFace,mipLevel=this.renderer._activeMipmapLevel;gl.framebufferTextureLayer(gl.FRAMEBUFFER,attachment,textureData.textureGPU,mipLevel,layer)}else if(useMultisampledRTT)multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER,attachment,gl.TEXTURE_2D,textureData.textureGPU,0,samples);else{const mipLevel=this.renderer._activeMipmapLevel;gl.framebufferTexture2D(gl.FRAMEBUFFER,attachment,gl.TEXTURE_2D,textureData.textureGPU,mipLevel)}}}const depthStyle=stencilBuffer?gl.DEPTH_STENCIL_ATTACHMENT:gl.DEPTH_ATTACHMENT;if(!0===renderTarget._autoAllocateDepthBuffer){const renderbuffer=gl.createRenderbuffer();this.textureUtils.setupRenderBufferStorage(renderbuffer,descriptor,0,useMultisampledRTT),renderTargetContextData.xrDepthRenderbuffer=renderbuffer,depthInvalidationArray.push(stencilBuffer?gl.DEPTH_STENCIL_ATTACHMENT:gl.DEPTH_ATTACHMENT),gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuffer),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,depthStyle,gl.RENDERBUFFER,renderbuffer)}else if(null!==descriptor.depthTexture){depthInvalidationArray.push(stencilBuffer?gl.DEPTH_STENCIL_ATTACHMENT:gl.DEPTH_ATTACHMENT);const textureData=this.get(descriptor.depthTexture);if(textureData.renderTarget=descriptor.renderTarget,textureData.cacheKey=cacheKey,renderTarget.multiview)multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER,depthStyle,textureData.textureGPU,0,samples,0,2);else if(_hasExternalTextures&&useMultisampledRTT)multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER,depthStyle,gl.TEXTURE_2D,textureData.textureGPU,0,samples);else if(descriptor.depthTexture.isArrayTexture){const layer=this.renderer._activeCubeFace;gl.framebufferTextureLayer(gl.FRAMEBUFFER,depthStyle,textureData.textureGPU,0,layer)}else if(descriptor.depthTexture.isCubeTexture){const cubeFace=this.renderer._activeCubeFace;gl.framebufferTexture2D(gl.FRAMEBUFFER,depthStyle,gl.TEXTURE_CUBE_MAP_POSITIVE_X+cubeFace,textureData.textureGPU,0)}else gl.framebufferTexture2D(gl.FRAMEBUFFER,depthStyle,gl.TEXTURE_2D,textureData.textureGPU,0)}renderTargetContextData.depthInvalidationArray=depthInvalidationArray}else{if(this._isRenderCameraDepthArray(descriptor)){state.bindFramebuffer(gl.FRAMEBUFFER,fb);const layer=this.renderer._activeCubeFace,depthData=this.get(descriptor.depthTexture),depthStyle=stencilBuffer?gl.DEPTH_STENCIL_ATTACHMENT:gl.DEPTH_ATTACHMENT;gl.framebufferTextureLayer(gl.FRAMEBUFFER,depthStyle,depthData.textureGPU,0,layer)}if((isXRRenderTarget||useMultisampledRTT||renderTarget.multiview)&&!0!==renderTarget._isOpaqueFramebuffer){state.bindFramebuffer(gl.FRAMEBUFFER,fb);const textureData=this.get(descriptor.textures[0]);renderTarget.multiview?multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,textureData.textureGPU,0,samples,0,2):useMultisampledRTT?multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,textureData.textureGPU,0,samples):gl.framebufferTexture2D(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,textureData.textureGPU,0);const depthStyle=stencilBuffer?gl.DEPTH_STENCIL_ATTACHMENT:gl.DEPTH_ATTACHMENT;if(!0===renderTarget._autoAllocateDepthBuffer){const renderbuffer=renderTargetContextData.xrDepthRenderbuffer;gl.bindRenderbuffer(gl.RENDERBUFFER,renderbuffer),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,depthStyle,gl.RENDERBUFFER,renderbuffer)}else{const textureData=this.get(descriptor.depthTexture);renderTarget.multiview?multiviewExt.framebufferTextureMultisampleMultiviewOVR(gl.FRAMEBUFFER,depthStyle,textureData.textureGPU,0,samples,0,2):useMultisampledRTT?multisampledRTTExt.framebufferTexture2DMultisampleEXT(gl.FRAMEBUFFER,depthStyle,gl.TEXTURE_2D,textureData.textureGPU,0,samples):gl.framebufferTexture2D(gl.FRAMEBUFFER,depthStyle,gl.TEXTURE_2D,textureData.textureGPU,0)}}}if(samples>0&&!1===useMultisampledRTT&&!renderTarget.multiview){if(void 0===msaaFb){const invalidationArray=[];msaaFb=gl.createFramebuffer(),state.bindFramebuffer(gl.FRAMEBUFFER,msaaFb);const msaaRenderbuffers=[],textures=descriptor.textures;for(let i=0;i<textures.length;i++){msaaRenderbuffers[i]=gl.createRenderbuffer(),gl.bindRenderbuffer(gl.RENDERBUFFER,msaaRenderbuffers[i]),invalidationArray.push(gl.COLOR_ATTACHMENT0+i);const texture=descriptor.textures[i],textureData=this.get(texture);gl.renderbufferStorageMultisample(gl.RENDERBUFFER,samples,textureData.glInternalFormat,descriptor.width,descriptor.height),gl.framebufferRenderbuffer(gl.FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.RENDERBUFFER,msaaRenderbuffers[i])}if(gl.bindRenderbuffer(gl.RENDERBUFFER,null),renderTargetContextData.msaaFrameBuffer=msaaFb,renderTargetContextData.msaaRenderbuffers=msaaRenderbuffers,depthBuffer&&void 0===depthRenderbuffer){depthRenderbuffer=gl.createRenderbuffer(),this.textureUtils.setupRenderBufferStorage(depthRenderbuffer,descriptor,samples),renderTargetContextData.depthRenderbuffer=depthRenderbuffer;const depthStyle=stencilBuffer?gl.DEPTH_STENCIL_ATTACHMENT:gl.DEPTH_ATTACHMENT;invalidationArray.push(depthStyle)}renderTargetContextData.invalidationArray=invalidationArray}currentFrameBuffer=renderTargetContextData.msaaFrameBuffer}else currentFrameBuffer=fb;state.drawBuffers(descriptor,fb)}state.bindFramebuffer(gl.FRAMEBUFFER,currentFrameBuffer)}_getVaoKey(attributes){let key="";for(let i=0;i<attributes.length;i++){key+=":"+this.get(attributes[i]).id}return key}_createVao(attributes){const{gl:gl}=this,vaoGPU=gl.createVertexArray();gl.bindVertexArray(vaoGPU);for(let i=0;i<attributes.length;i++){const attribute=attributes[i],attributeData=this.get(attribute);let stride,offset;gl.bindBuffer(gl.ARRAY_BUFFER,attributeData.bufferGPU),gl.enableVertexAttribArray(i),!0===attribute.isInterleavedBufferAttribute?(stride=attribute.data.stride*attributeData.bytesPerElement,offset=attribute.offset*attributeData.bytesPerElement):(stride=0,offset=0),attributeData.isInteger?gl.vertexAttribIPointer(i,attribute.itemSize,attributeData.type,stride,offset):gl.vertexAttribPointer(i,attribute.itemSize,attributeData.type,attribute.normalized,stride,offset),attribute.isInstancedBufferAttribute&&!attribute.isInterleavedBufferAttribute?gl.vertexAttribDivisor(i,attribute.meshPerAttribute):attribute.isInterleavedBufferAttribute&&attribute.data.isInstancedInterleavedBuffer&&gl.vertexAttribDivisor(i,attribute.data.meshPerAttribute)}return gl.bindBuffer(gl.ARRAY_BUFFER,null),vaoGPU}_getTransformFeedback(transformBuffers){let key="";for(let i=0;i<transformBuffers.length;i++)key+=":"+transformBuffers[i].id;let transformFeedbackGPU=this.transformFeedbackCache[key];if(void 0!==transformFeedbackGPU)return transformFeedbackGPU;const{gl:gl}=this;transformFeedbackGPU=gl.createTransformFeedback(),gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,transformFeedbackGPU);for(let i=0;i<transformBuffers.length;i++){const attributeData=transformBuffers[i];gl.bindBufferBase(gl.TRANSFORM_FEEDBACK_BUFFER,i,attributeData.transformBuffer)}return gl.bindTransformFeedback(gl.TRANSFORM_FEEDBACK,null),this.transformFeedbackCache[key]=transformFeedbackGPU,transformFeedbackGPU}_setupBindings(bindings,programGPU){const gl=this.gl;for(const bindGroup of bindings)for(const binding of bindGroup.bindings){const index=this.get(binding).index;if(binding.isUniformsGroup||binding.isUniformBuffer){const location=gl.getUniformBlockIndex(programGPU,binding.name);gl.uniformBlockBinding(programGPU,location,index)}else if(binding.isSampledTexture){const location=gl.getUniformLocation(programGPU,binding.name);gl.uniform1i(location,index)}}}_bindUniforms(bindings){const{gl:gl,state:state}=this;for(const bindGroup of bindings)for(const binding of bindGroup.bindings){const bindingData=this.get(binding),index=bindingData.index;binding.isUniformsGroup||binding.isUniformBuffer?state.bindBufferBase(gl.UNIFORM_BUFFER,index,bindingData.bufferGPU):binding.isSampledTexture&&state.bindTexture(bindingData.glTextureType,bindingData.textureGPU,gl.TEXTURE0+index)}}_resolveRenderTarget(renderContext){const{gl:gl,state:state}=this,renderTarget=renderContext.renderTarget;if(null!==renderContext.textures&&renderTarget){const renderTargetContextData=this.get(renderTarget);if(renderTarget.samples>0&&!1===this._useMultisampledExtension(renderTarget)){const fb=renderTargetContextData.framebuffers[renderContext.getCacheKey()];let mask=gl.COLOR_BUFFER_BIT;renderTarget.resolveDepthBuffer&&(renderTarget.depthBuffer&&(mask|=gl.DEPTH_BUFFER_BIT),renderTarget.stencilBuffer&&renderTarget.resolveStencilBuffer&&(mask|=gl.STENCIL_BUFFER_BIT));const msaaFrameBuffer=renderTargetContextData.msaaFrameBuffer,msaaRenderbuffers=renderTargetContextData.msaaRenderbuffers,textures=renderContext.textures,isMRT=textures.length>1;if(state.bindFramebuffer(gl.READ_FRAMEBUFFER,msaaFrameBuffer),state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,fb),isMRT)for(let i=0;i<textures.length;i++)gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.RENDERBUFFER,null),gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.TEXTURE_2D,null,0);for(let i=0;i<textures.length;i++){if(isMRT){const{textureGPU:textureGPU}=this.get(textures[i]);gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.RENDERBUFFER,msaaRenderbuffers[i]),gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER,gl.COLOR_ATTACHMENT0,gl.TEXTURE_2D,textureGPU,0)}if(renderContext.scissor){const{x:x,y:y,width:width,height:height}=renderContext.scissorValue,viewY=renderContext.height-height-y;gl.blitFramebuffer(x,viewY,x+width,viewY+height,x,viewY,x+width,viewY+height,mask,gl.NEAREST)}else gl.blitFramebuffer(0,0,renderContext.width,renderContext.height,0,0,renderContext.width,renderContext.height,mask,gl.NEAREST)}if(isMRT)for(let i=0;i<textures.length;i++){const{textureGPU:textureGPU}=this.get(textures[i]);gl.framebufferRenderbuffer(gl.READ_FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.RENDERBUFFER,msaaRenderbuffers[i]),gl.framebufferTexture2D(gl.DRAW_FRAMEBUFFER,gl.COLOR_ATTACHMENT0+i,gl.TEXTURE_2D,textureGPU,0)}!0===this._supportsInvalidateFramebuffer&&gl.invalidateFramebuffer(gl.READ_FRAMEBUFFER,renderTargetContextData.invalidationArray)}else if(!1===renderTarget.resolveDepthBuffer&&renderTargetContextData.framebuffers){const fb=renderTargetContextData.framebuffers[renderContext.getCacheKey()];state.bindFramebuffer(gl.DRAW_FRAMEBUFFER,fb),gl.invalidateFramebuffer(gl.DRAW_FRAMEBUFFER,renderTargetContextData.depthInvalidationArray)}}}_useMultisampledExtension(renderTarget){return!0===renderTarget.multiview||renderTarget.samples>0&&!0===this.extensions.has("WEBGL_multisampled_render_to_texture")&&!1!==renderTarget._autoAllocateDepthBuffer}dispose(){null!==this.textureUtils&&this.textureUtils.dispose();const extension=this.extensions.get("WEBGL_lose_context");extension&&extension.loseContext(),this.renderer.domElement.removeEventListener("webglcontextlost",this._onContextLost)}}const GPUPrimitiveTopology_PointList="point-list",GPUPrimitiveTopology_LineList="line-list",GPUPrimitiveTopology_LineStrip="line-strip",GPUPrimitiveTopology_TriangleList="triangle-list",GPUShaderStage="undefined"!=typeof self&&self.GPUShaderStage?self.GPUShaderStage:{VERTEX:1,FRAGMENT:2,COMPUTE:4},GPUCompareFunction_Never="never",GPUCompareFunction_Less="less",GPUCompareFunction_Equal="equal",GPUCompareFunction_LessEqual="less-equal",GPUCompareFunction_Greater="greater",GPUCompareFunction_NotEqual="not-equal",GPUCompareFunction_GreaterEqual="greater-equal",GPUCompareFunction_Always="always",GPUStoreOp_Store="store",GPULoadOp_Load="load",GPULoadOp_Clear="clear",GPUFrontFace_CCW="ccw",GPUFrontFace_CW="cw",GPUCullMode_None="none",GPUCullMode_Back="back",GPUIndexFormat_Uint16="uint16",GPUIndexFormat_Uint32="uint32",GPUTextureFormat_R8Unorm="r8unorm",GPUTextureFormat_R8Snorm="r8snorm",GPUTextureFormat_R8Uint="r8uint",GPUTextureFormat_R8Sint="r8sint",GPUTextureFormat_R16Uint="r16uint",GPUTextureFormat_R16Sint="r16sint",GPUTextureFormat_R16Float="r16float",GPUTextureFormat_RG8Unorm="rg8unorm",GPUTextureFormat_RG8Snorm="rg8snorm",GPUTextureFormat_RG8Uint="rg8uint",GPUTextureFormat_RG8Sint="rg8sint",GPUTextureFormat_R32Uint="r32uint",GPUTextureFormat_R32Sint="r32sint",GPUTextureFormat_R32Float="r32float",GPUTextureFormat_RG16Uint="rg16uint",GPUTextureFormat_RG16Sint="rg16sint",GPUTextureFormat_RG16Float="rg16float",GPUTextureFormat_RGBA8Unorm="rgba8unorm",GPUTextureFormat_RGBA8UnormSRGB="rgba8unorm-srgb",GPUTextureFormat_RGBA8Snorm="rgba8snorm",GPUTextureFormat_RGBA8Uint="rgba8uint",GPUTextureFormat_RGBA8Sint="rgba8sint",GPUTextureFormat_BGRA8Unorm="bgra8unorm",GPUTextureFormat_BGRA8UnormSRGB="bgra8unorm-srgb",GPUTextureFormat_RGB9E5UFloat="rgb9e5ufloat",GPUTextureFormat_RGB10A2Unorm="rgb10a2unorm",GPUTextureFormat_RG11B10UFloat="rg11b10ufloat",GPUTextureFormat_RG32Uint="rg32uint",GPUTextureFormat_RG32Sint="rg32sint",GPUTextureFormat_RG32Float="rg32float",GPUTextureFormat_RGBA16Uint="rgba16uint",GPUTextureFormat_RGBA16Sint="rgba16sint",GPUTextureFormat_RGBA16Float="rgba16float",GPUTextureFormat_RGBA32Uint="rgba32uint",GPUTextureFormat_RGBA32Sint="rgba32sint",GPUTextureFormat_RGBA32Float="rgba32float",GPUTextureFormat_Depth16Unorm="depth16unorm",GPUTextureFormat_Depth24Plus="depth24plus",GPUTextureFormat_Depth24PlusStencil8="depth24plus-stencil8",GPUTextureFormat_Depth32Float="depth32float",GPUTextureFormat_Depth32FloatStencil8="depth32float-stencil8",GPUTextureFormat_BC1RGBAUnorm="bc1-rgba-unorm",GPUTextureFormat_BC1RGBAUnormSRGB="bc1-rgba-unorm-srgb",GPUTextureFormat_BC2RGBAUnorm="bc2-rgba-unorm",GPUTextureFormat_BC2RGBAUnormSRGB="bc2-rgba-unorm-srgb",GPUTextureFormat_BC3RGBAUnorm="bc3-rgba-unorm",GPUTextureFormat_BC3RGBAUnormSRGB="bc3-rgba-unorm-srgb",GPUTextureFormat_BC4RUnorm="bc4-r-unorm",GPUTextureFormat_BC4RSnorm="bc4-r-snorm",GPUTextureFormat_BC5RGUnorm="bc5-rg-unorm",GPUTextureFormat_BC5RGSnorm="bc5-rg-snorm",GPUTextureFormat_BC6HRGBUFloat="bc6h-rgb-ufloat",GPUTextureFormat_BC6HRGBFloat="bc6h-rgb-float",GPUTextureFormat_BC7RGBAUnorm="bc7-rgba-unorm",GPUTextureFormat_BC7RGBAUnormSRGB="bc7-rgba-unorm-srgb",GPUTextureFormat_ETC2RGB8Unorm="etc2-rgb8unorm",GPUTextureFormat_ETC2RGB8UnormSRGB="etc2-rgb8unorm-srgb",GPUTextureFormat_ETC2RGB8A1Unorm="etc2-rgb8a1unorm",GPUTextureFormat_ETC2RGB8A1UnormSRGB="etc2-rgb8a1unorm-srgb",GPUTextureFormat_ETC2RGBA8Unorm="etc2-rgba8unorm",GPUTextureFormat_ETC2RGBA8UnormSRGB="etc2-rgba8unorm-srgb",GPUTextureFormat_EACR11Unorm="eac-r11unorm",GPUTextureFormat_EACR11Snorm="eac-r11snorm",GPUTextureFormat_EACRG11Unorm="eac-rg11unorm",GPUTextureFormat_EACRG11Snorm="eac-rg11snorm",GPUTextureFormat_ASTC4x4Unorm="astc-4x4-unorm",GPUTextureFormat_ASTC4x4UnormSRGB="astc-4x4-unorm-srgb",GPUTextureFormat_ASTC5x4Unorm="astc-5x4-unorm",GPUTextureFormat_ASTC5x4UnormSRGB="astc-5x4-unorm-srgb",GPUTextureFormat_ASTC5x5Unorm="astc-5x5-unorm",GPUTextureFormat_ASTC5x5UnormSRGB="astc-5x5-unorm-srgb",GPUTextureFormat_ASTC6x5Unorm="astc-6x5-unorm",GPUTextureFormat_ASTC6x5UnormSRGB="astc-6x5-unorm-srgb",GPUTextureFormat_ASTC6x6Unorm="astc-6x6-unorm",GPUTextureFormat_ASTC6x6UnormSRGB="astc-6x6-unorm-srgb",GPUTextureFormat_ASTC8x5Unorm="astc-8x5-unorm",GPUTextureFormat_ASTC8x5UnormSRGB="astc-8x5-unorm-srgb",GPUTextureFormat_ASTC8x6Unorm="astc-8x6-unorm",GPUTextureFormat_ASTC8x6UnormSRGB="astc-8x6-unorm-srgb",GPUTextureFormat_ASTC8x8Unorm="astc-8x8-unorm",GPUTextureFormat_ASTC8x8UnormSRGB="astc-8x8-unorm-srgb",GPUTextureFormat_ASTC10x5Unorm="astc-10x5-unorm",GPUTextureFormat_ASTC10x5UnormSRGB="astc-10x5-unorm-srgb",GPUTextureFormat_ASTC10x6Unorm="astc-10x6-unorm",GPUTextureFormat_ASTC10x6UnormSRGB="astc-10x6-unorm-srgb",GPUTextureFormat_ASTC10x8Unorm="astc-10x8-unorm",GPUTextureFormat_ASTC10x8UnormSRGB="astc-10x8-unorm-srgb",GPUTextureFormat_ASTC10x10Unorm="astc-10x10-unorm",GPUTextureFormat_ASTC10x10UnormSRGB="astc-10x10-unorm-srgb",GPUTextureFormat_ASTC12x10Unorm="astc-12x10-unorm",GPUTextureFormat_ASTC12x10UnormSRGB="astc-12x10-unorm-srgb",GPUTextureFormat_ASTC12x12Unorm="astc-12x12-unorm",GPUTextureFormat_ASTC12x12UnormSRGB="astc-12x12-unorm-srgb",GPUAddressMode_ClampToEdge="clamp-to-edge",GPUAddressMode_Repeat="repeat",GPUAddressMode_MirrorRepeat="mirror-repeat",GPUFilterMode_Linear="linear",GPUFilterMode_Nearest="nearest",GPUBlendFactor_Zero="zero",GPUBlendFactor_One="one",GPUBlendFactor_Src="src",GPUBlendFactor_OneMinusSrc="one-minus-src",GPUBlendFactor_SrcAlpha="src-alpha",GPUBlendFactor_OneMinusSrcAlpha="one-minus-src-alpha",GPUBlendFactor_Dst="dst",GPUBlendFactor_OneMinusDst="one-minus-dst",GPUBlendFactor_DstAlpha="dst-alpha",GPUBlendFactor_OneMinusDstAlpha="one-minus-dst-alpha",GPUBlendFactor_SrcAlphaSaturated="src-alpha-saturated",GPUBlendFactor_Constant="constant",GPUBlendFactor_OneMinusConstant="one-minus-constant",GPUBlendOperation_Add="add",GPUBlendOperation_Subtract="subtract",GPUBlendOperation_ReverseSubtract="reverse-subtract",GPUBlendOperation_Min="min",GPUBlendOperation_Max="max",GPUColorWriteFlags_None=0,GPUColorWriteFlags_All=15,GPUStencilOperation_Keep="keep",GPUStencilOperation_Zero="zero",GPUStencilOperation_Replace="replace",GPUStencilOperation_Invert="invert",GPUStencilOperation_IncrementClamp="increment-clamp",GPUStencilOperation_DecrementClamp="decrement-clamp",GPUStencilOperation_IncrementWrap="increment-wrap",GPUStencilOperation_DecrementWrap="decrement-wrap",GPUBufferBindingType_Storage="storage",GPUBufferBindingType_ReadOnlyStorage="read-only-storage",GPUStorageTextureAccess_WriteOnly="write-only",GPUStorageTextureAccess_ReadOnly="read-only",GPUStorageTextureAccess_ReadWrite="read-write",GPUSamplerBindingType_NonFiltering="non-filtering",GPUSamplerBindingType_Comparison="comparison",GPUTextureSampleType_Float="float",GPUTextureSampleType_UnfilterableFloat="unfilterable-float",GPUTextureSampleType_Depth="depth",GPUTextureSampleType_SInt="sint",GPUTextureSampleType_UInt="uint",GPUTextureDimension_TwoD="2d",GPUTextureDimension_ThreeD="3d",GPUTextureViewDimension_TwoD="2d",GPUTextureViewDimension_TwoDArray="2d-array",GPUTextureViewDimension_Cube="cube",GPUTextureViewDimension_ThreeD="3d",GPUTextureAspect_All="all",GPUInputStepMode_Vertex="vertex",GPUInputStepMode_Instance="instance",GPUFeatureName={CoreFeaturesAndLimits:"core-features-and-limits",DepthClipControl:"depth-clip-control",Depth32FloatStencil8:"depth32float-stencil8",TextureCompressionBC:"texture-compression-bc",TextureCompressionBCSliced3D:"texture-compression-bc-sliced-3d",TextureCompressionETC2:"texture-compression-etc2",TextureCompressionASTC:"texture-compression-astc",TextureCompressionASTCSliced3D:"texture-compression-astc-sliced-3d",TimestampQuery:"timestamp-query",IndirectFirstInstance:"indirect-first-instance",ShaderF16:"shader-f16",RG11B10UFloat:"rg11b10ufloat-renderable",BGRA8UNormStorage:"bgra8unorm-storage",Float32Filterable:"float32-filterable",Float32Blendable:"float32-blendable",ClipDistances:"clip-distances",DualSourceBlending:"dual-source-blending",Subgroups:"subgroups",TextureFormatsTier1:"texture-formats-tier1",TextureFormatsTier2:"texture-formats-tier2"},GPUFeatureMap={"texture-compression-s3tc":"texture-compression-bc","texture-compression-etc1":"texture-compression-etc2"};class NodeSampler extends Sampler{constructor(name,textureNode,groupNode){super(name,textureNode?textureNode.value:null),this.textureNode=textureNode,this.groupNode=groupNode}update(){const{textureNode:textureNode}=this;return this.texture!==textureNode.value?(this.texture=textureNode.value,!0):super.update()}}class StorageBuffer extends Buffer{constructor(name,attribute){super(name,attribute?attribute.array:null),this._attribute=attribute,this.isStorageBuffer=!0}get attribute(){return this._attribute}}let _id=0;class NodeStorageBuffer extends StorageBuffer{constructor(nodeUniform,groupNode){super("StorageBuffer_"+_id++,nodeUniform?nodeUniform.value:null),this.nodeUniform=nodeUniform,this.access=nodeUniform?nodeUniform.access:NodeAccess_READ_WRITE,this.groupNode=groupNode}get attribute(){return this.nodeUniform.value}get buffer(){return this.nodeUniform.value.array}}class WebGPUTexturePassUtils extends DataMap{constructor(device){super(),this.device=device;this.mipmapSampler=device.createSampler({minFilter:GPUFilterMode_Linear}),this.flipYSampler=device.createSampler({minFilter:GPUFilterMode_Nearest}),this.flipUniformBuffer=device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST}),device.queue.writeBuffer(this.flipUniformBuffer,0,new Uint32Array([1])),this.noFlipUniformBuffer=device.createBuffer({size:4,usage:GPUBufferUsage.UNIFORM}),this.transferPipelines={},this.mipmapShaderModule=device.createShaderModule({label:"mipmap",code:"\nstruct VarysStruct {\n\t@builtin( position ) Position: vec4f,\n\t@location( 0 ) vTex : vec2f,\n\t@location( 1 ) @interpolate(flat, either) vBaseArrayLayer: u32,\n};\n\n@group( 0 ) @binding ( 2 )\nvar<uniform> flipY: u32;\n\n@vertex\nfn mainVS(\n\t\t@builtin( vertex_index ) vertexIndex : u32,\n\t\t@builtin( instance_index ) instanceIndex : u32 ) -> VarysStruct {\n\n\tvar Varys : VarysStruct;\n\n\tvar pos = array(\n\t\tvec2f( -1, -1 ),\n\t\tvec2f( -1,  3 ),\n\t\tvec2f(  3, -1 ),\n\t);\n\n\tlet p = pos[ vertexIndex ];\n\tlet mult = select( vec2f( 0.5, -0.5 ), vec2f( 0.5, 0.5 ), flipY != 0 );\n\tVarys.vTex = p * mult + vec2f( 0.5 );\n\tVarys.Position = vec4f( p, 0, 1 );\n\tVarys.vBaseArrayLayer = instanceIndex;\n\n\treturn Varys;\n\n}\n\n@group( 0 ) @binding( 0 )\nvar imgSampler : sampler;\n\n@group( 0 ) @binding( 1 )\nvar img2d : texture_2d<f32>;\n\n@fragment\nfn main_2d( Varys: VarysStruct ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img2d, imgSampler, Varys.vTex );\n\n}\n\n@group( 0 ) @binding( 1 )\nvar img2dArray : texture_2d_array<f32>;\n\n@fragment\nfn main_2d_array( Varys: VarysStruct ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( img2dArray, imgSampler, Varys.vTex, Varys.vBaseArrayLayer );\n\n}\n\nconst faceMat = array(\n  mat3x3f(  0,  0,  -2,  0, -2,   0,  1,  1,   1 ),   // pos-x\n  mat3x3f(  0,  0,   2,  0, -2,   0, -1,  1,  -1 ),   // neg-x\n  mat3x3f(  2,  0,   0,  0,  0,   2, -1,  1,  -1 ),   // pos-y\n  mat3x3f(  2,  0,   0,  0,  0,  -2, -1, -1,   1 ),   // neg-y\n  mat3x3f(  2,  0,   0,  0, -2,   0, -1,  1,   1 ),   // pos-z\n  mat3x3f( -2,  0,   0,  0, -2,   0,  1,  1,  -1 ),   // neg-z\n);\n\n@group( 0 ) @binding( 1 )\nvar imgCube : texture_cube<f32>;\n\n@fragment\nfn main_cube( Varys: VarysStruct ) -> @location( 0 ) vec4<f32> {\n\n\treturn textureSample( imgCube, imgSampler, faceMat[ Varys.vBaseArrayLayer ] * vec3f( fract( Varys.vTex ), 1 ) );\n\n}\n"})}getTransferPipeline(format,textureBindingViewDimension){const key=`${format}-${textureBindingViewDimension=textureBindingViewDimension||"2d-array"}`;let pipeline=this.transferPipelines[key];return void 0===pipeline&&(pipeline=this.device.createRenderPipeline({label:`mipmap-${format}-${textureBindingViewDimension}`,vertex:{module:this.mipmapShaderModule},fragment:{module:this.mipmapShaderModule,entryPoint:`main_${textureBindingViewDimension.replace("-","_")}`,targets:[{format:format}]},layout:"auto"}),this.transferPipelines[key]=pipeline),pipeline}flipY(textureGPU,textureGPUDescriptor,baseArrayLayer=0){const format=textureGPUDescriptor.format,{width:width,height:height}=textureGPUDescriptor.size,tempTexture=this.device.createTexture({size:{width:width,height:height},format:format,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING}),copyTransferPipeline=this.getTransferPipeline(format,textureGPU.textureBindingViewDimension),flipTransferPipeline=this.getTransferPipeline(format,tempTexture.textureBindingViewDimension),commandEncoder=this.device.createCommandEncoder({}),pass=(pipeline,sourceTexture,sourceArrayLayer,destinationTexture,destinationArrayLayer,flipY)=>{const bindGroupLayout=pipeline.getBindGroupLayout(0),bindGroup=this.device.createBindGroup({layout:bindGroupLayout,entries:[{binding:0,resource:this.flipYSampler},{binding:1,resource:sourceTexture.createView({dimension:sourceTexture.textureBindingViewDimension||"2d-array",baseMipLevel:0,mipLevelCount:1})},{binding:2,resource:{buffer:flipY?this.flipUniformBuffer:this.noFlipUniformBuffer}}]}),passEncoder=commandEncoder.beginRenderPass({colorAttachments:[{view:destinationTexture.createView({dimension:"2d",baseMipLevel:0,mipLevelCount:1,baseArrayLayer:destinationArrayLayer,arrayLayerCount:1}),loadOp:GPULoadOp_Clear,storeOp:GPUStoreOp_Store}]});passEncoder.setPipeline(pipeline),passEncoder.setBindGroup(0,bindGroup),passEncoder.draw(3,1,0,sourceArrayLayer),passEncoder.end()};pass(copyTransferPipeline,textureGPU,baseArrayLayer,tempTexture,0,!1),pass(flipTransferPipeline,tempTexture,0,textureGPU,baseArrayLayer,!0),this.device.queue.submit([commandEncoder.finish()]),tempTexture.destroy()}generateMipmaps(textureGPU,encoder=null){const textureData=this.get(textureGPU),passes=textureData.layers||this._mipmapCreateBundles(textureGPU),commandEncoder=encoder||this.device.createCommandEncoder({label:"mipmapEncoder"});this._mipmapRunBundles(commandEncoder,passes),null===encoder&&this.device.queue.submit([commandEncoder.finish()]),textureData.layers=passes}_mipmapCreateBundles(textureGPU){const textureBindingViewDimension=textureGPU.textureBindingViewDimension||"2d-array",pipeline=this.getTransferPipeline(textureGPU.format,textureBindingViewDimension),bindGroupLayout=pipeline.getBindGroupLayout(0),passes=[];for(let baseMipLevel=1;baseMipLevel<textureGPU.mipLevelCount;baseMipLevel++)for(let baseArrayLayer=0;baseArrayLayer<textureGPU.depthOrArrayLayers;baseArrayLayer++){const bindGroup=this.device.createBindGroup({layout:bindGroupLayout,entries:[{binding:0,resource:this.mipmapSampler},{binding:1,resource:textureGPU.createView({dimension:textureBindingViewDimension,baseMipLevel:baseMipLevel-1,mipLevelCount:1})},{binding:2,resource:{buffer:this.noFlipUniformBuffer}}]}),passDescriptor={colorAttachments:[{view:textureGPU.createView({dimension:"2d",baseMipLevel:baseMipLevel,mipLevelCount:1,baseArrayLayer:baseArrayLayer,arrayLayerCount:1}),loadOp:GPULoadOp_Clear,storeOp:GPUStoreOp_Store}]},passEncoder=this.device.createRenderBundleEncoder({colorFormats:[textureGPU.format]});passEncoder.setPipeline(pipeline),passEncoder.setBindGroup(0,bindGroup),passEncoder.draw(3,1,0,baseArrayLayer),passes.push({renderBundles:[passEncoder.finish()],passDescriptor:passDescriptor})}return passes}_mipmapRunBundles(commandEncoder,passes){const levels=passes.length;for(let i=0;i<levels;i++){const pass=passes[i],passEncoder=commandEncoder.beginRenderPass(pass.passDescriptor);passEncoder.executeBundles(pass.renderBundles),passEncoder.end()}}}const _compareToWebGPU={[NeverCompare]:"never",[LessCompare]:"less",[EqualCompare]:"equal",[LessEqualCompare]:"less-equal",[GreaterCompare]:"greater",[GreaterEqualCompare]:"greater-equal",[AlwaysCompare]:"always",[NotEqualCompare]:"not-equal"},_flipMap=[0,1,3,2,4,5];class WebGPUTextureUtils{constructor(backend){this.backend=backend,this._passUtils=null,this.defaultTexture={},this.defaultCubeTexture={},this.defaultVideoFrame=null,this._samplerCache=new Map}updateSampler(texture){const backend=this.backend,samplerKey=texture.minFilter+"-"+texture.magFilter+"-"+texture.wrapS+"-"+texture.wrapT+"-"+(texture.wrapR||"0")+"-"+texture.anisotropy+"-"+(texture.compareFunction||0);let samplerData=this._samplerCache.get(samplerKey);if(void 0===samplerData){const samplerDescriptorGPU={addressModeU:this._convertAddressMode(texture.wrapS),addressModeV:this._convertAddressMode(texture.wrapT),addressModeW:this._convertAddressMode(texture.wrapR),magFilter:this._convertFilterMode(texture.magFilter),minFilter:this._convertFilterMode(texture.minFilter),mipmapFilter:this._convertFilterMode(texture.minFilter),maxAnisotropy:1};texture.isDepthTexture&&null===texture.compareFunction&&(samplerDescriptorGPU.magFilter=GPUFilterMode_Nearest,samplerDescriptorGPU.minFilter=GPUFilterMode_Nearest,samplerDescriptorGPU.mipmapFilter=GPUFilterMode_Nearest),samplerDescriptorGPU.magFilter===GPUFilterMode_Linear&&samplerDescriptorGPU.minFilter===GPUFilterMode_Linear&&samplerDescriptorGPU.mipmapFilter===GPUFilterMode_Linear&&(samplerDescriptorGPU.maxAnisotropy=texture.anisotropy),texture.isDepthTexture&&null!==texture.compareFunction&&backend.hasCompatibility(Compatibility_TEXTURE_COMPARE)&&(samplerDescriptorGPU.compare=_compareToWebGPU[texture.compareFunction]);samplerData={sampler:backend.device.createSampler(samplerDescriptorGPU),usedTimes:0},this._samplerCache.set(samplerKey,samplerData)}const textureData=backend.get(texture);if(textureData.sampler!==samplerData.sampler){if(void 0!==textureData.sampler){const oldSamplerData=this._samplerCache.get(textureData.samplerKey);oldSamplerData.usedTimes--,0===oldSamplerData.usedTimes&&this._samplerCache.delete(textureData.samplerKey)}textureData.samplerKey=samplerKey,textureData.sampler=samplerData.sampler,samplerData.usedTimes++}return samplerKey}createDefaultTexture(texture){let textureGPU;const format=getFormat(texture);textureGPU=texture.isCubeTexture?this._getDefaultCubeTextureGPU(format):this._getDefaultTextureGPU(format),this.backend.get(texture).texture=textureGPU}createTexture(texture,options={}){const backend=this.backend,textureData=backend.get(texture);if(textureData.initialized)throw new Error("WebGPUTextureUtils: Texture already initialized.");if(texture.isExternalTexture)return textureData.texture=texture.sourceTexture,void(textureData.initialized=!0);void 0===options.needsMipmaps&&(options.needsMipmaps=!1),void 0===options.levels&&(options.levels=1),void 0===options.depth&&(options.depth=1);const{width:width,height:height,depth:depth,levels:levels}=options;texture.isFramebufferTexture&&(options.renderTarget?options.format=this.backend.utils.getCurrentColorFormat(options.renderTarget):options.format=this.backend.utils.getPreferredCanvasFormat());const dimension=this._getDimension(texture),format=texture.internalFormat||options.format||getFormat(texture,backend.device);textureData.format=format;const{samples:samples,primarySamples:primarySamples,isMSAA:isMSAA}=backend.utils.getTextureSampleData(texture);let usage=GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.COPY_SRC;!0===texture.isStorageTexture&&(usage|=GPUTextureUsage.STORAGE_BINDING),!0!==texture.isCompressedTexture&&!0!==texture.isCompressedArrayTexture&&format!==GPUTextureFormat_RGB9E5UFloat&&(usage|=GPUTextureUsage.RENDER_ATTACHMENT);const textureDescriptorGPU={label:texture.name,size:{width:width,height:height,depthOrArrayLayers:depth},mipLevelCount:levels,sampleCount:primarySamples,dimension:dimension,format:format,usage:usage};if(void 0===format)return warn("WebGPURenderer: Texture format not supported."),void this.createDefaultTexture(texture);texture.isCubeTexture&&(textureDescriptorGPU.textureBindingViewDimension=GPUTextureViewDimension_Cube);try{textureData.texture=backend.device.createTexture(textureDescriptorGPU)}catch(e){return warn("WebGPURenderer: Failed to create texture with descriptor:",textureDescriptorGPU),void this.createDefaultTexture(texture)}if(isMSAA){const msaaTextureDescriptorGPU=Object.assign({},textureDescriptorGPU);msaaTextureDescriptorGPU.label=msaaTextureDescriptorGPU.label+"-msaa",msaaTextureDescriptorGPU.sampleCount=samples,msaaTextureDescriptorGPU.mipLevelCount=1,textureData.msaaTexture=backend.device.createTexture(msaaTextureDescriptorGPU)}textureData.initialized=!0,textureData.textureDescriptorGPU=textureDescriptorGPU}destroyTexture(texture,isDefaultTexture=!1){const backend=this.backend,textureData=backend.get(texture);void 0!==textureData.texture&&!1===isDefaultTexture&&textureData.texture.destroy(),void 0!==textureData.msaaTexture&&textureData.msaaTexture.destroy(),backend.delete(texture)}generateMipmaps(texture,encoder=null){const textureData=this.backend.get(texture);this._generateMipmaps(textureData.texture,encoder)}getColorBuffer(){const backend=this.backend,canvasTarget=backend.renderer.getCanvasTarget(),{width:width,height:height}=backend.getDrawingBufferSize(),samples=backend.renderer.currentSamples,colorTexture=canvasTarget.colorTexture,colorTextureData=backend.get(colorTexture);if(colorTexture.width===width&&colorTexture.height===height&&colorTexture.samples===samples)return colorTextureData.texture;let colorBuffer=colorTextureData.texture;return colorBuffer&&colorBuffer.destroy(),colorBuffer=backend.device.createTexture({label:"colorBuffer",size:{width:width,height:height,depthOrArrayLayers:1},sampleCount:backend.utils.getSampleCount(backend.renderer.currentSamples),format:backend.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC}),colorTexture.source.width=width,colorTexture.source.height=height,colorTexture.samples=samples,colorTextureData.texture=colorBuffer,colorBuffer}getDepthBuffer(depth=!0,stencil=!1){const backend=this.backend,canvasTarget=backend.renderer.getCanvasTarget(),{width:width,height:height}=backend.getDrawingBufferSize(),samples=backend.renderer.currentSamples,depthTexture=canvasTarget.depthTexture;if(depthTexture.width===width&&depthTexture.height===height&&depthTexture.samples===samples&&depthTexture.depth===depth&&depthTexture.stencil===stencil)return backend.get(depthTexture).texture;const depthTextureGPU=backend.get(depthTexture).texture;let format,type;if(stencil?(format=1027,type=1020):depth&&(format=1026,type=1014),void 0!==depthTextureGPU){if(depthTexture.image.width===width&&depthTexture.image.height===height&&depthTexture.format===format&&depthTexture.type===type&&depthTexture.samples===samples)return depthTextureGPU;this.destroyTexture(depthTexture)}return depthTexture.name="depthBuffer",depthTexture.format=format,depthTexture.type=type,depthTexture.image.width=width,depthTexture.image.height=height,depthTexture.samples=samples,this.createTexture(depthTexture,{width:width,height:height}),backend.get(depthTexture).texture}updateTexture(texture,options){const textureData=this.backend.get(texture),mipmaps=texture.mipmaps,{textureDescriptorGPU:textureDescriptorGPU}=textureData;if(!texture.isRenderTargetTexture&&void 0!==textureDescriptorGPU){if(texture.isDataTexture)if(mipmaps.length>0)for(let i=0,il=mipmaps.length;i<il;i++){const mipmap=mipmaps[i];this._copyBufferToTexture(mipmap,textureData.texture,textureDescriptorGPU,0,texture.flipY,0,i)}else this._copyBufferToTexture(options.image,textureData.texture,textureDescriptorGPU,0,texture.flipY);else if(texture.isArrayTexture||texture.isDataArrayTexture||texture.isData3DTexture)for(let i=0;i<options.image.depth;i++)this._copyBufferToTexture(options.image,textureData.texture,textureDescriptorGPU,i,texture.flipY,i);else if(texture.isCompressedTexture||texture.isCompressedArrayTexture)this._copyCompressedBufferToTexture(texture.mipmaps,textureData.texture,textureDescriptorGPU);else if(texture.isCubeTexture)this._copyCubeMapToTexture(texture,textureData.texture,textureDescriptorGPU);else if(mipmaps.length>0)for(let i=0,il=mipmaps.length;i<il;i++){const mipmap=mipmaps[i];this._copyImageToTexture(mipmap,textureData.texture,textureDescriptorGPU,0,texture.flipY,texture.premultiplyAlpha,i)}else this._copyImageToTexture(options.image,textureData.texture,textureDescriptorGPU,0,texture.flipY,texture.premultiplyAlpha);textureData.version=texture.version}}async copyTextureToBuffer(texture,x,y,width,height,faceIndex){const device=this.backend.device,textureData=this.backend.get(texture),textureGPU=textureData.texture,format=textureData.textureDescriptorGPU.format,bytesPerTexel=this._getBytesPerTexel(format);let bytesPerRow=width*bytesPerTexel;bytesPerRow=256*Math.ceil(bytesPerRow/256);const readBuffer=device.createBuffer({size:(height-1)*bytesPerRow+width*bytesPerTexel,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),encoder=device.createCommandEncoder();encoder.copyTextureToBuffer({texture:textureGPU,origin:{x:x,y:y,z:faceIndex}},{buffer:readBuffer,bytesPerRow:bytesPerRow},{width:width,height:height});const typedArrayType=this._getTypedArrayType(format);device.queue.submit([encoder.finish()]),await readBuffer.mapAsync(GPUMapMode.READ);return new typedArrayType(readBuffer.getMappedRange())}dispose(){this._samplerCache.clear()}_getDefaultTextureGPU(format){let defaultTexture=this.defaultTexture[format];if(void 0===defaultTexture){const texture=new Texture;texture.minFilter=1003,texture.magFilter=1003,this.createTexture(texture,{width:1,height:1,format:format}),this.defaultTexture[format]=defaultTexture=texture}return this.backend.get(defaultTexture).texture}_getDefaultCubeTextureGPU(format){let defaultCubeTexture=this.defaultCubeTexture[format];if(void 0===defaultCubeTexture){const texture=new CubeTexture;texture.minFilter=1003,texture.magFilter=1003,this.createTexture(texture,{width:1,height:1,depth:6}),this.defaultCubeTexture[format]=defaultCubeTexture=texture}return this.backend.get(defaultCubeTexture).texture}_copyCubeMapToTexture(texture,textureGPU,textureDescriptorGPU){const images=texture.images,mipmaps=texture.mipmaps;for(let i=0;i<6;i++){const image=images[i],flipIndex=!0===texture.flipY?_flipMap[i]:i;image.isDataTexture?this._copyBufferToTexture(image.image,textureGPU,textureDescriptorGPU,flipIndex,texture.flipY):this._copyImageToTexture(image,textureGPU,textureDescriptorGPU,flipIndex,texture.flipY,texture.premultiplyAlpha);for(let j=0;j<mipmaps.length;j++){const image=mipmaps[j].images[i];image.isDataTexture?this._copyBufferToTexture(image.image,textureGPU,textureDescriptorGPU,flipIndex,texture.flipY,0,j+1):this._copyImageToTexture(image,textureGPU,textureDescriptorGPU,flipIndex,texture.flipY,texture.premultiplyAlpha,j+1)}}}_copyImageToTexture(image,textureGPU,textureDescriptorGPU,originDepth,flipY,premultiplyAlpha,mipLevel=0){const device=this.backend.device,width=mipLevel>0?image.width:textureDescriptorGPU.size.width,height=mipLevel>0?image.height:textureDescriptorGPU.size.height;try{device.queue.copyExternalImageToTexture({source:image,flipY:flipY},{texture:textureGPU,mipLevel:mipLevel,origin:{x:0,y:0,z:originDepth},premultipliedAlpha:premultiplyAlpha},{width:width,height:height,depthOrArrayLayers:1})}catch(_){}}_getPassUtils(){let passUtils=this._passUtils;return null===passUtils&&(this._passUtils=passUtils=new WebGPUTexturePassUtils(this.backend.device)),passUtils}_generateMipmaps(textureGPU,encoder=null){this._getPassUtils().generateMipmaps(textureGPU,encoder)}_flipY(textureGPU,textureDescriptorGPU,originDepth=0){this._getPassUtils().flipY(textureGPU,textureDescriptorGPU,originDepth)}_copyBufferToTexture(image,textureGPU,textureDescriptorGPU,originDepth,flipY,depth=0,mipLevel=0){const device=this.backend.device,data=image.data,bytesPerTexel=this._getBytesPerTexel(textureDescriptorGPU.format),bytesPerRow=image.width*bytesPerTexel;device.queue.writeTexture({texture:textureGPU,mipLevel:mipLevel,origin:{x:0,y:0,z:originDepth}},data,{offset:image.width*image.height*bytesPerTexel*depth,bytesPerRow:bytesPerRow},{width:image.width,height:image.height,depthOrArrayLayers:1}),!0===flipY&&this._flipY(textureGPU,textureDescriptorGPU,originDepth)}_copyCompressedBufferToTexture(mipmaps,textureGPU,textureDescriptorGPU){const device=this.backend.device,blockData=this._getBlockData(textureDescriptorGPU.format),isArrayTexture=textureDescriptorGPU.size.depthOrArrayLayers>1;for(let i=0;i<mipmaps.length;i++){const mipmap=mipmaps[i],width=mipmap.width,height=mipmap.height,depth=isArrayTexture?textureDescriptorGPU.size.depthOrArrayLayers:1,bytesPerRow=Math.ceil(width/blockData.width)*blockData.byteLength,bytesPerImage=bytesPerRow*Math.ceil(height/blockData.height);for(let j=0;j<depth;j++)device.queue.writeTexture({texture:textureGPU,mipLevel:i,origin:{x:0,y:0,z:j}},mipmap.data,{offset:j*bytesPerImage,bytesPerRow:bytesPerRow,rowsPerImage:Math.ceil(height/blockData.height)},{width:Math.ceil(width/blockData.width)*blockData.width,height:Math.ceil(height/blockData.height)*blockData.height,depthOrArrayLayers:1})}}_getBlockData(format){return format===GPUTextureFormat_BC1RGBAUnorm||format===GPUTextureFormat_BC1RGBAUnormSRGB?{byteLength:8,width:4,height:4}:format===GPUTextureFormat_BC2RGBAUnorm||format===GPUTextureFormat_BC2RGBAUnormSRGB||format===GPUTextureFormat_BC3RGBAUnorm||format===GPUTextureFormat_BC3RGBAUnormSRGB?{byteLength:16,width:4,height:4}:format===GPUTextureFormat_BC4RUnorm||format===GPUTextureFormat_BC4RSnorm?{byteLength:8,width:4,height:4}:format===GPUTextureFormat_BC5RGUnorm||format===GPUTextureFormat_BC5RGSnorm||format===GPUTextureFormat_BC6HRGBUFloat||format===GPUTextureFormat_BC6HRGBFloat||format===GPUTextureFormat_BC7RGBAUnorm||format===GPUTextureFormat_BC7RGBAUnormSRGB?{byteLength:16,width:4,height:4}:format===GPUTextureFormat_ETC2RGB8Unorm||format===GPUTextureFormat_ETC2RGB8UnormSRGB||format===GPUTextureFormat_ETC2RGB8A1Unorm||format===GPUTextureFormat_ETC2RGB8A1UnormSRGB?{byteLength:8,width:4,height:4}:format===GPUTextureFormat_ETC2RGBA8Unorm||format===GPUTextureFormat_ETC2RGBA8UnormSRGB?{byteLength:16,width:4,height:4}:format===GPUTextureFormat_EACR11Unorm||format===GPUTextureFormat_EACR11Snorm?{byteLength:8,width:4,height:4}:format===GPUTextureFormat_EACRG11Unorm||format===GPUTextureFormat_EACRG11Snorm||format===GPUTextureFormat_ASTC4x4Unorm||format===GPUTextureFormat_ASTC4x4UnormSRGB?{byteLength:16,width:4,height:4}:format===GPUTextureFormat_ASTC5x4Unorm||format===GPUTextureFormat_ASTC5x4UnormSRGB?{byteLength:16,width:5,height:4}:format===GPUTextureFormat_ASTC5x5Unorm||format===GPUTextureFormat_ASTC5x5UnormSRGB?{byteLength:16,width:5,height:5}:format===GPUTextureFormat_ASTC6x5Unorm||format===GPUTextureFormat_ASTC6x5UnormSRGB?{byteLength:16,width:6,height:5}:format===GPUTextureFormat_ASTC6x6Unorm||format===GPUTextureFormat_ASTC6x6UnormSRGB?{byteLength:16,width:6,height:6}:format===GPUTextureFormat_ASTC8x5Unorm||format===GPUTextureFormat_ASTC8x5UnormSRGB?{byteLength:16,width:8,height:5}:format===GPUTextureFormat_ASTC8x6Unorm||format===GPUTextureFormat_ASTC8x6UnormSRGB?{byteLength:16,width:8,height:6}:format===GPUTextureFormat_ASTC8x8Unorm||format===GPUTextureFormat_ASTC8x8UnormSRGB?{byteLength:16,width:8,height:8}:format===GPUTextureFormat_ASTC10x5Unorm||format===GPUTextureFormat_ASTC10x5UnormSRGB?{byteLength:16,width:10,height:5}:format===GPUTextureFormat_ASTC10x6Unorm||format===GPUTextureFormat_ASTC10x6UnormSRGB?{byteLength:16,width:10,height:6}:format===GPUTextureFormat_ASTC10x8Unorm||format===GPUTextureFormat_ASTC10x8UnormSRGB?{byteLength:16,width:10,height:8}:format===GPUTextureFormat_ASTC10x10Unorm||format===GPUTextureFormat_ASTC10x10UnormSRGB?{byteLength:16,width:10,height:10}:format===GPUTextureFormat_ASTC12x10Unorm||format===GPUTextureFormat_ASTC12x10UnormSRGB?{byteLength:16,width:12,height:10}:format===GPUTextureFormat_ASTC12x12Unorm||format===GPUTextureFormat_ASTC12x12UnormSRGB?{byteLength:16,width:12,height:12}:void 0}_convertAddressMode(value){let addressMode=GPUAddressMode_ClampToEdge;return 1e3===value?addressMode=GPUAddressMode_Repeat:1002===value&&(addressMode=GPUAddressMode_MirrorRepeat),addressMode}_convertFilterMode(value){let filterMode=GPUFilterMode_Linear;return 1003!==value&&1004!==value&&1005!==value||(filterMode=GPUFilterMode_Nearest),filterMode}_getBytesPerTexel(format){return format===GPUTextureFormat_R8Unorm||format===GPUTextureFormat_R8Snorm||format===GPUTextureFormat_R8Uint||format===GPUTextureFormat_R8Sint?1:format===GPUTextureFormat_R16Uint||format===GPUTextureFormat_R16Sint||format===GPUTextureFormat_R16Float||format===GPUTextureFormat_RG8Unorm||format===GPUTextureFormat_RG8Snorm||format===GPUTextureFormat_RG8Uint||format===GPUTextureFormat_RG8Sint?2:format===GPUTextureFormat_R32Uint||format===GPUTextureFormat_R32Sint||format===GPUTextureFormat_R32Float||format===GPUTextureFormat_RG16Uint||format===GPUTextureFormat_RG16Sint||format===GPUTextureFormat_RG16Float||format===GPUTextureFormat_RGBA8Unorm||format===GPUTextureFormat_RGBA8UnormSRGB||format===GPUTextureFormat_RGBA8Snorm||format===GPUTextureFormat_RGBA8Uint||format===GPUTextureFormat_RGBA8Sint||format===GPUTextureFormat_BGRA8Unorm||format===GPUTextureFormat_BGRA8UnormSRGB||format===GPUTextureFormat_RGB9E5UFloat||format===GPUTextureFormat_RGB10A2Unorm||format===GPUTextureFormat_RG11B10UFloat||format===GPUTextureFormat_Depth32Float||format===GPUTextureFormat_Depth24Plus||format===GPUTextureFormat_Depth24PlusStencil8||format===GPUTextureFormat_Depth32FloatStencil8?4:format===GPUTextureFormat_RG32Uint||format===GPUTextureFormat_RG32Sint||format===GPUTextureFormat_RG32Float||format===GPUTextureFormat_RGBA16Uint||format===GPUTextureFormat_RGBA16Sint||format===GPUTextureFormat_RGBA16Float?8:format===GPUTextureFormat_RGBA32Uint||format===GPUTextureFormat_RGBA32Sint||format===GPUTextureFormat_RGBA32Float?16:void 0}_getTypedArrayType(format){return format===GPUTextureFormat_R8Uint?Uint8Array:format===GPUTextureFormat_R8Sint?Int8Array:format===GPUTextureFormat_R8Unorm?Uint8Array:format===GPUTextureFormat_R8Snorm?Int8Array:format===GPUTextureFormat_RG8Uint?Uint8Array:format===GPUTextureFormat_RG8Sint?Int8Array:format===GPUTextureFormat_RG8Unorm?Uint8Array:format===GPUTextureFormat_RG8Snorm?Int8Array:format===GPUTextureFormat_RGBA8Uint?Uint8Array:format===GPUTextureFormat_RGBA8Sint?Int8Array:format===GPUTextureFormat_RGBA8Unorm||format===GPUTextureFormat_RGBA8UnormSRGB?Uint8Array:format===GPUTextureFormat_RGBA8Snorm?Int8Array:format===GPUTextureFormat_R16Uint?Uint16Array:format===GPUTextureFormat_R16Sint?Int16Array:format===GPUTextureFormat_RG16Uint?Uint16Array:format===GPUTextureFormat_RG16Sint?Int16Array:format===GPUTextureFormat_RGBA16Uint?Uint16Array:format===GPUTextureFormat_RGBA16Sint?Int16Array:format===GPUTextureFormat_R16Float||format===GPUTextureFormat_RG16Float||format===GPUTextureFormat_RGBA16Float?Uint16Array:format===GPUTextureFormat_R32Uint?Uint32Array:format===GPUTextureFormat_R32Sint?Int32Array:format===GPUTextureFormat_R32Float?Float32Array:format===GPUTextureFormat_RG32Uint?Uint32Array:format===GPUTextureFormat_RG32Sint?Int32Array:format===GPUTextureFormat_RG32Float?Float32Array:format===GPUTextureFormat_RGBA32Uint?Uint32Array:format===GPUTextureFormat_RGBA32Sint?Int32Array:format===GPUTextureFormat_RGBA32Float?Float32Array:format===GPUTextureFormat_BGRA8Unorm||format===GPUTextureFormat_BGRA8UnormSRGB?Uint8Array:format===GPUTextureFormat_RGB10A2Unorm||format===GPUTextureFormat_RGB9E5UFloat||format===GPUTextureFormat_RG11B10UFloat?Uint32Array:format===GPUTextureFormat_Depth32Float?Float32Array:format===GPUTextureFormat_Depth24Plus||format===GPUTextureFormat_Depth24PlusStencil8?Uint32Array:format===GPUTextureFormat_Depth32FloatStencil8?Float32Array:void 0}_getDimension(texture){let dimension;return dimension=texture.is3DTexture||texture.isData3DTexture?GPUTextureDimension_ThreeD:GPUTextureDimension_TwoD,dimension}}function getFormat(texture,device=null){const format=texture.format,type=texture.type,colorSpace=texture.colorSpace,transfer=ColorManagement.getTransfer(colorSpace);let formatGPU;if(!0===texture.isCompressedTexture||!0===texture.isCompressedArrayTexture)switch(format){case 33776:case 33777:formatGPU="srgb"===transfer?GPUTextureFormat_BC1RGBAUnormSRGB:GPUTextureFormat_BC1RGBAUnorm;break;case 33778:formatGPU="srgb"===transfer?GPUTextureFormat_BC2RGBAUnormSRGB:GPUTextureFormat_BC2RGBAUnorm;break;case 33779:formatGPU="srgb"===transfer?GPUTextureFormat_BC3RGBAUnormSRGB:GPUTextureFormat_BC3RGBAUnorm;break;case 36283:formatGPU=GPUTextureFormat_BC4RUnorm;break;case 36284:formatGPU=GPUTextureFormat_BC4RSnorm;break;case 36285:formatGPU=GPUTextureFormat_BC5RGUnorm;break;case 36286:formatGPU=GPUTextureFormat_BC5RGSnorm;break;case 36492:formatGPU="srgb"===transfer?GPUTextureFormat_BC7RGBAUnormSRGB:GPUTextureFormat_BC7RGBAUnorm;break;case 37492:case 36196:formatGPU="srgb"===transfer?GPUTextureFormat_ETC2RGB8UnormSRGB:GPUTextureFormat_ETC2RGB8Unorm;break;case 37496:formatGPU="srgb"===transfer?GPUTextureFormat_ETC2RGBA8UnormSRGB:GPUTextureFormat_ETC2RGBA8Unorm;break;case 37488:formatGPU=GPUTextureFormat_EACR11Unorm;break;case 37489:formatGPU=GPUTextureFormat_EACR11Snorm;break;case 37490:formatGPU=GPUTextureFormat_EACRG11Unorm;break;case 37491:formatGPU=GPUTextureFormat_EACRG11Snorm;break;case 37808:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC4x4UnormSRGB:GPUTextureFormat_ASTC4x4Unorm;break;case 37809:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC5x4UnormSRGB:GPUTextureFormat_ASTC5x4Unorm;break;case 37810:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC5x5UnormSRGB:GPUTextureFormat_ASTC5x5Unorm;break;case 37811:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC6x5UnormSRGB:GPUTextureFormat_ASTC6x5Unorm;break;case 37812:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC6x6UnormSRGB:GPUTextureFormat_ASTC6x6Unorm;break;case 37813:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC8x5UnormSRGB:GPUTextureFormat_ASTC8x5Unorm;break;case 37814:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC8x6UnormSRGB:GPUTextureFormat_ASTC8x6Unorm;break;case 37815:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC8x8UnormSRGB:GPUTextureFormat_ASTC8x8Unorm;break;case 37816:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC10x5UnormSRGB:GPUTextureFormat_ASTC10x5Unorm;break;case 37817:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC10x6UnormSRGB:GPUTextureFormat_ASTC10x6Unorm;break;case 37818:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC10x8UnormSRGB:GPUTextureFormat_ASTC10x8Unorm;break;case 37819:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC10x10UnormSRGB:GPUTextureFormat_ASTC10x10Unorm;break;case 37820:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC12x10UnormSRGB:GPUTextureFormat_ASTC12x10Unorm;break;case 37821:formatGPU="srgb"===transfer?GPUTextureFormat_ASTC12x12UnormSRGB:GPUTextureFormat_ASTC12x12Unorm;break;case 1023:formatGPU="srgb"===transfer?GPUTextureFormat_RGBA8UnormSRGB:GPUTextureFormat_RGBA8Unorm;break;default:error("WebGPURenderer: Unsupported texture format.",format)}else switch(format){case 1023:switch(type){case 1010:formatGPU=GPUTextureFormat_RGBA8Snorm;break;case 1011:formatGPU=GPUTextureFormat_RGBA16Sint;break;case 1012:formatGPU=GPUTextureFormat_RGBA16Uint;break;case 1014:formatGPU=GPUTextureFormat_RGBA32Uint;break;case 1013:formatGPU=GPUTextureFormat_RGBA32Sint;break;case 1009:formatGPU="srgb"===transfer?GPUTextureFormat_RGBA8UnormSRGB:GPUTextureFormat_RGBA8Unorm;break;case HalfFloatType:formatGPU=GPUTextureFormat_RGBA16Float;break;case 1015:formatGPU=GPUTextureFormat_RGBA32Float;break;default:error("WebGPURenderer: Unsupported texture type with RGBAFormat.",type)}break;case 1022:switch(type){case 35902:formatGPU=GPUTextureFormat_RGB9E5UFloat;break;case 35899:formatGPU=GPUTextureFormat_RG11B10UFloat;break;default:error("WebGPURenderer: Unsupported texture type with RGBFormat.",type)}break;case 1028:switch(type){case 1010:formatGPU=GPUTextureFormat_R8Snorm;break;case 1011:formatGPU=GPUTextureFormat_R16Sint;break;case 1012:formatGPU=GPUTextureFormat_R16Uint;break;case 1014:formatGPU=GPUTextureFormat_R32Uint;break;case 1013:formatGPU=GPUTextureFormat_R32Sint;break;case 1009:formatGPU=GPUTextureFormat_R8Unorm;break;case HalfFloatType:formatGPU=GPUTextureFormat_R16Float;break;case 1015:formatGPU=GPUTextureFormat_R32Float;break;default:error("WebGPURenderer: Unsupported texture type with RedFormat.",type)}break;case 1030:switch(type){case 1010:formatGPU=GPUTextureFormat_RG8Snorm;break;case 1011:formatGPU=GPUTextureFormat_RG16Sint;break;case 1012:formatGPU=GPUTextureFormat_RG16Uint;break;case 1014:formatGPU=GPUTextureFormat_RG32Uint;break;case 1013:formatGPU=GPUTextureFormat_RG32Sint;break;case 1009:formatGPU=GPUTextureFormat_RG8Unorm;break;case HalfFloatType:formatGPU=GPUTextureFormat_RG16Float;break;case 1015:formatGPU=GPUTextureFormat_RG32Float;break;default:error("WebGPURenderer: Unsupported texture type with RGFormat.",type)}break;case 1026:switch(type){case 1012:formatGPU=GPUTextureFormat_Depth16Unorm;break;case 1014:formatGPU=GPUTextureFormat_Depth24Plus;break;case 1015:formatGPU=GPUTextureFormat_Depth32Float;break;default:error("WebGPURenderer: Unsupported texture type with DepthFormat.",type)}break;case 1027:switch(type){case 1020:formatGPU=GPUTextureFormat_Depth24PlusStencil8;break;case 1015:device&&!1===device.features.has(GPUFeatureName.Depth32FloatStencil8)&&error('WebGPURenderer: Depth textures with DepthStencilFormat + FloatType can only be used with the "depth32float-stencil8" GPU feature.'),formatGPU=GPUTextureFormat_Depth32FloatStencil8;break;default:error("WebGPURenderer: Unsupported texture type with DepthStencilFormat.",type)}break;case 1029:switch(type){case 1013:formatGPU=GPUTextureFormat_R32Sint;break;case 1014:formatGPU=GPUTextureFormat_R32Uint;break;default:error("WebGPURenderer: Unsupported texture type with RedIntegerFormat.",type)}break;case 1031:switch(type){case 1013:formatGPU=GPUTextureFormat_RG32Sint;break;case 1014:formatGPU=GPUTextureFormat_RG32Uint;break;default:error("WebGPURenderer: Unsupported texture type with RGIntegerFormat.",type)}break;case 1033:switch(type){case 1013:formatGPU=GPUTextureFormat_RGBA32Sint;break;case 1014:formatGPU=GPUTextureFormat_RGBA32Uint;break;default:error("WebGPURenderer: Unsupported texture type with RGBAIntegerFormat.",type)}break;default:error("WebGPURenderer: Unsupported texture format.",format)}return formatGPU}const declarationRegexp=/^[fn]*\s*([a-z_0-9]+)?\s*\(([\s\S]*?)\)\s*[\-\>]*\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/i,propertiesRegexp=/([a-z_0-9]+)\s*:\s*([a-z_0-9]+(?:<[\s\S]+?>)?)/gi,wgslTypeLib$1={f32:"float",i32:"int",u32:"uint",bool:"bool","vec2<f32>":"vec2","vec2<i32>":"ivec2","vec2<u32>":"uvec2","vec2<bool>":"bvec2",vec2f:"vec2",vec2i:"ivec2",vec2u:"uvec2",vec2b:"bvec2","vec3<f32>":"vec3","vec3<i32>":"ivec3","vec3<u32>":"uvec3","vec3<bool>":"bvec3",vec3f:"vec3",vec3i:"ivec3",vec3u:"uvec3",vec3b:"bvec3","vec4<f32>":"vec4","vec4<i32>":"ivec4","vec4<u32>":"uvec4","vec4<bool>":"bvec4",vec4f:"vec4",vec4i:"ivec4",vec4u:"uvec4",vec4b:"bvec4","mat2x2<f32>":"mat2",mat2x2f:"mat2","mat3x3<f32>":"mat3",mat3x3f:"mat3","mat4x4<f32>":"mat4",mat4x4f:"mat4",sampler:"sampler",texture_1d:"texture",texture_2d:"texture",texture_2d_array:"texture",texture_multisampled_2d:"cubeTexture",texture_depth_2d:"depthTexture",texture_depth_2d_array:"depthTexture",texture_depth_multisampled_2d:"depthTexture",texture_depth_cube:"depthTexture",texture_depth_cube_array:"depthTexture",texture_3d:"texture3D",texture_cube:"cubeTexture",texture_cube_array:"cubeTexture",texture_storage_1d:"storageTexture",texture_storage_2d:"storageTexture",texture_storage_2d_array:"storageTexture",texture_storage_3d:"storageTexture"};class WGSLNodeFunction extends NodeFunction{constructor(source){const{type:type,inputs:inputs,name:name,inputsCode:inputsCode,blockCode:blockCode,outputType:outputType}=(source=>{const declaration=(source=source.trim()).match(declarationRegexp);if(null!==declaration&&4===declaration.length){const inputsCode=declaration[2],propsMatches=[];let match=null;for(;null!==(match=propertiesRegexp.exec(inputsCode));)propsMatches.push({name:match[1],type:match[2]});const inputs=[];for(let i=0;i<propsMatches.length;i++){const{name:name,type:type}=propsMatches[i];let resolvedType=type;resolvedType.startsWith("ptr")?resolvedType="pointer":(resolvedType.startsWith("texture")&&(resolvedType=type.split("<")[0]),resolvedType=wgslTypeLib$1[resolvedType]),inputs.push(new NodeFunctionInput(resolvedType,name))}const blockCode=source.substring(declaration[0].length),outputType=declaration[3]||"void",name=void 0!==declaration[1]?declaration[1]:"";return{type:wgslTypeLib$1[outputType]||outputType,inputs:inputs,name:name,inputsCode:inputsCode,blockCode:blockCode,outputType:outputType}}throw new Error("FunctionNode: Function is not a WGSL code.")})(source);super(type,inputs,name),this.inputsCode=inputsCode,this.blockCode=blockCode,this.outputType=outputType}getCode(name=this.name){const outputType="void"!==this.outputType?"-> "+this.outputType:"";return`fn ${name} ( ${this.inputsCode.trim()} ) ${outputType}`+this.blockCode}}class WGSLNodeParser extends NodeParser{parseFunction(source){return new WGSLNodeFunction(source)}}const accessNames={[NodeAccess_READ_ONLY]:"read",[NodeAccess_WRITE_ONLY]:"write",[NodeAccess_READ_WRITE]:"read_write"},wrapNames={[RepeatWrapping]:"repeat",[ClampToEdgeWrapping]:"clamp",[MirroredRepeatWrapping]:"mirror"},gpuShaderStageLib={vertex:GPUShaderStage.VERTEX,fragment:GPUShaderStage.FRAGMENT,compute:GPUShaderStage.COMPUTE},supports={instance:!0,swizzleAssign:!1,storageBuffer:!0},wgslFnOpLib={"^^":"tsl_xor"},wgslTypeLib={float:"f32",int:"i32",uint:"u32",bool:"bool",color:"vec3<f32>",vec2:"vec2<f32>",ivec2:"vec2<i32>",uvec2:"vec2<u32>",bvec2:"vec2<bool>",vec3:"vec3<f32>",ivec3:"vec3<i32>",uvec3:"vec3<u32>",bvec3:"vec3<bool>",vec4:"vec4<f32>",ivec4:"vec4<i32>",uvec4:"vec4<u32>",bvec4:"vec4<bool>",mat2:"mat2x2<f32>",mat3:"mat3x3<f32>",mat4:"mat4x4<f32>"},wgslCodeCache={},wgslPolyfill={tsl_xor:new CodeNode("fn tsl_xor( a : bool, b : bool ) -> bool { return ( a || b ) && !( a && b ); }"),mod_float:new CodeNode("fn tsl_mod_float( x : f32, y : f32 ) -> f32 { return x - y * floor( x / y ); }"),mod_vec2:new CodeNode("fn tsl_mod_vec2( x : vec2f, y : vec2f ) -> vec2f { return x - y * floor( x / y ); }"),mod_vec3:new CodeNode("fn tsl_mod_vec3( x : vec3f, y : vec3f ) -> vec3f { return x - y * floor( x / y ); }"),mod_vec4:new CodeNode("fn tsl_mod_vec4( x : vec4f, y : vec4f ) -> vec4f { return x - y * floor( x / y ); }"),equals_bool:new CodeNode("fn tsl_equals_bool( a : bool, b : bool ) -> bool { return a == b; }"),equals_bvec2:new CodeNode("fn tsl_equals_bvec2( a : vec2f, b : vec2f ) -> vec2<bool> { return vec2<bool>( a.x == b.x, a.y == b.y ); }"),equals_bvec3:new CodeNode("fn tsl_equals_bvec3( a : vec3f, b : vec3f ) -> vec3<bool> { return vec3<bool>( a.x == b.x, a.y == b.y, a.z == b.z ); }"),equals_bvec4:new CodeNode("fn tsl_equals_bvec4( a : vec4f, b : vec4f ) -> vec4<bool> { return vec4<bool>( a.x == b.x, a.y == b.y, a.z == b.z, a.w == b.w ); }"),repeatWrapping_float:new CodeNode("fn tsl_repeatWrapping_float( coord: f32 ) -> f32 { return fract( coord ); }"),mirrorWrapping_float:new CodeNode("fn tsl_mirrorWrapping_float( coord: f32 ) -> f32 { let mirrored = fract( coord * 0.5 ) * 2.0; return 1.0 - abs( 1.0 - mirrored ); }"),clampWrapping_float:new CodeNode("fn tsl_clampWrapping_float( coord: f32 ) -> f32 { return clamp( coord, 0.0, 1.0 ); }"),biquadraticTexture:new CodeNode("\nfn tsl_biquadraticTexture( map : texture_2d<f32>, coord : vec2f, iRes : vec2u, level : u32 ) -> vec4f {\n\n\tlet res = vec2f( iRes );\n\n\tlet uvScaled = coord * res;\n\tlet uvWrapping = ( ( uvScaled % res ) + res ) % res;\n\n\t// https://www.shadertoy.com/view/WtyXRy\n\n\tlet uv = uvWrapping - 0.5;\n\tlet iuv = floor( uv );\n\tlet f = fract( uv );\n\n\tlet rg1 = textureLoad( map, vec2u( iuv + vec2( 0.5, 0.5 ) ) % iRes, level );\n\tlet rg2 = textureLoad( map, vec2u( iuv + vec2( 1.5, 0.5 ) ) % iRes, level );\n\tlet rg3 = textureLoad( map, vec2u( iuv + vec2( 0.5, 1.5 ) ) % iRes, level );\n\tlet rg4 = textureLoad( map, vec2u( iuv + vec2( 1.5, 1.5 ) ) % iRes, level );\n\n\treturn mix( mix( rg1, rg2, f.x ), mix( rg3, rg4, f.x ), f.y );\n\n}\n")},wgslMethods={dFdx:"dpdx",dFdy:"- dpdy",mod_float:"tsl_mod_float",mod_vec2:"tsl_mod_vec2",mod_vec3:"tsl_mod_vec3",mod_vec4:"tsl_mod_vec4",equals_bool:"tsl_equals_bool",equals_bvec2:"tsl_equals_bvec2",equals_bvec3:"tsl_equals_bvec3",equals_bvec4:"tsl_equals_bvec4",inversesqrt:"inverseSqrt",bitcast:"bitcast<f32>",floatpack_snorm_2x16:"pack2x16snorm",floatpack_unorm_2x16:"pack2x16unorm",floatpack_float16_2x16:"pack2x16float",floatunpack_snorm_2x16:"unpack2x16snorm",floatunpack_unorm_2x16:"unpack2x16unorm",floatunpack_float16_2x16:"unpack2x16float"};let diagnostics="";!0!==("undefined"!=typeof navigator&&/Firefox|Deno/g.test(navigator.userAgent))&&(diagnostics+="diagnostic( off, derivative_uniformity );\n");class WGSLNodeBuilder extends NodeBuilder{constructor(object,renderer){super(object,renderer,new WGSLNodeParser),this.uniformGroups={},this.uniformGroupsBindings={},this.builtins={},this.directives={},this.scopedArrays=new Map}_generateTextureSample(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet,shaderStage=this.shaderStage){return"fragment"===shaderStage?depthSnippet?offsetSnippet?`textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${offsetSnippet} )`:`textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet} )`:offsetSnippet?`textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${offsetSnippet} )`:`textureSample( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet} )`:this.generateTextureSampleLevel(texture,textureProperty,uvSnippet,"0",depthSnippet)}generateTextureSampleLevel(texture,textureProperty,uvSnippet,levelSnippet,depthSnippet,offsetSnippet){return!1===this.isUnfilterable(texture)?offsetSnippet?`textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`:`textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`:this.isFilteredTexture(texture)?this.generateFilteredTexture(texture,textureProperty,uvSnippet,offsetSnippet,levelSnippet):this.generateTextureLod(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet,levelSnippet)}generateWrapFunction(texture){const functionName=`tsl_coord_${wrapNames[texture.wrapS]}S_${wrapNames[texture.wrapT]}_${texture.is3DTexture||texture.isData3DTexture?"3d":"2d"}T`;let nodeCode=wgslCodeCache[functionName];if(void 0===nodeCode){const includes=[],coordType=texture.is3DTexture||texture.isData3DTexture?"vec3f":"vec2f";let code=`fn ${functionName}( coord : ${coordType} ) -> ${coordType} {\n\n\treturn ${coordType}(\n`;const addWrapSnippet=(wrap,axis)=>{1e3===wrap?(includes.push(wgslPolyfill.repeatWrapping_float),code+=`\t\ttsl_repeatWrapping_float( coord.${axis} )`):1001===wrap?(includes.push(wgslPolyfill.clampWrapping_float),code+=`\t\ttsl_clampWrapping_float( coord.${axis} )`):1002===wrap?(includes.push(wgslPolyfill.mirrorWrapping_float),code+=`\t\ttsl_mirrorWrapping_float( coord.${axis} )`):(code+=`\t\tcoord.${axis}`,warn(`WebGPURenderer: Unsupported texture wrap type "${wrap}" for vertex shader.`))};addWrapSnippet(texture.wrapS,"x"),code+=",\n",addWrapSnippet(texture.wrapT,"y"),(texture.is3DTexture||texture.isData3DTexture)&&(code+=",\n",addWrapSnippet(texture.wrapR,"z")),code+="\n\t);\n\n}\n",wgslCodeCache[functionName]=nodeCode=new CodeNode(code,includes)}return nodeCode.build(this),functionName}generateArrayDeclaration(type,count){return`array< ${this.getType(type)}, ${count} >`}generateTextureDimension(texture,textureProperty,levelSnippet){const textureData=this.getDataFromNode(texture,this.shaderStage,this.globalCache);void 0===textureData.dimensionsSnippet&&(textureData.dimensionsSnippet={});let textureDimensionNode=textureData.dimensionsSnippet[levelSnippet];if(void 0===textureData.dimensionsSnippet[levelSnippet]){let textureDimensionsParams,dimensionType;const{primarySamples:primarySamples}=this.renderer.backend.utils.getTextureSampleData(texture),isMultisampled=primarySamples>1;dimensionType=texture.is3DTexture||texture.isData3DTexture?"vec3<u32>":"vec2<u32>",textureDimensionsParams=isMultisampled||texture.isStorageTexture?textureProperty:`${textureProperty}${levelSnippet?`, u32( ${levelSnippet} )`:""}`,textureDimensionNode=new VarNode(new ExpressionNode(`textureDimensions( ${textureDimensionsParams} )`,dimensionType)),textureData.dimensionsSnippet[levelSnippet]=textureDimensionNode,(texture.isArrayTexture||texture.isDataArrayTexture||texture.is3DTexture||texture.isData3DTexture)&&(textureData.arrayLayerCount=new VarNode(new ExpressionNode(`textureNumLayers(${textureProperty})`,"u32"))),texture.isTextureCube&&(textureData.cubeFaceCount=new VarNode(new ExpressionNode("6u","u32")))}return textureDimensionNode.build(this)}generateFilteredTexture(texture,textureProperty,uvSnippet,offsetSnippet,levelSnippet="0u"){this._include("biquadraticTexture");const wrapFunction=this.generateWrapFunction(texture),textureDimension=this.generateTextureDimension(texture,textureProperty,levelSnippet);return offsetSnippet&&(uvSnippet=`${uvSnippet} + vec2<f32>(${offsetSnippet}) / ${textureDimension}`),`tsl_biquadraticTexture( ${textureProperty}, ${wrapFunction}( ${uvSnippet} ), ${textureDimension}, u32( ${levelSnippet} ) )`}generateTextureLod(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet,levelSnippet="0u"){if(!0===texture.isCubeTexture){offsetSnippet&&(uvSnippet=`${uvSnippet} + vec3<f32>(${offsetSnippet})`);return`textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${texture.isDepthTexture?"u32":"f32"}( ${levelSnippet} ) )`}const wrapFunction=this.generateWrapFunction(texture),textureDimension=this.generateTextureDimension(texture,textureProperty,levelSnippet),vecType=texture.is3DTexture||texture.isData3DTexture?"vec3":"vec2";offsetSnippet&&(uvSnippet=`${uvSnippet} + ${vecType}<f32>(${offsetSnippet}) / ${vecType}<f32>( ${textureDimension} )`);return uvSnippet=`${vecType}<u32>( clamp( floor( ${wrapFunction}( ${uvSnippet} ) * ${vecType}<f32>( ${textureDimension} ) ), ${`${vecType}<f32>( 0 )`}, ${`${vecType}<f32>( ${textureDimension} - ${"vec3"===vecType?"vec3<u32>( 1, 1, 1 )":"vec2<u32>( 1, 1 )"} )`} ) )`,this.generateTextureLoad(texture,textureProperty,uvSnippet,levelSnippet,depthSnippet,null)}generateTextureLoad(texture,textureProperty,uvIndexSnippet,levelSnippet,depthSnippet,offsetSnippet){const isStorageTexture=!0===texture.isStorageTexture;let snippet;return null!==levelSnippet||isStorageTexture||(levelSnippet="0u"),offsetSnippet&&(uvIndexSnippet=`${uvIndexSnippet} + ${offsetSnippet}`),depthSnippet?snippet=isStorageTexture?`textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet} )`:`textureLoad( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, u32( ${levelSnippet} ) )`:isStorageTexture?snippet=`textureLoad( ${textureProperty}, ${uvIndexSnippet} )`:(snippet=`textureLoad( ${textureProperty}, ${uvIndexSnippet}, u32( ${levelSnippet} ) )`,this.renderer.backend.compatibilityMode&&texture.isDepthTexture&&(snippet+=".x")),snippet}generateTextureStore(texture,textureProperty,uvIndexSnippet,depthSnippet,valueSnippet){let snippet;return snippet=depthSnippet?`textureStore( ${textureProperty}, ${uvIndexSnippet}, ${depthSnippet}, ${valueSnippet} )`:`textureStore( ${textureProperty}, ${uvIndexSnippet}, ${valueSnippet} )`,snippet}isSampleCompare(texture){return!0===texture.isDepthTexture&&null!==texture.compareFunction&&this.renderer.hasCompatibility(Compatibility_TEXTURE_COMPARE)}isUnfilterable(texture){return"float"!==this.getComponentTypeFromTexture(texture)||!this.isAvailable("float32Filterable")&&!0===texture.isDataTexture&&1015===texture.type||!1===this.isSampleCompare(texture)&&1003===texture.minFilter&&1003===texture.magFilter||this.renderer.backend.utils.getTextureSampleData(texture).primarySamples>1}generateTexture(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet,shaderStage=this.shaderStage){let snippet=null;return snippet=this.isUnfilterable(texture)?this.generateTextureLod(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet,"0",shaderStage):this._generateTextureSample(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet,shaderStage),snippet}generateTextureGrad(texture,textureProperty,uvSnippet,gradSnippet,depthSnippet,offsetSnippet,shaderStage=this.shaderStage){if("fragment"===shaderStage)return offsetSnippet?`textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]}, ${offsetSnippet} )`:`textureSampleGrad( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet},  ${gradSnippet[0]}, ${gradSnippet[1]} )`;error(`WebGPURenderer: THREE.TextureNode.gradient() does not support ${shaderStage} shader.`)}generateTextureCompare(texture,textureProperty,uvSnippet,compareSnippet,depthSnippet,offsetSnippet,shaderStage=this.shaderStage){if("fragment"===shaderStage)return!0===texture.isDepthTexture&&!0===texture.isArrayTexture?offsetSnippet?`textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet}, ${offsetSnippet} )`:`textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${depthSnippet}, ${compareSnippet} )`:offsetSnippet?`textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet}, ${offsetSnippet} )`:`textureSampleCompare( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${compareSnippet} )`;error(`WebGPURenderer: THREE.DepthTexture.compareFunction() does not support ${shaderStage} shader.`)}generateTextureLevel(texture,textureProperty,uvSnippet,levelSnippet,depthSnippet,offsetSnippet){return!1===this.isUnfilterable(texture)?offsetSnippet?`textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet}, ${offsetSnippet} )`:`textureSampleLevel( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${levelSnippet} )`:this.isFilteredTexture(texture)?this.generateFilteredTexture(texture,textureProperty,uvSnippet,offsetSnippet,levelSnippet):this.generateTextureLod(texture,textureProperty,uvSnippet,depthSnippet,offsetSnippet,levelSnippet)}generateTextureBias(texture,textureProperty,uvSnippet,biasSnippet,depthSnippet,offsetSnippet,shaderStage=this.shaderStage){if("fragment"===shaderStage)return offsetSnippet?`textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet}, ${offsetSnippet} )`:`textureSampleBias( ${textureProperty}, ${textureProperty}_sampler, ${uvSnippet}, ${biasSnippet} )`;error(`WebGPURenderer: THREE.TextureNode.biasNode does not support ${shaderStage} shader.`)}getPropertyName(node,shaderStage=this.shaderStage){if(!0===node.isNodeVarying&&!0===node.needsInterpolation){if("vertex"===shaderStage)return`varyings.${node.name}`}else if(!0===node.isNodeUniform){const name=node.name,type=node.type;return"texture"===type||"cubeTexture"===type||"cubeDepthTexture"===type||"storageTexture"===type||"texture3D"===type?name:"buffer"===type||"storageBuffer"===type||"indirectStorageBuffer"===type?this.isCustomStruct(node)?name:name+".value":node.groupNode.name+"."+name}return super.getPropertyName(node)}getOutputStructName(){return"output"}getFunctionOperator(op){const fnOp=wgslFnOpLib[op];return void 0!==fnOp?(this._include(fnOp),fnOp):null}getNodeAccess(node,shaderStage){return"compute"!==shaderStage?!0===node.isAtomic?(warn("WebGPURenderer: Atomic operations are only supported in compute shaders."),NodeAccess_READ_WRITE):NodeAccess_READ_ONLY:node.access}getStorageAccess(node,shaderStage){return accessNames[this.getNodeAccess(node,shaderStage)]}getUniformFromNode(node,type,shaderStage,name=null){const uniformNode=super.getUniformFromNode(node,type,shaderStage,name),nodeData=this.getDataFromNode(node,shaderStage,this.globalCache);if(void 0===nodeData.uniformGPU){let uniformGPU;const group=node.groupNode,groupName=group.name,bindings=this.getBindGroupArray(groupName,shaderStage);if("texture"===type||"cubeTexture"===type||"cubeDepthTexture"===type||"storageTexture"===type||"texture3D"===type){let texture=null;const access=this.getNodeAccess(node,shaderStage);"texture"===type||"storageTexture"===type?texture=!0===node.value.is3DTexture?new NodeSampledTexture3D(uniformNode.name,uniformNode.node,group,access):new NodeSampledTexture(uniformNode.name,uniformNode.node,group,access):"cubeTexture"===type||"cubeDepthTexture"===type?texture=new NodeSampledCubeTexture(uniformNode.name,uniformNode.node,group,access):"texture3D"===type&&(texture=new NodeSampledTexture3D(uniformNode.name,uniformNode.node,group,access)),texture.store=!0===node.isStorageTextureNode,texture.mipLevel=texture.store?node.mipLevel:0,texture.setVisibility(gpuShaderStageLib[shaderStage]);if(!0===node.value.isCubeTexture||!1===this.isUnfilterable(node.value)&&!1===texture.store){const sampler=new NodeSampler(`${uniformNode.name}_sampler`,uniformNode.node,group);sampler.setVisibility(gpuShaderStageLib[shaderStage]),bindings.push(sampler,texture),uniformGPU=[sampler,texture]}else bindings.push(texture),uniformGPU=[texture]}else if("buffer"===type||"storageBuffer"===type||"indirectStorageBuffer"===type){const sharedData=this.getSharedDataFromNode(node);let buffer=sharedData.buffer;if(void 0===buffer){buffer=new("buffer"===type?NodeUniformBuffer:NodeStorageBuffer)(node,group),sharedData.buffer=buffer}buffer.setVisibility(buffer.getVisibility()|gpuShaderStageLib[shaderStage]),bindings.push(buffer),uniformGPU=buffer,uniformNode.name=name||"NodeBuffer_"+uniformNode.id}else{let uniformsGroup=this.uniformGroups[groupName];void 0===uniformsGroup?(uniformsGroup=new NodeUniformsGroup(groupName,group),uniformsGroup.setVisibility(gpuShaderStageLib[shaderStage]),this.uniformGroups[groupName]=uniformsGroup,bindings.push(uniformsGroup)):(uniformsGroup.setVisibility(uniformsGroup.getVisibility()|gpuShaderStageLib[shaderStage]),-1===bindings.indexOf(uniformsGroup)&&bindings.push(uniformsGroup)),uniformGPU=this.getNodeUniform(uniformNode,type);const uniformName=uniformGPU.name;uniformsGroup.uniforms.some(u=>u.name===uniformName)||uniformsGroup.addUniform(uniformGPU)}nodeData.uniformGPU=uniformGPU}return uniformNode}getBuiltin(name,property,type,shaderStage=this.shaderStage){const map=this.builtins[shaderStage]||(this.builtins[shaderStage]=new Map);return!1===map.has(name)&&map.set(name,{name:name,property:property,type:type}),property}hasBuiltin(name,shaderStage=this.shaderStage){return void 0!==this.builtins[shaderStage]&&this.builtins[shaderStage].has(name)}getVertexIndex(){return"vertex"===this.shaderStage?this.getBuiltin("vertex_index","vertexIndex","u32","attribute"):"vertexIndex"}buildFunctionCode(shaderNode){const layout=shaderNode.layout,flowData=this.flowShaderNode(shaderNode),parameters=[];for(const input of layout.inputs)parameters.push(input.name+" : "+this.getType(input.type));let code=`fn ${layout.name}( ${parameters.join(", ")} ) -> ${this.getType(layout.type)} {\n${flowData.vars}\n${flowData.code}\n`;return flowData.result&&(code+=`\treturn ${flowData.result};\n`),code+="\n}\n",code}getInstanceIndex(){return"vertex"===this.shaderStage?this.getBuiltin("instance_index","instanceIndex","u32","attribute"):"instanceIndex"}getInvocationLocalIndex(){return this.getBuiltin("local_invocation_index","invocationLocalIndex","u32","attribute")}getSubgroupSize(){return this.enableSubGroups(),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute")}getInvocationSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_invocation_id","invocationSubgroupIndex","u32","attribute")}getSubgroupIndex(){return this.enableSubGroups(),this.getBuiltin("subgroup_id","subgroupIndex","u32","attribute")}getDrawIndex(){return null}getFrontFacing(){return this.getBuiltin("front_facing","isFront","bool")}getFragCoord(){return this.getBuiltin("position","fragCoord","vec4<f32>")+".xy"}getFragDepth(){return"output."+this.getBuiltin("frag_depth","depth","f32","output")}getClipDistance(){return"varyings.hw_clip_distances"}isFlipY(){return!1}enableDirective(name,shaderStage=this.shaderStage){(this.directives[shaderStage]||(this.directives[shaderStage]=new Set)).add(name)}getDirectives(shaderStage){const snippets=[],directives=this.directives[shaderStage];if(void 0!==directives)for(const directive of directives)snippets.push(`enable ${directive};`);return snippets.join("\n")}enableSubGroups(){this.enableDirective("subgroups")}enableSubgroupsF16(){this.enableDirective("subgroups-f16")}enableClipDistances(){this.enableDirective("clip_distances")}enableShaderF16(){this.enableDirective("f16")}enableDualSourceBlending(){this.enableDirective("dual_source_blending")}enableHardwareClipping(planeCount){this.enableClipDistances(),this.getBuiltin("clip_distances","hw_clip_distances",`array<f32, ${planeCount} >`,"vertex")}getBuiltins(shaderStage){const snippets=[],builtins=this.builtins[shaderStage];if(void 0!==builtins)for(const{name:name,property:property,type:type}of builtins.values())snippets.push(`@builtin( ${name} ) ${property} : ${type}`);return snippets.join(",\n\t")}getScopedArray(name,scope,bufferType,bufferCount){return!1===this.scopedArrays.has(name)&&this.scopedArrays.set(name,{name:name,scope:scope,bufferType:bufferType,bufferCount:bufferCount}),name}getScopedArrays(shaderStage){if("compute"!==shaderStage)return;const snippets=[];for(const{name:name,scope:scope,bufferType:bufferType,bufferCount:bufferCount}of this.scopedArrays.values()){const type=this.getType(bufferType);snippets.push(`var<${scope}> ${name}: array< ${type}, ${bufferCount} >;`)}return snippets.join("\n")}getAttributes(shaderStage){const snippets=[];if("compute"===shaderStage&&(this.getBuiltin("global_invocation_id","globalId","vec3<u32>","attribute"),this.getBuiltin("workgroup_id","workgroupId","vec3<u32>","attribute"),this.getBuiltin("local_invocation_id","localId","vec3<u32>","attribute"),this.getBuiltin("num_workgroups","numWorkgroups","vec3<u32>","attribute"),this.renderer.hasFeature("subgroups")&&(this.enableDirective("subgroups",shaderStage),this.getBuiltin("subgroup_size","subgroupSize","u32","attribute"))),"vertex"===shaderStage||"compute"===shaderStage){const builtins=this.getBuiltins("attribute");builtins&&snippets.push(builtins);const attributes=this.getAttributesArray();for(let index=0,length=attributes.length;index<length;index++){const attribute=attributes[index],name=attribute.name,type=this.getType(attribute.type);snippets.push(`@location( ${index} ) ${name} : ${type}`)}}return snippets.join(",\n\t")}getStructMembers(struct){const snippets=[];for(const member of struct.members){const prefix=struct.output?"@location( "+member.index+" ) ":"";let type=this.getType(member.type);member.atomic&&(type="atomic< "+type+" >"),snippets.push(`\t${prefix+member.name} : ${type}`)}return struct.output&&snippets.push(`\t${this.getBuiltins("output")}`),snippets.join(",\n")}getStructs(shaderStage){let result="";const structs=this.structs[shaderStage];if(structs.length>0){const snippets=[];for(const struct of structs){let snippet=`struct ${struct.name} {\n`;snippet+=this.getStructMembers(struct),snippet+="\n};",snippets.push(snippet)}result="\n"+snippets.join("\n\n")+"\n"}return result}getVar(type,name,count=null){let snippet=`var ${name} : `;return snippet+=null!==count?this.generateArrayDeclaration(type,count):this.getType(type),snippet}getVars(shaderStage){const snippets=[],vars=this.vars[shaderStage];if(void 0!==vars)for(const variable of vars)snippets.push(`\t${this.getVar(variable.type,variable.name,variable.count)};`);return`\n${snippets.join("\n")}\n`}getVaryings(shaderStage){const snippets=[];if("vertex"===shaderStage&&this.getBuiltin("position","builtinClipSpace","vec4<f32>","vertex"),"vertex"===shaderStage||"fragment"===shaderStage){const varyings=this.varyings,vars=this.vars[shaderStage];for(let index=0;index<varyings.length;index++){const varying=varyings[index];if(varying.needsInterpolation){let attributesSnippet=`@location( ${index} )`;if(varying.interpolationType){const samplingSnippet=null!==varying.interpolationSampling?`, ${varying.interpolationSampling} )`:" )";attributesSnippet+=` @interpolate( ${varying.interpolationType}${samplingSnippet}`}else/^(int|uint|ivec|uvec)/.test(varying.type)&&(attributesSnippet+=" @interpolate(flat, either)");snippets.push(`${attributesSnippet} ${varying.name} : ${this.getType(varying.type)}`)}else"vertex"===shaderStage&&!1===vars.includes(varying)&&vars.push(varying)}}const builtins=this.getBuiltins(shaderStage);builtins&&snippets.push(builtins);const code=snippets.join(",\n\t");return"vertex"===shaderStage?this._getWGSLStruct("VaryingsStruct","\t"+code):code}isCustomStruct(nodeUniform){const attribute=nodeUniform.value,bufferNode=nodeUniform.node,isAttributeStructType=(attribute.isBufferAttribute||attribute.isInstancedBufferAttribute)&&null!==bufferNode.structTypeNode,isStructArray=bufferNode.value&&bufferNode.value.array&&"number"==typeof bufferNode.value.itemSize&&bufferNode.value.array.length>bufferNode.value.itemSize;return isAttributeStructType&&!isStructArray}getUniforms(shaderStage){const uniforms=this.uniforms[shaderStage],bindingSnippets=[],bufferSnippets=[],structSnippets=[],uniformGroups={};for(const uniform of uniforms){const groupName=uniform.groupNode.name,uniformIndexes=this.bindingsIndexes[groupName];if("texture"===uniform.type||"cubeTexture"===uniform.type||"cubeDepthTexture"===uniform.type||"storageTexture"===uniform.type||"texture3D"===uniform.type){const texture=uniform.node.value;let textureType;(!0===texture.isCubeTexture||!1===this.isUnfilterable(texture)&&!0!==uniform.node.isStorageTextureNode)&&(this.isSampleCompare(texture)?bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler_comparison;`):bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name}_sampler : sampler;`));let multisampled="";const{primarySamples:primarySamples}=this.renderer.backend.utils.getTextureSampleData(texture);if(primarySamples>1&&(multisampled="_multisampled"),!0===texture.isCubeTexture&&!0===texture.isDepthTexture)textureType="texture_depth_cube";else if(!0===texture.isCubeTexture)textureType="texture_cube<f32>";else if(!0===texture.isDepthTexture)textureType=this.renderer.backend.compatibilityMode&&null===texture.compareFunction?`texture${multisampled}_2d<f32>`:`texture_depth${multisampled}_2d${!0===texture.isArrayTexture?"_array":""}`;else if(!0===uniform.node.isStorageTextureNode){const format=getFormat(texture),access=this.getStorageAccess(uniform.node,shaderStage),is3D=uniform.node.value.is3DTexture,isArrayTexture=uniform.node.value.isArrayTexture;textureType=`texture_storage_${is3D?"3d":"2d"+(isArrayTexture?"_array":"")}<${format}, ${access}>`}else if(!0===texture.isArrayTexture||!0===texture.isDataArrayTexture||!0===texture.isCompressedArrayTexture)textureType="texture_2d_array<f32>";else if(!0===texture.is3DTexture||!0===texture.isData3DTexture)textureType="texture_3d<f32>";else{textureType=`texture${multisampled}_2d<${this.getComponentTypeFromTexture(texture).charAt(0)}32>`}bindingSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var ${uniform.name} : ${textureType};`)}else if("buffer"===uniform.type||"storageBuffer"===uniform.type||"indirectStorageBuffer"===uniform.type){const bufferNode=uniform.node,bufferType=this.getType(bufferNode.getNodeType(this)),bufferCount=bufferNode.bufferCount,bufferCountSnippet=bufferCount>0&&"buffer"===uniform.type?", "+bufferCount:"",bufferAccessMode=bufferNode.isStorageBufferNode?`storage, ${this.getStorageAccess(bufferNode,shaderStage)}`:"uniform";if(this.isCustomStruct(uniform))bufferSnippets.push(`@binding( ${uniformIndexes.binding++} ) @group( ${uniformIndexes.group} ) var<${bufferAccessMode}> ${uniform.name} : ${bufferType};`);else{const bufferSnippet=`\tvalue : array< ${bufferNode.isAtomic?`atomic<${bufferType}>`:`${bufferType}`}${bufferCountSnippet} >`;bufferSnippets.push(this._getWGSLStructBinding(uniform.name,bufferSnippet,bufferAccessMode,uniformIndexes.binding++,uniformIndexes.group))}}else{const groupName=uniform.groupNode.name;if(void 0===uniformGroups[groupName]){const sharedUniformGroup=this.uniformGroups[groupName];if(void 0!==sharedUniformGroup){const snippets=[];for(const sharedUniform of sharedUniformGroup.uniforms){const type=sharedUniform.getType(),vectorType=this.getType(this.getVectorType(type));snippets.push(`\t${sharedUniform.name} : ${vectorType}`)}let groupBinding=this.uniformGroupsBindings[groupName];void 0===groupBinding&&(groupBinding={index:uniformIndexes.binding++,id:uniformIndexes.group},this.uniformGroupsBindings[groupName]=groupBinding),uniformGroups[groupName]={index:groupBinding.index,id:groupBinding.id,snippets:snippets}}}}}for(const name in uniformGroups){const group=uniformGroups[name];structSnippets.push(this._getWGSLStructBinding(name,group.snippets.join(",\n"),"uniform",group.index,group.id))}return[...bindingSnippets,...bufferSnippets,...structSnippets].join("\n")}buildCode(){const shadersData=null!==this.material?{fragment:{},vertex:{}}:{compute:{}};this.sortBindingGroups();for(const shaderStage in shadersData){this.shaderStage=shaderStage;const stageData=shadersData[shaderStage];stageData.uniforms=this.getUniforms(shaderStage),stageData.attributes=this.getAttributes(shaderStage),stageData.varyings=this.getVaryings(shaderStage),stageData.structs=this.getStructs(shaderStage),stageData.vars=this.getVars(shaderStage),stageData.codes=this.getCodes(shaderStage),stageData.directives=this.getDirectives(shaderStage),stageData.scopedArrays=this.getScopedArrays(shaderStage);let flow="// code\n\n";flow+=this.flowCode[shaderStage];const flowNodes=this.flowNodes[shaderStage],mainNode=flowNodes[flowNodes.length-1],outputNode=mainNode.outputNode,isOutputStruct=void 0!==outputNode&&!0===outputNode.isOutputStructNode;for(const node of flowNodes){const flowSlotData=this.getFlowData(node),slotName=node.name;if(slotName&&(flow.length>0&&(flow+="\n"),flow+=`\t// flow -> ${slotName}\n`),flow+=`${flowSlotData.code}\n\t`,node===mainNode&&"compute"!==shaderStage)if(flow+="// result\n\n\t","vertex"===shaderStage)flow+=`varyings.builtinClipSpace = ${flowSlotData.result};`;else if("fragment"===shaderStage)if(isOutputStruct)stageData.returnType=outputNode.getNodeType(this),stageData.structs+="var<private> output : "+stageData.returnType+";",flow+=`return ${flowSlotData.result};`;else{let structSnippet="\t@location(0) color: vec4<f32>";const builtins=this.getBuiltins("output");builtins&&(structSnippet+=",\n\t"+builtins),stageData.returnType="OutputStruct",stageData.structs+=this._getWGSLStruct("OutputStruct",structSnippet),stageData.structs+="\nvar<private> output : OutputStruct;",flow+=`output.color = ${flowSlotData.result};\n\n\treturn output;`}}stageData.flow=flow}if(this.shaderStage=null,null!==this.material)this.vertexShader=this._getWGSLVertexCode(shadersData.vertex),this.fragmentShader=this._getWGSLFragmentCode(shadersData.fragment);else{const workgroupSize=this.object.workgroupSize;this.computeShader=this._getWGSLComputeCode(shadersData.compute,workgroupSize)}}getMethod(method,output=null){let wgslMethod;return null!==output&&(wgslMethod=this._getWGSLMethod(method+"_"+output)),void 0===wgslMethod&&(wgslMethod=this._getWGSLMethod(method)),wgslMethod||method}getBitcastMethod(type){return`bitcast<${this.getType(type)}>`}getFloatPackingMethod(encoding){return this.getMethod(`floatpack_${encoding}_2x16`)}getFloatUnpackingMethod(encoding){return this.getMethod(`floatunpack_${encoding}_2x16`)}getTernary(condSnippet,ifSnippet,elseSnippet){return`select( ${elseSnippet}, ${ifSnippet}, ${condSnippet} )`}getType(type){return wgslTypeLib[type]||type}isAvailable(name){let result=supports[name];return void 0===result&&("float32Filterable"===name?result=this.renderer.hasFeature("float32-filterable"):"clipDistance"===name&&(result=this.renderer.hasFeature("clip-distances")),supports[name]=result),result}getUniformBufferLimit(){return this.renderer.backend.device.limits.maxUniformBufferBindingSize}_getWGSLMethod(method){return void 0!==wgslPolyfill[method]&&this._include(method),wgslMethods[method]}_include(name){const codeNode=wgslPolyfill[name];return codeNode.build(this),this.addInclude(codeNode),codeNode}_getWGSLVertexCode(shaderData){return`${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// varyings\n${shaderData.varyings}\nvar<private> varyings : VaryingsStruct;\n\n// codes\n${shaderData.codes}\n\n@vertex\nfn main( ${shaderData.attributes} ) -> VaryingsStruct {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n\treturn varyings;\n\n}\n`}_getWGSLFragmentCode(shaderData){return`${this.getSignature()}\n// global\n${diagnostics}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@fragment\nfn main( ${shaderData.varyings} ) -> ${shaderData.returnType} {\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`}_getWGSLComputeCode(shaderData,workgroupSize){const[workgroupSizeX,workgroupSizeY,workgroupSizeZ]=workgroupSize;return`${this.getSignature()}\n// directives\n${shaderData.directives}\n\n// system\nvar<private> instanceIndex : u32;\n\n// locals\n${shaderData.scopedArrays}\n\n// structs\n${shaderData.structs}\n\n// uniforms\n${shaderData.uniforms}\n\n// codes\n${shaderData.codes}\n\n@compute @workgroup_size( ${workgroupSizeX}, ${workgroupSizeY}, ${workgroupSizeZ} )\nfn main( ${shaderData.attributes} ) {\n\n\t// system\n\tinstanceIndex = globalId.x\n\t\t+ globalId.y * ( ${workgroupSizeX} * numWorkgroups.x )\n\t\t+ globalId.z * ( ${workgroupSizeX} * numWorkgroups.x ) * ( ${workgroupSizeY} * numWorkgroups.y );\n\n\t// vars\n\t${shaderData.vars}\n\n\t// flow\n\t${shaderData.flow}\n\n}\n`}_getWGSLStruct(name,vars){return`\nstruct ${name} {\n${vars}\n};`}_getWGSLStructBinding(name,vars,access,binding=0,group=0){const structName=name+"Struct";return`${this._getWGSLStruct(structName,vars)}\n@binding( ${binding} ) @group( ${group} )\nvar<${access}> ${name} : ${structName};`}}class WebGPUUtils{constructor(backend){this.backend=backend}getCurrentDepthStencilFormat(renderContext){let format;return renderContext.depth&&(format=null!==renderContext.depthTexture?this.getTextureFormatGPU(renderContext.depthTexture):renderContext.stencil?GPUTextureFormat_Depth24PlusStencil8:GPUTextureFormat_Depth24Plus),format}getTextureFormatGPU(texture){return this.backend.get(texture).format}getTextureSampleData(texture){let samples;if(texture.isFramebufferTexture)samples=1;else if(texture.isDepthTexture&&!texture.renderTarget){const renderer=this.backend.renderer,renderTarget=renderer.getRenderTarget();samples=renderTarget?renderTarget.samples:renderer.currentSamples}else texture.renderTarget&&(samples=texture.renderTarget.samples);samples=samples||1;const isMSAA=samples>1&&null!==texture.renderTarget&&!0!==texture.isDepthTexture&&!0!==texture.isFramebufferTexture;return{samples:samples,primarySamples:isMSAA?1:samples,isMSAA:isMSAA}}getCurrentColorFormat(renderContext){let format;return format=null!==renderContext.textures?this.getTextureFormatGPU(renderContext.textures[0]):this.getPreferredCanvasFormat(),format}getCurrentColorFormats(renderContext){return null!==renderContext.textures?renderContext.textures.map(t=>this.getTextureFormatGPU(t)):[this.getPreferredCanvasFormat()]}getCurrentColorSpace(renderContext){return null!==renderContext.textures?renderContext.textures[0].colorSpace:this.backend.renderer.outputColorSpace}getPrimitiveTopology(object,material){return object.isPoints?GPUPrimitiveTopology_PointList:object.isLineSegments||object.isMesh&&!0===material.wireframe?GPUPrimitiveTopology_LineList:object.isLine?GPUPrimitiveTopology_LineStrip:object.isMesh?GPUPrimitiveTopology_TriangleList:void 0}getSampleCount(sampleCount){return sampleCount>=4?4:1}getSampleCountRenderContext(renderContext){return null!==renderContext.textures?this.getSampleCount(renderContext.sampleCount):this.getSampleCount(this.backend.renderer.currentSamples)}getPreferredCanvasFormat(){const bufferType=this.backend.parameters.outputType;if(void 0===bufferType)return navigator.gpu.getPreferredCanvasFormat();if(1009===bufferType)return GPUTextureFormat_BGRA8Unorm;if(bufferType===HalfFloatType)return GPUTextureFormat_RGBA16Float;throw new Error("Unsupported output buffer type.")}}const typedArraysToVertexFormatPrefix=new Map([[Int8Array,["sint8","snorm8"]],[Uint8Array,["uint8","unorm8"]],[Int16Array,["sint16","snorm16"]],[Uint16Array,["uint16","unorm16"]],[Int32Array,["sint32","snorm32"]],[Uint32Array,["uint32","unorm32"]],[Float32Array,["float32"]]]);"undefined"!=typeof Float16Array&&typedArraysToVertexFormatPrefix.set(Float16Array,["float16"]);const typedAttributeToVertexFormatPrefix=new Map([[Float16BufferAttribute,["float16"]]]),typeArraysToVertexFormatPrefixForItemSize1=new Map([[Int32Array,"sint32"],[Int16Array,"sint32"],[Uint32Array,"uint32"],[Uint16Array,"uint32"],[Float32Array,"float32"]]);class WebGPUAttributeUtils{constructor(backend){this.backend=backend}createAttribute(attribute,usage){const bufferAttribute=this._getBufferAttribute(attribute),backend=this.backend,bufferData=backend.get(bufferAttribute);let buffer=bufferData.buffer;if(void 0===buffer){const device=backend.device;let array=bufferAttribute.array;if(!1===attribute.normalized)if(array.constructor===Int16Array||array.constructor===Int8Array)array=new Int32Array(array);else if((array.constructor===Uint16Array||array.constructor===Uint8Array)&&(array=new Uint32Array(array),usage&GPUBufferUsage.INDEX))for(let i=0;i<array.length;i++)65535===array[i]&&(array[i]=4294967295);if(bufferAttribute.array=array,(bufferAttribute.isStorageBufferAttribute||bufferAttribute.isStorageInstancedBufferAttribute)&&3===bufferAttribute.itemSize){array=new array.constructor(4*bufferAttribute.count);for(let i=0;i<bufferAttribute.count;i++)array.set(bufferAttribute.array.subarray(3*i,3*i+3),4*i);bufferAttribute.itemSize=4,bufferAttribute.array=array,bufferData._force3to4BytesAlignment=!0}const byteLength=array.byteLength,size=byteLength+(4-byteLength%4)%4;buffer=device.createBuffer({label:bufferAttribute.name,size:size,usage:usage,mappedAtCreation:!0}),new array.constructor(buffer.getMappedRange()).set(array),buffer.unmap(),bufferData.buffer=buffer}}updateAttribute(attribute){const bufferAttribute=this._getBufferAttribute(attribute),backend=this.backend,device=backend.device,bufferData=backend.get(bufferAttribute),buffer=backend.get(bufferAttribute).buffer;let array=bufferAttribute.array;if(!0===bufferData._force3to4BytesAlignment){array=new array.constructor(4*bufferAttribute.count);for(let i=0;i<bufferAttribute.count;i++)array.set(bufferAttribute.array.subarray(3*i,3*i+3),4*i);bufferAttribute.array=array}const updateRanges=bufferAttribute.updateRanges;if(0===updateRanges.length)device.queue.writeBuffer(buffer,0,array,0);else{const isTyped=isTypedArray(array),byteOffsetFactor=isTyped?1:array.BYTES_PER_ELEMENT;for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i];let dataOffset,size;if(!0===bufferData._force3to4BytesAlignment){dataOffset=4*Math.floor(range.start/3)*byteOffsetFactor,size=4*Math.ceil(range.count/3)*byteOffsetFactor}else dataOffset=range.start*byteOffsetFactor,size=range.count*byteOffsetFactor;const bufferOffset=dataOffset*(isTyped?array.BYTES_PER_ELEMENT:1);device.queue.writeBuffer(buffer,bufferOffset,array,dataOffset,size)}bufferAttribute.clearUpdateRanges()}}createShaderVertexBuffers(renderObject){const attributes=renderObject.getAttributes(),vertexBuffers=new Map;for(let slot=0;slot<attributes.length;slot++){const geometryAttribute=attributes[slot],bytesPerElement=geometryAttribute.array.BYTES_PER_ELEMENT,bufferAttribute=this._getBufferAttribute(geometryAttribute);let vertexBufferLayout=vertexBuffers.get(bufferAttribute);if(void 0===vertexBufferLayout){let arrayStride,stepMode;!0===geometryAttribute.isInterleavedBufferAttribute?(arrayStride=geometryAttribute.data.stride*bytesPerElement,stepMode=geometryAttribute.data.isInstancedInterleavedBuffer?GPUInputStepMode_Instance:GPUInputStepMode_Vertex):(arrayStride=geometryAttribute.itemSize*bytesPerElement,stepMode=geometryAttribute.isInstancedBufferAttribute?GPUInputStepMode_Instance:GPUInputStepMode_Vertex),!1!==geometryAttribute.normalized||geometryAttribute.array.constructor!==Int16Array&&geometryAttribute.array.constructor!==Uint16Array||(arrayStride=4),vertexBufferLayout={arrayStride:arrayStride,attributes:[],stepMode:stepMode},vertexBuffers.set(bufferAttribute,vertexBufferLayout)}const format=this._getVertexFormat(geometryAttribute),offset=!0===geometryAttribute.isInterleavedBufferAttribute?geometryAttribute.offset*bytesPerElement:0;vertexBufferLayout.attributes.push({shaderLocation:slot,offset:offset,format:format})}return Array.from(vertexBuffers.values())}destroyAttribute(attribute){const backend=this.backend;backend.get(this._getBufferAttribute(attribute)).buffer.destroy(),backend.delete(attribute)}async getArrayBufferAsync(attribute){const backend=this.backend,device=backend.device,bufferGPU=backend.get(this._getBufferAttribute(attribute)).buffer,size=bufferGPU.size,readBufferGPU=device.createBuffer({label:`${attribute.name}_readback`,size:size,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ}),cmdEncoder=device.createCommandEncoder({label:`readback_encoder_${attribute.name}`});cmdEncoder.copyBufferToBuffer(bufferGPU,0,readBufferGPU,0,size);const gpuCommands=cmdEncoder.finish();device.queue.submit([gpuCommands]),await readBufferGPU.mapAsync(GPUMapMode.READ);const arrayBuffer=readBufferGPU.getMappedRange(),dstBuffer=new attribute.array.constructor(arrayBuffer.slice(0));return readBufferGPU.unmap(),dstBuffer.buffer}_getVertexFormat(geometryAttribute){const{itemSize:itemSize,normalized:normalized}=geometryAttribute,ArrayType=geometryAttribute.array.constructor,AttributeType=geometryAttribute.constructor;let format;if(1===itemSize)format=typeArraysToVertexFormatPrefixForItemSize1.get(ArrayType);else{const prefix=(typedAttributeToVertexFormatPrefix.get(AttributeType)||typedArraysToVertexFormatPrefix.get(ArrayType))[normalized?1:0];if(prefix){const bytesPerUnit=ArrayType.BYTES_PER_ELEMENT*itemSize,paddedItemSize=4*Math.floor((bytesPerUnit+3)/4)/ArrayType.BYTES_PER_ELEMENT;if(paddedItemSize%1)throw new Error("THREE.WebGPUAttributeUtils: Bad vertex format item size.");format=`${prefix}x${paddedItemSize}`}}return format||error("WebGPUAttributeUtils: Vertex format not supported yet."),format}_getBufferAttribute(attribute){return attribute.isInterleavedBufferAttribute&&(attribute=attribute.data),attribute}}class BindGroupLayout{constructor(layoutGPU){this.layoutGPU=layoutGPU,this.usedTimes=0}}class WebGPUBindingUtils{constructor(backend){this.backend=backend,this._bindGroupLayoutCache=new Map}createBindingsLayout(bindGroup){const backend=this.backend,device=backend.device,bindingsData=backend.get(bindGroup);if(bindingsData.layout)return bindingsData.layout.layoutGPU;const entries=this._createLayoutEntries(bindGroup),bindGroupLayoutKey=JSON.stringify(entries);let bindGroupLayout=this._bindGroupLayoutCache.get(bindGroupLayoutKey);return void 0===bindGroupLayout&&(bindGroupLayout=new BindGroupLayout(device.createBindGroupLayout({entries:entries})),this._bindGroupLayoutCache.set(bindGroupLayoutKey,bindGroupLayout)),bindGroupLayout.usedTimes++,bindingsData.layout=bindGroupLayout,bindingsData.layoutKey=bindGroupLayoutKey,bindGroupLayout.layoutGPU}createBindings(bindGroup,bindings,cacheIndex,version=0){const{backend:backend}=this,bindingsData=backend.get(bindGroup),bindLayoutGPU=this.createBindingsLayout(bindGroup);let bindGroupGPU;cacheIndex>0&&(void 0===bindingsData.groups&&(bindingsData.groups=[],bindingsData.versions=[]),bindingsData.versions[cacheIndex]===version&&(bindGroupGPU=bindingsData.groups[cacheIndex])),void 0===bindGroupGPU&&(bindGroupGPU=this.createBindGroup(bindGroup,bindLayoutGPU),cacheIndex>0&&(bindingsData.groups[cacheIndex]=bindGroupGPU,bindingsData.versions[cacheIndex]=version)),bindingsData.group=bindGroupGPU}updateBinding(binding){const backend=this.backend,device=backend.device,array=binding.buffer,buffer=backend.get(binding).buffer,updateRanges=binding.updateRanges;if(0===updateRanges.length)device.queue.writeBuffer(buffer,0,array,0);else{const isTyped=isTypedArray(array),byteOffsetFactor=isTyped?1:array.BYTES_PER_ELEMENT;for(let i=0,l=updateRanges.length;i<l;i++){const range=updateRanges[i],dataOffset=range.start*byteOffsetFactor,size=range.count*byteOffsetFactor,bufferOffset=dataOffset*(isTyped?array.BYTES_PER_ELEMENT:1);device.queue.writeBuffer(buffer,bufferOffset,array,dataOffset,size)}}}createBindGroupIndex(data,layoutGPU){const device=this.backend.device,usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,index=data[0],buffer=device.createBuffer({label:"bindingCameraIndex_"+index,size:16,usage:usage});device.queue.writeBuffer(buffer,0,data,0);const entries=[{binding:0,resource:{buffer:buffer}}];return device.createBindGroup({label:"bindGroupCameraIndex_"+index,layout:layoutGPU,entries:entries})}createBindGroup(bindGroup,layoutGPU){const backend=this.backend,device=backend.device;let bindingPoint=0;const entriesGPU=[];for(const binding of bindGroup.bindings){if(binding.isUniformBuffer){const bindingData=backend.get(binding);if(void 0===bindingData.buffer){const byteLength=binding.byteLength,usage=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,visibilities=[];binding.visibility&GPUShaderStage.VERTEX&&visibilities.push("vertex"),binding.visibility&GPUShaderStage.FRAGMENT&&visibilities.push("fragment"),binding.visibility&GPUShaderStage.COMPUTE&&visibilities.push("compute");const bufferVisibility=`(${visibilities.join(",")})`,bufferGPU=device.createBuffer({label:`bindingBuffer${binding.id}_${binding.name}_${bufferVisibility}`,size:byteLength,usage:usage});bindingData.buffer=bufferGPU}entriesGPU.push({binding:bindingPoint,resource:{buffer:bindingData.buffer}})}else if(binding.isStorageBuffer){const buffer=backend.get(binding.attribute).buffer;entriesGPU.push({binding:bindingPoint,resource:{buffer:buffer}})}else if(binding.isSampledTexture){const textureData=backend.get(binding.texture);let resourceGPU;if(void 0!==textureData.externalTexture)resourceGPU=device.importExternalTexture({source:textureData.externalTexture});else{const mipLevelCount=binding.store?1:textureData.texture.mipLevelCount,baseMipLevel=binding.store?binding.mipLevel:0;let propertyName=`view-${textureData.texture.width}-${textureData.texture.height}`;if(textureData.texture.depthOrArrayLayers>1&&(propertyName+=`-${textureData.texture.depthOrArrayLayers}`),propertyName+=`-${mipLevelCount}-${baseMipLevel}`,resourceGPU=textureData[propertyName],void 0===resourceGPU){const aspectGPU=GPUTextureAspect_All;let dimensionViewGPU;dimensionViewGPU=binding.isSampledCubeTexture?GPUTextureViewDimension_Cube:binding.isSampledTexture3D?GPUTextureViewDimension_ThreeD:binding.texture.isArrayTexture||binding.texture.isDataArrayTexture||binding.texture.isCompressedArrayTexture?GPUTextureViewDimension_TwoDArray:GPUTextureViewDimension_TwoD,resourceGPU=textureData[propertyName]=textureData.texture.createView({aspect:aspectGPU,dimension:dimensionViewGPU,mipLevelCount:mipLevelCount,baseMipLevel:baseMipLevel})}}entriesGPU.push({binding:bindingPoint,resource:resourceGPU})}else if(binding.isSampler){const textureGPU=backend.get(binding.texture);entriesGPU.push({binding:bindingPoint,resource:textureGPU.sampler})}bindingPoint++}return device.createBindGroup({label:"bindGroup_"+bindGroup.name,layout:layoutGPU,entries:entriesGPU})}_createLayoutEntries(bindGroup){const entries=[];let index=0;for(const binding of bindGroup.bindings){const backend=this.backend,bindingGPU={binding:index,visibility:binding.visibility};if(binding.isUniformBuffer||binding.isStorageBuffer){const buffer={};binding.isStorageBuffer&&(binding.visibility&GPUShaderStage.COMPUTE&&(binding.access===NodeAccess_READ_WRITE||binding.access===NodeAccess_WRITE_ONLY)?buffer.type=GPUBufferBindingType_Storage:buffer.type=GPUBufferBindingType_ReadOnlyStorage),bindingGPU.buffer=buffer}else if(binding.isSampledTexture&&binding.store){const storageTexture={};storageTexture.format=this.backend.get(binding.texture).texture.format;const access=binding.access;storageTexture.access=access===NodeAccess_READ_WRITE?GPUStorageTextureAccess_ReadWrite:access===NodeAccess_WRITE_ONLY?GPUStorageTextureAccess_WriteOnly:GPUStorageTextureAccess_ReadOnly,binding.texture.isArrayTexture?storageTexture.viewDimension=GPUTextureViewDimension_TwoDArray:binding.texture.is3DTexture&&(storageTexture.viewDimension=GPUTextureViewDimension_ThreeD),bindingGPU.storageTexture=storageTexture}else if(binding.isSampledTexture){const texture={},{primarySamples:primarySamples}=backend.utils.getTextureSampleData(binding.texture);if(primarySamples>1&&(texture.multisampled=!0,binding.texture.isDepthTexture||(texture.sampleType=GPUTextureSampleType_UnfilterableFloat)),binding.texture.isDepthTexture)backend.compatibilityMode&&null===binding.texture.compareFunction?texture.sampleType=GPUTextureSampleType_UnfilterableFloat:texture.sampleType=GPUTextureSampleType_Depth;else if(binding.texture.isDataTexture||binding.texture.isDataArrayTexture||binding.texture.isData3DTexture){const type=binding.texture.type;1013===type?texture.sampleType=GPUTextureSampleType_SInt:1014===type?texture.sampleType=GPUTextureSampleType_UInt:1015===type&&(this.backend.hasFeature("float32-filterable")?texture.sampleType=GPUTextureSampleType_Float:texture.sampleType=GPUTextureSampleType_UnfilterableFloat)}binding.isSampledCubeTexture?texture.viewDimension=GPUTextureViewDimension_Cube:binding.texture.isArrayTexture||binding.texture.isDataArrayTexture||binding.texture.isCompressedArrayTexture?texture.viewDimension=GPUTextureViewDimension_TwoDArray:binding.isSampledTexture3D&&(texture.viewDimension=GPUTextureViewDimension_ThreeD),bindingGPU.texture=texture}else if(binding.isSampler){const sampler={};binding.texture.isDepthTexture&&(null!==binding.texture.compareFunction&&backend.hasCompatibility(Compatibility_TEXTURE_COMPARE)?sampler.type=GPUSamplerBindingType_Comparison:sampler.type=GPUSamplerBindingType_NonFiltering),bindingGPU.sampler=sampler}else error(`WebGPUBindingUtils: Unsupported binding "${binding}".`);entries.push(bindingGPU),index++}return entries}deleteBindGroupData(bindGroup){const{backend:backend}=this,bindingsData=backend.get(bindGroup);bindingsData.layout&&(bindingsData.layout.usedTimes--,0===bindingsData.layout.usedTimes&&this._bindGroupLayoutCache.delete(bindingsData.layoutKey),bindingsData.layout=void 0,bindingsData.layoutKey=void 0)}dispose(){this._bindGroupLayoutCache.clear()}}class WebGPUPipelineUtils{constructor(backend){this.backend=backend,this._activePipelines=new WeakMap}setPipeline(pass,pipeline){this._activePipelines.get(pass)!==pipeline&&(pass.setPipeline(pipeline),this._activePipelines.set(pass,pipeline))}_getSampleCount(renderContext){return this.backend.utils.getSampleCountRenderContext(renderContext)}createRenderPipeline(renderObject,promises){const{object:object,material:material,geometry:geometry,pipeline:pipeline}=renderObject,{vertexProgram:vertexProgram,fragmentProgram:fragmentProgram}=pipeline,backend=this.backend,device=backend.device,utils=backend.utils,pipelineData=backend.get(pipeline),bindGroupLayouts=[];for(const bindGroup of renderObject.getBindings()){const bindingsData=backend.get(bindGroup),{layoutGPU:layoutGPU}=bindingsData.layout;bindGroupLayouts.push(layoutGPU)}const vertexBuffers=backend.attributeUtils.createShaderVertexBuffers(renderObject);let materialBlending;0===material.blending||1===material.blending&&!1===material.transparent||(materialBlending=this._getBlending(material));let stencilFront={};!0===material.stencilWrite&&(stencilFront={compare:this._getStencilCompare(material),failOp:this._getStencilOperation(material.stencilFail),depthFailOp:this._getStencilOperation(material.stencilZFail),passOp:this._getStencilOperation(material.stencilZPass)});const colorWriteMask=this._getColorWriteMask(material),targets=[];if(null!==renderObject.context.textures){const textures=renderObject.context.textures,mrt=renderObject.context.mrt;for(let i=0;i<textures.length;i++){const texture=textures[i],colorFormat=utils.getTextureFormatGPU(texture);let blending;if(null!==mrt){const blendMode=mrt.getBlendMode(texture.name);6===blendMode.blending?blending=materialBlending:0!==blendMode.blending&&(blending=this._getBlending(blendMode))}else blending=materialBlending;targets.push({format:colorFormat,blend:blending,writeMask:colorWriteMask})}}else{const colorFormat=utils.getCurrentColorFormat(renderObject.context);targets.push({format:colorFormat,blend:materialBlending,writeMask:colorWriteMask})}const vertexModule=backend.get(vertexProgram).module,fragmentModule=backend.get(fragmentProgram).module,primitiveState=this._getPrimitiveState(object,geometry,material),depthCompare=this._getDepthCompare(material),depthStencilFormat=utils.getCurrentDepthStencilFormat(renderObject.context),sampleCount=this._getSampleCount(renderObject.context),pipelineDescriptor={label:`renderPipeline_${material.name||material.type}_${material.id}`,vertex:Object.assign({},vertexModule,{buffers:vertexBuffers}),fragment:Object.assign({},fragmentModule,{targets:targets}),primitive:primitiveState,multisample:{count:sampleCount,alphaToCoverageEnabled:material.alphaToCoverage&&sampleCount>1},layout:device.createPipelineLayout({bindGroupLayouts:bindGroupLayouts})},depthStencil={},renderDepth=renderObject.context.depth,renderStencil=renderObject.context.stencil;if(!0!==renderDepth&&!0!==renderStencil||(!0===renderDepth&&(depthStencil.format=depthStencilFormat,depthStencil.depthWriteEnabled=material.depthWrite,depthStencil.depthCompare=depthCompare),!0===renderStencil&&(depthStencil.stencilFront=stencilFront,depthStencil.stencilBack={},depthStencil.stencilReadMask=material.stencilFuncMask,depthStencil.stencilWriteMask=material.stencilWriteMask),!0===material.polygonOffset&&(depthStencil.depthBias=material.polygonOffsetUnits,depthStencil.depthBiasSlopeScale=material.polygonOffsetFactor,depthStencil.depthBiasClamp=0),pipelineDescriptor.depthStencil=depthStencil),device.pushErrorScope("validation"),null===promises)pipelineData.pipeline=device.createRenderPipeline(pipelineDescriptor),device.popErrorScope().then(err=>{null!==err&&(pipelineData.error=!0,error(err.message))});else{const p=new Promise(async resolve=>{try{pipelineData.pipeline=await device.createRenderPipelineAsync(pipelineDescriptor)}catch(err){}const errorScope=await device.popErrorScope();null!==errorScope&&(pipelineData.error=!0,error(errorScope.message)),resolve()});promises.push(p)}}createBundleEncoder(renderContext,label="renderBundleEncoder"){const backend=this.backend,{utils:utils,device:device}=backend,depthStencilFormat=utils.getCurrentDepthStencilFormat(renderContext),descriptor={label:label,colorFormats:utils.getCurrentColorFormats(renderContext),depthStencilFormat:depthStencilFormat,sampleCount:this._getSampleCount(renderContext)};return device.createRenderBundleEncoder(descriptor)}createComputePipeline(pipeline,bindings){const backend=this.backend,device=backend.device,computeProgram=backend.get(pipeline.computeProgram).module,pipelineGPU=backend.get(pipeline),bindGroupLayouts=[];for(const bindingsGroup of bindings){const bindingsData=backend.get(bindingsGroup),{layoutGPU:layoutGPU}=bindingsData.layout;bindGroupLayouts.push(layoutGPU)}pipelineGPU.pipeline=device.createComputePipeline({compute:computeProgram,layout:device.createPipelineLayout({bindGroupLayouts:bindGroupLayouts})})}_getBlending(object){let color,alpha;const blending=object.blending,blendSrc=object.blendSrc,blendDst=object.blendDst,blendEquation=object.blendEquation;if(5===blending){const blendSrcAlpha=null!==object.blendSrcAlpha?object.blendSrcAlpha:blendSrc,blendDstAlpha=null!==object.blendDstAlpha?object.blendDstAlpha:blendDst,blendEquationAlpha=null!==object.blendEquationAlpha?object.blendEquationAlpha:blendEquation;color={srcFactor:this._getBlendFactor(blendSrc),dstFactor:this._getBlendFactor(blendDst),operation:this._getBlendOperation(blendEquation)},alpha={srcFactor:this._getBlendFactor(blendSrcAlpha),dstFactor:this._getBlendFactor(blendDstAlpha),operation:this._getBlendOperation(blendEquationAlpha)}}else{const setBlend=(srcRGB,dstRGB,srcAlpha,dstAlpha)=>{color={srcFactor:srcRGB,dstFactor:dstRGB,operation:GPUBlendOperation_Add},alpha={srcFactor:srcAlpha,dstFactor:dstAlpha,operation:GPUBlendOperation_Add}};if(object.premultipliedAlpha)switch(blending){case 1:setBlend(GPUBlendFactor_One,GPUBlendFactor_OneMinusSrcAlpha,GPUBlendFactor_One,GPUBlendFactor_OneMinusSrcAlpha);break;case 2:setBlend(GPUBlendFactor_One,GPUBlendFactor_One,GPUBlendFactor_One,GPUBlendFactor_One);break;case 3:setBlend(GPUBlendFactor_Zero,GPUBlendFactor_OneMinusSrc,GPUBlendFactor_Zero,GPUBlendFactor_One);break;case 4:setBlend(GPUBlendFactor_Dst,GPUBlendFactor_OneMinusSrcAlpha,GPUBlendFactor_Zero,GPUBlendFactor_One)}else switch(blending){case 1:setBlend(GPUBlendFactor_SrcAlpha,GPUBlendFactor_OneMinusSrcAlpha,GPUBlendFactor_One,GPUBlendFactor_OneMinusSrcAlpha);break;case 2:setBlend(GPUBlendFactor_SrcAlpha,GPUBlendFactor_One,GPUBlendFactor_One,GPUBlendFactor_One);break;case 3:error(`WebGPURenderer: "SubtractiveBlending" requires "${object.isMaterial?"material":"blendMode"}.premultipliedAlpha = true".`);break;case 4:error(`WebGPURenderer: "MultiplyBlending" requires "${object.isMaterial?"material":"blendMode"}.premultipliedAlpha = true".`)}}if(void 0!==color&&void 0!==alpha)return{color:color,alpha:alpha};error("WebGPURenderer: Invalid blending: ",blending)}_getBlendFactor(blend){let blendFactor;switch(blend){case 200:blendFactor=GPUBlendFactor_Zero;break;case 201:blendFactor=GPUBlendFactor_One;break;case 202:blendFactor=GPUBlendFactor_Src;break;case 203:blendFactor=GPUBlendFactor_OneMinusSrc;break;case 204:blendFactor=GPUBlendFactor_SrcAlpha;break;case 205:blendFactor=GPUBlendFactor_OneMinusSrcAlpha;break;case 208:blendFactor=GPUBlendFactor_Dst;break;case 209:blendFactor=GPUBlendFactor_OneMinusDst;break;case 206:blendFactor=GPUBlendFactor_DstAlpha;break;case 207:blendFactor=GPUBlendFactor_OneMinusDstAlpha;break;case 210:blendFactor=GPUBlendFactor_SrcAlphaSaturated;break;case 211:blendFactor=GPUBlendFactor_Constant;break;case 212:blendFactor=GPUBlendFactor_OneMinusConstant;break;default:error("WebGPURenderer: Blend factor not supported.",blend)}return blendFactor}_getStencilCompare(material){let stencilCompare;const stencilFunc=material.stencilFunc;switch(stencilFunc){case 512:stencilCompare=GPUCompareFunction_Never;break;case 519:stencilCompare=GPUCompareFunction_Always;break;case 513:stencilCompare=GPUCompareFunction_Less;break;case 515:stencilCompare=GPUCompareFunction_LessEqual;break;case 514:stencilCompare=GPUCompareFunction_Equal;break;case 518:stencilCompare=GPUCompareFunction_GreaterEqual;break;case 516:stencilCompare=GPUCompareFunction_Greater;break;case 517:stencilCompare=GPUCompareFunction_NotEqual;break;default:error("WebGPURenderer: Invalid stencil function.",stencilFunc)}return stencilCompare}_getStencilOperation(op){let stencilOperation;switch(op){case 7680:stencilOperation=GPUStencilOperation_Keep;break;case 0:stencilOperation=GPUStencilOperation_Zero;break;case 7681:stencilOperation=GPUStencilOperation_Replace;break;case 5386:stencilOperation=GPUStencilOperation_Invert;break;case 7682:stencilOperation=GPUStencilOperation_IncrementClamp;break;case 7683:stencilOperation=GPUStencilOperation_DecrementClamp;break;case 34055:stencilOperation=GPUStencilOperation_IncrementWrap;break;case 34056:stencilOperation=GPUStencilOperation_DecrementWrap;break;default:error("WebGPURenderer: Invalid stencil operation.",stencilOperation)}return stencilOperation}_getBlendOperation(blendEquation){let blendOperation;switch(blendEquation){case 100:blendOperation=GPUBlendOperation_Add;break;case 101:blendOperation=GPUBlendOperation_Subtract;break;case 102:blendOperation=GPUBlendOperation_ReverseSubtract;break;case 103:blendOperation=GPUBlendOperation_Min;break;case 104:blendOperation=GPUBlendOperation_Max;break;default:error("WebGPUPipelineUtils: Blend equation not supported.",blendEquation)}return blendOperation}_getPrimitiveState(object,geometry,material){const descriptor={},utils=this.backend.utils;descriptor.topology=utils.getPrimitiveTopology(object,material),null!==geometry.index&&!0===object.isLine&&!0!==object.isLineSegments&&(descriptor.stripIndexFormat=geometry.index.array instanceof Uint16Array?GPUIndexFormat_Uint16:GPUIndexFormat_Uint32);let flipSided=1===material.side;return object.isMesh&&object.matrixWorld.determinant()<0&&(flipSided=!flipSided),descriptor.frontFace=!0===flipSided?GPUFrontFace_CW:GPUFrontFace_CCW,descriptor.cullMode=2===material.side?GPUCullMode_None:GPUCullMode_Back,descriptor}_getColorWriteMask(material){return!0===material.colorWrite?GPUColorWriteFlags_All:GPUColorWriteFlags_None}_getDepthCompare(material){let depthCompare;if(!1===material.depthTest)depthCompare=GPUCompareFunction_Always;else{const depthFunc=material.depthFunc;switch(depthFunc){case 0:depthCompare=GPUCompareFunction_Never;break;case 1:depthCompare=GPUCompareFunction_Always;break;case 2:depthCompare=GPUCompareFunction_Less;break;case 3:depthCompare=GPUCompareFunction_LessEqual;break;case 4:depthCompare=GPUCompareFunction_Equal;break;case 5:depthCompare=GPUCompareFunction_GreaterEqual;break;case 6:depthCompare=GPUCompareFunction_Greater;break;case 7:depthCompare=GPUCompareFunction_NotEqual;break;default:error("WebGPUPipelineUtils: Invalid depth function.",depthFunc)}}return depthCompare}}class WebGPUTimestampQueryPool extends TimestampQueryPool{constructor(device,type,maxQueries=2048){super(maxQueries),this.device=device,this.type=type,this.querySet=this.device.createQuerySet({type:"timestamp",count:this.maxQueries,label:`queryset_global_timestamp_${type}`});const bufferSize=8*this.maxQueries;this.resolveBuffer=this.device.createBuffer({label:`buffer_timestamp_resolve_${type}`,size:bufferSize,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.resultBuffer=this.device.createBuffer({label:`buffer_timestamp_result_${type}`,size:bufferSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ})}allocateQueriesForContext(uid){if(!this.trackTimestamp||this.isDisposed)return null;if(this.currentQueryIndex+2>this.maxQueries)return warnOnce(`WebGPUTimestampQueryPool [${this.type}]: Maximum number of queries exceeded, when using trackTimestamp it is necessary to resolves the queries via renderer.resolveTimestampsAsync( THREE.TimestampQuery.${this.type.toUpperCase()} ).`),null;const baseOffset=this.currentQueryIndex;return this.currentQueryIndex+=2,this.queryOffsets.set(uid,baseOffset),baseOffset}async resolveQueriesAsync(){if(!this.trackTimestamp||0===this.currentQueryIndex||this.isDisposed)return this.lastValue;if(this.pendingResolve)return this.pendingResolve;this.pendingResolve=this._resolveQueries();try{return await this.pendingResolve}finally{this.pendingResolve=null}}async _resolveQueries(){if(this.isDisposed)return this.lastValue;try{if("unmapped"!==this.resultBuffer.mapState)return this.lastValue;const currentOffsets=new Map(this.queryOffsets),queryCount=this.currentQueryIndex,bytesUsed=8*queryCount;this.currentQueryIndex=0,this.queryOffsets.clear();const commandEncoder=this.device.createCommandEncoder();commandEncoder.resolveQuerySet(this.querySet,0,queryCount,this.resolveBuffer,0),commandEncoder.copyBufferToBuffer(this.resolveBuffer,0,this.resultBuffer,0,bytesUsed);const commandBuffer=commandEncoder.finish();if(this.device.queue.submit([commandBuffer]),"unmapped"!==this.resultBuffer.mapState)return this.lastValue;if(await this.resultBuffer.mapAsync(GPUMapMode.READ,0,bytesUsed),this.isDisposed)return"mapped"===this.resultBuffer.mapState&&this.resultBuffer.unmap(),this.lastValue;const times=new BigUint64Array(this.resultBuffer.getMappedRange(0,bytesUsed)),framesDuration={},frames=[];for(const[uid,baseOffset]of currentOffsets){const match=uid.match(/^(.*):f(\d+)$/),frame=parseInt(match[2]);!1===frames.includes(frame)&&frames.push(frame),void 0===framesDuration[frame]&&(framesDuration[frame]=0);const startTime=times[baseOffset],endTime=times[baseOffset+1],duration=Number(endTime-startTime)/1e6;this.timestamps.set(uid,duration),framesDuration[frame]+=duration}const totalDuration=framesDuration[frames[frames.length-1]];return this.resultBuffer.unmap(),this.lastValue=totalDuration,this.frames=frames,totalDuration}catch(e){return error("Error resolving queries:",e),"mapped"===this.resultBuffer.mapState&&this.resultBuffer.unmap(),this.lastValue}}async dispose(){if(!this.isDisposed){if(this.isDisposed=!0,this.pendingResolve)try{await this.pendingResolve}catch(e){error("Error waiting for pending resolve:",e)}if(this.resultBuffer&&"mapped"===this.resultBuffer.mapState)try{this.resultBuffer.unmap()}catch(e){error("Error unmapping buffer:",e)}this.querySet&&(this.querySet.destroy(),this.querySet=null),this.resolveBuffer&&(this.resolveBuffer.destroy(),this.resolveBuffer=null),this.resultBuffer&&(this.resultBuffer.destroy(),this.resultBuffer=null),this.queryOffsets.clear(),this.pendingResolve=null}}}class WebGPUBackend extends Backend{constructor(parameters={}){super(parameters),this.isWebGPUBackend=!0,this.parameters.alpha=void 0===parameters.alpha||parameters.alpha,this.parameters.requiredLimits=void 0===parameters.requiredLimits?{}:parameters.requiredLimits,this.compatibilityMode=null,this.device=null,this.defaultRenderPassdescriptor=null,this.utils=new WebGPUUtils(this),this.attributeUtils=new WebGPUAttributeUtils(this),this.bindingUtils=new WebGPUBindingUtils(this),this.pipelineUtils=new WebGPUPipelineUtils(this),this.textureUtils=new WebGPUTextureUtils(this),this.occludedResolveCache=new Map;const compatibilityTextureCompare="undefined"==typeof navigator||!1===/Android/.test(navigator.userAgent);this._compatibility={[Compatibility_TEXTURE_COMPARE]:compatibilityTextureCompare}}async init(renderer){await super.init(renderer);const parameters=this.parameters;let device;if(void 0===parameters.device){const adapterOptions={powerPreference:parameters.powerPreference,featureLevel:"compatibility"},adapter="undefined"!=typeof navigator?await navigator.gpu.requestAdapter(adapterOptions):null;if(null===adapter)throw new Error("WebGPUBackend: Unable to create WebGPU adapter.");const features=Object.values(GPUFeatureName),supportedFeatures=[];for(const name of features)adapter.features.has(name)&&supportedFeatures.push(name);const deviceDescriptor={requiredFeatures:supportedFeatures,requiredLimits:parameters.requiredLimits};device=await adapter.requestDevice(deviceDescriptor)}else device=parameters.device;this.compatibilityMode=!device.features.has("core-features-and-limits"),this.compatibilityMode&&(renderer._samples=0),device.lost.then(info=>{if("destroyed"===info.reason)return;const deviceLossInfo={api:"WebGPU",message:info.message||"Unknown reason",reason:info.reason||null,originalEvent:info};renderer.onDeviceLost(deviceLossInfo)}),this.device=device,this.trackTimestamp=this.trackTimestamp&&this.hasFeature(GPUFeatureName.TimestampQuery),this.updateSize()}get context(){const canvasTarget=this.renderer.getCanvasTarget(),canvasData=this.get(canvasTarget);let context=canvasData.context;if(void 0===context){const parameters=this.parameters;context=!0===canvasTarget.isDefaultCanvasTarget&&void 0!==parameters.context?parameters.context:canvasTarget.domElement.getContext("webgpu"),"setAttribute"in canvasTarget.domElement&&canvasTarget.domElement.setAttribute("data-engine","three.js r183dev webgpu");const alphaMode=parameters.alpha?"premultiplied":"opaque",toneMappingMode=parameters.outputType===HalfFloatType?"extended":"standard";context.configure({device:this.device,format:this.utils.getPreferredCanvasFormat(),usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC,alphaMode:alphaMode,toneMapping:{mode:toneMappingMode}}),canvasData.context=context}return context}get coordinateSystem(){return 2001}async getArrayBufferAsync(attribute){return await this.attributeUtils.getArrayBufferAsync(attribute)}getContext(){return this.context}_getDefaultRenderPassDescriptor(){const renderer=this.renderer,canvasTarget=renderer.getCanvasTarget(),canvasData=this.get(canvasTarget),samples=renderer.currentSamples;let descriptor=canvasData.descriptor;if(void 0===descriptor||canvasData.samples!==samples){descriptor={colorAttachments:[{view:null}]},!0!==renderer.depth&&!0!==renderer.stencil||(descriptor.depthStencilAttachment={view:this.textureUtils.getDepthBuffer(renderer.depth,renderer.stencil).createView()});const colorAttachment=descriptor.colorAttachments[0];samples>0?colorAttachment.view=this.textureUtils.getColorBuffer().createView():colorAttachment.resolveTarget=void 0,canvasData.descriptor=descriptor,canvasData.samples=samples}const colorAttachment=descriptor.colorAttachments[0];return samples>0?colorAttachment.resolveTarget=this.context.getCurrentTexture().createView():colorAttachment.view=this.context.getCurrentTexture().createView(),descriptor}_isRenderCameraDepthArray(renderContext){return renderContext.depthTexture&&renderContext.depthTexture.image.depth>1&&renderContext.camera.isArrayCamera}_getRenderPassDescriptor(renderContext,colorAttachmentsConfig={}){const renderTarget=renderContext.renderTarget,renderTargetData=this.get(renderTarget);let descriptors=renderTargetData.descriptors;void 0!==descriptors&&renderTargetData.width===renderTarget.width&&renderTargetData.height===renderTarget.height&&renderTargetData.samples===renderTarget.samples||(descriptors={},renderTargetData.descriptors=descriptors);const cacheKey=renderContext.getCacheKey();let descriptorBase=descriptors[cacheKey];if(void 0===descriptorBase){const textures=renderContext.textures,textureViews=[];let sliceIndex;const isRenderCameraDepthArray=this._isRenderCameraDepthArray(renderContext);for(let i=0;i<textures.length;i++){const textureData=this.get(textures[i]),viewDescriptor={label:`colorAttachment_${i}`,baseMipLevel:renderContext.activeMipmapLevel,mipLevelCount:1,baseArrayLayer:renderContext.activeCubeFace,arrayLayerCount:1,dimension:GPUTextureViewDimension_TwoD};if(renderTarget.isRenderTarget3D)sliceIndex=renderContext.activeCubeFace,viewDescriptor.baseArrayLayer=0,viewDescriptor.dimension=GPUTextureViewDimension_ThreeD,viewDescriptor.depthOrArrayLayers=textures[i].image.depth;else if(renderTarget.isRenderTarget&&textures[i].image.depth>1)if(!0===isRenderCameraDepthArray){const cameras=renderContext.camera.cameras;for(let layer=0;layer<cameras.length;layer++){const layerViewDescriptor={...viewDescriptor,baseArrayLayer:layer,arrayLayerCount:1,dimension:GPUTextureViewDimension_TwoD},textureView=textureData.texture.createView(layerViewDescriptor);textureViews.push({view:textureView,resolveTarget:void 0,depthSlice:void 0})}}else viewDescriptor.dimension=GPUTextureViewDimension_TwoDArray,viewDescriptor.depthOrArrayLayers=textures[i].image.depth;if(!0!==isRenderCameraDepthArray){const textureView=textureData.texture.createView(viewDescriptor);let view,resolveTarget;void 0!==textureData.msaaTexture?(view=textureData.msaaTexture.createView(),resolveTarget=textureView):(view=textureView,resolveTarget=void 0),textureViews.push({view:view,resolveTarget:resolveTarget,depthSlice:sliceIndex})}}if(descriptorBase={textureViews:textureViews},renderContext.depth){const depthTextureData=this.get(renderContext.depthTexture),options={};(renderContext.depthTexture.isArrayTexture||renderContext.depthTexture.isCubeTexture)&&(options.dimension=GPUTextureViewDimension_TwoD,options.arrayLayerCount=1,options.baseArrayLayer=renderContext.activeCubeFace),descriptorBase.depthStencilView=depthTextureData.texture.createView(options)}descriptors[cacheKey]=descriptorBase,renderTargetData.width=renderTarget.width,renderTargetData.height=renderTarget.height,renderTargetData.samples=renderTarget.samples,renderTargetData.activeMipmapLevel=renderContext.activeMipmapLevel,renderTargetData.activeCubeFace=renderContext.activeCubeFace}const descriptor={colorAttachments:[]};for(let i=0;i<descriptorBase.textureViews.length;i++){const viewInfo=descriptorBase.textureViews[i];let clearValue={r:0,g:0,b:0,a:1};0===i&&colorAttachmentsConfig.clearValue&&(clearValue=colorAttachmentsConfig.clearValue),descriptor.colorAttachments.push({view:viewInfo.view,depthSlice:viewInfo.depthSlice,resolveTarget:viewInfo.resolveTarget,loadOp:colorAttachmentsConfig.loadOp||GPULoadOp_Load,storeOp:colorAttachmentsConfig.storeOp||GPUStoreOp_Store,clearValue:clearValue})}return descriptorBase.depthStencilView&&(descriptor.depthStencilAttachment={view:descriptorBase.depthStencilView}),descriptor}beginRender(renderContext){const renderContextData=this.get(renderContext),device=this.device,occlusionQueryCount=renderContext.occlusionQueryCount;let occlusionQuerySet,descriptor;occlusionQueryCount>0&&(renderContextData.currentOcclusionQuerySet&&renderContextData.currentOcclusionQuerySet.destroy(),renderContextData.currentOcclusionQueryBuffer&&renderContextData.currentOcclusionQueryBuffer.destroy(),renderContextData.currentOcclusionQuerySet=renderContextData.occlusionQuerySet,renderContextData.currentOcclusionQueryBuffer=renderContextData.occlusionQueryBuffer,renderContextData.currentOcclusionQueryObjects=renderContextData.occlusionQueryObjects,occlusionQuerySet=device.createQuerySet({type:"occlusion",count:occlusionQueryCount,label:`occlusionQuerySet_${renderContext.id}`}),renderContextData.occlusionQuerySet=occlusionQuerySet,renderContextData.occlusionQueryIndex=0,renderContextData.occlusionQueryObjects=new Array(occlusionQueryCount),renderContextData.lastOcclusionObject=null),descriptor=null===renderContext.textures?this._getDefaultRenderPassDescriptor():this._getRenderPassDescriptor(renderContext,{loadOp:GPULoadOp_Load}),this.initTimestampQuery(TimestampQuery_RENDER,this.getTimestampUID(renderContext),descriptor),descriptor.occlusionQuerySet=occlusionQuerySet;const depthStencilAttachment=descriptor.depthStencilAttachment;if(null!==renderContext.textures){const colorAttachments=descriptor.colorAttachments;for(let i=0;i<colorAttachments.length;i++){const colorAttachment=colorAttachments[i];renderContext.clearColor?(colorAttachment.clearValue=0===i?renderContext.clearColorValue:{r:0,g:0,b:0,a:1},colorAttachment.loadOp=GPULoadOp_Clear):colorAttachment.loadOp=GPULoadOp_Load,colorAttachment.storeOp=GPUStoreOp_Store}}else{const colorAttachment=descriptor.colorAttachments[0];renderContext.clearColor?(colorAttachment.clearValue=renderContext.clearColorValue,colorAttachment.loadOp=GPULoadOp_Clear):colorAttachment.loadOp=GPULoadOp_Load,colorAttachment.storeOp=GPUStoreOp_Store}renderContext.depth&&(renderContext.clearDepth?(depthStencilAttachment.depthClearValue=renderContext.clearDepthValue,depthStencilAttachment.depthLoadOp=GPULoadOp_Clear):depthStencilAttachment.depthLoadOp=GPULoadOp_Load,depthStencilAttachment.depthStoreOp=GPUStoreOp_Store),renderContext.stencil&&(renderContext.clearStencil?(depthStencilAttachment.stencilClearValue=renderContext.clearStencilValue,depthStencilAttachment.stencilLoadOp=GPULoadOp_Clear):depthStencilAttachment.stencilLoadOp=GPULoadOp_Load,depthStencilAttachment.stencilStoreOp=GPUStoreOp_Store);const encoder=device.createCommandEncoder({label:"renderContext_"+renderContext.id});if(!0===this._isRenderCameraDepthArray(renderContext)){const cameras=renderContext.camera.cameras;renderContextData.layerDescriptors&&renderContextData.layerDescriptors.length===cameras.length?this._updateDepthLayerDescriptors(renderContext,renderContextData,cameras):this._createDepthLayerDescriptors(renderContext,renderContextData,descriptor,cameras),renderContextData.bundleEncoders=[],renderContextData.bundleSets=[];for(let i=0;i<cameras.length;i++){const bundleEncoder=this.pipelineUtils.createBundleEncoder(renderContext,"renderBundleArrayCamera_"+i),bundleSets={attributes:{},bindingGroups:[],pipeline:null,index:null};renderContextData.bundleEncoders.push(bundleEncoder),renderContextData.bundleSets.push(bundleSets)}renderContextData.currentPass=null}else{const currentPass=encoder.beginRenderPass(descriptor);renderContextData.currentPass=currentPass,renderContext.viewport&&this.updateViewport(renderContext),renderContext.scissor&&this.updateScissor(renderContext)}renderContextData.descriptor=descriptor,renderContextData.encoder=encoder,renderContextData.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},renderContextData.renderBundles=[]}_createDepthLayerDescriptors(renderContext,renderContextData,descriptor,cameras){const depthStencilAttachment=descriptor.depthStencilAttachment;renderContextData.layerDescriptors=[];const depthTextureData=this.get(renderContext.depthTexture);depthTextureData.viewCache||(depthTextureData.viewCache=[]);for(let i=0;i<cameras.length;i++){const layerDescriptor={...descriptor,colorAttachments:[{...descriptor.colorAttachments[0],view:descriptor.colorAttachments[i].view}]};if(descriptor.depthStencilAttachment){const layerIndex=i;depthTextureData.viewCache[layerIndex]||(depthTextureData.viewCache[layerIndex]=depthTextureData.texture.createView({dimension:GPUTextureViewDimension_TwoD,baseArrayLayer:i,arrayLayerCount:1})),layerDescriptor.depthStencilAttachment={view:depthTextureData.viewCache[layerIndex],depthLoadOp:depthStencilAttachment.depthLoadOp||GPULoadOp_Clear,depthStoreOp:depthStencilAttachment.depthStoreOp||GPUStoreOp_Store,depthClearValue:depthStencilAttachment.depthClearValue||1},renderContext.stencil&&(layerDescriptor.depthStencilAttachment.stencilLoadOp=depthStencilAttachment.stencilLoadOp,layerDescriptor.depthStencilAttachment.stencilStoreOp=depthStencilAttachment.stencilStoreOp,layerDescriptor.depthStencilAttachment.stencilClearValue=depthStencilAttachment.stencilClearValue)}else layerDescriptor.depthStencilAttachment={...depthStencilAttachment};renderContextData.layerDescriptors.push(layerDescriptor)}}_updateDepthLayerDescriptors(renderContext,renderContextData,cameras){for(let i=0;i<cameras.length;i++){const layerDescriptor=renderContextData.layerDescriptors[i];if(layerDescriptor.depthStencilAttachment){const depthAttachment=layerDescriptor.depthStencilAttachment;renderContext.depth&&(renderContext.clearDepth?(depthAttachment.depthClearValue=renderContext.clearDepthValue,depthAttachment.depthLoadOp=GPULoadOp_Clear):depthAttachment.depthLoadOp=GPULoadOp_Load),renderContext.stencil&&(renderContext.clearStencil?(depthAttachment.stencilClearValue=renderContext.clearStencilValue,depthAttachment.stencilLoadOp=GPULoadOp_Clear):depthAttachment.stencilLoadOp=GPULoadOp_Load)}}}finishRender(renderContext){const renderContextData=this.get(renderContext),occlusionQueryCount=renderContext.occlusionQueryCount;renderContextData.renderBundles.length>0&&renderContextData.currentPass.executeBundles(renderContextData.renderBundles),occlusionQueryCount>renderContextData.occlusionQueryIndex&&renderContextData.currentPass.endOcclusionQuery();const encoder=renderContextData.encoder;if(!0===this._isRenderCameraDepthArray(renderContext)){const bundles=[];for(let i=0;i<renderContextData.bundleEncoders.length;i++){const bundleEncoder=renderContextData.bundleEncoders[i];bundles.push(bundleEncoder.finish())}for(let i=0;i<renderContextData.layerDescriptors.length;i++)if(i<bundles.length){const layerDescriptor=renderContextData.layerDescriptors[i],renderPass=encoder.beginRenderPass(layerDescriptor);if(renderContext.viewport){const{x:x,y:y,width:width,height:height,minDepth:minDepth,maxDepth:maxDepth}=renderContext.viewportValue;renderPass.setViewport(x,y,width,height,minDepth,maxDepth)}if(renderContext.scissor){const{x:x,y:y,width:width,height:height}=renderContext.scissorValue;renderPass.setScissorRect(x,y,width,height)}renderPass.executeBundles([bundles[i]]),renderPass.end()}}else renderContextData.currentPass&&renderContextData.currentPass.end();if(occlusionQueryCount>0){const bufferSize=8*occlusionQueryCount;let queryResolveBuffer=this.occludedResolveCache.get(bufferSize);void 0===queryResolveBuffer&&(queryResolveBuffer=this.device.createBuffer({size:bufferSize,usage:GPUBufferUsage.QUERY_RESOLVE|GPUBufferUsage.COPY_SRC}),this.occludedResolveCache.set(bufferSize,queryResolveBuffer));const readBuffer=this.device.createBuffer({size:bufferSize,usage:GPUBufferUsage.COPY_DST|GPUBufferUsage.MAP_READ});renderContextData.encoder.resolveQuerySet(renderContextData.occlusionQuerySet,0,occlusionQueryCount,queryResolveBuffer,0),renderContextData.encoder.copyBufferToBuffer(queryResolveBuffer,0,readBuffer,0,bufferSize),renderContextData.occlusionQueryBuffer=readBuffer,this.resolveOccludedAsync(renderContext)}if(this.device.queue.submit([renderContextData.encoder.finish()]),null!==renderContext.textures){const textures=renderContext.textures;for(let i=0;i<textures.length;i++){const texture=textures[i];!0===texture.generateMipmaps&&this.textureUtils.generateMipmaps(texture)}}}isOccluded(renderContext,object){const renderContextData=this.get(renderContext);return renderContextData.occluded&&renderContextData.occluded.has(object)}async resolveOccludedAsync(renderContext){const renderContextData=this.get(renderContext),{currentOcclusionQueryBuffer:currentOcclusionQueryBuffer,currentOcclusionQueryObjects:currentOcclusionQueryObjects}=renderContextData;if(currentOcclusionQueryBuffer&&currentOcclusionQueryObjects){const occluded=new WeakSet;renderContextData.currentOcclusionQueryObjects=null,renderContextData.currentOcclusionQueryBuffer=null,await currentOcclusionQueryBuffer.mapAsync(GPUMapMode.READ);const buffer=currentOcclusionQueryBuffer.getMappedRange(),results=new BigUint64Array(buffer);for(let i=0;i<currentOcclusionQueryObjects.length;i++)results[i]===BigInt(0)&&occluded.add(currentOcclusionQueryObjects[i]);currentOcclusionQueryBuffer.destroy(),renderContextData.occluded=occluded}}updateViewport(renderContext){const{currentPass:currentPass}=this.get(renderContext),{x:x,y:y,width:width,height:height,minDepth:minDepth,maxDepth:maxDepth}=renderContext.viewportValue;currentPass.setViewport(x,y,width,height,minDepth,maxDepth)}updateScissor(renderContext){const{currentPass:currentPass}=this.get(renderContext),{x:x,y:y,width:width,height:height}=renderContext.scissorValue;currentPass.setScissorRect(x,y,width,height)}getClearColor(){const clearColor=super.getClearColor();return!0===this.renderer.alpha&&(clearColor.r*=clearColor.a,clearColor.g*=clearColor.a,clearColor.b*=clearColor.a),clearColor}clear(color,depth,stencil,renderTargetContext=null){const device=this.device,renderer=this.renderer;let depthStencilAttachment,clearValue,supportsDepth,supportsStencil,colorAttachments=[];if(color){const clearColor=this.getClearColor();clearValue={r:clearColor.r,g:clearColor.g,b:clearColor.b,a:clearColor.a}}if(null===renderTargetContext){supportsDepth=renderer.depth,supportsStencil=renderer.stencil;const descriptor=this._getDefaultRenderPassDescriptor();if(color){colorAttachments=descriptor.colorAttachments;const colorAttachment=colorAttachments[0];colorAttachment.clearValue=clearValue,colorAttachment.loadOp=GPULoadOp_Clear,colorAttachment.storeOp=GPUStoreOp_Store}(supportsDepth||supportsStencil)&&(depthStencilAttachment=descriptor.depthStencilAttachment)}else{supportsDepth=renderTargetContext.depth,supportsStencil=renderTargetContext.stencil;const clearConfig={loadOp:color?GPULoadOp_Clear:GPULoadOp_Load,clearValue:color?clearValue:void 0};supportsDepth&&(clearConfig.depthLoadOp=depth?GPULoadOp_Clear:GPULoadOp_Load,clearConfig.depthClearValue=depth?renderer.getClearDepth():void 0,clearConfig.depthStoreOp=GPUStoreOp_Store),supportsStencil&&(clearConfig.stencilLoadOp=stencil?GPULoadOp_Clear:GPULoadOp_Load,clearConfig.stencilClearValue=stencil?renderer.getClearStencil():void 0,clearConfig.stencilStoreOp=GPUStoreOp_Store);const descriptor=this._getRenderPassDescriptor(renderTargetContext,clearConfig);colorAttachments=descriptor.colorAttachments,depthStencilAttachment=descriptor.depthStencilAttachment}supportsDepth&&depthStencilAttachment&&(depth?(depthStencilAttachment.depthLoadOp=GPULoadOp_Clear,depthStencilAttachment.depthClearValue=renderer.getClearDepth(),depthStencilAttachment.depthStoreOp=GPUStoreOp_Store):(depthStencilAttachment.depthLoadOp=GPULoadOp_Load,depthStencilAttachment.depthStoreOp=GPUStoreOp_Store)),supportsStencil&&depthStencilAttachment&&(stencil?(depthStencilAttachment.stencilLoadOp=GPULoadOp_Clear,depthStencilAttachment.stencilClearValue=renderer.getClearStencil(),depthStencilAttachment.stencilStoreOp=GPUStoreOp_Store):(depthStencilAttachment.stencilLoadOp=GPULoadOp_Load,depthStencilAttachment.stencilStoreOp=GPUStoreOp_Store));const encoder=device.createCommandEncoder({label:"clear"});encoder.beginRenderPass({colorAttachments:colorAttachments,depthStencilAttachment:depthStencilAttachment}).end(),device.queue.submit([encoder.finish()])}beginCompute(computeGroup){const groupGPU=this.get(computeGroup),descriptor={label:"computeGroup_"+computeGroup.id};this.initTimestampQuery(TimestampQuery_COMPUTE,this.getTimestampUID(computeGroup),descriptor),groupGPU.cmdEncoderGPU=this.device.createCommandEncoder({label:"computeGroup_"+computeGroup.id}),groupGPU.passEncoderGPU=groupGPU.cmdEncoderGPU.beginComputePass(descriptor)}compute(computeGroup,computeNode,bindings,pipeline,dispatchSize=null){const computeNodeData=this.get(computeNode),{passEncoderGPU:passEncoderGPU}=this.get(computeGroup),pipelineGPU=this.get(pipeline).pipeline;this.pipelineUtils.setPipeline(passEncoderGPU,pipelineGPU);for(let i=0,l=bindings.length;i<l;i++){const bindGroup=bindings[i],bindingsData=this.get(bindGroup);passEncoderGPU.setBindGroup(i,bindingsData.group)}if(null===dispatchSize&&(dispatchSize=computeNode.count),dispatchSize&&"object"==typeof dispatchSize&&dispatchSize.isIndirectStorageBufferAttribute){const dispatchBuffer=this.get(dispatchSize).buffer;return void passEncoderGPU.dispatchWorkgroupsIndirect(dispatchBuffer,0)}if("number"==typeof dispatchSize){const count=dispatchSize;if(void 0===computeNodeData.dispatchSize||computeNodeData.count!==count){computeNodeData.dispatchSize=[0,1,1],computeNodeData.count=count;const workgroupSize=computeNode.workgroupSize;let size=workgroupSize[0];for(let i=1;i<workgroupSize.length;i++)size*=workgroupSize[i];const dispatchCount=Math.ceil(count/size),maxComputeWorkgroupsPerDimension=this.device.limits.maxComputeWorkgroupsPerDimension;dispatchSize=[dispatchCount,1,1],dispatchCount>maxComputeWorkgroupsPerDimension&&(dispatchSize[0]=Math.min(dispatchCount,maxComputeWorkgroupsPerDimension),dispatchSize[1]=Math.ceil(dispatchCount/maxComputeWorkgroupsPerDimension)),computeNodeData.dispatchSize=dispatchSize}dispatchSize=computeNodeData.dispatchSize}passEncoderGPU.dispatchWorkgroups(dispatchSize[0],dispatchSize[1]||1,dispatchSize[2]||1)}finishCompute(computeGroup){const groupData=this.get(computeGroup);groupData.passEncoderGPU.end(),this.device.queue.submit([groupData.cmdEncoderGPU.finish()])}draw(renderObject,info){const{object:object,material:material,context:context,pipeline:pipeline}=renderObject,bindings=renderObject.getBindings(),renderContextData=this.get(context),pipelineData=this.get(pipeline),pipelineGPU=pipelineData.pipeline;if(!0===pipelineData.error)return;const index=renderObject.getIndex(),hasIndex=null!==index,drawParams=renderObject.getDrawParameters();if(null===drawParams)return;const setPipelineAndBindings=(passEncoderGPU,currentSets)=>{this.pipelineUtils.setPipeline(passEncoderGPU,pipelineGPU),currentSets.pipeline=pipelineGPU;const currentBindingGroups=currentSets.bindingGroups;for(let i=0,l=bindings.length;i<l;i++){const bindGroup=bindings[i],bindingsData=this.get(bindGroup);currentBindingGroups[bindGroup.index]!==bindGroup.id&&(passEncoderGPU.setBindGroup(bindGroup.index,bindingsData.group),currentBindingGroups[bindGroup.index]=bindGroup.id)}if(!0===hasIndex&&currentSets.index!==index){const buffer=this.get(index).buffer,indexFormat=index.array instanceof Uint16Array?GPUIndexFormat_Uint16:GPUIndexFormat_Uint32;passEncoderGPU.setIndexBuffer(buffer,indexFormat),currentSets.index=index}const vertexBuffers=renderObject.getVertexBuffers();for(let i=0,l=vertexBuffers.length;i<l;i++){const vertexBuffer=vertexBuffers[i];if(currentSets.attributes[i]!==vertexBuffer){const buffer=this.get(vertexBuffer).buffer;passEncoderGPU.setVertexBuffer(i,buffer),currentSets.attributes[i]=vertexBuffer}}!0===context.stencil&&!0===material.stencilWrite&&renderContextData.currentStencilRef!==material.stencilRef&&(passEncoderGPU.setStencilReference(material.stencilRef),renderContextData.currentStencilRef=material.stencilRef)},draw=(passEncoderGPU,currentSets)=>{if(setPipelineAndBindings(passEncoderGPU,currentSets),!0===object.isBatchedMesh){const starts=object._multiDrawStarts,counts=object._multiDrawCounts,drawCount=object._multiDrawCount,drawInstances=object._multiDrawInstances;null!==drawInstances&&warnOnce("WebGPUBackend: renderMultiDrawInstances has been deprecated and will be removed in r184. Append to renderMultiDraw arguments and use indirection.");let bytesPerElement=!0===hasIndex?index.array.BYTES_PER_ELEMENT:1;material.wireframe&&(bytesPerElement=object.geometry.attributes.position.count>65535?4:2);for(let i=0;i<drawCount;i++){const count=drawInstances?drawInstances[i]:1,firstInstance=count>1?0:i;!0===hasIndex?passEncoderGPU.drawIndexed(counts[i],count,starts[i]/bytesPerElement,0,firstInstance):passEncoderGPU.draw(counts[i],count,starts[i],firstInstance),info.update(object,counts[i],count)}}else if(!0===hasIndex){const{vertexCount:indexCount,instanceCount:instanceCount,firstVertex:firstIndex}=drawParams,indirect=renderObject.getIndirect();if(null!==indirect){const buffer=this.get(indirect).buffer,indirectOffset=renderObject.getIndirectOffset(),indirectOffsets=Array.isArray(indirectOffset)?indirectOffset:[indirectOffset];for(let i=0;i<indirectOffsets.length;i++)passEncoderGPU.drawIndexedIndirect(buffer,indirectOffsets[i])}else passEncoderGPU.drawIndexed(indexCount,instanceCount,firstIndex,0,0);info.update(object,indexCount,instanceCount)}else{const{vertexCount:vertexCount,instanceCount:instanceCount,firstVertex:firstVertex}=drawParams,indirect=renderObject.getIndirect();if(null!==indirect){const buffer=this.get(indirect).buffer,indirectOffset=renderObject.getIndirectOffset(),indirectOffsets=Array.isArray(indirectOffset)?indirectOffset:[indirectOffset];for(let i=0;i<indirectOffsets.length;i++)passEncoderGPU.drawIndirect(buffer,indirectOffsets[i])}else passEncoderGPU.draw(vertexCount,instanceCount,firstVertex,0);info.update(object,vertexCount,instanceCount)}};if(renderObject.camera.isArrayCamera&&renderObject.camera.cameras.length>0){const cameraData=this.get(renderObject.camera),cameras=renderObject.camera.cameras,cameraIndex=renderObject.getBindingGroup("cameraIndex");if(void 0===cameraData.indexesGPU||cameraData.indexesGPU.length!==cameras.length){const bindingsData=this.get(cameraIndex),indexesGPU=[],data=new Uint32Array([0,0,0,0]);for(let i=0,len=cameras.length;i<len;i++){data[0]=i;const{layoutGPU:layoutGPU}=bindingsData.layout,bindGroupIndex=this.bindingUtils.createBindGroupIndex(data,layoutGPU);indexesGPU.push(bindGroupIndex)}cameraData.indexesGPU=indexesGPU}const pixelRatio=this.renderer.getPixelRatio();for(let i=0,len=cameras.length;i<len;i++){const subCamera=cameras[i];if(object.layers.test(subCamera.layers)){const vp=subCamera.viewport;let pass=renderContextData.currentPass,sets=renderContextData.currentSets;if(renderContextData.bundleEncoders){pass=renderContextData.bundleEncoders[i],sets=renderContextData.bundleSets[i]}vp&&pass.setViewport(Math.floor(vp.x*pixelRatio),Math.floor(vp.y*pixelRatio),Math.floor(vp.width*pixelRatio),Math.floor(vp.height*pixelRatio),context.viewportValue.minDepth,context.viewportValue.maxDepth),cameraIndex&&cameraData.indexesGPU&&(pass.setBindGroup(cameraIndex.index,cameraData.indexesGPU[i]),sets.bindingGroups[cameraIndex.index]=cameraIndex.id),draw(pass,sets)}}}else if(renderContextData.currentPass){if(void 0!==renderContextData.occlusionQuerySet){const lastObject=renderContextData.lastOcclusionObject;lastObject!==object&&(null!==lastObject&&!0===lastObject.occlusionTest&&(renderContextData.currentPass.endOcclusionQuery(),renderContextData.occlusionQueryIndex++),!0===object.occlusionTest&&(renderContextData.currentPass.beginOcclusionQuery(renderContextData.occlusionQueryIndex),renderContextData.occlusionQueryObjects[renderContextData.occlusionQueryIndex]=object),renderContextData.lastOcclusionObject=object)}draw(renderContextData.currentPass,renderContextData.currentSets)}}needsRenderUpdate(renderObject){const data=this.get(renderObject),{object:object,material:material}=renderObject,utils=this.utils,sampleCount=utils.getSampleCountRenderContext(renderObject.context),colorSpace=utils.getCurrentColorSpace(renderObject.context),colorFormat=utils.getCurrentColorFormat(renderObject.context),depthStencilFormat=utils.getCurrentDepthStencilFormat(renderObject.context),primitiveTopology=utils.getPrimitiveTopology(object,material);let needsUpdate=!1;return data.material===material&&data.materialVersion===material.version&&data.transparent===material.transparent&&data.blending===material.blending&&data.premultipliedAlpha===material.premultipliedAlpha&&data.blendSrc===material.blendSrc&&data.blendDst===material.blendDst&&data.blendEquation===material.blendEquation&&data.blendSrcAlpha===material.blendSrcAlpha&&data.blendDstAlpha===material.blendDstAlpha&&data.blendEquationAlpha===material.blendEquationAlpha&&data.colorWrite===material.colorWrite&&data.depthWrite===material.depthWrite&&data.depthTest===material.depthTest&&data.depthFunc===material.depthFunc&&data.stencilWrite===material.stencilWrite&&data.stencilFunc===material.stencilFunc&&data.stencilFail===material.stencilFail&&data.stencilZFail===material.stencilZFail&&data.stencilZPass===material.stencilZPass&&data.stencilFuncMask===material.stencilFuncMask&&data.stencilWriteMask===material.stencilWriteMask&&data.side===material.side&&data.alphaToCoverage===material.alphaToCoverage&&data.sampleCount===sampleCount&&data.colorSpace===colorSpace&&data.colorFormat===colorFormat&&data.depthStencilFormat===depthStencilFormat&&data.primitiveTopology===primitiveTopology&&data.clippingContextCacheKey===renderObject.clippingContextCacheKey||(data.material=material,data.materialVersion=material.version,data.transparent=material.transparent,data.blending=material.blending,data.premultipliedAlpha=material.premultipliedAlpha,data.blendSrc=material.blendSrc,data.blendDst=material.blendDst,data.blendEquation=material.blendEquation,data.blendSrcAlpha=material.blendSrcAlpha,data.blendDstAlpha=material.blendDstAlpha,data.blendEquationAlpha=material.blendEquationAlpha,data.colorWrite=material.colorWrite,data.depthWrite=material.depthWrite,data.depthTest=material.depthTest,data.depthFunc=material.depthFunc,data.stencilWrite=material.stencilWrite,data.stencilFunc=material.stencilFunc,data.stencilFail=material.stencilFail,data.stencilZFail=material.stencilZFail,data.stencilZPass=material.stencilZPass,data.stencilFuncMask=material.stencilFuncMask,data.stencilWriteMask=material.stencilWriteMask,data.side=material.side,data.alphaToCoverage=material.alphaToCoverage,data.sampleCount=sampleCount,data.colorSpace=colorSpace,data.colorFormat=colorFormat,data.depthStencilFormat=depthStencilFormat,data.primitiveTopology=primitiveTopology,data.clippingContextCacheKey=renderObject.clippingContextCacheKey,needsUpdate=!0),needsUpdate}getRenderCacheKey(renderObject){const{object:object,material:material}=renderObject,utils=this.utils,renderContext=renderObject.context,frontFaceCW=object.isMesh&&object.matrixWorld.determinant()<0;return[material.transparent,material.blending,material.premultipliedAlpha,material.blendSrc,material.blendDst,material.blendEquation,material.blendSrcAlpha,material.blendDstAlpha,material.blendEquationAlpha,material.colorWrite,material.depthWrite,material.depthTest,material.depthFunc,material.stencilWrite,material.stencilFunc,material.stencilFail,material.stencilZFail,material.stencilZPass,material.stencilFuncMask,material.stencilWriteMask,material.side,frontFaceCW,utils.getSampleCountRenderContext(renderContext),utils.getCurrentColorSpace(renderContext),utils.getCurrentColorFormat(renderContext),utils.getCurrentDepthStencilFormat(renderContext),utils.getPrimitiveTopology(object,material),renderObject.getGeometryCacheKey(),renderObject.clippingContextCacheKey].join()}updateSampler(texture){return this.textureUtils.updateSampler(texture)}createDefaultTexture(texture){return this.textureUtils.createDefaultTexture(texture)}createTexture(texture,options){this.textureUtils.createTexture(texture,options)}updateTexture(texture,options){this.textureUtils.updateTexture(texture,options)}generateMipmaps(texture){this.textureUtils.generateMipmaps(texture)}destroyTexture(texture,isDefaultTexture=!1){this.textureUtils.destroyTexture(texture,isDefaultTexture)}async copyTextureToBuffer(texture,x,y,width,height,faceIndex){return this.textureUtils.copyTextureToBuffer(texture,x,y,width,height,faceIndex)}initTimestampQuery(type,uid,descriptor){if(!this.trackTimestamp)return;this.timestampQueryPool[type]||(this.timestampQueryPool[type]=new WebGPUTimestampQueryPool(this.device,type,2048));const timestampQueryPool=this.timestampQueryPool[type],baseOffset=timestampQueryPool.allocateQueriesForContext(uid);descriptor.timestampWrites={querySet:timestampQueryPool.querySet,beginningOfPassWriteIndex:baseOffset,endOfPassWriteIndex:baseOffset+1}}createNodeBuilder(object,renderer){return new WGSLNodeBuilder(object,renderer)}createProgram(program){this.get(program).module={module:this.device.createShaderModule({code:program.code,label:program.stage+(""!==program.name?`_${program.name}`:"")}),entryPoint:"main"}}destroyProgram(program){this.delete(program)}createRenderPipeline(renderObject,promises){this.pipelineUtils.createRenderPipeline(renderObject,promises)}createComputePipeline(computePipeline,bindings){this.pipelineUtils.createComputePipeline(computePipeline,bindings)}beginBundle(renderContext){const renderContextData=this.get(renderContext);renderContextData._currentPass=renderContextData.currentPass,renderContextData._currentSets=renderContextData.currentSets,renderContextData.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},renderContextData.currentPass=this.pipelineUtils.createBundleEncoder(renderContext)}finishBundle(renderContext,bundle){const renderContextData=this.get(renderContext),bundleGPU=renderContextData.currentPass.finish();this.get(bundle).bundleGPU=bundleGPU,renderContextData.currentSets=renderContextData._currentSets,renderContextData.currentPass=renderContextData._currentPass}addBundle(renderContext,bundle){this.get(renderContext).renderBundles.push(this.get(bundle).bundleGPU)}createBindings(bindGroup,bindings,cacheIndex,version){this.bindingUtils.createBindings(bindGroup,bindings,cacheIndex,version)}updateBindings(bindGroup,bindings,cacheIndex,version){this.bindingUtils.createBindings(bindGroup,bindings,cacheIndex,version)}updateBinding(binding){this.bindingUtils.updateBinding(binding)}deleteBindGroupData(bindGroup){this.bindingUtils.deleteBindGroupData(bindGroup)}createIndexAttribute(attribute){let usage=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST;(attribute.isStorageBufferAttribute||attribute.isStorageInstancedBufferAttribute)&&(usage|=GPUBufferUsage.STORAGE),this.attributeUtils.createAttribute(attribute,usage)}createAttribute(attribute){this.attributeUtils.createAttribute(attribute,GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createStorageAttribute(attribute){this.attributeUtils.createAttribute(attribute,GPUBufferUsage.STORAGE|GPUBufferUsage.VERTEX|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}createIndirectStorageAttribute(attribute){this.attributeUtils.createAttribute(attribute,GPUBufferUsage.STORAGE|GPUBufferUsage.INDIRECT|GPUBufferUsage.COPY_SRC|GPUBufferUsage.COPY_DST)}updateAttribute(attribute){this.attributeUtils.updateAttribute(attribute)}destroyAttribute(attribute){this.attributeUtils.destroyAttribute(attribute)}updateSize(){this.delete(this.renderer.getCanvasTarget())}getMaxAnisotropy(){return 16}hasFeature(name){return void 0!==GPUFeatureMap[name]&&(name=GPUFeatureMap[name]),this.device.features.has(name)}copyTextureToTexture(srcTexture,dstTexture,srcRegion=null,dstPosition=null,srcLevel=0,dstLevel=0){let dstX=0,dstY=0,dstZ=0,srcX=0,srcY=0,srcZ=0,srcWidth=srcTexture.image.width,srcHeight=srcTexture.image.height,srcDepth=1;null!==srcRegion&&(!0===srcRegion.isBox3?(srcX=srcRegion.min.x,srcY=srcRegion.min.y,srcZ=srcRegion.min.z,srcWidth=srcRegion.max.x-srcRegion.min.x,srcHeight=srcRegion.max.y-srcRegion.min.y,srcDepth=srcRegion.max.z-srcRegion.min.z):(srcX=srcRegion.min.x,srcY=srcRegion.min.y,srcWidth=srcRegion.max.x-srcRegion.min.x,srcHeight=srcRegion.max.y-srcRegion.min.y,srcDepth=1)),null!==dstPosition&&(dstX=dstPosition.x,dstY=dstPosition.y,dstZ=dstPosition.z||0);const encoder=this.device.createCommandEncoder({label:"copyTextureToTexture_"+srcTexture.id+"_"+dstTexture.id}),sourceGPU=this.get(srcTexture).texture,destinationGPU=this.get(dstTexture).texture;encoder.copyTextureToTexture({texture:sourceGPU,mipLevel:srcLevel,origin:{x:srcX,y:srcY,z:srcZ}},{texture:destinationGPU,mipLevel:dstLevel,origin:{x:dstX,y:dstY,z:dstZ}},[srcWidth,srcHeight,srcDepth]),this.device.queue.submit([encoder.finish()]),0===dstLevel&&dstTexture.generateMipmaps&&this.textureUtils.generateMipmaps(dstTexture)}copyFramebufferToTexture(texture,renderContext,rectangle){const renderContextData=this.get(renderContext);let sourceGPU=null;sourceGPU=renderContext.renderTarget?texture.isDepthTexture?this.get(renderContext.depthTexture).texture:this.get(renderContext.textures[0]).texture:texture.isDepthTexture?this.textureUtils.getDepthBuffer(renderContext.depth,renderContext.stencil):this.context.getCurrentTexture();const destinationGPU=this.get(texture).texture;if(sourceGPU.format!==destinationGPU.format)return void error("WebGPUBackend: copyFramebufferToTexture: Source and destination formats do not match.",sourceGPU.format,destinationGPU.format);let encoder;if(renderContextData.currentPass?(renderContextData.currentPass.end(),encoder=renderContextData.encoder):encoder=this.device.createCommandEncoder({label:"copyFramebufferToTexture_"+texture.id}),encoder.copyTextureToTexture({texture:sourceGPU,origin:[rectangle.x,rectangle.y,0]},{texture:destinationGPU},[rectangle.z,rectangle.w]),texture.generateMipmaps&&this.textureUtils.generateMipmaps(texture,encoder),renderContextData.currentPass){const{descriptor:descriptor}=renderContextData;for(let i=0;i<descriptor.colorAttachments.length;i++)descriptor.colorAttachments[i].loadOp=GPULoadOp_Load;renderContext.depth&&(descriptor.depthStencilAttachment.depthLoadOp=GPULoadOp_Load),renderContext.stencil&&(descriptor.depthStencilAttachment.stencilLoadOp=GPULoadOp_Load),renderContextData.currentPass=encoder.beginRenderPass(descriptor),renderContextData.currentSets={attributes:{},bindingGroups:[],pipeline:null,index:null},renderContext.viewport&&this.updateViewport(renderContext),renderContext.scissor&&this.updateScissor(renderContext)}else this.device.queue.submit([encoder.finish()])}hasCompatibility(name){return void 0!==this._compatibility[Compatibility_TEXTURE_COMPARE]?this._compatibility[Compatibility_TEXTURE_COMPARE]:super.hasCompatibility(name)}dispose(){if(this.bindingUtils.dispose(),this.textureUtils.dispose(),this.occludedResolveCache){for(const buffer of this.occludedResolveCache.values())buffer.destroy();this.occludedResolveCache.clear()}if(this.timestampQueryPool)for(const queryPool of Object.values(this.timestampQueryPool))null!==queryPool&&queryPool.dispose();void 0===this.parameters.device&&null!==this.device&&this.device.destroy()}}class IESSpotLight extends SpotLight{constructor(color,intensity,distance,angle,penumbra,decay){super(color,intensity,distance,angle,penumbra,decay),this.iesMap=null}copy(source,recursive){return super.copy(source,recursive),this.iesMap=source.iesMap,this}}class ProjectorLight extends SpotLight{constructor(color,intensity,distance,angle,penumbra,decay){super(color,intensity,distance,angle,penumbra,decay),this.aspect=null}copy(source,recursive){return super.copy(source,recursive),this.aspect=source.aspect,this}}class StandardNodeLibrary extends NodeLibrary{constructor(){super(),this.addMaterial(MeshPhongNodeMaterial,"MeshPhongMaterial"),this.addMaterial(MeshStandardNodeMaterial,"MeshStandardMaterial"),this.addMaterial(MeshPhysicalNodeMaterial,"MeshPhysicalMaterial"),this.addMaterial(MeshToonNodeMaterial,"MeshToonMaterial"),this.addMaterial(MeshBasicNodeMaterial,"MeshBasicMaterial"),this.addMaterial(MeshLambertNodeMaterial,"MeshLambertMaterial"),this.addMaterial(MeshNormalNodeMaterial,"MeshNormalMaterial"),this.addMaterial(MeshMatcapNodeMaterial,"MeshMatcapMaterial"),this.addMaterial(LineBasicNodeMaterial,"LineBasicMaterial"),this.addMaterial(LineDashedNodeMaterial,"LineDashedMaterial"),this.addMaterial(PointsNodeMaterial,"PointsMaterial"),this.addMaterial(SpriteNodeMaterial,"SpriteMaterial"),this.addMaterial(ShadowNodeMaterial,"ShadowMaterial"),this.addLight(PointLightNode,PointLight),this.addLight(DirectionalLightNode,DirectionalLight),this.addLight(RectAreaLightNode,RectAreaLight),this.addLight(SpotLightNode,SpotLight),this.addLight(AmbientLightNode,AmbientLight),this.addLight(HemisphereLightNode,HemisphereLight),this.addLight(LightProbeNode,LightProbe),this.addLight(IESSpotLightNode,IESSpotLight),this.addLight(ProjectorLightNode,ProjectorLight),this.addToneMapping(linearToneMapping,1),this.addToneMapping(reinhardToneMapping,2),this.addToneMapping(cineonToneMapping,3),this.addToneMapping(acesFilmicToneMapping,4),this.addToneMapping(agxToneMapping,6),this.addToneMapping(neutralToneMapping,7)}}class WebGPURenderer extends Renderer{constructor(parameters={}){let BackendClass;parameters.forceWebGL?BackendClass=WebGLBackend:(BackendClass=WebGPUBackend,parameters.getFallback=()=>(warn("WebGPURenderer: WebGPU is not available, running under WebGL2 backend."),new WebGLBackend(parameters)));super(new BackendClass(parameters),parameters),this.library=new StandardNodeLibrary,this.isWebGPURenderer=!0,"undefined"!=typeof __THREE_DEVTOOLS__&&__THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{detail:this}))}}class RenderPipeline{constructor(renderer,outputNode=vec4(0,0,1,1)){this.renderer=renderer,this.outputNode=outputNode,this.outputColorTransform=!0,this.needsUpdate=!0;const material=new NodeMaterial;material.name="RenderPipeline",this._quadMesh=new QuadMesh(material),this._quadMesh.name="Render Pipeline",this._context=null}render(){const renderer=this.renderer;this._update(),null!==this._context.onBeforeRenderPipeline&&this._context.onBeforeRenderPipeline();const toneMapping=renderer.toneMapping,outputColorSpace=renderer.outputColorSpace;renderer.toneMapping=0,renderer.outputColorSpace=ColorManagement.workingColorSpace;const currentXR=renderer.xr.enabled;renderer.xr.enabled=!1,this._quadMesh.render(renderer),renderer.xr.enabled=currentXR,renderer.toneMapping=toneMapping,renderer.outputColorSpace=outputColorSpace,null!==this._context.onAfterRenderPipeline&&this._context.onAfterRenderPipeline()}get context(){return this._context}dispose(){this._quadMesh.material.dispose()}_update(){if(!0===this.needsUpdate){const renderer=this.renderer,toneMapping=renderer.toneMapping,outputColorSpace=renderer.outputColorSpace,context={renderPipeline:this,onBeforeRenderPipeline:null,onAfterRenderPipeline:null};let outputNode=this.outputNode;!0===this.outputColorTransform?(outputNode=outputNode.context(context),outputNode=renderOutput(outputNode,toneMapping,outputColorSpace)):(context.toneMapping=toneMapping,context.outputColorSpace=outputColorSpace,outputNode=outputNode.context(context)),this._context=context,this._quadMesh.material.fragmentNode=outputNode,this._quadMesh.material.needsUpdate=!0,this.needsUpdate=!1}}async renderAsync(){warnOnce('RenderPipeline: "renderAsync()" has been deprecated. Use "render()" and "await renderer.init();" when creating the renderer.'),await this.renderer.init(),this.render()}}class PostProcessing extends RenderPipeline{constructor(renderer,outputNode){warnOnce('PostProcessing: "PostProcessing" has been renamed to "RenderPipeline". Please update your code to use "THREE.RenderPipeline" instead.'),super(renderer,outputNode)}}var __getOwnPropDesc$R=Object.getOwnPropertyDescriptor;const IconsetDB={};let Iconset=class extends ReactiveNode{registerIcons(name,svg){const stagingElement=document.createElement("div");stagingElement.innerHTML=svg,stagingElement.querySelectorAll("[id]").forEach(icon=>{IconsetDB[name]=IconsetDB[name]||{},IconsetDB[name][icon.id]=icon.outerHTML})}getIcon(icon){const iconset=IconsetDB[icon.split(":")[0]];if(iconset){const id=icon.split(":")[1];if(iconset[id]){return`<svg viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet">${iconset[id].replace(' id="',' class="icon-id-')}</svg>`}}return'<svg viewBox="0 0 24 24" preserveAspectRatio="xMidYMid meet"></g>'}};Iconset=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$R(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],Iconset);const IconsetSingleton=new Iconset;IconsetSingleton.registerIcons("io",'\n<svg>\n  <g id="io">\n    <ellipse fill="#83A61E" cx="5.4" cy="12.1" rx="3.4" ry="3.4"/>\n    <path fill="#646464" d="M16.3,17.7c-3.1,0-5.6-2.6-5.6-5.6s2.6-5.6,5.6-5.6s5.6,2.6,5.6,5.6S19.3,17.7,16.3,17.7z M16.3,8.8\n    c-1.8,0-3.3,1.5-3.3,3.2s1.5,3.2,3.3,3.2s3.3-1.5,3.3-3.2S18.1,8.8,16.3,8.8z"/>\n  </g>\n  <g id="io_logo">\n    <path fill="#646464" d="M19.5,12.7c0.3-0.3,0.3-0.9,0-1.2l-0.7-0.7l-2.6-2.6c-0.3-0.3-0.3-0.9,0-1.2c0.3-0.3,0.9-0.3,1.2,0l3.8,3.8\n      c0.7,0.7,0.7,1.8,0,2.6l-3.8,3.8c-0.3,0.3-0.9,0.3-1.2,0c-0.3-0.3-0.3-0.9,0-1.2"/>\n    <path fill="#646464" d="M4.3,12.7c-0.3-0.3-0.3-0.9,0-1.2L5,10.8l2.6-2.6c0.3-0.3,0.3-0.9,0-1.2C7.3,6.7,6.7,6.7,6.4,7l-3.8,3.8\n      c-0.7,0.7-0.7,1.8,0,2.6l3.8,3.8c0.3,0.3,0.9,0.3,1.2,0s0.3-0.9,0-1.2"/>\n    <ellipse fill="#83A61E" cx="8.4" cy="12.1" rx="1.7" ry="1.7"/>\n    <path fill="#646464" d="M13.9,14.9c-1.6,0-2.8-1.2-2.8-2.8s1.2-2.8,2.8-2.8s2.8,1.2,2.8,2.8S15.4,14.9,13.9,14.9z M13.9,10.4\n      c-0.9,0-1.7,0.7-1.7,1.7c0,0.9,0.7,1.7,1.7,1.7c0.9,0,1.7-0.7,1.7-1.7C15.5,11.2,14.8,10.4,13.9,10.4z"/>\n  </g>\n\n  <g id="numeric-0">\n    <path d="M11,7A2,2 0 0,0 9,9V15A2,2 0 0,0 11,17H13A2,2 0 0,0 15,15V9A2,2 0 0,0 13,7H11M11,9H13V15H11V9Z" />\n  </g>\n  <g id="numeric-1">\n    <path d="M10,7V9H12V17H14V7H10Z" />\n  </g>\n  <g id="numeric-2">\n    <path d="M9,7V9H13V11H11A2,2 0 0,0 9,13V17H11L15,17V15H11V13H13A2,2 0 0,0 15,11V9A2,2 0 0,0 13,7H9Z" />\n  </g>\n  <g id="numeric-3">\n    <path d="M15,15V13.5A1.5,1.5 0 0,0 13.5,12A1.5,1.5 0 0,0 15,10.5V9C15,7.89 14.1,7 13,7H9V9H13V11H11V13H13V15H9V17H13A2,2 0 0,0 15,15" />\n  </g>\n  <g id="numeric-4">\n    <path d="M9,7V13H13V17H15V7H13V11H11V7H9Z" />\n  </g>\n  <g id="numeric-5">\n    <path d="M9,7V13H13V15H9V17H13A2,2 0 0,0 15,15V13A2,2 0 0,0 13,11H11V9H15V7H9Z" />\n  </g>\n  <g id="numeric-6">\n    <path d="M11,7A2,2 0 0,0 9,9V15A2,2 0 0,0 11,17H13A2,2 0 0,0 15,15V13A2,2 0 0,0 13,11H11V9H15V7H11M11,13H13V15H11V13Z" />\n  </g>\n  <g id="numeric-7">\n    <path d="M11,17L15,9V7H9V9H13L9,17" />\n  </g>\n  <g id="numeric-8">\n    <path d="M11,13H13V15H11M11,9H13V11H11M11,17H13A2,2 0 0,0 15,15V13.5A1.5,1.5 0 0,0 13.5,12A1.5,1.5 0 0,0 15,10.5V9C15,7.89 14.1,7 13,7H11A2,2 0 0,0 9,9V10.5A1.5,1.5 0 0,0 10.5,12A1.5,1.5 0 0,0 9,13.5V15C9,16.11 9.9,17 11,17" />\n  </g> \n  <g id="numeric-9">\n    <path d="M13,17A2,2 0 0,0 15,15V9A2,2 0 0,0 13,7H11A2,2 0 0,0 9,9V11A2,2 0 0,0 11,13H13V15H9V17H13M13,11H11V9H13V11Z" />\n  </g>\n  <g id="numeric-0-box">\n    <path d="M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3H19M11,7A2,2 0 0,0 9,9V15A2,2 0 0,0 11,17H13A2,2 0 0,0 15,15V9A2,2 0 0,0 13,7H11M11,9H13V15H11V9Z" />\n  </g>\n  <g id="numeric-1-box">\n    <path d="M14,17H12V9H10V7H14M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3Z" />\n  </g>\n  <g id="numeric-2-box">\n    <path d="M15,11C15,12.11 14.1,13 13,13H11V15H15V17H9V13C9,11.89 9.9,11 11,11H13V9H9V7H13A2,2 0 0,1 15,9M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3Z" />\n  </g>\n  <g id="numeric-3-box">\n    <path d="M15,10.5A1.5,1.5 0 0,1 13.5,12C14.34,12 15,12.67 15,13.5V15C15,16.11 14.11,17 13,17H9V15H13V13H11V11H13V9H9V7H13C14.11,7 15,7.89 15,9M19,3H5C3.91,3 3,3.9 3,5V19A2,2 0 0,0 5,21H19C20.11,21 21,20.1 21,19V5A2,2 0 0,0 19,3Z" />\n  </g>\n  <g id="numeric-4-box">\n    <path d="M15,17H13V13H9V7H11V11H13V7H15M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3Z" />\n  </g>\n  <g id="numeric-5-box">\n    <path d="M15,9H11V11H13A2,2 0 0,1 15,13V15C15,16.11 14.1,17 13,17H9V15H13V13H9V7H15M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3Z" />\n  </g>\n  <g id="numeric-6-box">\n    <path d="M15,9H11V11H13A2,2 0 0,1 15,13V15C15,16.11 14.1,17 13,17H11A2,2 0 0,1 9,15V9C9,7.89 9.9,7 11,7H15M19,3H5A2,2 0 0,0 3,5V19A2,2 0 0,0 5,21H19A2,2 0 0,0 21,19V5A2,2 0 0,0 19,3M11,15H13V13H11V15Z" />\n  </g>\n  <g id="numeric-7-box">\n    <path d="M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3H19M11,17L15,9V7H9V9H13L9,17H11Z" />\n  </g>\n  <g id="numeric-8-box">\n    <path d="M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3H19M11,17H13A2,2 0 0,0 15,15V13.5A1.5,1.5 0 0,0 13.5,12A1.5,1.5 0 0,0 15,10.5V9C15,7.89 14.1,7 13,7H11A2,2 0 0,0 9,9V10.5A1.5,1.5 0 0,0 10.5,12A1.5,1.5 0 0,0 9,13.5V15C9,16.11 9.9,17 11,17M11,13H13V15H11V13M11,9H13V11H11V9Z" />\n  </g>\n  <g id="numeric-9-box">\n    <path d="M19,3A2,2 0 0,1 21,5V19A2,2 0 0,1 19,21H5A2,2 0 0,1 3,19V5A2,2 0 0,1 5,3H19M13,11H11V9H13V11M13,7H11A2,2 0 0,0 9,9V11C9,12.11 9.9,13 11,13H13V15H9V17H13A2,2 0 0,0 15,15V9C15,7.89 14.1,7 13,7Z" />\n  </g>\n  \n  <g id="unlink">\n    <path d="M3.9,12c0-1.7,1.4-3.2,3.2-3.2h4V7H7c-2.7,0-5,2.2-5,5s2.2,5,5,5h4v-1.9H7C5.2,15.1,3.9,13.7,3.9,12z M17,7h-4.1v1.9H17\n    c1.7,0,3.2,1.4,3.2,3.2s-1.4,3.2-3.2,3.2h-4.1v1.9H17c2.7,0,5-2.2,5-5S19.8,7,17,7z"/>\n  </g>\n  <g id="link">\n    <path d="M3.9,12c0-1.7,1.4-3.2,3.2-3.2h4V7H7c-2.7,0-5,2.2-5,5s2.2,5,5,5h4v-1.9H7C5.2,15.1,3.9,13.7,3.9,12z M8,13h8.1v-2H8V13z\n      M17,7h-4.1v1.9H17c1.7,0,3.2,1.4,3.2,3.2s-1.4,3.2-3.2,3.2h-4.1v1.9H17c2.7,0,5-2.2,5-5S19.8,7,17,7z"/>\n  </g>\n  <g id="gear">\n    <path d="M21.3,14.6L19.2,13c0-0.3,0.1-0.6,0.1-1c0-0.3,0-0.6-0.1-1l2.1-1.7c0.2-0.2,0.2-0.4,0.1-0.6l-1.9-3.4\n      c-0.1-0.2-0.3-0.2-0.6-0.2l-2.4,1c-0.5-0.3-1.1-0.7-1.7-1l-0.3-2.7c0-0.2-0.2-0.4-0.4-0.4h-4C9.8,2.3,9.5,2.4,9.5,2.7L9.1,5.3\n      C8.5,5.5,8,5.8,7.5,6.3l-2.4-1c-0.2-0.1-0.5,0-0.7,0.2L2.5,8.8C2.4,9.1,2.4,9.3,2.6,9.5l2.1,1.7c0,0.3-0.1,0.6-0.1,1s0,0.6,0.1,1\n      l-2.1,1.7c-0.2,0.2-0.2,0.4-0.1,0.6l1.9,3.4C4.5,19,4.7,19,5,19l2.4-1c0.5,0.4,1.1,0.7,1.7,1l0.4,2.7c0,0.2,0.3,0.4,0.6,0.4H14\n      c0.2,0,0.4-0.2,0.5-0.4l0.3-2.7c0.6-0.2,1.2-0.5,1.7-1l2.4,1c0.2,0.1,0.4,0,0.6-0.2l1.9-3.4C21.6,15.1,21.5,14.8,21.3,14.6z\n      M11.9,15.6c-2,0-3.7-1.7-3.7-3.7s1.7-3.6,3.7-3.6s3.7,1.7,3.7,3.7S13.9,15.6,11.9,15.6z"/>\n  </g>\n  <g id="less">\n    <path d="M6.6,20.3L8.3,22l3.7-4l3.7,4l1.7-1.7l-5.3-5.7L6.6,20.3z M17.3,3.8l-1.7-1.7l-3.7,4l-3.7-4L6.6,3.8l5.3,5.7L17.3,3.8z"/>\n  </g>\n  <g id="more">\n    <path d="M11.9,5.3l3.7,3.5l1.7-1.6L12,2.1L6.6,7.2l1.7,1.6L11.9,5.3z M11.9,18.9l-3.7-3.5L6.6,17l5.3,5.1l5.3-5.1l-1.7-1.6\n      L11.9,18.9z"/>\n  </g>\n  <g id="code">\n    <path d="M9.4,16.6L4.8,12l4.6-4.6L8,6.1l-6,6l6,6L9.4,16.6z M14.5,16.6l4.6-4.6l-4.6-4.6L15.9,6l6,6l-6,6L14.5,16.6z"/>\n  </g>\n  <g id="tune">\n    <path d="M2,17.6v2.2h6.6v-2.2H2z M2,4.3v2.2h11V4.3H2z M13,22v-2.2h8.9v-2.2H13v-2.2h-2.2V22H13z M6.4,8.7V11H2v2.2h4.4v2.2h2.2\n      V8.7H6.4z M21.9,13.1v-2.2h-11v2.2H21.9z M15.3,8.7h2.2V6.5h4.4V4.3h-4.4V2.1h-2.2V8.7z"/>\n  </g>\n  <g id="unlock">\n    <path d="M11.9,17.3c1,0,1.9-0.8,1.9-1.9s-0.8-1.9-1.9-1.9S10,14.3,10,15.4S11,17.3,11.9,17.3z M17.6,8.7h-0.9V6.8\n      c-0.1-2.6-2.2-4.7-4.7-4.7S7.3,4.3,7.3,6.8H9c0-1.7,1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9v1.9H6.4c-1.1,0-1.9,0.8-1.9,1.9v9.5\n      c0,1.1,0.8,1.9,1.9,1.9h11.2c1,0,1.9-0.8,1.9-1.9v-9.5C19.4,9.6,18.6,8.7,17.6,8.7z M17.6,20.1H6.4v-9.5h11.2V20.1z"/>\n  </g>\n  <g id="lock">\n    <path d="M11.9,17.3c1,0,1.9-0.8,1.9-1.9s-0.8-1.9-1.9-1.9S10,14.3,10,15.4S11,17.3,11.9,17.3z M17.6,8.7h-0.9V6.8\n      c-0.1-2.6-2.2-4.7-4.7-4.7S7.3,4.3,7.3,6.8v1.9H6.4c-1.1,0-1.9,0.8-1.9,1.9v9.5c0,1.1,0.8,1.9,1.9,1.9h11.2c1,0,1.9-0.8,1.9-1.9\n      v-9.5C19.4,9.6,18.6,8.7,17.6,8.7z M9,6.8c0-1.7,1.3-2.9,2.9-2.9s2.9,1.3,2.9,2.9v1.9H9V6.8z M17.6,20.1H6.4v-9.5h11.2V20.1z"/>\n  </g>\n  <g id="more_horizontal">\n    <path d="M4.5,9.6C3.1,9.6,2,10.7,2,12.1s1.1,2.5,2.5,2.5S7,13.5,7,12.1S5.9,9.6,4.5,9.6z M19.4,9.6c-1.4,0-2.5,1.1-2.5,2.5\n      s1.1,2.5,2.5,2.5s2.5-1.1,2.5-2.5S20.8,9.6,19.4,9.6z M11.9,9.6c-1.4,0-2.5,1.1-2.5,2.5s1.1,2.5,2.5,2.5s2.5-1.1,2.5-2.5\n      S13.4,9.6,11.9,9.6z"/>\n  </g>\n  <g id="more_vertical">\n    <path d="M11.9,7.1c1.4,0,2.5-1.1,2.5-2.5s-1.1-2.5-2.5-2.5S9.5,3.2,9.5,4.6S10.5,7.1,11.9,7.1z M11.9,9.6c-1.4,0-2.5,1.1-2.5,2.5\n      s1.1,2.5,2.5,2.5s2.5-1.1,2.5-2.5S13.4,9.6,11.9,9.6z M11.9,17.1c-1.4,0-2.5,1.1-2.5,2.5s1.1,2.5,2.5,2.5s2.5-1.1,2.5-2.5\n      S13.4,17.1,11.9,17.1z"/>\n  </g>\n  <g id="chevron_left">\n    <path d="M18.1,4.4l-2.3-2.3l-10,10l10,10l2.3-2.3l-7.6-7.6L18.1,4.4z"/>\n  </g>\n  <g id="chevron_up">\n    <path d="M11.9,5.9l-10,10l2.3,2.3l7.6-7.6l7.6,7.6l2.3-2.3L11.9,5.9z"/>\n  </g>\n  <g id="chevron_down">\n    <path d="M4.3,5.9l7.6,7.6l7.6-7.6l2.3,2.3l-10,10L2,8.2L4.3,5.9z"/>\n  </g>\n  <g id="chevron_right">\n    <path d="M5.8,19.7l7.6-7.6L5.8,4.4l2.3-2.3l10,10l-10,10L5.8,19.7z"/>\n  </g>\n  <g id="arrow_left">\n    <path d="M21.9,10.8H6.7l7-7L12,2.1l-10,10l10,10l1.7-1.7l-7-7h15.2V10.8z"/>\n  </g>\n  <g id="arrow_down">\n    <path d="M21.9,12.1l-1.7-1.7l-7,7V2.1h-2.5v15.2l-7-7L2,12.1l10,10L21.9,12.1z"/>\n  </g>\n  <g id="arrow_up">\n    <path d="M2,12.1l1.7,1.7l7-7V22h2.5V6.8l7,7l1.7-1.7l-10-10L2,12.1z"/>\n  </g>\n  <g id="arrow_right">\n    <path d="M2,13.3h15.2l-7,7l1.7,1.7l10-10l-10-10l-1.7,1.7l7,7H2V13.3z"/>\n  </g>\n  <g id="arrow_end">\n    <polygon points="7.6,3.8 14.6,10.8 2,10.8 2,13.3 14.6,13.3 7.6,20.3 9.4,22 19.3,12.1 9.4,2.1   "/>\n    <rect x="19.4" y="2.1" width="2.5" height="19.9"/>\n  </g>\n  <g id="arrow_home">\n    <polygon points="16.3,20.3 9.3,13.3 21.9,13.3 21.9,10.8 9.3,10.8 16.3,3.8 14.5,2.1 4.6,12.1 14.5,22   "/>\n    <rect x="2" y="2.1" width="2.5" height="19.9"/>\n  </g>\n  <g id="chevron_end">\n    <path d="M2,4.4L9.6,12L2,19.7L4.3,22l10-10L4.3,2L2,4.4z M18.6,2.1h3.3V22h-3.3V2.1z"/>\n  </g>\n  <g id="chevron_home">\n    <path d="M21.9,19.7l-7.6-7.6l7.6-7.6l-2.3-2.3l-10,10l10,10L21.9,19.7z M5.3,22H2V2.1h3.3V22z"/>\n  </g>\n  <g id="check">\n    <path d="M8.3,16.5l-4.7-4.7L2,13.3l6.3,6.3L21.9,6.1l-1.6-1.6L8.3,16.5z"/>\n  </g>\n  <g id="close">\n    <path d="M21.9,4.1l-2-2l-8,8l-8-8l-2,2l8,8l-8,8l2,2l8-8l8,8l2-2l-8-8L21.9,4.1z"/>\n  </g>\n  <g id="circle">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8\n      s8,3.6,8,8S16.4,20,11.9,20z"/>\n  </g>\n  <g id="circle_minus">\n    <path d="M7,11.1v2h10v-2C16.9,11.1,7,11.1,7,11.1z M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z\n      M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,11.9,20z"/>\n  </g>\n  <g id="circle_plus">\n    <path d="M12.9,7.1h-2v4H7v2h4v4h2v-4h4v-2h-4v-4H12.9z M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1\n      z M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,11.9,20z"/>\n  </g>\n  <g id="circle_close">\n    <path d="M14.5,8.1l-2.6,2.6L9.4,8.1L8,9.5l2.6,2.6L8,14.6L9.4,16l2.6-2.6l2.6,2.6l1.4-1.4L13.4,12L16,9.4L14.5,8.1z M11.9,2.1\n      c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8\n      S16.4,20,11.9,20z"/>\n  </g>\n  <g id="close_small">\n    <path d="M14.5,8.1l-2.6,2.6L9.4,8.1L8,9.5l2.6,2.6L8,14.6L9.4,16l2.6-2.6l2.6,2.6l1.4-1.4L13.4,12L16,9.4L14.5,8.1z"/>\n  </g>\n  <g id="circle_triangle_right">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8\n      s8,3.6,8,8S16.4,20,11.9,20z"/>\n    <polygon points="10,16.6 15.9,12.1 10,7.6   "/>\n  </g>\n  <g id="circle_triangle_down">\n    <path d="M21.9,12.1c0-5.5-4.5-10-10-10S2,6.6,2,12.1s4.5,10,10,10S21.9,17.5,21.9,12.1z M4,12.1c0-4.4,3.6-8,8-8s8,3.6,8,8\n      s-3.6,8-8,8S4,16.5,4,12.1z"/>\n    <polygon points="7.5,10.1 11.9,16.1 16.4,10.1   "/>\n  </g>\n  <g id="circle_triangle_left">\n    <path d="M11.9,22c5.5,0,10-4.5,10-10s-4.5-10-10-10S2,6.6,2,12.1S6.5,22,11.9,22z M11.9,4.1c4.4,0,8,3.6,8,8s-3.6,8-8,8s-8-3.6-8-8\n      S7.5,4.1,11.9,4.1z"/>\n    <polygon points="13.9,7.6 8,12.1 13.9,16.6   "/>\n  </g>\n  <g id="circle_triangle_up">\n    <path d="M2,12.1c0,5.5,4.5,10,10,10s10-4.5,10-10s-4.5-10-10-10S2,6.6,2,12.1z M19.9,12.1c0,4.4-3.6,8-8,8s-8-3.6-8-8s3.6-8,8-8\n      S19.9,7.7,19.9,12.1z"/>\n    <polygon points="16.4,14.1 11.9,8.1 7.5,14.1   "/>\n  </g>\n  <g id="triangle_right">\n    <polygon points="9.1,16.5 14.9,12 9.1,7.5   "/>\n  </g>\n  <g id="triangle_down">\n    <polygon points="7.6,9 11.9,15 16.5,9   "/>\n  </g>\n  <g id="triangle_left">\n    <polygon points="14.9,7.5 9.1,12 14.9,16.5   "/>\n  </g>\n  <g id="triangle_up">\n    <polygon points="16.5,15 11.9,9 7.6,15   "/>\n  </g>\n  <g id="circle_pause">\n    <path d="M9,16.1h2v-8H9V16.1z M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M11.9,20\n      c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,11.9,20z M12.9,16.1h2v-8h-2V16.1z"/>\n  </g>\n  <g id="circle_info">\n    <path d="M11,17.1h2v-6h-2V17.1z M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M11.9,20\n      c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,11.9,20z M11,9.1h2v-2h-2C11,7.1,11,9.1,11,9.1z"/>\n  </g>\n  <g id="circle_warning">\n    <path d="M11,15.1h2v2h-2V15.1z M11,7.1h2v6h-2V7.1z M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z\n      M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,11.9,20z"/>\n  </g>\n  <g id="circle_help">\n    <path d="M11,18h2v-2h-2C11,16.1,11,18,11,18z M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z\n      M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,11.9,20z M11.9,6.1c-2.2,0-4,1.8-4,4h2c0-1.1,0.9-2,2-2s2,0.9,2,2\n      c0,2-3,1.8-3,5h2c0-2.3,3-2.5,3-5C15.9,7.9,14.1,6.1,11.9,6.1z"/>\n  </g>\n  <g id="circle_checked">\n    <path d="M11.9,7.1c-2.8,0-5,2.2-5,5s2.2,5,5,5s5-2.2,5-5S14.8,7.1,11.9,7.1z M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10\n      s10-4.5,10-10S17.4,2.1,11.9,2.1z M11.9,20c-4.4,0-8-3.6-8-8s3.6-8,8-8s8,3.6,8,8S16.4,20,11.9,20z"/>\n  </g>\n  <g id="circle_location">\n    <path d="M20,11.2c-0.4-3.8-3.4-6.8-7.1-7.1v-2H11V4c-3.8,0.3-6.8,3.3-7.1,7.1H2V13h1.9c0.4,3.8,3.4,6.8,7.1,7.1V22h1.8v-1.9\n      c3.8-0.4,6.8-3.4,7.1-7.1h1.9v-1.8C21.9,11.2,20,11.2,20,11.2z M11.9,18.4c-3.6,0-6.3-2.8-6.3-6.3s2.7-6.3,6.3-6.3s6.3,2.8,6.3,6.3\n      S15.5,18.4,11.9,18.4z"/>\n  </g>\n  <g id="circle_location_checked">\n    <path d="M11.9,8.4c-2,0-3.7,1.7-3.7,3.7s1.7,3.7,3.7,3.7s3.7-1.7,3.7-3.7S13.9,8.4,11.9,8.4z M20,11.2c-0.4-3.8-3.4-6.8-7.1-7.1v-2\n      H11V4c-3.8,0.3-6.8,3.3-7.1,7.1H2V13h1.9c0.4,3.8,3.4,6.8,7.1,7.1V22h1.8v-1.9c3.8-0.4,6.8-3.4,7.1-7.1h1.9v-1.8\n      C21.9,11.2,20,11.2,20,11.2z M11.9,18.4c-3.6,0-6.3-2.8-6.3-6.3s2.7-6.3,6.3-6.3s6.3,2.8,6.3,6.3S15.5,18.4,11.9,18.4z"/>\n  </g>\n  <g id="circle_fill">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z"/>\n  </g>\n  <g id="circle_fill_checked">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M10,17.1l-5-5l1.4-1.4l3.6,3.6l7.6-7.6\n      L19,8.1L10,17.1z"/>\n  </g>\n  <g id="circle_fill_minus">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M16.9,13.1H7v-2h10v2H16.9z"/>\n  </g>\n  <g id="circle_fill_plus">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M16.9,13.1h-4v4h-2v-4H7v-2h4v-4h2v4h4v2\n      H16.9z"/>\n  </g>\n  <g id="circle_fill_arrow_down">\n    <path d="M21.9,12.1c0-5.5-4.5-10-10-10S2,6.6,2,12.1s4.5,10,10,10S21.9,17.5,21.9,12.1z M7.5,10.1h9l-4.5,6L7.5,10.1z"/>\n  </g>\n  <g id="circle_fill_arrow_left">\n    <path d="M11.9,22c5.5,0,10-4.5,10-10s-4.5-10-10-10S2,6.6,2,12.1S6.5,22,11.9,22z M13.9,7.6v9l-6-4.5L13.9,7.6z"/>\n  </g>\n  <g id="circle_fill_arrow_up">\n    <path d="M2,12.1c0,5.5,4.5,10,10,10s10-4.5,10-10s-4.5-10-10-10S2,6.6,2,12.1z M16.4,14.1h-9l4.5-6L16.4,14.1z"/>\n  </g>\n  <g id="circle_fill_arrow_right">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M10,16.6v-9l6,4.5L10,16.6z"/>\n  </g>\n  <g id="circle_fill_pause">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M11,16.1H9v-8h2V16.1z M14.9,16.1h-2v-8h2\n      V16.1z"/>\n  </g>\n  <g id="circle_fill_info">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M12.9,17.1h-2v-6h2V17.1z M12.9,9.1h-2v-2h2\n      C12.9,7.1,12.9,9.1,12.9,9.1z"/>\n  </g>\n  <g id="circle_fill_warning">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M12.9,17.1h-2v-2h2V17.1z M12.9,13.1h-2v-6h2\n      C12.9,7.1,12.9,13.1,12.9,13.1z"/>\n  </g>\n  <g id="circle_fill_help">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M12.9,19h-2v-2h2C12.9,17.1,12.9,19,12.9,19z\n      M15,11.4l-0.9,0.9c-0.8,0.7-1.2,1.3-1.2,2.8h-2v-0.6c0-1.1,0.4-2.1,1.2-2.8l1.2-1.3c0.4-0.3,0.6-0.8,0.6-1.4C14,8,13.1,7.1,12,7.1\n      s-2,0.9-2,2H8c0-2.2,1.8-4,4-4s4,1.8,4,4C15.9,10,15.5,10.7,15,11.4z"/>\n  </g>\n  <g id="circle_fill_group">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10s10-4.5,10-10S17.4,2.1,11.9,2.1z M8,17.5c-1.4,0-2.5-1.1-2.5-2.5\n      s1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5S9.4,17.5,8,17.5z M9.5,8.1c0-1.4,1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5s-1.1,2.5-2.5,2.5\n      S9.5,9.5,9.5,8.1z M15.9,17.5c-1.4,0-2.5-1.1-2.5-2.5s1.1-2.5,2.5-2.5s2.5,1.1,2.5,2.5S17.3,17.5,15.9,17.5z"/>\n  </g>\n  <g id="box">\n    <path d="M19.7,4.3v15.5H4.2V4.3H19.7 M19.7,2.1H4.2C3,2.1,2,3.1,2,4.3v15.5C2,21,3,22,4.2,22h15.5c1.2,0,2.2-1,2.2-2.2V4.3\n      C21.9,3.1,20.9,2.1,19.7,2.1z"/>\n  </g>\n  <g id="box_fill">\n    <path d="M19.7,2.1H4.2C3,2.1,2,3.1,2,4.3v15.5C2,21,3,22,4.2,22h15.5c1.2,0,2.2-1,2.2-2.2V4.3C21.9,3.1,20.9,2.1,19.7,2.1z"/>\n  </g>\n  <g id="box_fill_checked">\n    <path d="M19.7,2.1H4.2C3,2.1,2,3.1,2,4.3v15.5C2,21,3,22,4.2,22h15.5c1.2,0,2.2-1,2.2-2.2V4.3C21.9,3.1,20.9,2.1,19.7,2.1z\n      M9.8,17.6l-5.5-5.5l1.6-1.6l4,4l8.3-8.4l1.6,1.5L9.8,17.6z"/>\n  </g>\n  <g id="box_fill_minus">\n    <path d="M19.7,2.1H4.2C3,2.1,2,3.1,2,4.3v15.5C2,21,3,22,4.2,22h15.5c1.2,0,2.2-1,2.2-2.2V4.3C21.9,3.1,20.9,2.1,19.7,2.1z\n      M17.5,13.1H6.4v-2.2h11L17.5,13.1L17.5,13.1z"/>\n  </g>\n  <path id="box_fill_plus" d="M19.7,2.1H4.2C3,2.1,2,3.1,2,4.3v15.5C2,21,3,22,4.2,22h15.5c1.2,0,2.2-1,2.2-2.2V4.3\n    C21.9,3.1,20.9,2.1,19.7,2.1z M17.5,13.1h-4.4v4.4h-2.2v-4.4H6.4v-2.2h4.4V6.5H13v4.4h4.4L17.5,13.1L17.5,13.1z"/>\n  <g id="box_fill_gear">\n    <path d="M11.9,9.8c-1.2,0-2.2,1-2.2,2.2s1,2.2,2.2,2.2s2.2-1,2.2-2.2S13.2,9.8,11.9,9.8z M19.7,2.1H4.2C3,2.1,2,3.1,2,4.3v15.5\n      C2,21,3,22,4.2,22h15.5c1.2,0,2.2-1,2.2-2.2V4.3C21.9,3.1,20.9,2.1,19.7,2.1z M17.8,12.1c0,0.2,0,0.5-0.1,0.7l1.7,1.2\n      c0.2,0.1,0.2,0.3,0.1,0.5l-1.6,2.7c-0.1,0.2-0.3,0.2-0.5,0.2l-1.9-0.7c-0.4,0.3-0.8,0.6-1.3,0.7L14,19.5c0,0.2-0.2,0.3-0.4,0.3\n      h-3.1c-0.2,0-0.3-0.2-0.4-0.3l-0.2-2.1C9.4,17.2,9,17,8.6,16.7l-1.9,0.7c-0.2,0.1-0.4,0-0.5-0.2l-1.5-2.7c-0.1-0.2-0.1-0.4,0.1-0.5\n      l1.7-1.2c-0.1-0.2-0.1-0.5-0.1-0.7s0-0.5,0.1-0.7l-1.7-1.2C4.4,9.9,4.4,9.7,4.5,9.6l1.6-2.7c0.1-0.2,0.2-0.3,0.4-0.2l1.9,0.7\n      c0.4-0.3,0.8-0.6,1.3-0.7L10,4.6c0-0.2,0.2-0.3,0.4-0.3h3.1c0.2,0,0.3,0.2,0.4,0.3l0.2,2.1c0.5,0.2,0.9,0.4,1.3,0.7l1.9-0.7\n      c0.2-0.1,0.4,0,0.5,0.2l1.6,2.7c0.1,0.2,0.1,0.4-0.1,0.5l-1.7,1.2C17.8,11.6,17.8,11.8,17.8,12.1z"/>\n  </g>\n  <g id="box_focus">\n    <path d="M4.2,15.4H2v4.4C2,21,3,22,4.2,22h4.4v-2.2H4.2V15.4z M4.2,4.3h4.4V2.1H4.2C3,2.1,2,3.1,2,4.3v4.4h2.2V4.3z M19.7,2.1h-4.4\n      v2.2h4.4v4.4h2.2V4.3C21.9,3.1,20.9,2.1,19.7,2.1z M19.7,19.8h-4.4V22h4.4c1.2,0,2.2-1,2.2-2.2v-4.4h-2.2V19.8z M11.9,7.7\n      c-2.4,0-4.4,2-4.4,4.4s2,4.4,4.4,4.4s4.4-2,4.4-4.4S14.4,7.7,11.9,7.7z M11.9,14.3c-1.2,0-2.2-1-2.2-2.2s1-2.2,2.2-2.2\n      s2.2,1,2.2,2.2S13.2,14.3,11.9,14.3z"/>\n  </g>\n  <g id="rows">\n    <path d="M20.8,13.1H3.1c-0.6,0-1.1,0.5-1.1,1.1v6.6C2,21.5,2.5,22,3.1,22H21c0.6,0,1.1-0.5,1.1-1.1v-6.6\n      C21.9,13.6,21.4,13.1,20.8,13.1z M20.8,2.1H3.1C2.5,2.1,2,2.6,2,3.2v6.6c0,0.6,0.5,1.1,1.1,1.1H21c0.6,0,1.1-0.5,1.1-1.1V3.2\n      C21.9,2.6,21.4,2.1,20.8,2.1z"/>\n  </g>\n  <g id="columns">\n    <path d="M6.2,2.1H3.1C2.5,2.1,2,2.8,2,3.5v17.1C2,21.4,2.5,22,3.1,22h3.2c0.6,0,1.1-0.7,1.1-1.4V3.5C7.2,2.8,6.7,2.1,6.2,2.1z\n      M20.8,2.1h-3.2c-0.6,0-1.1,0.7-1.1,1.4v17.1c0,0.7,0.5,1.4,1.1,1.4h3.2c0.6,0,1.1-0.7,1.1-1.4V3.5C21.9,2.8,21.4,2.1,20.8,2.1z\n      M13.5,2.1h-3.2c-0.6,0-1.1,0.7-1.1,1.4v17.1c0,0.7,0.5,1.4,1.1,1.4h3.2c0.6,0,1.1-0.7,1.1-1.4V3.5C14.6,2.8,14.1,2.1,13.5,2.1z"/>\n  </g>\n  <g id="dashboard">\n    <path d="M2,13.1h8.9v-11H2V13.1z M2,22h8.9v-6.6H2V22z M13,22h8.9V11H13V22z M13,2.1v6.6h8.9V2.1H13z"/>\n  </g>\n  <g id="layer_add">\n    <path d="M4,6.1H2v14c0,1.1,0.9,2,2,2h14v-2H4V6.1z M19.9,2.1H8c-1.1,0-2,0.9-2,2v12c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2v-12\n      C21.9,3,21,2.1,19.9,2.1z M18.9,11.1h-4v4h-2v-4H9v-2h4v-4h2v4h4C18.9,9.1,18.9,11.1,18.9,11.1z"/>\n  </g>\n  <g id="layer_remove">\n    <path d="M4,6.1H2v14c0,1.1,0.9,2,2,2h14v-2H4V6.1z"/>\n    <path d="M19.9,2.1H8c-1.1,0-2,0.9-2,2v12c0,1.1,0.9,2,2,2h12c1.1,0,2-0.9,2-2v-12C21.9,3,21,2.1,19.9,2.1z M18.9,11.1H9v-2h10v2\n      H18.9z"/>\n  </g>\n  <g id="layer_to_back">\n    <path d="M8.6,6.5H6.4v2.2h2.2V6.5L8.6,6.5z M8.6,11H6.4v2.2h2.2V11C8.5,11,8.6,11,8.6,11z M8.6,2.1c-1.2,0-2.2,1-2.2,2.2h2.2V2.1\n      L8.6,2.1z M13,15.4h-2.2v2.2H13C13,17.5,13,15.4,13,15.4z M19.8,2.1v2.2H22C21.9,3.1,20.9,2.1,19.8,2.1z M13,2.1h-2.2v2.2H13V2.1z\n      M8.6,17.6v-2.2H6.4C6.4,16.6,7.4,17.6,8.6,17.6z M19.8,13.1H22V11h-2.2V13.1z M19.8,8.7H22V6.5h-2.2V8.7z M19.8,17.6\n      c1.2,0,2.2-1,2.2-2.2h-2.2V17.6z M4.1,6.5H2v13.3C2,21,3,22,4.1,22h13.3v-2.2H4.1C4.1,19.9,4.1,6.5,4.1,6.5z M15.3,4.3h2.2V2.1\n      h-2.2V4.3z M15.3,17.6h2.2v-2.2h-2.2V17.6z"/>\n  </g>\n  <g id="layer_to_front">\n    <path d="M2,13.1h2.2V11H2V13.1z M2,17.6h2.2v-2.2H2V17.6z M4.1,22v-2.2H2C2,21,3,22,4.1,22z M2,8.7h2.2V6.5H2V8.7z M15.3,22h2.2\n      v-2.2h-2.2V22z M19.8,2.1H8.6c-1.2,0-2.2,1-2.2,2.2v11.1c0,1.2,1,2.2,2.2,2.2h11c1.2,0,2.2-1,2.2-2.2V4.3\n      C21.9,3.1,20.9,2.1,19.8,2.1z M19.8,15.4H8.6V4.3h11L19.8,15.4L19.8,15.4z M10.9,22H13v-2.2h-2.2C10.9,19.9,10.9,22,10.9,22z\n      M6.4,22h2.2v-2.2H6.4V22z"/>\n  </g>\n  <g id="layer_image">\n    <path d="M21.9,16.1v-12c0-1.1-0.9-2-2-2H8c-1.1,0-2,0.9-2,2v12c0,1.1,0.9,2,2,2h12C21,18,21.9,17.1,21.9,16.1z M11,12.1l2,2.7\n      l3-3.7l4,5H8L11,12.1z M2,6.1v14c0,1.1,0.9,2,2,2h14v-2H4v-14C4,6.1,2,6.1,2,6.1z"/>\n  </g>\n  <g id="image">\n    <path d="M21.9,19.8V4.3c0-1.2-1-2.2-2.2-2.2H4.2C3,2.1,2,3.1,2,4.3v15.5C2,21,3,22,4.2,22h15.5C20.9,22,21.9,21,21.9,19.8z M8,13.7\n      l2.7,3.3l3.9-5l5,6.6H4.2L8,13.7z"/>\n  </g>\n  <g id="label_fill">\n    <path d="M17.3,5.6c-0.4-0.5-1-0.9-1.7-0.9H4.1C2.9,4.8,2,5.7,2,6.8v10.5c0,1.2,0.9,2.1,2.1,2.1h11.5c0.7,0,1.3-0.3,1.7-0.9l4.6-6.4\n      L17.3,5.6z"/>\n  </g>\n  <g id="label">\n    <path d="M17.3,5.6c-0.4-0.5-1-0.9-1.7-0.9H4.1C2.9,4.7,2,5.6,2,6.8v10.5c0,1.2,0.9,2.1,2.1,2.1h11.5c0.7,0,1.3-0.3,1.7-0.9l4.6-6.3\n      L17.3,5.6z M15.6,17.3H4.1V6.8h11.5l3.7,5.2L15.6,17.3z"/>\n  </g>\n  <g id="backspace">\n    <path d="M20.3,4.8H7.8c-0.6,0-1,0.2-1.3,0.7L2,12.1l4.5,6.6c0.3,0.4,0.7,0.7,1.3,0.7h12.5c0.9,0,1.7-0.7,1.7-1.7V6.3\n      C21.9,5.4,21.2,4.8,20.3,4.8z M17.8,15l-1.2,1.2l-3-2.9l-3,2.9L9.5,15l3-2.9l-3-2.9L10.6,8l3,2.9l3-2.9l1.2,1.2l-3,2.9L17.8,15z"/>\n  </g>\n  <g id="redo">\n    <path d="M18.3,11.2c-1.8-1.6-4.2-2.6-6.7-2.6c-4.6,0-8.3,3-9.7,7.1l2.2,0.7c1-3.1,4-5.3,7.4-5.3c1.9,0,3.7,0.7,5,1.8l-3.6,3.6h9\n      V7.7L18.3,11.2z"/>\n  </g>\n  <g id="undo">\n    <path d="M12.2,8.6c-2.6,0-4.9,1-6.7,2.6L2,7.7v8.8h8.8L7.2,13c1.3-1.2,3.1-1.8,5-1.8c3.4,0,6.3,2.2,7.4,5.3l2.2-0.8\n      C20.6,11.6,16.8,8.6,12.2,8.6z"/>\n  </g>\n  <g id="reload">\n    <path d="M19,5c-1.8-1.7-4.3-2.9-7.1-2.9c-5.5,0-10,4.5-10,10s4.5,10,10,10c4.7,0,8.6-3.2,9.6-7.5H19c-1,2.9-3.8,5-7.1,5\n      c-4.2,0-7.5-3.3-7.5-7.5s3.3-7.5,7.5-7.5c2.1,0,3.9,0.8,5.2,2.2l-4,4h8.7V2.1L19,5z"/>\n  </g>\n  <g id="grid_fill">\n    <path d="M4,8.1h4v-4H4V8.1z M10,20h4v-4h-4V20z M4,20h4v-4H4V20z M4,14.1h4v-4H4V14.1z M10,14.1h4v-4h-4V14.1z M15.9,4.1v4h4v-4\n      C19.9,4.1,15.9,4.1,15.9,4.1z M10,8.1h4v-4h-4V8.1z M15.9,14.1h4v-4h-4V14.1z M15.9,20h4v-4h-4V20z"/>\n  </g>\n  <g id="grid">\n    <path d="M19.9,2.1H4c-1.1,0-2,0.9-2,2V20c0,1.1,0.9,2,2,2h15.9c1.1,0,2-0.9,2-2V4.1C21.9,3,21,2.1,19.9,2.1z M8,20H4v-4h4\n      C8,16.1,8,20,8,20z M8,14.1H4v-4h4V14.1z M8,8.1H4v-4h4C8,4.1,8,8.1,8,8.1z M13.9,20h-4v-4h4C13.9,16.1,13.9,20,13.9,20z\n      M13.9,14.1h-4v-4h4V14.1z M13.9,8.1h-4v-4h4C13.9,4.1,13.9,8.1,13.9,8.1z M19.9,20h-4v-4h4C19.9,16.1,19.9,20,19.9,20z M19.9,14.1\n      h-4v-4h4V14.1z M19.9,8.1h-4v-4h4C19.9,4.1,19.9,8.1,19.9,8.1z"/>\n  </g>\n  <g id="search">\n    <path d="M16.2,14.6h-0.9L15,14.3c1.1-1.2,1.7-2.9,1.7-4.7c0-4.1-3.2-7.3-7.3-7.3S2.1,5.5,2.1,9.6s3.2,7.3,7.3,7.3\n      c1.8,0,3.5-0.7,4.7-1.7l0.3,0.3v0.9L20,22l1.7-1.7L16.2,14.6z M9.5,14.6c-2.8,0-5.1-2.2-5.1-5.1s2.2-5.1,5.1-5.1s5.1,2.2,5.1,5.1\n      S12.2,14.6,9.5,14.6z"/>\n  </g>\n  <g id="zoom_in">\n    <path d="M16.2,14.6h-0.9L15,14.3c1.1-1.2,1.7-3,1.7-4.7c0-4.1-3.2-7.3-7.3-7.3S2.1,5.5,2.1,9.6s3.2,7.3,7.3,7.3\n      c1.8,0,3.5-0.7,4.7-1.7l0.3,0.3v0.9L20,22l1.7-1.7L16.2,14.6z M9.5,14.6c-2.8,0-5.1-2.2-5.1-5.1s2.2-5.1,5.1-5.1s5.1,2.2,5.1,5.1\n      S12.2,14.6,9.5,14.6z M12.2,10.1H10v2.2H8.9v-2.2H6.6V9h2.2V6.8H10V9h2.2V10.1L12.2,10.1z"/>\n  </g>\n  <g id="zoom_out">\n    <path d="M16.2,14.6h-0.9L15,14.3c1.1-1.2,1.7-3,1.7-4.7c0-4.1-3.2-7.3-7.3-7.3S2.1,5.5,2.1,9.6s3.2,7.3,7.3,7.3\n      c1.8,0,3.5-0.7,4.7-1.7l0.3,0.3v0.9L20,22l1.7-1.7L16.2,14.6z M9.5,14.6c-2.8,0-5.1-2.2-5.1-5.1s2.2-5.1,5.1-5.1s5.1,2.2,5.1,5.1\n      S12.2,14.6,9.5,14.6z M6.6,9h5.6v1.2H6.6V9z"/>\n  </g>\n  <g id="fullscreen">\n    <path d="M4.8,14.9H2V22h7.1v-2.8H4.8V14.9z M2,9.2h2.8V4.9H9V2.1H2V9.2z M19.1,19.2h-4.2V22H22v-7.1h-2.8v4.3H19.1z M14.8,2.1v2.8\n      H19v4.2h2.9v-7H14.8z"/>\n  </g>\n  <g id="fullscreen_off">\n    <path d="M2,17.8h4.2V22H9v-7.1H2V17.8z M6.2,6.3H2v2.8h7.1v-7H6.2V6.3z M14.8,22h2.8v-4.2h4.3V15h-7.1C14.8,15,14.8,22,14.8,22z\n      M17.7,6.3V2.1h-2.8v7.1H22V6.3H17.7z"/>\n  </g>\n  <g id="color_palette">\n    <path d="M11.9,2.1c-5.5,0-10,4.5-10,10s4.5,10,10,10c0.9,0,1.7-0.7,1.7-1.7c0-0.4-0.2-0.8-0.4-1.1c-0.2-0.3-0.4-0.7-0.4-1.1\n      c0-0.9,0.7-1.7,1.7-1.7h2c3.1,0,5.6-2.5,5.6-5.6C21.9,6.1,17.4,2.1,11.9,2.1z M5.9,12.1c-0.9,0-1.7-0.7-1.7-1.7S5,8.7,5.9,8.7\n      s1.7,0.7,1.7,1.7S6.8,12.1,5.9,12.1z M9.2,7.7C8.3,7.7,7.5,6.9,7.5,6s0.7-1.7,1.7-1.7S10.9,5,10.9,6S10.1,7.7,9.2,7.7z M14.7,7.7\n      C13.8,7.7,13,6.9,13,6s0.7-1.7,1.7-1.7c0.9,0,1.7,0.7,1.7,1.7S15.6,7.7,14.7,7.7z M18,12.1c-0.9,0-1.7-0.7-1.7-1.7S17,8.7,18,8.7\n      s1.7,0.7,1.7,1.7S18.9,12.1,18,12.1z"/>\n  </g>\n  <g id="color_picker">\n    <path d="M21.6,5L19,2.4c-0.4-0.4-1.2-0.4-1.6,0l-3.5,3.5l-2.1-2.2l-1.6,1.6l1.6,1.6L2,16.8V22h5.2l9.9-9.9l1.6,1.6l1.6-1.6L18.1,10\n      l3.5-3.5C22,6.2,22,5.4,21.6,5z M6.3,19.8l-2.2-2.2l9-8.9l2.2,2.2L6.3,19.8z"/>\n  </g>\n  <g id="trash">\n    <path d="M5.3,19.8c0,1.2,1,2.2,2.2,2.2h8.9c1.2,0,2.2-1,2.2-2.2V6.5H5.3V19.8z M19.7,3.2h-3.9l-1.1-1.1H9.2L8,3.2H4.2v2.2h15.5V3.2\n      L19.7,3.2z"/>\n  </g>\n  <g id="trash_empty">\n    <path d="M5.3,19.8c0,1.2,1,2.2,2.2,2.2h8.9c1.2,0,2.2-1,2.2-2.2V6.5H5.3V19.8z M8,11.9l1.6-1.5l2.3,2.3l2.3-2.3l1.6,1.6l-2.3,2.3\n      l2.3,2.3l-1.6,1.6l-2.3-2.4l-2.3,2.3L8,16.6l2.3-2.3L8,11.9z M15.9,3.2l-1.2-1.1H9.2L8,3.2H4.2v2.2h15.5V3.2H15.9z"/>\n  </g>\n  <g id="developer">\n    <path d="M21.9,9V6.9h-2v-2c0-1.2-0.9-2.1-2-2.1H4c-1.1,0-2,0.9-2,2.1v14.4c0,1.2,0.9,2.1,2,2.1h13.9c1.1,0,2-0.9,2-2.1v-2.1H22\n      v-2.1h-2V13h2v-2h-2V9H21.9z M17.9,19.2H4V4.9h13.9V19.2L17.9,19.2z M6,13.1h5v4.1H6V13.1z M11.9,6.9h4V10h-4V6.9z M6,6.9h5V12H6\n      V6.9z M11.9,11.1h4v6.1h-4V11.1z"/>\n  </g>\n  <g id="hub">\n    <path d="M17.5,16.5L13,12.1V8.6c1.3-0.5,2.2-1.7,2.2-3.2c0-1.8-1.5-3.3-3.3-3.3S8.6,3.6,8.6,5.4c0,1.4,0.9,2.7,2.2,3.2v3.5\n      l-4.4,4.4H2V22h5.6v-3.4l4.4-4.7l4.4,4.7V22H22v-5.6h-4.5V16.5z"/>\n  </g>\n  <g id="camera">\n    <path d="M9.4,10.6l4.7-8.2c-0.7-0.2-1.4-0.2-2.2-0.2C9.5,2.2,7.3,3,5.6,4.4L9.4,10.6L9.4,10.6z M21.4,9.1c-0.9-2.9-3.2-5.2-6-6.3\n      l-3.7,6.3H21.4z M21.8,10.1h-7.5l0.2,0.5l4.7,8.2c1.7-1.7,2.7-4.2,2.7-6.7C21.9,11.4,21.8,10.7,21.8,10.1z M8.5,12.1L4.6,5.3\n      C3,7.1,2,9.5,2,12.1c0,0.7,0.1,1.3,0.2,2h7.5L8.5,12.1z M2.5,15.1c0.9,2.9,3.2,5.2,6,6.3l3.7-6.3C12.2,15.1,2.5,15.1,2.5,15.1z\n      M13.7,15.1l-3.9,6.7C10.5,22,11.2,22,12,22c2.4,0,4.6-0.8,6.3-2.2l-3.7-6.3C14.6,13.5,13.7,15.1,13.7,15.1z"/>\n  </g>\n  <g id="camera_alt">\n    <circle cx="11.9" cy="13.1" r="3.2"/>\n    <path d="M9,3.1l-1.8,2H4c-1.1,0-2,0.9-2,2v12c0,1.1,0.9,2,2,2h15.9c1.1,0,2-0.9,2-2v-12c0-1.1-0.9-2-2-2h-3.2l-1.8-2\n      C14.9,3.1,9,3.1,9,3.1z M11.9,18c-2.7,0-5-2.2-5-5s2.2-5,5-5s5,2.2,5,5S14.7,18,11.9,18z"/>\n  </g>\n  <g id="film">\n    <path d="M13.9,5.9c0-1.1-0.9-1.9-2-1.9H11V3c0-0.5-0.4-0.9-0.9-0.9H6.2C5.7,2.1,5.3,2.5,5.3,3v0.9H4.4c-1.1,0-1.9,0.8-1.9,1.9V20\n      c0,1.1,0.8,1.9,1.9,1.9H12c1.1,0,1.9-0.8,1.9-1.9h7.6V5.9H13.9z M11.9,18.2H10v-1.9h1.9V18.2z M11.9,9.7H10V7.8h1.9V9.7z\n      M15.8,18.2h-1.9v-1.9h1.9V18.2z M15.8,9.7h-1.9V7.8h1.9V9.7z M19.5,18.2h-1.9v-1.9h1.9V18.2z M19.5,9.7h-1.9V7.8h1.9V9.7z"/>\n  </g>\n  <g id="visibility">\n    <path d="M12,5.3c-4.5,0-8.3,2.8-9.9,6.7c1.5,3.9,5.4,6.7,9.9,6.7s8.3-2.8,9.9-6.7C20.3,8,16.5,5.3,12,5.3z M12,16.5\n      c-2.5,0-4.5-2-4.5-4.5s2-4.5,4.5-4.5s4.5,2,4.5,4.5S14.5,16.5,12,16.5z M12,9.2c-1.5,0-2.7,1.2-2.7,2.7s1.2,2.7,2.7,2.7\n      s2.7-1.2,2.7-2.7S13.5,9.2,12,9.2z"/>\n  </g>\n  <g id="visibility_off">\n    <path d="M12,7.4c2.5,0,4.5,2,4.5,4.5c0,0.6-0.1,1.2-0.3,1.7l2.7,2.7c1.3-1.2,2.4-2.6,3.1-4.2c-1.6-4.1-5.4-6.8-9.9-6.8\n      c-1.2,0-2.5,0.2-3.6,0.7l1.9,1.9C10.9,7.5,11.5,7.4,12,7.4z M3.1,4.9l2,2.1l0.4,0.4C4,8.6,2.8,10.2,2.1,11.9c1.6,4,5.4,6.7,9.9,6.7\n      c1.4,0,2.7-0.2,3.9-0.7l0.4,0.4L19,21l1.2-1.2L4.1,3.8L3.1,4.9z M8,9.9l1.4,1.4c-0.1,0.2-0.1,0.4-0.1,0.6c0,1.5,1.2,2.7,2.7,2.7\n      c0.2,0,0.4,0,0.6-0.1L14,16c-0.6,0.3-1.2,0.5-2,0.5c-2.5,0-4.5-2-4.5-4.5C7.5,11.2,7.7,10.5,8,9.9z M11.9,9.2l2.8,2.8v-0.2\n      C14.7,10.4,13.4,9.2,11.9,9.2L11.9,9.2z"/>\n  </g>\n  <g id="layers">\n    <path d="M11.9,19.5l-7.3-5.7L3,15l8.9,7l9-7l-1.6-1.2L11.9,19.5z M11.9,17l7.3-5.7l1.7-1.2l-9-6.9l-9,7l1.6,1.2L11.9,17z"/>\n  </g>\n  <g id="layers_off">\n    <path d="M19.7,16l1.2-0.9l-1.4-1.4l-1.2,0.9L19.7,16z M19.3,11.3l1.7-1.2l-9-7L9,5.3l7.8,7.8C16.9,13.1,19.3,11.3,19.3,11.3z\n      M3.3,2.1L2,3.3l4.2,4.2L2.9,10l1.6,1.2l7.3,5.7l2.1-1.6l1.4,1.4L12,19.4l-7.3-5.7l-1.6,1.2l8.9,7l4.9-3.8l3.7,3.7l1.2-1.2L3.3,2.1\n      z"/>\n  </g>\n  <g id="hamburger">\n    <path d="M20.9,9.1H3.2c-0.6,0-1.1,0.3-1.1,0.7V14c0,0.4,0.5,0.8,1.1,0.8h17.9c0.6,0,1.1-0.3,1.1-0.7V9.9C22,9.4,21.5,9.1,20.9,9.1z\n      M20.9,2.1H3.2c-0.6,0-1.1,0.3-1.1,0.7V7c0,0.4,0.5,0.7,1.1,0.7h17.9c0.6,0,1.1-0.3,1.1-0.7V2.8C22,2.4,21.5,2.1,20.9,2.1z\n      M20.9,16.5H3.2c-0.6,0-1.1,0.3-1.1,0.7v4.2c0,0.4,0.5,0.7,1.1,0.7h17.9c0.6,0,1.1-0.3,1.1-0.7v-4.2C22,16.8,21.5,16.5,20.9,16.5z"\n      />\n  </g>\n  <g id="sliders" transform="translate(0 14)">\n    <path d="M5 1.5q-1.25 0-2.125-0.875T2 -1.5q0-1.25 0.875-2.125T5 -4.5h14q1.25 0 2.125 0.875T22 -1.5q0 1.25-0.875 2.125T19 1.5H5Zm9-2h5q0.425 0 0.713-0.288T20 -1.5q0-0.425-0.288-0.713T19 -2.5h-5v2Z"/>\n  </g>\n  <g id="toggle_on">\n    <path d="M0 0h24v24H0z" fill="none"/><path d="M17 7H7c-2.76 0-5 2.24-5 5s2.24 5 5 5h10c2.76 0 5-2.24 5-5s-2.24-5-5-5zm0 8c-1.66 0-3-1.34-3-3s1.34-3 3-3 3 1.34 3 3-1.34 3-3 3z"/>\n  </g>\n</svg>');var __defProp$L=Object.defineProperty,__getOwnPropDesc$Q=Object.getOwnPropertyDescriptor,__decorateClass$T=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$Q(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$L(target,key,result),result};let IoIcon=class extends IoElement{static get Style(){return"\n      :host {\n        display: inline-block;\n        fill: var(--io_color);\n      }\n      :host[size=small] {\n        width: var(--io_lineHeight);\n        height: var(--io_lineHeight);\n        min-width: var(--io_lineHeight);\n      }\n      :host[size=medium] {\n        width: var(--io_fieldHeight);\n        height: var(--io_fieldHeight);\n        min-width: var(--io_fieldHeight);\n      }\n      :host[size=large] {\n        width: calc(var(--io_fieldHeight) * 2);\n        height: calc(var(--io_fieldHeight) * 2);\n        min-width: calc(var(--io_fieldHeight) * 2);\n      }\n      :host:not([value]) {\n        display: none;\n      }\n      :host[stroke] {\n        stroke: var(--io_colorStrong);\n        stroke-width: var(--io_borderWidth);\n      }\n      :host > svg {\n        height: 100%;\n      }\n      :host > svg > g {\n        transform-origin: 0px 0px;\n      }\n    "}constructor(args){super(args)}valueChanged(){-1!==this.value.search(":")?this.innerHTML=IconsetSingleton.getIcon(this.value):this.innerText=this.value}};__decorateClass$T([ReactiveProperty({value:"",type:String,reflect:!0})],IoIcon.prototype,"value",2),__decorateClass$T([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoIcon.prototype,"stroke",2),__decorateClass$T([ReactiveProperty({value:"small",type:String,reflect:!0})],IoIcon.prototype,"size",2),IoIcon=__decorateClass$T([Register],IoIcon);const ioIcon=function(arg0){return IoIcon.vConstructor(arg0)};var __defProp$K=Object.defineProperty,__getOwnPropDesc$P=Object.getOwnPropertyDescriptor,__decorateClass$S=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$P(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$K(target,key,result),result};let IoField=class extends IoElement{static get Style(){return"\n      :host {\n        cursor: pointer;\n        height: var(--io_fieldHeight);\n        min-height: var(--io_fieldHeight);\n        line-height: var(--io_lineHeight);\n        border: var(--io_border);\n        border-color: transparent;\n        border-radius: var(--io_borderRadius);\n        padding: var(--io_spacing) var(--io_spacing2);\n        color: var(--io_color);\n        text-overflow: ellipsis;\n        white-space: nowrap;\n        font-size: var(--io_fontSize);\n        text-size-adjust: 100%;\n        overflow: hidden;\n        @apply --unselectable;\n      }\n      :host:focus {\n        text-overflow: inherit;\n        @apply --io_focus;\n      }\n      :host[hidden] {\n        display: none;\n      }\n      :host[disabled] {\n        opacity: 0.5;\n      }\n      :host[pressed] {\n        border-color: var(--io_borderColorInset) !important;\n        box-shadow: var(--io_shadowInset) !important;\n      }\n      :host span {\n        height: var(--io_lineHeight);\n        vertical-align: top;\n      }\n      :host[appearance=neutral] {\n        color: var(--io_color);\n        background-color: transparent;\n      }\n      :host[appearance=inset] {\n        color: var(--io_colorInput);\n        background-color: var(--io_bgColorInput);\n        border-color: var(--io_borderColorInset);\n        padding-top: calc(var(--io_spacing) + 0.05em);\n        padding-bottom: calc(var(--io_spacing) - 0.05em);\n        box-shadow: var(--io_shadowInset);\n      }\n      :host[appearance=outset] {\n        border-color: var(--io_borderColorOutset);\n        background-image: var(--io_gradientOutset);\n        box-shadow: var(--io_shadowOutset);\n      }\n      :host.red,\n      :host[invalid] {\n        color: var(--io_colorWhite);\n        background-color: var(--io_bgColorRed);\n        border-color: var(--io_borderColorRed);\n      }\n      :host.green {\n        color: var(--io_colorWhite);\n        background-color: var(--io_bgColorGreen);\n        border-color: var(--io_borderColorGreen);\n      }\n      :host.blue,\n      :host[selected] {\n        color: var(--io_colorWhite);\n        background-color: var(--io_bgColorBlue);\n        border-color: var(--io_borderColorBlue);\n      }\n    "}static get Listeners(){return{focus:"onFocus",pointerdown:"onPointerdown",touchstart:["onTouchstart",{passive:!1}],click:"onClick"}}constructor(args={}){super(args)}onFocus(event){this.addEventListener("blur",this.onBlur),this.addEventListener("keydown",this.onKeydown),this.addEventListener("keyup",this.onKeyup)}onBlur(event){this.removeEventListener("blur",this.onBlur),this.removeEventListener("keydown",this.onKeydown),this.removeEventListener("keyup",this.onKeyup)}onPointerdown(event){event.stopPropagation(),this.setPointerCapture(event.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerleave",this.onPointerleave),this.addEventListener("pointerup",this.onPointerup),this.addEventListener("pointercancel",this.onPointercancel),this.pressed=!0}onPointermove(event){event.stopPropagation()}onPointercancel(event){event.stopPropagation(),this.releasePointerCapture(event.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerleave",this.onPointerleave),this.removeEventListener("pointerup",this.onPointerup),this.removeEventListener("pointercancel",this.onPointercancel),this.pressed=!1}onPointerleave(event){event.stopPropagation(),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerleave",this.onPointerleave),this.removeEventListener("pointerup",this.onPointerup),this.removeEventListener("pointercancel",this.onPointercancel),this.pressed=!1}onPointerup(event){event.stopPropagation(),this.releasePointerCapture(event.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerleave",this.onPointerleave),this.removeEventListener("pointerup",this.onPointerup),this.removeEventListener("pointercancel",this.onPointercancel),this.pressed=!1}onTouchstart(event){event.stopPropagation(),this.addEventListener("touchmove",this.onTouchmove,{passive:!1}),this.addEventListener("touchend",this.onTouchend),this.focus()}onTouchmove(event){event.stopPropagation()}onTouchend(event){event.stopPropagation(),this.removeEventListener("touchmove",this.onTouchmove),this.removeEventListener("touchend",this.onTouchend)}inputValue(value){if(this.value!==value||"object"==typeof this.value){const oldValue=this.value;this.setProperty("value",value),this.dispatch("value-input",{value:value,oldValue:oldValue},!1)}}onClick(event){}onKeydown(event){switch(event.key){case"Enter":case" ":event.preventDefault(),this.onClick();break;default:["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Tab","Home","End","PageUp","PageDown"].includes(event.key)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0))}}onKeyup(event){}getCaretPosition(){let position=0;const selection=window.getSelection();if(selection&&selection.rangeCount){const range=selection.getRangeAt(0),selected=range.toString().length,preCaretRange=range.cloneRange();preCaretRange.selectNodeContents(this),preCaretRange.setEnd(range.endContainer,range.endOffset),position=preCaretRange.toString().length-selected}return position}setCaretPosition(position=0){const selection=window.getSelection();this._flattenTextNode(this);const textNode=this._textNode;if(selection){const range=document.createRange();range.setStart(textNode,Math.max(0,Math.min(position,textNode.length))),range.collapse(!0),selection.removeAllRanges(),selection.addRange(range)}}selectAll(){const selection=window.getSelection();this._flattenTextNode(this);const textNode=this._textNode;if(selection&&textNode){const range=document.createRange();range.selectNodeContents(textNode),selection.removeAllRanges(),selection.addRange(range)}}labelChanged(){this.label?this.setAttribute("aria-label",this.label):this.removeAttribute("aria-label")}selectedChanged(){this.selected?this.setAttribute("aria-selected","true"):this.removeAttribute("aria-selected")}invalidChanged(){this.invalid?this.setAttribute("aria-invalid","true"):this.removeAttribute("aria-invalid")}disabledChanged(){this.inert=this.disabled,this.disabled?this.setAttribute("aria-disabled","true"):this.removeAttribute("aria-disabled")}changed(){this.render([this.icon?ioIcon({value:this.icon}):null,void 0!==this.value?span(String(this.value)):null])}};__decorateClass$S([ReactiveProperty({value:""})],IoField.prototype,"value",2),__decorateClass$S([ReactiveProperty({type:String,value:""})],IoField.prototype,"icon",2),__decorateClass$S([ReactiveProperty({type:String,value:"",reflect:!0})],IoField.prototype,"label",2),__decorateClass$S([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoField.prototype,"selected",2),__decorateClass$S([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoField.prototype,"invalid",2),__decorateClass$S([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoField.prototype,"disabled",2),__decorateClass$S([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoField.prototype,"pressed",2),__decorateClass$S([ReactiveProperty({value:"neutral",reflect:!0})],IoField.prototype,"appearance",2),__decorateClass$S([ReactiveProperty({value:"",type:String,reflect:!0})],IoField.prototype,"pattern",2),__decorateClass$S([Property(!1)],IoField.prototype,"spellcheck",2),__decorateClass$S([Property(0)],IoField.prototype,"tabIndex",2),IoField=__decorateClass$S([Register],IoField);const ioField=function(arg0){return IoField.vConstructor(arg0)};var __defProp$J=Object.defineProperty,__getOwnPropDesc$O=Object.getOwnPropertyDescriptor,__decorateClass$R=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$O(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$J(target,key,result),result};let IoBoolean=class extends IoField{static get Style(){return"\n      :host {\n        padding: var(--io_spacing);\n      }\n    "}constructor(args={}){super(args)}onClick(){this.toggle(),this.dispatch("io-boolean-clicked",{value:this.value},!0)}toggle(){this.inputValue(!this.value)}ready(){this.valueChanged(),this.changed()}valueChanged(){this.invalid="boolean"!=typeof this.value,this.setAttribute("aria-checked",String(!!this.value))}changed(){const value=this.value?this.true:this.false;this.render([this.icon?ioIcon({value:this.icon}):null,value?value.startsWith("io:")?ioIcon({value:value}):span(value):null])}};__decorateClass$R([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoBoolean.prototype,"value",2),__decorateClass$R([ReactiveProperty({value:"true",type:String})],IoBoolean.prototype,"true",2),__decorateClass$R([ReactiveProperty({value:"false",type:String})],IoBoolean.prototype,"false",2),__decorateClass$R([Property("checkbox")],IoBoolean.prototype,"role",2),IoBoolean=__decorateClass$R([Register],IoBoolean);const ioBoolean=function(arg0){return IoBoolean.vConstructor(arg0)};var __defProp$I=Object.defineProperty,__getOwnPropDesc$N=Object.getOwnPropertyDescriptor,__decorateClass$Q=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$N(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$I(target,key,result),result};let IoButton=class extends IoField{static get Style(){return"\n      :host {\n        text-align: center;\n        color: var(--io_colorStrong);\n      }\n      :host > io-icon {\n        margin-right: var(--io_spacing);\n      }\n      :host > span {\n        vertical-align: top;\n      }\n    "}constructor(args={}){super(args)}onPointerdown(event){event.preventDefault(),super.onPointerdown(event)}onKeydown(event){super.onKeydown(event),"Enter"!==event.key&&" "!==event.key||(this.pressed=!0)}onKeyup(event){super.onKeyup(event),this.pressed=!1}onClick(event){"function"==typeof this.action&&this.action(this.value),this.dispatch("io-button-clicked",{value:this.value},!0)}ready(){this.changed()}changed(){this.setAttribute("aria-pressed",String(this.pressed)),this.render([this.icon?ioIcon({value:this.icon}):null,this.label?span(this.label):null])}};__decorateClass$Q([ReactiveProperty({value:void 0})],IoButton.prototype,"value",2),__decorateClass$Q([ReactiveProperty()],IoButton.prototype,"action",2),__decorateClass$Q([ReactiveProperty({value:"outset",type:String,reflect:!0})],IoButton.prototype,"appearance",2),__decorateClass$Q([Property("button")],IoButton.prototype,"role",2),IoButton=__decorateClass$Q([Register],IoButton);const ioButton=function(arg0){return IoButton.vConstructor(arg0)};var __defProp$H=Object.defineProperty,__getOwnPropDesc$M=Object.getOwnPropertyDescriptor,__decorateClass$P=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$M(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$H(target,key,result),result};let IoNumberLadderStep=class extends IoField{static get Style(){return"\n      :host {\n        pointer-events: all;\n        display: inline-block;\n        cursor: ew-resize;\n        text-align: center;\n        background-color: var(--io_bgColorStrong) !important;\n        color: var(--io_color);\n        align-self: stretch;\n        touch-action: none;\n        width: 6em;\n      }\n      :host:focus {\n        background-color: var(--io_bgColor) !important;\n      }\n      /* TODO: use icons */\n      :host:before {\n        float: left;\n        content: '<';\n        opacity: 0.25;\n      }\n      :host:after {\n        float: right;\n        content: '>';\n        opacity: 0.25;\n      }\n    "}constructor(args){super(args)}onKeydown(event){let stepMove=0;switch(event.key){case"Enter":case"Escape":case" ":this.dispatch("ladder-step-collapse",{},!0);break;case"ArrowLeft":case"Backspace":event.preventDefault(),stepMove=-1*this.value;break;case"ArrowUp":case"ArrowDown":event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0);break;case"ArrowRight":event.preventDefault(),stepMove=1*this.value}0!==stepMove&&this.dispatch("ladder-step-change",{step:Number(stepMove.toFixed(5)),round:event.shiftKey},!0)}onPointerdown(event){this.setPointerCapture(event.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),this.startX=event.clientX}onPointermove(event){const deltaX=event.clientX-this.startX;if(Math.abs(deltaX)>5){const expMove=Math.pow(deltaX/5,2)*deltaX<0?-1:1,roundMove=deltaX>0?Math.floor(expMove):Math.ceil(expMove),stepMove=this.value*roundMove;this.startX=event.clientX,this.dispatch("ladder-step-change",{step:Number(stepMove.toFixed(5)),round:event.shiftKey},!0)}}onPointerup(event){this.releasePointerCapture(event.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this.dispatch("ladder-step-collapse",{},!0)}ready(){this.changed()}changed(){this.render([span(this.label)]),this.setAttribute("aria-label",this.label),this.setAttribute("aria-valuestep",this.label)}};__decorateClass$P([ReactiveProperty({value:1,type:Number})],IoNumberLadderStep.prototype,"value",2),__decorateClass$P([ReactiveProperty({value:"",type:String})],IoNumberLadderStep.prototype,"label",2),__decorateClass$P([Property("spinbutton")],IoNumberLadderStep.prototype,"role",2),IoNumberLadderStep=__decorateClass$P([Register],IoNumberLadderStep);const ioNumberLadderStep=function(arg0){return IoNumberLadderStep.vConstructor(arg0)};var __defProp$G=Object.defineProperty,__getOwnPropDesc$L=Object.getOwnPropertyDescriptor,__decorateClass$O=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$L(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$G(target,key,result),result};let IoNumberLadder=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n        position: absolute;\n        pointer-events: none;\n        box-shadow: unset;\n        @apply --unselectable;\n      }\n      :host:not([expanded]) {\n        visibility: hidden;\n      }\n      :host > io-number-ladder-step {\n        box-shadow: var(--io_shadow);\n      }\n      :host > .io-up1,\n      :host > .io-up2,\n      :host > .io-up3,\n      :host > .io-up4 {\n        margin-bottom: var(--io_borderWidth);\n        box-shadow: 0px -2px 6px var(--io_shadowColor), 0 -1px 3px var(--io_shadowColor);\n      }\n      :host > .io-down1,\n      :host > .io-down2,\n      :host > .io-down3,\n      :host > .io-down4 {\n        margin-top: var(--io_borderWidth);\n        box-shadow: 0px 2px 6px var(--io_shadowColor), 0 1px 3px var(--io_shadowColor);\n      }\n      :host > .io-up1,\n      :host > .io-down1{\n        z-index: 4;\n      }\n      :host > .io-up2,\n      :host > .io-down2 {\n        z-index: 3;\n      }\n      :host > .io-up3,\n      :host > .io-down3 {\n        z-index: 2;\n      }\n      :host > .io-up4,\n      :host > .io-down4 {\n        z-index: 1;\n      }\n      :host > io-number-ladder-step:focus {\n        background-color: var(--io_bgColorStrong);\n        border-color: var(--io_colorBlue);\n      }\n      :host > .io-number-ladder-empty {\n        height: var(--io_fieldHeight);\n      }\n      :host > .io-number-ladder-center {\n        height: calc(1.5 * var(--io_fieldHeight));\n      }\n    "}static get Listeners(){return{"ladder-step-change":"_onLadderStepChange","ladder-step-collapse":"onLadderStepCollapse","io-focus-to":"onIoFocusTo"}}get value(){return this.src?this.src.value:0}get min(){return this.src?this.src.min:-Infinity}get max(){return this.src?this.src.max:Infinity}get step(){return this.src?this.src.step:1e-4}get conversion(){return this.src?this.src.conversion:1}constructor(args={}){super(args)}onIoFocusTo(event){const source=event.detail.source,command=event.detail.command;this.src&&("ArrowDown"===command&&source===this.querySelector(".io-up1")||"ArrowUp"===command&&source===this.querySelector(".io-down1"))&&(event.stopPropagation(),this.src.focus(),this.src.setCaretPosition(this.src.textNode.length))}_onLadderStepChange(event){const src=this.src;if(src){const step=event.detail.step,value=event.detail.round?Math.round(this.value/step)*step:this.value;let newValue=Math.min(this.max,Math.max(this.min,value+step));newValue=Number(newValue.toFixed(5)),src.inputValue(newValue)}}onLadderStepCollapse(){this.setProperty("expanded",!1)}expandedChanged(){if(this.expanded){if(this.src){const rect=this.src.getBoundingClientRect(),selfRect=this.getBoundingClientRect(),layerRect=IoOverlaySingleton.getBoundingClientRect();this.style.top=rect.bottom-layerRect.top+"px",this.style.left=rect.left-layerRect.left+"px",this.style.marginTop=-(selfRect.height/2+ThemeSingleton.lineHeight/2+ThemeSingleton.spacing)+"px"}}else setTimeout(()=>{this.src?.setCaretPosition(this.src.textNode.length)}),this.removeAttribute("style");this.dispatch("expanded",{value:this.expanded},!0)}changed(){const range=this.max-this.min,hiddenItem=span({class:"io-number-ladder-empty"});let step=this.step/1e4;for(;step<.1;)step*=10;const upStep4=1e4*step,upStep3=1e3*step,upStep2=100*step,upStep1=10*step,downStep1=1*step,downStep2=.1*step,downStep3=.01*step,downStep4=.001*step,upLabel4=Number((upStep4*this.conversion).toFixed(6)),upLabel3=Number((upStep3*this.conversion).toFixed(6)),upLabel2=Number((upStep2*this.conversion).toFixed(6)),upLabel1=Number((upStep1*this.conversion).toFixed(6)),downLabel1=Number((downStep1*this.conversion).toFixed(6)),downLabel2=Number((downStep2*this.conversion).toFixed(6)),downLabel3=Number((downStep3*this.conversion).toFixed(6)),downLabel4=Number((downStep4*this.conversion).toFixed(6));this.render([range>=upStep4?ioNumberLadderStep({class:"io-up4",value:upStep4,label:String(upLabel4)}):hiddenItem,range>=upStep3?ioNumberLadderStep({class:"io-up3",value:upStep3,label:String(upLabel3)}):hiddenItem,range>=upStep2?ioNumberLadderStep({class:"io-up2",value:upStep2,label:String(upLabel2)}):hiddenItem,range>=upStep1?ioNumberLadderStep({class:"io-up1",value:upStep1,label:String(upLabel1)}):hiddenItem,span({class:"io-number-ladder-center"}),this.step<=downStep1?ioNumberLadderStep({class:"io-down1",value:downStep1,label:String(downLabel1)}):hiddenItem,this.step<=downStep2?ioNumberLadderStep({class:"io-down2",value:downStep2,label:String(downLabel2)}):hiddenItem,this.step<=downStep3?ioNumberLadderStep({class:"io-down3",value:downStep3,label:String(downLabel3)}):hiddenItem,this.step<=downStep4?ioNumberLadderStep({class:"io-down4",value:downStep4,label:String(downLabel4)}):hiddenItem]),this.setAttribute("aria-valuemin",this.min),this.setAttribute("aria-valuemax",this.max),this.setAttribute("aria-valuenow",this.value),this.setAttribute("aria-valuestep",this.step),this.setAttribute("aria-invalid",!("number"==typeof this.value&&!isNaN(this.value))&&"true");const steps=this.querySelectorAll("io-number-ladder-step");for(let i=steps.length;i--;)steps[i].setAttribute("aria-valuemin",String(this.min)),steps[i].setAttribute("aria-valuemax",String(this.max)),steps[i].setAttribute("aria-valuenow",String(this.value)),steps[i].changed()}};__decorateClass$O([ReactiveProperty({value:void 0,type:IoElement,init:null})],IoNumberLadder.prototype,"src",2),__decorateClass$O([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoNumberLadder.prototype,"expanded",2),__decorateClass$O([Property("listbox")],IoNumberLadder.prototype,"role",2),IoNumberLadder=__decorateClass$O([Register],IoNumberLadder);const IoNumberLadderSingleton=new IoNumberLadder;setTimeout(()=>{IoOverlaySingleton.appendChild(IoNumberLadderSingleton)},100);var __defProp$F=Object.defineProperty,__getOwnPropDesc$K=Object.getOwnPropertyDescriptor,__decorateClass$N=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$K(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$F(target,key,result),result};let IoNumber=class extends IoField{static get Style(){return"\n      :host {\n        cursor: text;\n        user-select: text;\n        -webkit-user-select: text;\n        -webkit-touch-callout: default;\n        font-family: monospace;\n      }\n      :host[placeholder]:empty:before {\n        content: attr(placeholder);\n        visibility: visible;\n        color: var(--io_colorInput);\n        padding: 0 calc(var(--io_spacing) + var(--io_borderWidth));\n        opacity: 0.5;\n      }\n    "}constructor(args={}){super(args)}get textNode(){return this._flattenTextNode(this),this._textNode.nodeValue}set textNode(value){this._flattenTextNode(this),this._textNode.nodeValue=String(value)}onBlur(event){super.onBlur(event),this._setFromTextNode(),this.scrollTop=0,this.scrollLeft=0,setTimeout(()=>{document.activeElement.parentElement!==IoNumberLadderSingleton&&(IoNumberLadderSingleton.expanded=!1)})}onPointerdown(event){this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),document.activeElement!==this||event.button}onPointerup(event){this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this.ladder||1===event.button?("touch"===event.pointerType?(event.preventDefault(),document.activeElement.blur()):document.activeElement!==this&&(this.focus(),this.setCaretPosition(this.textNode.length)),this.expandLadder()):document.activeElement!==this&&(this.focus(),this.setCaretPosition(this.textNode.length))}expandLadder(){IoNumberLadderSingleton.src=this,IoNumberLadderSingleton.expanded=!0}collapseLadder(){IoNumberLadderSingleton.expanded=!1}onKeydown(event){const range=window.getSelection().getRangeAt(0),rangeStart=range.startOffset,rangeEnd=range.endOffset,length=this.childNodes[0]?this.childNodes[0].length:0,rangeInside=range.startContainer===range.endContainer&&(range.startContainer===this.childNodes[0]||range.startContainer===this);switch(event.key){case"Escape":case"Enter":case" ":event.preventDefault(),this._setFromTextNode(),function isMobileDevice(){return/Mobi|Android|iPhone|iPad|iPod|Opera Mini|IEMobile|Mobile/i.test(navigator.userAgent)||"ontouchstart"in window&&!window.matchMedia("(pointer: fine)").matches}()&&this.blur();break;case"Home":event.preventDefault(),this.textNode=String(this.min),this._setFromTextNode();break;case"End":event.preventDefault(),this.textNode=String(this.max),this._setFromTextNode();break;case"ArrowLeft":(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&0===rangeStart)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0));break;case"ArrowUp":if(IoNumberLadderSingleton.expanded){event.preventDefault();const upStep=IoNumberLadderSingleton.querySelector(".io-up1");upStep&&upStep.focus()}else(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&0===rangeStart)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0));break;case"ArrowRight":(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&rangeStart===length)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0));break;case"ArrowDown":if(IoNumberLadderSingleton.expanded){event.preventDefault();const downStep=IoNumberLadderSingleton.querySelector(".io-down1");downStep&&downStep.focus()}else(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&rangeStart===length)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0))}}onKeyup(event){if("Control"===event.key||"Shift"===event.key?IoNumberLadderSingleton.expanded?this.collapseLadder():this.expandLadder():"Escape"!==event.key&&"Enter"!==event.key&&" "!==event.key||this.collapseLadder(),this.live){const carretPosition=this.getCaretPosition();this._setFromTextNode(),this.setCaretPosition(carretPosition)}}_setFromTextNode(){const valueText=this.textNode.trim().replace(",",".");let valueNumber=Number(valueText)/this.conversion;valueNumber=Math.min(this.max,Math.max(this.min,valueNumber)),valueNumber=Math.round(valueNumber/this.step)*this.step;const d=Math.max(0,Math.min(100,-Math.floor(Math.log(this.step)/Math.LN10)));valueNumber=Number(valueNumber.toFixed(d)),isNaN(valueNumber)?(this._reactiveProperties.get("invalid").value=!0,this.setAttribute("invalid","true"),this.setAttribute("aria-invalid","true")):(this._reactiveProperties.get("invalid").value=!1,this.removeAttribute("invalid"),this.removeAttribute("aria-invalid"),this.inputValue(valueNumber))}ready(){this.disabledChanged(),this.changed()}changed(){this.setAttribute("aria-valuenow",this.value),this.setAttribute("aria-valuemin",this.min),this.setAttribute("aria-valuemax",this.max),this.setAttribute("aria-valuestep",this.step),"number"!=typeof this.value||isNaN(this.value)?(this.setAttribute("invalid","true"),this.setAttribute("aria-invalid","true")):(this.removeAttribute("invalid"),this.removeAttribute("aria-invalid"));let valueText,value=this.value;if("number"!=typeof value||isNaN(value))valueText="NaN";else{value*=this.conversion;let d=-Math.floor(Math.log(this.step*this.conversion)/Math.LN10);d=Math.max(0,Math.min(100,d)),value=Number(value.toFixed(d)),valueText=String(value)}this.setAttribute("value",valueText),this.setAttribute("positive",this.value>=0),this.textNode=valueText}};__decorateClass$N([ReactiveProperty({value:0,type:Number})],IoNumber.prototype,"value",2),__decorateClass$N([ReactiveProperty({value:!1,type:Boolean})],IoNumber.prototype,"live",2),__decorateClass$N([ReactiveProperty({value:1,type:Number})],IoNumber.prototype,"conversion",2),__decorateClass$N([ReactiveProperty({value:1e-4,type:Number})],IoNumber.prototype,"step",2),__decorateClass$N([ReactiveProperty({value:-Infinity,type:Number})],IoNumber.prototype,"min",2),__decorateClass$N([ReactiveProperty({value:Infinity,type:Number})],IoNumber.prototype,"max",2),__decorateClass$N([ReactiveProperty({value:!1,type:Boolean})],IoNumber.prototype,"ladder",2),__decorateClass$N([ReactiveProperty({value:"inset",type:String,reflect:!0})],IoNumber.prototype,"appearance",2),__decorateClass$N([Property("true")],IoNumber.prototype,"contentEditable",2),__decorateClass$N([ReactiveProperty({value:'pattern="-?[0-9]*?[0-9]*"',type:String,reflect:!0})],IoNumber.prototype,"pattern",2),__decorateClass$N([Property("text")],IoNumber.prototype,"inputMode",2),__decorateClass$N([Property("textbox")],IoNumber.prototype,"role",2),IoNumber=__decorateClass$N([Register],IoNumber);const ioNumber=function(arg0){return IoNumber.vConstructor(arg0)};var __defProp$E=Object.defineProperty,__getOwnPropDesc$J=Object.getOwnPropertyDescriptor,__decorateClass$M=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$J(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$E(target,key,result),result};let IoString=class extends IoField{static get Style(){return"\n      :host {\n        cursor: text;\n        user-select: text;\n        -webkit-user-select: text;\n        -webkit-touch-callout: default;\n      }\n      :host[placeholder]:empty:before {\n        content: attr(placeholder);\n        visibility: visible;\n        color: var(--io_colorInput);\n        padding: 0 calc(var(--io_spacing) + var(--io_borderWidth));\n        opacity: 0.5;\n      }\n    "}constructor(args={}){super(args)}onPointerdown(event){this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),document.activeElement!==this||event.button}onPointerup(event){this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),document.activeElement!==this&&(this.focus(),this.setCaretPosition(this.textNode.length))}get textNode(){return this._flattenTextNode(this),this._textNode.nodeValue}set textNode(value){this._flattenTextNode(this),this._textNode.nodeValue=String(value)}_setFromTextNode(){const textNode=this.textNode;"string"==typeof this.value&&textNode!==String(this.value)&&this.inputValue(textNode)}_setObjectFromTextNodeJSON(){const textNode=this.textNode;try{const value=JSON.parse(textNode.replace(/[\t\n\r ]+/g," "));this.inputValue(value)}catch(error){console.warn("IoString: Cannot parse value",textNode),console.error(error),this._setFromTextNode()}}onBlur(event){super.onBlur(event),this._setFromTextNode(),this.scrollTop=0,this.scrollLeft=0}onKeydown(event){const range=window.getSelection().getRangeAt(0),rangeStart=range.startOffset,rangeEnd=range.endOffset,length=this.childNodes[0]?this.childNodes[0].length:0,rangeInside=range.startContainer===range.endContainer&&(range.startContainer===this.childNodes[0]||range.startContainer===this);switch(event.key){case"Enter":event.preventDefault(),event.shiftKey?this._setObjectFromTextNodeJSON():this._setFromTextNode();break;case"ArrowLeft":(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&0===rangeStart)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:"ArrowLeft"},!0));break;case"ArrowUp":(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&0===rangeStart)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:"ArrowUp"},!0));break;case"ArrowRight":(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&rangeStart===length)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:"ArrowRight"},!0));break;case"ArrowDown":(event.ctrlKey||rangeInside&&rangeStart===rangeEnd&&rangeStart===length)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:"ArrowDown"},!0));break;default:["Tab","Home","End","PageUp","PageDown"].includes(event.key)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0))}}onKeyup(event){if(super.onKeyup(event),this.live){const carretPosition=this.getCaretPosition();this._setFromTextNode(),this.setCaretPosition(carretPosition)}}ready(){this.disabledChanged()}valueChanged(){this.invalid="string"!=typeof this.value&&null!==this.value&&void 0!==this.value}changed(){this.textNode=String(this.value||"")}};__decorateClass$M([ReactiveProperty({value:"",type:String})],IoString.prototype,"value",2),__decorateClass$M([ReactiveProperty({value:!1,type:Boolean})],IoString.prototype,"live",2),__decorateClass$M([ReactiveProperty({value:"",type:String,reflect:!0})],IoString.prototype,"placeholder",2),__decorateClass$M([ReactiveProperty({value:"inset",reflect:!0})],IoString.prototype,"appearance",2),__decorateClass$M([Property("true")],IoString.prototype,"contentEditable",2),__decorateClass$M([Property("textbox")],IoString.prototype,"role",2),IoString=__decorateClass$M([Register],IoString);const ioString=function(arg0){return IoString.vConstructor(arg0)};var __getOwnPropDesc$I=Object.getOwnPropertyDescriptor;let IoSwitch=class extends IoBoolean{static get Style(){return"\n      :host {\n        display: flex;\n        position: relative;\n        overflow: visible;\n        padding: var(--io_spacing) var(--io_spacing);\n      }\n      :host:focus {\n        outline: 0 !important;\n        border-color: transparent !important;\n      }\n      :host:focus > span:before {\n        @apply --io_focus;\n      }\n      :host[pressed] {\n        border-color: transparent !important;\n        box-shadow: none !important;\n      }\n      :host > span {\n        position: relative;\n        width: calc(1.5 * var(--io_fieldHeight));\n      }\n      :host > span:before {\n        content: '';\n        box-sizing: border-box;\n        position: absolute;\n        visibility: visible;\n        left: 0;\n        width: 100%;\n        height: var(--io_lineHeight);\n        border-radius: var(--io_lineHeight);\n        border: var(--io_border);\n        border-color: var(--io_borderColorInset);\n        background-color: var(--io_bgColorInput);\n        box-shadow: var(--io_shadowInset);\n        transition: background-color 0.4s;\n      }\n      :host > span:after {\n        content: '';\n        box-sizing: border-box;\n        position: absolute;\n        visibility: visible;\n        top: var(--io_borderWidth);\n        left: var(--io_borderWidth);\n        height: calc(var(--io_lineHeight) - calc(2 * var(--io_borderWidth)));\n        width: calc(var(--io_lineHeight) - calc(2 * var(--io_borderWidth)));\n        background-color: var(--io_bgColorLight);\n        box-shadow: var(--io_shadowOutset);\n        border: var(--io_border);\n        border-color: var(--io_borderColorOutset);\n        border-radius: var(--io_lineHeight);\n        transition-timing-function: ease-in-out;\n        transition: left 0.25s;\n        z-index: 1;\n      }\n      :host[value] > span:after {\n        background-color: var(--io_bgColorBlue);\n        left: calc(100% - calc(var(--io_lineHeight) - var(--io_borderWidth)));\n      }\n    "}changed(){this.render([this.icon?ioIcon({value:this.icon}):null,span()])}};IoSwitch=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$I(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],IoSwitch);const ioSwitch=function(arg0){return IoSwitch.vConstructor(arg0)};var __defProp$D=Object.defineProperty,__getOwnPropDesc$H=Object.getOwnPropertyDescriptor,__decorateClass$K=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$H(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$D(target,key,result),result};let IoVectorBase=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex: 1 1 auto;\n        max-width: 100%;\n        overflow: hidden;\n      }\n      :host > io-number {\n        flex: 1 1 0;\n      }\n      :host > *:not(:last-child) {\n        margin-right: var(--io_spacing);\n      }\n      :host > io-boolicon {\n        flex-shrink: 0;\n        padding: var(--io_spacing);\n      }\n    "}_ratios={};constructor(args){super(args)}_onNumberPointerDown(event){const id=event.composedPath()[0].id;if(this._ratios={},this.linked&&0!==this.value[id]){const value=this.value;for(const k of this.keys)this._ratios[k]=value[k]/value[id]}}_onNumberValueInput(event){const id=event.composedPath()[0].id;if(this.value[id]=event.detail.value,this.linked)for(const k of this.keys){const value=this.value;k!==id&&this._ratios[k]&&(value[k]=value[id]*this._ratios[k])}this.value._isNode||this.dispatchMutation(this.value)}valueMutated(){this.debounce(this.changed)}changed(){const vChildren=[];for(const k of this.keys){const value=this.value[k];void 0!==value&&vChildren.push(ioNumber({id:k,value:value,conversion:this.conversion,step:this.step,min:this.min,max:this.max,ladder:this.ladder,disabled:this.disabled,"@pointerdown":this._onNumberPointerDown,"@value-input":this._onNumberValueInput}))}vChildren.push(this.linkable?ioBoolean({value:this.bind("linked"),true:"io:link",false:"io:unlink"}):null),this.render(vChildren)}};__decorateClass$K([ReactiveProperty({type:Object,init:null})],IoVectorBase.prototype,"value",2),__decorateClass$K([ReactiveProperty(1)],IoVectorBase.prototype,"conversion",2),__decorateClass$K([ReactiveProperty(.001)],IoVectorBase.prototype,"step",2),__decorateClass$K([ReactiveProperty(-Infinity)],IoVectorBase.prototype,"min",2),__decorateClass$K([ReactiveProperty(Infinity)],IoVectorBase.prototype,"max",2),__decorateClass$K([ReactiveProperty(!1)],IoVectorBase.prototype,"linkable",2),__decorateClass$K([ReactiveProperty(!1)],IoVectorBase.prototype,"linked",2),__decorateClass$K([ReactiveProperty(!0)],IoVectorBase.prototype,"ladder",2),__decorateClass$K([ReactiveProperty(!1)],IoVectorBase.prototype,"disabled",2),__decorateClass$K([Property([])],IoVectorBase.prototype,"keys",2),IoVectorBase=__decorateClass$K([Register],IoVectorBase);var __defProp$C=Object.defineProperty,__getOwnPropDesc$G=Object.getOwnPropertyDescriptor,__decorateClass$J=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$G(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$C(target,key,result),result};let IoEuler=class extends IoVectorBase{constructor(args){super(args)}};__decorateClass$J([ReactiveProperty({type:Euler,init:null})],IoEuler.prototype,"value",2),__decorateClass$J([Property(["x","y","z"])],IoEuler.prototype,"keys",2),IoEuler=__decorateClass$J([Register],IoEuler);const ioEuler=function(arg0){return IoEuler.vConstructor(arg0)};var __defProp$B=Object.defineProperty,__getOwnPropDesc$F=Object.getOwnPropertyDescriptor,__decorateClass$I=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$F(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$B(target,key,result),result};let IoMatrixBase=class extends IoElement{static get Style(){return"\n      :host {\n        display: grid;\n        align-self: stretch;\n        justify-self: stretch;\n        grid-gap: var(--io_spacing);\n        max-width: 100%;\n        overflow: hidden;\n        flex: 1 1 auto;\n      }\n      :host > io-number {\n        flex: 1 1 auto;\n      }\n      :host > *:not(:last-child) {\n        margin-right: 0;\n      }\n      :host > io-boolicon {\n        flex-shrink: 0;\n        padding: var(--io_spacing);\n      }\n    "}constructor(args){super(args)}_onNumberValueInput(event){const item=event.composedPath()[0];this.value[item.id]=event.detail.value,this.value._isNode||this.dispatchMutation(this.value),this.dispatch("value-input",{property:item.id,value:this.value},!1)}valueChanged(){this.keys.length=0,this.keys=Array.from(Array(this.value.length).keys())}valueMutated(){this.debounce(this.changed)}changed(){const vChildren=[];for(const k of this.keys)void 0!==this.value[k]&&vChildren.push(ioNumber({id:String(k),value:this.value[k],step:1e-5,disabled:this.disabled,"@value-input":this._onNumberValueInput}));this.render(vChildren)}};__decorateClass$I([ReactiveProperty({type:Array})],IoMatrixBase.prototype,"value",2),__decorateClass$I([ReactiveProperty({value:!1,type:Boolean})],IoMatrixBase.prototype,"disabled",2),__decorateClass$I([Property({type:Array,init:null})],IoMatrixBase.prototype,"keys",2),IoMatrixBase=__decorateClass$I([Register],IoMatrixBase);var __getOwnPropDesc$E=Object.getOwnPropertyDescriptor;let IoMatrix2=class extends IoMatrixBase{static get Style(){return"\n      :host {\n        grid-template-columns: repeat(2, 1fr);\n      }\n    "}};IoMatrix2=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$E(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],IoMatrix2);var __getOwnPropDesc$D=Object.getOwnPropertyDescriptor;let IoMatrix3=class extends IoMatrixBase{static get Style(){return"\n      :host {\n        grid-template-columns: repeat(3, 1fr);\n      }\n    "}};IoMatrix3=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$D(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],IoMatrix3);var __getOwnPropDesc$C=Object.getOwnPropertyDescriptor;let IoMatrix4=class extends IoMatrixBase{static get Style(){return"\n      :host {\n        grid-template-columns: repeat(4, 1fr);\n      }\n    "}};IoMatrix4=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$C(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],IoMatrix4);var __defProp$A=Object.defineProperty,__getOwnPropDesc$B=Object.getOwnPropertyDescriptor,__decorateClass$E=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$B(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$A(target,key,result),result};let IoQuaternion=class extends IoVectorBase{constructor(args){super(args)}};__decorateClass$E([ReactiveProperty({type:Quaternion,init:null})],IoQuaternion.prototype,"value",2),__decorateClass$E([Property(["x","y","z","w"])],IoQuaternion.prototype,"keys",2),IoQuaternion=__decorateClass$E([Register],IoQuaternion);const ioQuaternion=function(arg0){return IoQuaternion.vConstructor(arg0)};var __defProp$z=Object.defineProperty,__getOwnPropDesc$A=Object.getOwnPropertyDescriptor,__decorateClass$D=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$A(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$z(target,key,result),result};let IoVector2=class extends IoVectorBase{constructor(args){super(args)}};__decorateClass$D([ReactiveProperty({type:Vector2,init:null})],IoVector2.prototype,"value",2),__decorateClass$D([Property(["x","y"])],IoVector2.prototype,"keys",2),IoVector2=__decorateClass$D([Register],IoVector2);var __defProp$y=Object.defineProperty,__getOwnPropDesc$z=Object.getOwnPropertyDescriptor,__decorateClass$C=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$z(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$y(target,key,result),result};let IoVector3=class extends IoVectorBase{constructor(args){super(args)}};__decorateClass$C([ReactiveProperty({type:Vector3,init:null})],IoVector3.prototype,"value",2),__decorateClass$C([Property(["x","y","z"])],IoVector3.prototype,"keys",2),IoVector3=__decorateClass$C([Register],IoVector3);const ioVector3=function(arg0){return IoVector3.vConstructor(arg0)};var __defProp$x=Object.defineProperty,__getOwnPropDesc$y=Object.getOwnPropertyDescriptor,__decorateClass$B=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$y(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$x(target,key,result),result};let IoVector4=class extends IoVectorBase{constructor(args){super(args)}};__decorateClass$B([ReactiveProperty({type:Vector4,init:null})],IoVector4.prototype,"value",2),__decorateClass$B([Property(["x","y","z","w"])],IoVector4.prototype,"keys",2),IoVector4=__decorateClass$B([Register],IoVector4);const ioVector4=function(arg0){return IoVector4.vConstructor(arg0)};var __defProp$w=Object.defineProperty,__getOwnPropDesc$x=Object.getOwnPropertyDescriptor,__decorateClass$A=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$x(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$w(target,key,result),result};let MenuOption=class extends ReactiveNode{static get Listeners(){return{"option-selected-changed":"onOptionSelectedChanged"}}constructor(args){"string"!=typeof args&&"number"!=typeof args&&"boolean"!=typeof args&&null!=args||(args={id:String(args),value:args}),(args={...args}).id=args.id??"",args.label=args.label??args.id,args.value=args.value??args.id,args.options=args.options??[],args.options=args.options.map(option=>option instanceof MenuOption?option:new MenuOption(option));const selectedOptions=args.options.filter(option=>"select"===option.mode&&option.selected);for(let i=1;i<selectedOptions.length;i++)console.warn('Duplicate selected options with mode "select" found!',selectedOptions),selectedOptions[i].selected=!1;super(args)}getAllOptions(){const options=[this];for(let i=0;i<this.options.length;i++)options.push(...this.options[i].getAllOptions());{const ids=/* @__PURE__ */new Set;for(let i=0;i<options.length;i++)ids.has(options[i].id)&&console.warn(`Duplicate id "${options[i].id}"`,this),ids.add(options[i].id)}return options}findItemByValue(value){const allItems=this.getAllOptions();for(let i=0;i<allItems.length;i++)if(allItems[i].value===value)return allItems[i]}findItemById(id){const allItems=this.getAllOptions();for(let i=0;i<allItems.length;i++)if(allItems[i].id===id)return allItems[i]}selectDefault(){let walker="select"===this.mode?this:void 0;for(;walker;){const next=walker.options.find(option=>"select"===option.mode);if("select"!==walker.mode||!next)break;walker=next}walker&&(walker.selected=!0)}selectedChanged(){!1===this.selected&&this.unselectSuboptions(),this.dispatch("option-selected-changed",{option:this},!0)}selectedIDChanged(){const option=this.findItemById(this.selectedID);option&&(option.selected=!0,this.dispatch("option-selected",{option:option},!1))}selectedIDImmediateChanged(){if(this.selectedIDImmediate){this.selected=!0;const option=this.options.find(option2=>option2.id===this.selectedIDImmediate);option&&(option.selected=!0)}this.updatePaths()}getSelectedIDImmediate(){let selected="";for(let i=0;i<this.options.length;i++){const item=this.options[i];if(item.selected&&item.id&&"select"===item.mode){selected=item.id;break}}return selected}setSelectedIDImmediate(id){this.options.withInternalOperation(()=>{for(let i=0;i<this.options.length;i++){const item=this.options[i];item.id===id?item.selected=!0:item.selected=!1}}),this.options.dispatchMutation()}onOptionSelectedChanged(event){if(-1===this.options.indexOf(event.detail.option))return;if(event.detail.option===this)return;const selectedOption=event.detail.option;if(selectedOption.selected)for(let i=0;i<this.options.length;i++){const option=this.options[i];option!==selectedOption&&"select"===option.mode&&"select"===selectedOption.mode&&(option.selected=!1)}this.options.some(option=>option.selected&&"select"===option.mode)||this.setProperties({selectedID:"",selectedIDImmediate:"",path:""})}unselectSuboptions(){for(let i=0;i<this.options.length;i++){const option=this.options[i];"select"===option.mode&&(option.selected=!1,option.unselectSuboptions())}}updatePaths(){const path=[];if("select"!==this.mode||!this.selected)return void(this.path="");let selectedIDImmediate=this.getSelectedIDImmediate(),walker=selectedIDImmediate?this.options.find(option=>"select"===option.mode&&option.selected&&option.id===selectedIDImmediate):void 0;if(walker){for(;walker;)path.push(walker.id),selectedIDImmediate=walker.getSelectedIDImmediate(),walker=selectedIDImmediate?walker.options.find(option=>"select"===option.mode&&option.selected&&option.id===selectedIDImmediate):void 0;this.path=path.join(",")}}pathChanged(){const path=this.path?[...this.path.split(",")]:[];path.length&&(this.selectedID=path[path.length-1])}optionsMutated(event){const selectedIDImmediate=this.getSelectedIDImmediate();"select"===this.mode&&selectedIDImmediate&&this.options.length&&this.setProperties({selected:!0,selectedIDImmediate:selectedIDImmediate}),this.updatePaths(),this.dispatchMutation()}toJSON(){return{id:this.id,value:this.value,label:this.label,icon:this.icon,hint:this.hint,disabled:this.disabled,mode:this.mode,options:this.options.map(option=>option.toJSON())}}fromJSON(json){return this.setProperties({id:json.id,value:json.value??void 0,label:json.label??json.id,icon:json.icon??"",hint:json.hint??"",disabled:json.disabled??!1,mode:json.mode??"select",selected:json.selected??!1,options:json.options?.map(option=>new MenuOption(option))??[]}),this}changed(){-1===["select","toggle","none"].indexOf(this.mode)&&console.warn(`Unknown "mode" property "${this.mode}"!`,this),this.selected&&-1===["select","toggle"].indexOf(this.mode)&&console.warn('"selected" property is only valid when mode is "select" or "toggle"!',this),this.action&&"function"!=typeof this.action&&console.warn(`Invalid type "${typeof this.action}" of "action" property!`,this)}dispose(){this.options.length=0,super.dispose()}};__decorateClass$A([ReactiveProperty({value:"",type:String})],MenuOption.prototype,"id",2),__decorateClass$A([ReactiveProperty({value:void 0})],MenuOption.prototype,"value",2),__decorateClass$A([ReactiveProperty({value:"",type:String})],MenuOption.prototype,"label",2),__decorateClass$A([ReactiveProperty({value:"",type:String})],MenuOption.prototype,"icon",2),__decorateClass$A([ReactiveProperty({value:"",type:String})],MenuOption.prototype,"hint",2),__decorateClass$A([ReactiveProperty({value:!1,type:Boolean})],MenuOption.prototype,"disabled",2),__decorateClass$A([ReactiveProperty()],MenuOption.prototype,"action",2),__decorateClass$A([ReactiveProperty({value:"select",type:String})],MenuOption.prototype,"mode",2),__decorateClass$A([ReactiveProperty({value:!1,type:Boolean})],MenuOption.prototype,"selected",2),__decorateClass$A([ReactiveProperty({value:"",type:String})],MenuOption.prototype,"selectedIDImmediate",2),__decorateClass$A([ReactiveProperty({value:"",type:String})],MenuOption.prototype,"selectedID",2),__decorateClass$A([ReactiveProperty({value:"",type:String})],MenuOption.prototype,"path",2),__decorateClass$A([ReactiveProperty({type:NodeArray,init:"this"})],MenuOption.prototype,"options",2),MenuOption=__decorateClass$A([Register],MenuOption);const MenuElementTags=["io-menu-item","io-menu-options","io-menu-hamburger","io-option-select","io-string","io-menu-tree"],MenuElementTagsSelector=MenuElementTags.join(", ");function getMenuDescendants(element){const descendants=[];if(element.$options){descendants.push(element.$options);const options=element.$options.querySelectorAll(MenuElementTagsSelector);for(let i=options.length;i--;)descendants.push(options[i]),descendants.push(...getMenuDescendants(options[i]))}else{const options=Array.from(element.querySelectorAll(MenuElementTagsSelector));for(let i=options.length;i--;)descendants.push(options[i]),descendants.push(...getMenuDescendants(options[i]))}return descendants}function getMenuAncestors(element){const ancestors=[];let option=element;for(;option&&option.$parent;)option=option.$parent,option&&ancestors.push(option);return ancestors}function getMenuSiblings(element){const siblings=[],parent=element.parentElement;return parent&&siblings.push(...Array.from(parent.querySelectorAll(MenuElementTagsSelector))),siblings}function getMenuRoot(element){let root=element;for(;root&&root.$parent;)root=root.$parent;return root}function isPointerAboveIoMenuItem(event,element){if(-1!==MenuElementTags.indexOf(element.localName)&&!element.disabled&&element.parentElement!==IoOverlaySingleton&&element.parentElement.expanded){const r=element.getBoundingClientRect(),x=event.clientX,y=event.clientY;return r.top<=y&&r.bottom>=y&&r.left<=x&&r.right>=x}return!1}function matchMenuOption(option,search){return!option.options.length&&(void 0!==option.value&&-1!==String(option.value).toLowerCase().indexOf(search)||(!(!option.label||-1===option.label.toLowerCase().indexOf(search))||!(!option.hint||-1===option.hint.toLowerCase().indexOf(search))))}function searchMenuOption(option,search,depth=5,d=0){search=search.toLowerCase();const subitems=[];if(d<=depth)for(let i=0;i<option.options.length;i++)matchMenuOption(option.options[i],search)&&subitems.push(option.options[i]),option.options[i].options.length&&subitems.push(...searchMenuOption(option.options[i],search,depth,d+1));return subitems}var __defProp$v=Object.defineProperty,__getOwnPropDesc$w=Object.getOwnPropertyDescriptor,__decorateClass$z=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$w(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$v(target,key,result),result};let IoMenuOptions=class extends IoElement{static get Style(){return"\n    :host {\n      display: flex;\n      flex-direction: column;\n      align-self: flex-start;\n      border: var(--io_border);\n      border-radius: calc(var(--io_borderRadius) + var(--io_spacing2));\n      border-color: var(--io_borderColorOutset);\n      background-color: var(--io_bgColorLight);\n      padding: calc(var(--io_spacing) + var(--io_borderWidth));\n      transition: opacity 0.3s ease-in-out;\n      @apply --unselectable;\n    }\n    :host[horizontal] {\n      padding: var(--io_spacing) 0;\n      flex-direction: row;\n      align-self: stretch;\n    }\n    :host[inoverlay] {\n      overflow-y: auto;\n      box-shadow: 1px 1px 16px var(--io_shadowColor),\n                  1px 1px 8px var(--io_shadowColor), \n                  1px 1px 4px var(--io_shadowColor);\n    }\n    :host[inoverlay]:not([expanded]) {\n      visibility: hidden;\n      opacity: 0;\n    }\n    :host > io-menu-item[hidden] ~ span.divider {\n      display: none;\n    }\n    :host > span.divider {\n      flex: 0 0 0;\n      border: var(--io_border);\n      border-color: var(--io_borderColorInset);\n      margin: var(--io_spacing) 0;\n      opacity: 0.1;\n    }\n    :host[horizontal] > span.divider {\n      margin: 0 var(--io_spacing);\n    }\n    :host[horizontal] > io-menu-item > .hint {\n      display: none;\n    }\n    :host:not([horizontal]) > #search {\n      margin: var(--io_spacing);\n      margin-top: 0;\n    }\n    :host[horizontal] > #search {\n      margin: 0 var(--io_spacing);\n      flex: 0 0 10em;\n    }\n    "}static get Listeners(){return{touchstart:["stopPropagation"],"io-focus-to":"onIoFocusTo"}}get inoverlay(){return IoOverlaySingleton.contains(this.parentElement)}constructor(args={}){super(args)}stopPropagation(event){this.inoverlay&&event.stopPropagation()}connectedCallback(){super.connectedCallback(),this.inoverlay&&this.setAttribute("inoverlay","true")}onIoFocusTo(event){const source=event.detail.source,cmd=event.detail.command,siblings=getMenuSiblings(source),index=siblings.indexOf(source),inoverlay=this.inoverlay;let parentIsAbove=!1,parentIsBelow=!1,parentIsLeft=!1,parentIsRight=!1;if(this.$parent){const rect=this.getBoundingClientRect(),parentRect=this.$parent.getBoundingClientRect();parentIsAbove=rect.top>parentRect.top,parentIsBelow=rect.bottom<parentRect.bottom,parentIsLeft=rect.left>parentRect.left,parentIsRight=rect.right<parentRect.right}let cmdOverride="";this.horizontal?("ArrowRight"===cmd&&inoverlay&&(cmdOverride="Next"),"ArrowLeft"===cmd&&inoverlay&&(cmdOverride="Prev"),"ArrowUp"===cmd&&parentIsAbove&&(cmdOverride="Out"),"ArrowDown"===cmd&&parentIsBelow&&(cmdOverride="Out")):("ArrowDown"===cmd&&inoverlay&&(cmdOverride="Next"),"ArrowUp"===cmd&&inoverlay&&(cmdOverride="Prev"),"ArrowLeft"===cmd&&parentIsLeft&&(cmdOverride="Out"),"ArrowRight"===cmd&&parentIsRight&&(cmdOverride="Out")),"Tab"===cmd&&inoverlay&&(cmdOverride="Next"),cmdOverride&&("Next"===cmdOverride?siblings[(index+1)%siblings.length].focus():"Prev"===cmdOverride?siblings[(index-1+siblings.length)%siblings.length].focus():"Out"===cmdOverride&&this.$parent&&this.$parent.focus(),event.stopPropagation())}collapse(){const optionWasFocused=this.contains(document.activeElement),searchHadInput=this.searchable&&!!this.search;getMenuDescendants(this).forEach(descendant=>{descendant.expanded=!1}),this.expanded=!1,searchHadInput&&optionWasFocused&&!this.inoverlay&&(this.search="",this.$.search.focus())}expandedChanged(){this.expanded?this.inoverlay&&this.debounce(this.onExpandInOverlay):(this.style.top="",this.style.height="",this.scrollTop=0,this.search="")}searchChanged(){this.inoverlay&&this.$parent&&this.debounce(this.onExpandInOverlay)}onExpandInOverlay(){this.$parent&&nudge(this,this.$parent,this.direction,!0)}changed(){const vChildren=this.widget?[this.widget]:[];if(this.searchable&&vChildren.push(ioString({id:"search",role:"search",value:this.bind("search"),placeholder:"Search",live:!0})),this.search){const filteredItems=searchMenuOption(this.option,this.search,this.depth);if(0===filteredItems.length)vChildren.push(ioField({label:"No matches"}));else for(let i=0;i<filteredItems.length;i++)vChildren.push(ioMenuItem({option:filteredItems[i],depth:0})),i<filteredItems.length-1&&vChildren.push({tag:"span",props:{class:"divider"}})}else{let direction=this.horizontal?"down":"right";this.horizontal&&"up"===this.direction&&(direction="up");for(let i=0;i<this.option.options.length;i++)vChildren.push(ioMenuItem({option:this.option.options[i],direction:direction,$parent:this,depth:this.depth})),i<this.option.options.length-1&&vChildren.push(span({class:"divider"}))}this.render(vChildren)}};__decorateClass$z([ReactiveProperty({type:MenuOption})],IoMenuOptions.prototype,"option",2),__decorateClass$z([ReactiveProperty({value:!1,reflect:!0})],IoMenuOptions.prototype,"expanded",2),__decorateClass$z([ReactiveProperty({value:!1,reflect:!0})],IoMenuOptions.prototype,"horizontal",2),__decorateClass$z([ReactiveProperty(!1)],IoMenuOptions.prototype,"searchable",2),__decorateClass$z([ReactiveProperty("")],IoMenuOptions.prototype,"search",2),__decorateClass$z([ReactiveProperty({value:"none",reflect:!0})],IoMenuOptions.prototype,"direction",2),__decorateClass$z([ReactiveProperty(100)],IoMenuOptions.prototype,"depth",2),__decorateClass$z([ReactiveProperty({value:"",reflect:!0})],IoMenuOptions.prototype,"overflow",2),__decorateClass$z([ReactiveProperty(null)],IoMenuOptions.prototype,"widget",2),__decorateClass$z([Property()],IoMenuOptions.prototype,"$parent",2),__decorateClass$z([Property("listbox")],IoMenuOptions.prototype,"role",2),IoMenuOptions=__decorateClass$z([Register],IoMenuOptions);var __defProp$u=Object.defineProperty,__getOwnPropDesc$v=Object.getOwnPropertyDescriptor,__decorateClass$y=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$v(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$u(target,key,result),result};let timeoutOpen,hovered,prevHovered;function onOverlayPointerdown(event){hovered=void 0,prevHovered=void 0}function onOverlayPointermove(event){if(clearTimeout(timeoutOpen),hovered=function getHoveredMenuItem(event){const options=Array.from(IoOverlaySingleton.querySelectorAll("io-menu-item, io-menu-options")),hovered=[];if(IoOverlaySingleton.expanded)for(let i=options.length;i--;)isPointerAboveIoMenuItem(event,options[i])&&hovered.push(options[i]);if(hovered.length){hovered.sort((a,b)=>a.depth>b.depth?1:a.depth<b.depth?-1:"io-menu-item"===a.localName?1:"io-menu-item"===b.localName?-1:0);const first=hovered[0],second=hovered[1];if("io-menu-item"===first.localName)return first;if("io-menu-options"===first.localName&&second&&"io-menu-item"===second.localName&&second.depth===first.depth)return second}}(event),hovered&&hovered!==prevHovered){const v=Math.abs(event.movementY)-Math.abs(event.movementX),h=hovered.parentElement?.horizontal;prevHovered?.parentElement!==hovered.parentElement||(h?v<-.25:v>.25)?(prevHovered=hovered,hovered.focus()):timeoutOpen=setTimeout(()=>{prevHovered=hovered,hovered&&hovered.focus()},250)}}function onOverlayPointeup(event){hovered&&hovered.onClick()}IoOverlaySingleton.addEventListener("pointermove",onOverlayPointermove);let IoMenuItem=class extends IoField{static get Style(){return"\n      :host > * {\n        pointer-events: none;\n        text-overflow: ellipsis;\n      }\n      :host > .label {\n        flex: 1 1 auto;\n        padding: 0 var(--io_spacing2);\n      }\n      :host > .hint {\n        flex: 0 1 auto;\n        opacity: 0.25;\n        padding: 0 var(--io_spacing2);\n      }\n      :host > .hasmore {\n        opacity: 0.5;\n      }\n    "}static get Listeners(){return{click:"preventDefault",focus:"onFocus",blur:"onBlur"}}constructor(args={}){super(args)}preventDefault(event){event.stopPropagation(),event.preventDefault()}get hasmore(){return this.option.options.length&&this.depth>0}get inoverlay(){return IoOverlaySingleton.contains(this.parentElement?.parentElement)}connectedCallback(){super.connectedCallback(),this.$options&&IoOverlaySingleton.appendChild(this.$options)}disconnectedCallback(){super.disconnectedCallback(),this.$options&&IoOverlaySingleton.removeChild(this.$options)}onClick(){const o=this.option;this.hasmore?this.expanded||(this.expanded=!0):("toggle"===o.mode?o.selected=!o.selected:(o.action&&(o.action.apply(null,[o.value]),this.collapseRoot()),"select"===o.mode&&(o.options.length&&this.depth<=0?o.selectDefault():o.selected=!0,this.collapseRoot())),getMenuRoot(this).dispatch("io-menu-option-clicked",{option:o},!0))}onPointerdown(event){super.onPointerdown(event),"touch"!==event.pointerType&&(this.setPointerCapture(event.pointerId),event.stopPropagation(),this.hasmore&&(this.expanded=!0),onOverlayPointerdown.call(this,event))}onPointermove(event){event.stopPropagation(),"touch"!==event.pointerType&&onOverlayPointermove.call(this,event)}onPointerup(event){super.onPointerup(event),event.stopPropagation(),this.onPointerupAction(event)}onPointerupAction(event){this.onClick()}onFocus(event){super.onFocus(event),this.hasmore&&this.inoverlay&&(this.expanded=!0);const $allitems=getMenuDescendants(getMenuRoot(this)),$ancestoritems=getMenuAncestors(this);for(let i=$allitems.length;i--;)$allitems[i]!==this&&$allitems[i]!==this.$options&&-1===$ancestoritems.indexOf($allitems[i])&&$allitems[i].expanded&&$allitems[i].collapse()}onBlur(event){super.onBlur(event),this.debounce(this.onBlurDebounced)}onBlurDebounced(){if(this._disposed)return;const descendants=getMenuDescendants(this),siblings=getMenuSiblings(this),ancestors=getMenuAncestors(this),descendantIsFocused=descendants.some(descendant=>descendant===document.activeElement),siblingIsFocused=siblings.some(sibling=>sibling===document.activeElement),ancestorIsFocused=ancestors.some(ancestor=>ancestor===document.activeElement),nothingIsFocused=document.activeElement===document.body,fucusLeftOverlay=!IoOverlaySingleton.contains(document.activeElement);descendantIsFocused||nothingIsFocused||(ancestorIsFocused||siblingIsFocused?this.collapse():fucusLeftOverlay&&this.collapseRoot())}onKeydown(event){const inoverlay=this.inoverlay;let direction=this.direction,optionsAreAbove=!1,optionsAreBelow=!1,optionsAreLeft=!1,optionsAreRight=!1;if(this.expanded&&this.$options){const rect=this.getBoundingClientRect(),optionsRect=this.$options.getBoundingClientRect();optionsAreAbove=rect.top>optionsRect.top,optionsAreBelow=rect.bottom<optionsRect.bottom,optionsAreLeft=rect.left>optionsRect.left,optionsAreRight=rect.right<optionsRect.right}"up"===direction&&optionsAreBelow&&(direction="down"),"down"===direction&&optionsAreAbove&&(direction="up"),"left"===direction&&optionsAreRight&&(direction="right"),"right"===direction&&optionsAreLeft&&(direction="left");let cmd=null;if("Enter"===event.key||" "===event.key){if(!this.hasmore)return event.preventDefault(),void this.onClick();cmd="In"}else"Backspace"===event.key?cmd="Out":"Escape"===event.key?cmd="Collapse":"ArrowLeft"===event.key&&(inoverlay||this.expanded)?this.hasmore&&"left"===direction?cmd="In":"right"===direction&&(cmd="Out"):"ArrowRight"===event.key&&(inoverlay||this.expanded)?this.hasmore&&"right"===direction?cmd="In":"left"===direction&&(cmd="Out"):"ArrowUp"===event.key&&(inoverlay||this.expanded)?this.hasmore&&"up"===direction?cmd="In":"down"===direction&&(cmd="Out"):"ArrowDown"===event.key&&(inoverlay||this.expanded)&&(this.hasmore&&"down"===direction?cmd="In":"up"===direction&&(cmd="Out"));if(cmd)switch(event.preventDefault(),cmd){case"Collapse":this.collapseRoot();break;case"In":if(this.hasmore&&(this.expanded=!0),this.$options&&this.$options.children.length){const option=this.$options.querySelector("[selected]");option?option.focus():this.$options.children[0].focus()}break;case"Out":this.$parent&&this.$parent.$parent&&(this.$parent.$parent.focus(),this.$parent.$parent.collapse())}else super.onKeydown(event)}collapse(){getMenuDescendants(this).forEach(descendant=>{descendant.expanded=!1}),this.expanded=!1}collapseRoot(){getMenuRoot(this).collapse()}optionChanged(){this.setProperties({selected:this.option.selected,disabled:this.option.disabled}),this.initOptions()}optionMutated(){this.setProperties({selected:this.option.selected,disabled:this.option.disabled}),this.changed()}initOptions(){this.option.options&&this.depth>0&&(void 0===this.$options?this.$options=new IoMenuOptions({expanded:this.bind("expanded"),depth:this.depth-1,option:this.option,direction:this.direction,$parent:this}):this.$options.option=this.option)}changed(){const icon=this.icon||this.option.icon,label=this.label||this.option.label;this.render([this.hasmore&&"left"===this.direction?ioIcon({value:"io:triangle_left",class:"hasmore"}):null,this.hasmore&&"up"===this.direction?ioIcon({value:"io:triangle_up",class:"hasmore"}):null,icon?ioIcon({value:icon}):null,label?span({class:"label"},label):null,this.option.hint?span({class:"hint"},this.option.hint):null,this.hasmore&&"right"===this.direction?ioIcon({value:"io:triangle_right",class:"hasmore"}):null,this.hasmore&&"down"===this.direction?ioIcon({value:"io:triangle_down",class:"hasmore"}):null])}dispose(){super.dispose(),delete this.$options}};__decorateClass$y([ReactiveProperty({type:MenuOption})],IoMenuItem.prototype,"option",2),__decorateClass$y([Property("")],IoMenuItem.prototype,"label",2),__decorateClass$y([ReactiveProperty({value:!1,reflect:!0})],IoMenuItem.prototype,"expanded",2),__decorateClass$y([ReactiveProperty({value:"right",reflect:!0})],IoMenuItem.prototype,"direction",2),__decorateClass$y([ReactiveProperty({value:1e3,reflect:!0})],IoMenuItem.prototype,"depth",2),__decorateClass$y([Property("false")],IoMenuItem.prototype,"contentEditable",2),__decorateClass$y([Property()],IoMenuItem.prototype,"$parent",2),IoMenuItem=__decorateClass$y([Register],IoMenuItem);const ioMenuItem=function(arg0){return IoMenuItem.vConstructor(arg0)};var __defProp$t=Object.defineProperty,__getOwnPropDesc$u=Object.getOwnPropertyDescriptor,__decorateClass$x=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$u(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$t(target,key,result),result};let IoMenuHamburger=class extends IoMenuItem{static get Style(){return"\n      :host {\n        display: flex;\n        flex-shrink: 0;\n      }\n      :host > * {\n        pointer-events: none;\n        text-overflow: ellipsis;\n      }\n    "}changed(){this.render([ioIcon({value:"io:hamburger"})])}};__decorateClass$x([ReactiveProperty({value:"down",reflect:!0})],IoMenuHamburger.prototype,"direction",2),IoMenuHamburger=__decorateClass$x([Register],IoMenuHamburger),IoMenuHamburger.vConstructor;var __defProp$s=Object.defineProperty,__getOwnPropDesc$t=Object.getOwnPropertyDescriptor,__decorateClass$w=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$t(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$s(target,key,result),result};let IoMenuTreeBranch=class extends IoElement{static get Style(){return'\n    :host {\n      display: flex;\n      flex-direction: column;\n    }\n    :host > io-boolean {\n      overflow: visible;\n      padding-left: var(--io_spacing3);\n      padding-right: var(--io_spacing3);\n    }\n    :host > io-boolean:before {\n      display: inline-block;\n      width: var(--io_fontSize);\n      content: ""\n    }\n    :host > io-boolean[value]:before {\n      content: ""\n    }\n    :host > io-menu-tree {\n      background: transparent;\n      border: none;\n      border-left: var(--io_border);\n      border-color: var(--io_colorLight);\n      margin-left: var(--io_spacing5);\n    }\n    '}optionMutated(){this.option.selected&&(this.expanded=this.option.selected)}expandedChanged(){clearFocusBacktrack()}changed(){this.render([ioBoolean({icon:this.option.icon,true:this.option.label,false:this.option.label,value:this.bind("expanded")}),this.expanded?ioMenuTree({option:this.option,depth:this.depth+1}):null])}};__decorateClass$w([ReactiveProperty(Number)],IoMenuTreeBranch.prototype,"depth",2),__decorateClass$w([ReactiveProperty({type:MenuOption})],IoMenuTreeBranch.prototype,"option",2),__decorateClass$w([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoMenuTreeBranch.prototype,"expanded",2),__decorateClass$w([Property("region")],IoMenuTreeBranch.prototype,"role",2),IoMenuTreeBranch=__decorateClass$w([Register],IoMenuTreeBranch);const ioMenuTreeBranch=function(arg0){return IoMenuTreeBranch.vConstructor(arg0)};var __defProp$r=Object.defineProperty,__getOwnPropDesc$s=Object.getOwnPropertyDescriptor,__decorateClass$v=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$s(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$r(target,key,result),result};function genObjectStorageID(object){const string=JSON.stringify(object);let hash=0;for(let i=0;i<string.length;i++)hash=Math.imul(31,hash)+string.charCodeAt(i)|0;return"io-local-state-"+String(hash)}let IoMenuTree=class extends IoElement{static get Style(){return'\n    :host {\n      display: flex;\n      flex-direction: column;\n      align-self: flex-start;\n      border: var(--io_border);\n      border-radius: var(--io_borderRadius);\n      border-color: var(--io_borderColorOutset);\n      background-color: var(--io_bgColorLight);\n      padding: var(--io_spacing);\n      @apply --unselectable;\n    }\n    :host io-menu-tree {\n      padding: 0 !important;\n    }\n    :host > io-menu-item {\n      padding-left: var(--io_spacing);\n      padding-right: var(--io_spacing3);\n    }\n    :host > io-menu-item[selected] {\n      border-color: transparent var(--io_colorBlue) transparent transparent;\n    }\n    :host > io-menu-item:before {\n      display: inline-block;\n      width: var(--io_fontSize);\n      content: ""\n    }\n    '}constructor(args={}){super(args)}onResized(){this.dispatch("io-menu-tree-resized",{element:this},!0)}changed(){const vChildren=this.widget?[this.widget]:[];if(this.searchable&&vChildren.push(ioString({id:"search",role:"search",value:this.bind("search"),placeholder:"Search",live:!0})),this.search){const filteredItems=searchMenuOption(this.option,this.search,this.depth);if(0===filteredItems.length)vChildren.push(ioField({label:"No matches"}));else for(let i=0;i<filteredItems.length;i++)vChildren.push(ioMenuItem({option:filteredItems[i],depth:0}))}else vChildren.push(...function addMenuOptionsOrTreeBranches(option,depth,d=0){const elements=[];if(d<=depth)for(let i=0;i<option.options.length;i++){const subOption=option.options[i];if(subOption.options.length){const collapsibleState=Storage({value:!1,storage:"local",key:genObjectStorageID(subOption)});!0===subOption.selected&&(collapsibleState.value=!0),elements.push(ioMenuTreeBranch({option:subOption,depth:d,expanded:collapsibleState}))}else elements.push(ioMenuItem({option:subOption,depth:d}))}return elements}(this.option,this.depth));this.render(vChildren)}};__decorateClass$v([ReactiveProperty({type:MenuOption})],IoMenuTree.prototype,"option",2),__decorateClass$v([ReactiveProperty({value:!1,type:Boolean})],IoMenuTree.prototype,"searchable",2),__decorateClass$v([ReactiveProperty({value:"",type:String})],IoMenuTree.prototype,"search",2),__decorateClass$v([ReactiveProperty({value:Infinity,type:Number})],IoMenuTree.prototype,"depth",2),__decorateClass$v([ReactiveProperty(null)],IoMenuTree.prototype,"widget",2),__decorateClass$v([Property()],IoMenuTree.prototype,"$parent",2),__decorateClass$v([Property("listbox")],IoMenuTree.prototype,"role",2),IoMenuTree=__decorateClass$v([Register],IoMenuTree);const ioMenuTree=function(arg0){return IoMenuTree.vConstructor(arg0)};var __defProp$q=Object.defineProperty,__getOwnPropDesc$r=Object.getOwnPropertyDescriptor,__decorateClass$u=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$r(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$q(target,key,result),result};let IoOptionSelect=class extends IoElement{static get Style(){return"\n    :host {\n      display: inline-block;\n      text-align: center;\n      border-radius: var(--io_borderRadius);\n      border: var(--io_border);\n      border-color: var(--io_borderColorOutset);\n      background-color: var(--io_bgColorLight);\n      background-image: var(--io_gradientOutset);\n      text-align: left;\n    }\n    :host > io-menu-item {\n      margin: calc(-1 * var(--io_borderWidth));\n      background-color: transparent !important;\n      border-color: transparent !important;\n    }\n    "}constructor(args){super(args)}onOptionSelected(event){this._disposed||("value"===this.selectBy?this.inputValue(event.detail.option.value):"id"===this.selectBy&&this.inputValue(event.detail.option.id))}inputValue(value){if(this.value!==value||"object"==typeof this.value){const oldValue=this.value;this.setProperty("value",value),this.dispatch("value-input",{value:value,oldValue:oldValue},!1)}}optionChanged(change){if(change.oldValue&&change.oldValue.removeEventListener("option-selected",this.onOptionSelected),change.value&&change.value.addEventListener("option-selected",this.onOptionSelected),void 0===this.value){const selectedID=this.option.selectedID,selectedItem=this.option.findItemById(selectedID);"value"===this.selectBy?selectedItem&&(this.value=selectedItem.value):"id"===this.selectBy&&selectedItem&&(this.value=selectedItem.id)}}changed(){let selectedItem,label=this.label;"value"===this.selectBy?(selectedItem=this.option.findItemByValue(this.value),label=selectedItem?selectedItem.label:String(this.value)):"id"===this.selectBy&&(selectedItem=this.option.findItemById(this.value),label=selectedItem?selectedItem.label:String(this.value)),this.render([ioMenuItem({option:this.option,label:label,icon:this.icon,direction:"down"})])}};__decorateClass$u([ReactiveProperty({value:void 0})],IoOptionSelect.prototype,"value",2),__decorateClass$u([ReactiveProperty("")],IoOptionSelect.prototype,"label",2),__decorateClass$u([ReactiveProperty("")],IoOptionSelect.prototype,"icon",2),__decorateClass$u([ReactiveProperty("value")],IoOptionSelect.prototype,"selectBy",2),__decorateClass$u([ReactiveProperty({type:MenuOption})],IoOptionSelect.prototype,"option",2),__decorateClass$u([Property("button")],IoOptionSelect.prototype,"role",2),IoOptionSelect=__decorateClass$u([Register],IoOptionSelect);const ioOptionSelect=function(arg0){return IoOptionSelect.vConstructor(arg0)};var __defProp$p=Object.defineProperty,__getOwnPropDesc$q=Object.getOwnPropertyDescriptor,__decorateClass$t=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$q(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$p(target,key,result),result};let IoContextMenu=class extends IoElement{static get ReactiveProperties(){return{$options:null}}constructor(args){super(args),this.$options=new IoMenuOptions({expanded:this.bind("expanded"),option:this.option,$parent:this})}init(){this.collapse=this.collapse.bind(this)}optionChanged(){this.$options&&(this.$options.option=this.option)}connectedCallback(){super.connectedCallback(),IoOverlaySingleton.appendChild(this.$options),this.parentElement.addEventListener("pointerdown",this.onPointerdown),this.parentElement.addEventListener("click",this.onClick),this.parentElement.addEventListener("contextmenu",this.onContextmenu)}disconnectedCallback(){super.disconnectedCallback(),IoOverlaySingleton.removeChild(this.$options),this.parentElement.removeEventListener("pointerdown",this.onPointerdown),this.parentElement.removeEventListener("click",this.onClick),this.parentElement.removeEventListener("contextmenu",this.onContextmenu)}getBoundingClientRect(){return this.parentElement.getBoundingClientRect()}onContextmenu(event){2===this.button&&event.preventDefault()}onPointerdown(event){event.stopPropagation(),this.$options.style.left=`${event.clientX}px`,this.$options.style.top=`${event.clientY}px`,this.parentElement.addEventListener("pointermove",this.onPointermove),this.parentElement.addEventListener("pointerleave",this.onPointerleave),this.parentElement.addEventListener("pointerup",this.onPointerup),clearTimeout(this._contextTimeout),"touch"!==event.pointerType?event.button===this.button&&(this.setPointerCapture(event.pointerId),this.expanded=!0):(event.preventDefault(),this._contextTimeout=setTimeout(()=>{this.setPointerCapture(event.pointerId),this.expanded=!0},150)),onOverlayPointerdown.call(this,event)}onPointermove(event){event.stopPropagation(),clearTimeout(this._contextTimeout),("touch"!==event.pointerType||this.expanded)&&onOverlayPointermove.call(this,event)}onPointerup(event){clearTimeout(this._contextTimeout),this.releasePointerCapture(event.pointerId),this.parentElement.removeEventListener("pointermove",this.onPointermove),this.parentElement.removeEventListener("pointerleave",this.onPointerleave),this.parentElement.removeEventListener("pointerup",this.onPointerup),onOverlayPointeup.call(this,event)}onPointerleave(event){this.releasePointerCapture(event.pointerId),this.parentElement.removeEventListener("pointermove",this.onPointermove),this.parentElement.removeEventListener("pointerleave",this.onPointerleave),this.parentElement.removeEventListener("pointerup",this.onPointerup)}collapse(){IoOverlaySingleton.collapse()}};__decorateClass$t([ReactiveProperty({type:MenuOption})],IoContextMenu.prototype,"option",2),__decorateClass$t([ReactiveProperty({value:!1,reflect:!0})],IoContextMenu.prototype,"expanded",2),__decorateClass$t([ReactiveProperty(0)],IoContextMenu.prototype,"button",2),IoContextMenu=__decorateClass$t([Register],IoContextMenu);var __defProp$o=Object.defineProperty,__decorateClass$s=(decorators,target,key,kind)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);return result&&__defProp$o(target,key,result),result};const clamp$1=(num,min,max)=>max>min?Math.min(Math.max(num,min),max):Math.min(Math.max(num,max),min);class IoSliderBase extends IoGl{static get Style(){return"\n      :host {\n        display: flex;\n        cursor: ew-resize;\n        border: var(--io_border);\n        border-radius: var(--io_borderRadius);\n        border-color: var(--io_borderColorInset);\n        min-height: var(--io_fieldHeight);\n        min-width: var(--io_fieldHeight);\n        flex-grow: 1;\n      }\n      :host[vertical] {\n        cursor: ns-resize;\n        width: var(--io_fieldHeight);\n        min-height: calc(var(--io_fieldHeight) * 5);\n        flex-basis: var(--io_fieldHeight);\n        flex-grow: 0;\n      }\n      :host[invalid] {\n        color: var(--io_colorWhite);\n        background-color: var(--io_bgColorRed);\n        border-color: var(--io_colorRed);\n      }\n      :host:focus {\n        @apply --io_focus;\n      }\n    "}_startX=0;_startY=0;_rect=null;_active=-1;get _min(){return"number"==typeof this.min?[this.min,this.min]:this.min instanceof Array?[...this.min]:[-Infinity,-Infinity]}get _max(){return"number"==typeof this.max?[this.max,this.max]:this.max instanceof Array?[...this.max]:[Infinity,Infinity]}get _step(){return"number"==typeof this.step?[this.step,this.step]:this.step instanceof Array?[...this.step]:[.01,.01]}get _value(){return"number"==typeof this.value?[this.value,this.value]:this.value instanceof Array?[...this.value]:[NaN,NaN]}static get Listeners(){return{focus:"onFocus",contextmenu:"onContextmenu",pointerdown:"onPointerdown",touchstart:["onTouchstart",{passive:!1}]}}constructor(args={}){super(args)}onFocus(){this.addEventListener("blur",this.onBlur),this.addEventListener("keydown",this.onKeydown)}onBlur(){this.removeEventListener("blur",this.onBlur),this.removeEventListener("keydown",this.onKeydown)}onContextmenu(event){event.stopPropagation(),event.preventDefault()}onTouchstart(event){this._rect=this.getBoundingClientRect(),this.addEventListener("touchmove",this.onTouchmove,{passive:!1}),this.addEventListener("touchend",this.onTouchend),this._startX=event.changedTouches[0].clientX,this._startY=event.changedTouches[0].clientY,this._active=this.noscroll?1:-1}onTouchmove(event){const dx=Math.abs(this._startX-event.changedTouches[0].clientX),dy=Math.abs(this._startY-event.changedTouches[0].clientY);-1===this._active&&(this.vertical?dy>5&&dy>dx&&(this._active=dy>dx&&dx<5?1:0):dx>5&&dx>dy&&(this._active=dx>dy&&dy<5?1:0)),1===this._active&&event.cancelable&&(event.stopPropagation(),event.preventDefault())}onTouchend(){this.removeEventListener("touchmove",this.onTouchmove),this.removeEventListener("touchend",this.onTouchend)}onPointerdown(event){event.stopPropagation(),this._rect=this.getBoundingClientRect(),this.setPointerCapture(event.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),this.addEventListener("pointercancel",this.onPointerup)}onPointermove(event){"touch"!==event.pointerType&&(this._active=1),this.throttle(this.onPointermoveThrottled,event)}onPointerup(event){this.releasePointerCapture(event.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this.removeEventListener("pointercancel",this.onPointerup),this._active=-1}_getPointerCoord(event){const rect=this._rect||this.getBoundingClientRect();let x=Math.max(0,Math.min(1,(event.clientX-rect.x)/rect.width)),y=Math.max(0,Math.min(1,1-(event.clientY-rect.y)/rect.height));return x=Math.pow(x,this.exponent),y=Math.pow(y,this.exponent),this.vertical?[y,x]:[x,y]}_getValueFromCoord(coord){const value=[0,0],min=this._min,max=this._max;return value[0]=min[0]*(1-coord[0])+max[0]*coord[0],value[1]=min[1]*(1-coord[1])+max[1]*coord[1],value}onPointermoveThrottled(event){if(1===this._active){document.activeElement!==this&&this.focus();const coord=this._getPointerCoord(event),value=this._getValueFromCoord(coord);this._inputValue(value)}}_inputValue(value){const min=this._min,max=this._max,step=this._step;if(value[0]=clamp$1(value[0],max[0],min[0]),value[1]=clamp$1(value[1],max[1],min[1]),value[0]=Math.round(value[0]/step[0])*step[0],value[1]=Math.round(value[1]/step[1])*step[1],value[0]=Number(value[0].toFixed(5)),value[1]=Number(value[1].toFixed(5)),"number"==typeof this.value){if(this.value===value[0])return;this.inputValue(value[0])}else if(this.value instanceof Array){const oldValue=JSON.stringify(this.value);if(this.value[0]=value[0],this.value[1]=value[1],oldValue===JSON.stringify(this.value))return;this.inputValue(this.value),this.dispatchMutation(this.value)}else if("object"==typeof this.value){const oldValue=JSON.stringify(this.value),$value=this.value;if($value.x=value[0],$value.y=value[1],oldValue===JSON.stringify(this.value))return;this.inputValue(this.value),this.dispatchMutation(this.value)}}inputValue(value){if(this.value!==value||"object"==typeof this.value){const oldValue=this.value;this.setProperty("value",value),this.dispatch("value-input",{value:value,oldValue:oldValue},!1)}}onKeydown(event){const oneDimension="number"==typeof this.value;if(event.shiftKey)switch(event.key){case"ArrowLeft":oneDimension?this._setDecrease():this._setLeft();break;case"ArrowUp":oneDimension?this._setIncrease():this._setUp();break;case"ArrowRight":oneDimension?this._setIncrease():this._setRight();break;case"ArrowDown":oneDimension?this._setDecrease():this._setDown()}else["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Tab","Home","End","PageUp","PageDown"].includes(event.key)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0))}_setIncrease(){const value=this._value,step=this._step;value[0]=value[0]+step[0],value[1]=value[1]+step[1],this._inputValue(value)}_setDecrease(){const value=this._value,step=this._step;value[0]=value[0]-step[0],value[1]=value[1]-step[1],this._inputValue(value)}_setMin(){const min=this._min;this._inputValue(min)}_setMax(){const max=this._max;this._inputValue(max)}_setUp(){const value=this._value,step=this._step;value[0]=value[0]+step[0],this._inputValue(value)}_setDown(){const value=this._value,step=this._step;value[0]=value[0]-step[0],this._inputValue(value)}_setLeft(){const value=this._value,step=this._step;value[1]=value[1]-step[1],this._inputValue(value)}_setRight(){const value=this._value,step=this._step;value[1]=value[1]+step[1],this._inputValue(value)}ready(){this.changed()}valueChanged(){let invalid=!1;this.value instanceof Array?invalid=isNaN(this.value[0])||isNaN(this.value[1]):isNaN(this.value)&&(invalid=!0),this.invalid=invalid}invalidChanged(){this.invalid?this.setAttribute("aria-invalid","true"):this.removeAttribute("aria-invalid")}valueMutated(){this.changed(),this.dispatchMutation()}changed(){super.changed(),this.setAttribute("aria-valuemin",JSON.stringify(this.min)),this.setAttribute("aria-valuemax",JSON.stringify(this.max)),this.setAttribute("aria-valuestep",JSON.stringify(this.step));const value=this._value;"number"!=typeof value[0]||isNaN(value[0])?this.setAttribute("aria-invalid","true"):this.removeAttribute("aria-invalid"),this.setAttribute("aria-valuenow",JSON.stringify(this.value))}}__decorateClass$s([ReactiveProperty({type:Number,value:0})],IoSliderBase.prototype,"value"),__decorateClass$s([ReactiveProperty({type:Number,value:.01})],IoSliderBase.prototype,"step"),__decorateClass$s([ReactiveProperty({type:Number,value:0})],IoSliderBase.prototype,"min"),__decorateClass$s([ReactiveProperty({type:Number,value:1})],IoSliderBase.prototype,"max"),__decorateClass$s([ReactiveProperty({type:Number,value:1})],IoSliderBase.prototype,"exponent"),__decorateClass$s([ReactiveProperty({value:!1,reflect:!0})],IoSliderBase.prototype,"vertical"),__decorateClass$s([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoSliderBase.prototype,"invalid"),__decorateClass$s([Property(!1)],IoSliderBase.prototype,"noscroll"),__decorateClass$s([Property("slider")],IoSliderBase.prototype,"role"),__decorateClass$s([Property(0)],IoSliderBase.prototype,"tabIndex");var __defProp$n=Object.defineProperty,__getOwnPropDesc$p=Object.getOwnPropertyDescriptor,__decorateClass$r=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$p(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$n(target,key,result),result};let IoSliderRange=class extends IoSliderBase{_index=0;constructor(args={}){super(args)}_getCoordFromValue(value){const coord=[0,0],min=this._min,max=this._max;return coord[0]=(value[0]-min[0])/(max[0]-min[0]),coord[1]=(value[1]-min[1])/(max[1]-min[1]),coord}onPointerdown(event){super.onPointerdown(event);const value=this._value,p=this._getPointerCoord(event),c=this._getCoordFromValue(value);this._index=Math.abs(c[0]-p[0])<Math.abs(c[1]-p[0])?0:1}onPointermoveThrottled(event){if(1===this._active){document.activeElement!==this&&this.focus();const value=this._value,coord=this._getPointerCoord(event),newValue=this._getValueFromCoord(coord);0===this._index?this._inputValue([newValue[0],value[1]]):1===this._index&&this._inputValue([value[0],newValue[0]])}}static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * vec2(uv.x, uv.y - 0.5);\n      vec2 expPosition = size * vec2(pow(uv.x, uExponent), uv.y - 0.5);\n\n      vec2 valueInRange = (uValue - vec2(uMin)) / (vec2(uMax) - vec2(uMin));\n\n      vec2 valueSign = sign(valueInRange);\n      vec2 expValueInRange = pow(abs(valueInRange), vec2(1./uExponent)) * valueSign;\n      float valueInRangeWidth = valueInRange[1] - valueInRange[0];\n      float valueInRangeCenter = (valueInRange[1] + valueInRange[0]) / 2.0;\n      float signRange = sign(valueInRangeWidth);\n\n      // Colors\n      vec3 finalCol = io_bgColorInput.rgb;\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 sliderCol = signRange > 0.0 ? io_bgColorBlue.rgb : io_bgColorRed.rgb;\n      vec3 lineCol1 = io_color.rgb;\n      vec3 lineCol2 = io_bgColor.rgb;\n\n      // Grid\n      float gridSize = size.x / abs((uMax - uMin) / uStep);\n      float gridOffset = mod(uStep - uMin, uStep) / (uMax - uMin) * size.x;\n      float gridShape = paintDerivativeGrid2D(translate(expPosition, gridOffset, 0.0), vec2(gridSize, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      // Slider\n      float sliderShape = rectangle(translate(expPosition, size.x * valueInRangeCenter, 0.0), vec2(size.x * abs(valueInRangeWidth) * 0.5, size.y));\n      finalCol = compose(finalCol, vec4(sliderCol, sliderShape));\n      finalCol = compose(finalCol, vec4(io_bgColorInput.rgb, gridShape * sliderShape * 0.125));\n\n      // Lines\n      float maxPos = expValueInRange[0];\n      float minPos = expValueInRange[1];\n\n      float lineMinShape1 = lineVertical(translate(position, maxPos * size.x, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol1, lineMinShape1));\n      float lineMinShape2 = lineVertical(translate(position, maxPos * size.x + io_borderWidth * signRange, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol2, lineMinShape2));\n      \n      float lineMaxShape1 = lineVertical(translate(position, minPos * size.x, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol1, lineMaxShape1));\n      float lineMaxShape2 = lineVertical(translate(position, minPos * size.x - io_borderWidth * signRange, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol2, lineMaxShape2));\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }\n    "}};__decorateClass$r([ReactiveProperty({type:Array,value:void 0,init:[0,0]})],IoSliderRange.prototype,"value",2),__decorateClass$r([ReactiveProperty({type:Number,value:.01})],IoSliderRange.prototype,"step",2),__decorateClass$r([ReactiveProperty({type:Number,value:0})],IoSliderRange.prototype,"min",2),__decorateClass$r([ReactiveProperty({type:Number,value:1})],IoSliderRange.prototype,"max",2),IoSliderRange=__decorateClass$r([Register],IoSliderRange);var __defProp$m=Object.defineProperty,__getOwnPropDesc$o=Object.getOwnPropertyDescriptor,__decorateClass$q=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$o(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$m(target,key,result),result};let IoNumberSliderRange=class extends IoElement{static get Style(){return"\n    :host {\n      display: flex;\n    }\n    :host > io-number {\n      flex: 0 0 3.5em;\n    }\n    :host > io-slider-range {\n      margin-left: var(--io_spacing);\n      margin-right: var(--io_spacing);\n      flex: 1 1 3.5em;\n      min-width: 3.5em;\n    }\n    "}constructor(args={}){super(args)}_onNumberSet(event){const item=event.composedPath()[0];item===this.$.number0&&(this.value[0]=event.detail.value),item===this.$.number1&&(this.value[1]=event.detail.value),this.value._isNode||this.dispatchMutation(this.value)}_onSliderSet(event){this.value=event.detail.value,this.value._isNode||this.dispatchMutation(this.value)}ready(){this.changed()}changed(){var arg0;this.render([ioNumber({id:"number0",value:this.value[0],step:this.step,conversion:this.conversion,"@value-input":this._onNumberSet}),(arg0={id:"slider",value:this.value,step:this.step,min:this.min,max:this.max,exponent:this.exponent,"@value-input":this._onSliderSet},IoSliderRange.vConstructor(arg0)),ioNumber({id:"number1",value:this.value[1],step:this.step,conversion:this.conversion,"@value-input":this._onNumberSet})])}};__decorateClass$q([ReactiveProperty({type:Array,init:[0,0]})],IoNumberSliderRange.prototype,"value",2),__decorateClass$q([ReactiveProperty(.01)],IoNumberSliderRange.prototype,"step",2),__decorateClass$q([ReactiveProperty(0)],IoNumberSliderRange.prototype,"min",2),__decorateClass$q([ReactiveProperty(1)],IoNumberSliderRange.prototype,"max",2),__decorateClass$q([ReactiveProperty(1)],IoNumberSliderRange.prototype,"exponent",2),__decorateClass$q([ReactiveProperty(1)],IoNumberSliderRange.prototype,"conversion",2),IoNumberSliderRange=__decorateClass$q([Register],IoNumberSliderRange);var _startX,_startY,_active,_rect,__defProp$l=Object.defineProperty,__getOwnPropDesc$n=Object.getOwnPropertyDescriptor,__typeError=msg=>{throw TypeError(msg)},__decorateClass$p=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$n(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$l(target,key,result),result},__accessCheck=(obj,member,msg)=>member.has(obj)||__typeError("Cannot "+msg),__privateGet=(obj,member,getter)=>(__accessCheck(obj,member,"read from private field"),member.get(obj)),__privateAdd=(obj,member,value)=>member.has(obj)?__typeError("Cannot add the same private member more than once"):member instanceof WeakSet?member.add(obj):member.set(obj,value),__privateSet=(obj,member,value,setter)=>(__accessCheck(obj,member,"write to private field"),member.set(obj,value),value);let IoSlider=class extends IoGl{constructor(args={}){super(args),__privateAdd(this,_startX,0),__privateAdd(this,_startY,0),__privateAdd(this,_active,-1),__privateAdd(this,_rect,null)}static get Style(){return"\n      :host {\n        display: flex;\n        cursor: ew-resize;\n        border: var(--io_border);\n        border-radius: var(--io_borderRadius);\n        border-color: var(--io_borderColorInset);\n        min-height: var(--io_fieldHeight);\n        min-width: var(--io_fieldHeight);\n        flex-grow: 1;\n      }\n      :host[vertical] {\n        cursor: ns-resize;\n        width: var(--io_fieldHeight);\n        min-height: calc(var(--io_fieldHeight) * 5);\n        flex-basis: var(--io_fieldHeight);\n        flex-grow: 0;\n      }\n      :host[invalid] {\n        border-color: var(--io_colorRed);\n      }\n      :host[disabled] {\n        opacity: 0.5;\n      }\n      :host:focus {\n        @apply --io_focus;\n      }\n    "}static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * vec2(uv.x, uv.y - 0.5);\n      vec2 expPosition = size * vec2(pow(uv.x, uExponent), uv.y - 0.5);\n      float valueInRange = (uValue - uMin) / (uMax - uMin);\n      if (uInvalid == 1) valueInRange = 0.0;\n      float valueSign = sign(valueInRange);\n      float expValueInRange = pow(abs(valueInRange), 1./uExponent) * valueSign;\n\n      // Colors\n      vec3 finalCol = io_bgColorInput.rgb;\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 sliderCol = io_bgColorBlue.rgb;\n      vec3 lineCol1 = io_color.rgb;\n      vec3 lineCol2 = io_bgColor.rgb;\n\n      // Grid\n      float gridSize = size.x / abs((uMax - uMin) / uStep);\n      float gridOffset = mod(uStep - uMin, uStep) / (uMax - uMin) * size.x;\n      float gridShape = paintDerivativeGrid2D(translate(expPosition, gridOffset, 0.0), vec2(gridSize, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      // Slider\n      float sliderShape = rectangle(expPosition, vec2(size.x * valueInRange, size.y));\n      finalCol = compose(finalCol, vec4(sliderCol, sliderShape));\n      finalCol = compose(finalCol, vec4(io_bgColorInput.rgb, gridShape * sliderShape * 0.125));\n\n      // Lines\n      float lineShape1 = lineVertical(translate(position, expValueInRange * size.x, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol1, lineShape1));\n      float lineShape2 = lineVertical(translate(position, expValueInRange * size.x - io_borderWidth, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol2, lineShape2));\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }"}static get Listeners(){return{focus:"onFocus",contextmenu:"onContextmenu",pointerdown:"onPointerdown",touchstart:["onTouchstart",{passive:!1}]}}onFocus(){this.addEventListener("blur",this.onBlur),this.addEventListener("keydown",this.onKeydown)}onBlur(){this.removeEventListener("blur",this.onBlur),this.removeEventListener("keydown",this.onKeydown)}onContextmenu(event){event.preventDefault()}onTouchstart(event){__privateSet(this,_rect,this.getBoundingClientRect()),this.addEventListener("touchmove",this.onTouchmove,{passive:!1}),this.addEventListener("touchend",this.onTouchend),__privateSet(this,_startX,event.changedTouches[0].clientX),__privateSet(this,_startY,event.changedTouches[0].clientY),__privateSet(this,_active,this.noscroll?1:-1)}onTouchmove(event){const dx=Math.abs(__privateGet(this,_startX)-event.changedTouches[0].clientX),dy=Math.abs(__privateGet(this,_startY)-event.changedTouches[0].clientY);-1===__privateGet(this,_active)&&(this.vertical?dy>5&&dy>dx&&__privateSet(this,_active,dy>dx&&dx<5?1:0):dx>5&&dx>dy&&__privateSet(this,_active,dx>dy&&dy<5?1:0)),1===__privateGet(this,_active)&&event.cancelable&&event.preventDefault()}onTouchend(){this.removeEventListener("touchmove",this.onTouchmove),this.removeEventListener("touchend",this.onTouchend)}onPointerdown(event){event.stopPropagation(),__privateSet(this,_rect,this.getBoundingClientRect()),this.setPointerCapture(event.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),this.addEventListener("pointercancel",this.onPointerup)}onPointermove(event){"touch"!==event.pointerType&&__privateSet(this,_active,1),this.throttle(this.onPointermoveThrottled,event)}onPointerup(event){this.releasePointerCapture(event.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this.removeEventListener("pointercancel",this.onPointerup),__privateSet(this,_active,-1)}_getPointerCoord(event){const rect=__privateGet(this,_rect)||this.getBoundingClientRect(),x=Math.max(0,Math.min(1,(event.clientX-rect.x)/rect.width)),y=Math.max(0,Math.min(1,1-(event.clientY-rect.y)/rect.height));return Math.pow(this.vertical?y:x,this.exponent)}_getValueFromCoord(coord){return this.min*(1-coord)+this.max*coord}onPointermoveThrottled(event){if(1===__privateGet(this,_active)){document.activeElement!==this&&this.focus();const coord=this._getPointerCoord(event),value=this._getValueFromCoord(coord);this._inputValue(value)}}_incrementValue(value){this._inputValue(this.value+value)}_inputValue(value){var num,min,max;num=value,min=this.max,value=(max=this.min)>min?Math.min(Math.max(num,min),max):Math.min(Math.max(num,max),min),value=Math.round(value/this.step)*this.step,value=Number(value.toFixed(5)),isNaN(value)||this.value===value||this.inputValue(value)}inputValue(value){if(this.value!==value||"object"==typeof this.value){const oldValue=this.value;this.setProperty("value",value),this.dispatch("value-input",{value:value,oldValue:oldValue},!1)}}onKeydown(event){const invert=this.max<this.min;if(event.shiftKey)switch(event.key){case"ArrowLeft":case"ArrowDown":this._incrementValue(invert?this.step:-this.step);break;case"ArrowUp":case"ArrowRight":this._incrementValue(invert?-this.step:this.step);break;case"Home":event.preventDefault(),this._inputValue(this.min);break;case"End":event.preventDefault(),this._inputValue(this.max);break;case"PageUp":event.preventDefault(),this._incrementValue(invert?-this.step:this.step);break;case"PageDown":event.preventDefault(),this._incrementValue(invert?this.step:-this.step)}else["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Tab","Home","End","PageUp","PageDown"].includes(event.key)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0))}ready(){this.valueChanged(),this.minChanged(),this.maxChanged(),this.changed()}invalidChanged(){this.ariaInvalid=String(this.invalid)}disabledChanged(){this.inert=this.disabled,this.ariaDisabled=String(this.disabled)}valueChanged(){this.invalid=isNaN(this.value),this.ariaValueNow=String(this.value)}minChanged(){this.ariaValueMin=String(this.min)}maxChanged(){this.ariaValueMax=String(this.max)}};_startX=new WeakMap,_startY=new WeakMap,_active=new WeakMap,_rect=new WeakMap,__decorateClass$p([ReactiveProperty(0)],IoSlider.prototype,"value",2),__decorateClass$p([ReactiveProperty(.01)],IoSlider.prototype,"step",2),__decorateClass$p([ReactiveProperty(0)],IoSlider.prototype,"min",2),__decorateClass$p([ReactiveProperty(1)],IoSlider.prototype,"max",2),__decorateClass$p([ReactiveProperty(1)],IoSlider.prototype,"exponent",2),__decorateClass$p([ReactiveProperty({value:!1,reflect:!0})],IoSlider.prototype,"vertical",2),__decorateClass$p([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoSlider.prototype,"invalid",2),__decorateClass$p([ReactiveProperty({value:!1,type:Boolean,reflect:!0})],IoSlider.prototype,"disabled",2),__decorateClass$p([Property(!1)],IoSlider.prototype,"noscroll",2),__decorateClass$p([Property("slider")],IoSlider.prototype,"role",2),__decorateClass$p([Property(0)],IoSlider.prototype,"tabIndex",2),IoSlider=__decorateClass$p([Register],IoSlider);var __defProp$k=Object.defineProperty,__getOwnPropDesc$m=Object.getOwnPropertyDescriptor,__decorateClass$o=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$m(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$k(target,key,result),result};let IoNumberSlider=class extends IoElement{static get Style(){return"\n    :host {\n      display: flex;\n    }\n    :host > io-number {\n      flex: 0 0 3.8em;\n      margin-right: var(--io_spacing);\n    }\n    :host > io-slider {\n      flex: 1 1 3em;\n      min-width: 3em;\n    }\n    "}constructor(args={}){super(args)}_onNumberSet(event){this.value=event.detail.value,this.dispatch("value-input",event.detail,!1)}_onSliderSet(event){event.detail.value=event.detail.value/this.conversion,this.value=event.detail.value,this.dispatch("value-input",event.detail,!1)}ready(){this.changed()}changed(){var arg0;this.render([ioNumber({id:"number",value:this.value,step:this.step,conversion:this.conversion,disabled:this.disabled,"@value-input":this._onNumberSet}),(arg0={id:"slider",value:this.value*this.conversion,step:this.step*this.conversion,min:this.min*this.conversion,max:this.max*this.conversion,exponent:this.exponent,disabled:this.disabled,"@value-input":this._onSliderSet},IoSlider.vConstructor(arg0))])}};__decorateClass$o([ReactiveProperty({value:0})],IoNumberSlider.prototype,"value",2),__decorateClass$o([ReactiveProperty(.01)],IoNumberSlider.prototype,"step",2),__decorateClass$o([ReactiveProperty(0)],IoNumberSlider.prototype,"min",2),__decorateClass$o([ReactiveProperty(1)],IoNumberSlider.prototype,"max",2),__decorateClass$o([ReactiveProperty(1)],IoNumberSlider.prototype,"exponent",2),__decorateClass$o([ReactiveProperty(1)],IoNumberSlider.prototype,"conversion",2),__decorateClass$o([ReactiveProperty(!1)],IoNumberSlider.prototype,"disabled",2),IoNumberSlider=__decorateClass$o([Register],IoNumberSlider);const ioNumberSlider=function(arg0){return IoNumberSlider.vConstructor(arg0)};var __defProp$j=Object.defineProperty,__getOwnPropDesc$l=Object.getOwnPropertyDescriptor,__decorateClass$n=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$l(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$j(target,key,result),result};let IoSlider2d=class extends IoSliderBase{static get Style(){return"\n      :host {\n        cursor: crosshair;\n        border: var(--io_border);\n        border-radius: var(--io_borderRadius);\n        border-color: var(--io_borderColorInset);\n        flex-grow: 0;\n      }\n      :host:not([vertical]),\n      :host[vertical] {\n        min-width: calc(var(--io_fieldHeight) * 5);\n        min-height: calc(var(--io_fieldHeight) * 5);\n        cursor: crosshair;\n      }\n    "}constructor(args={}){super(args)}static get GlUtils(){return"\n      vec3 paintKnob(vec3 dstCol, vec2 p, vec2 center, vec3 color) {\n        vec4 finalCol = vec4(0.0);\n        vec2 pCenter = translate(p, center);\n        float radius = io_fieldHeight * 0.25;\n        float stroke = io_borderWidth;\n        float strokeShape = circle(pCenter, radius + stroke + stroke);\n        float fillShape   = circle(pCenter, radius + stroke);\n        float colorShape  = circle(pCenter, radius);\n        finalCol = mix(io_colorStrong, finalCol, strokeShape);\n        finalCol = mix(vec4(io_bgColor.rgb, 1.0), finalCol, fillShape);\n        finalCol = mix(vec4(color, 1.0), finalCol, colorShape);\n        return compose(dstCol, finalCol);\n      }\n    "}static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * (uv - vec2(0.5));\n\n      // Colors\n      vec3 finalCol = io_bgColorInput.rgb;\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 sliderCol = io_bgColorBlue.rgb;\n      vec3 lineCol1 = io_color.rgb;\n      vec3 lineCol2 = io_bgColor.rgb;\n\n      // Grid\n      vec2 gridSize = size / abs((uMax - uMin) / uStep);\n      vec2 gridOffset = (uMax + uMin) / (uMax - uMin) * size / 2.;\n      vec2 gridPosition = translate(position, -gridOffset);\n      float gridShape = paintDerivativeGrid2D(gridPosition, gridSize, io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      // Axis\n      float axisShape = lineCross2d(gridPosition, io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, axisShape));\n\n      // Knob\n      vec2 knobPos = uValue / (uMax - uMin) * size;\n      finalCol = paintKnob(finalCol, gridPosition, knobPos, sliderCol);\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }"}};__decorateClass$n([ReactiveProperty({type:Array,value:void 0,init:[0,0]})],IoSlider2d.prototype,"value",2),__decorateClass$n([ReactiveProperty({type:Array,value:void 0,init:[.01,.01]})],IoSlider2d.prototype,"step",2),__decorateClass$n([ReactiveProperty({type:Array,value:void 0,init:[-1,-1]})],IoSlider2d.prototype,"min",2),__decorateClass$n([ReactiveProperty({type:Array,value:void 0,init:[1,1]})],IoSlider2d.prototype,"max",2),__decorateClass$n([Property(!0)],IoSlider2d.prototype,"noscroll",2),IoSlider2d=__decorateClass$n([Register],IoSlider2d);var __defProp$i=Object.defineProperty,__getOwnPropDesc$k=Object.getOwnPropertyDescriptor,__decorateClass$m=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$k(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$i(target,key,result),result};let IoColorBase=class extends IoElement{ready(){this.valueChanged(),this.changed()}valueMutated(){this.valueChanged(),this.changed()}rgbFromHsv(){const rgb=function(hsv){const h=hsv[0]/60,s=hsv[1]/100;let v=hsv[2]/100;const hi=Math.floor(h)%6,f=h-Math.floor(h),p=255*v*(1-s),q=255*v*(1-s*f),t=255*v*(1-s*(1-f));switch(v*=255,hi){case 0:return[v,t,p];case 1:return[q,v,p];case 2:return[p,v,t];case 3:return[p,q,v];case 4:return[t,p,v];default:return[v,p,q]}}([360*this.hsv[0],100*this.hsv[1],100*this.hsv[2]]);this.rgba[0]=rgb[0]/255,this.rgba[1]=rgb[1]/255,this.rgba[2]=rgb[2]/255}rgbFromHsl(){const rgb=function(hsl){const h=hsl[0]/360,s=hsl[1]/100,l=hsl[2]/100;let t2,t3,val;if(0===s)return val=255*l,[val,val,val];t2=l<.5?l*(1+s):l+s-l*s;const t1=2*l-t2,rgb=[0,0,0];for(let i=0;i<3;i++)t3=h+1/3*-(i-1),t3<0&&t3++,t3>1&&t3--,val=6*t3<1?t1+6*(t2-t1)*t3:2*t3<1?t2:3*t3<2?t1+(t2-t1)*(2/3-t3)*6:t1,rgb[i]=255*val;return rgb}([360*this.hsl[0],100*this.hsl[1],100*this.hsl[2]]);this.rgba[0]=rgb[0]/255,this.rgba[1]=rgb[1]/255,this.rgba[2]=rgb[2]/255}valueFromRgb(){this.value.r=this.rgba[0],this.value.g=this.rgba[1],this.value.b=this.rgba[2]}valueChanged(){{const c=Object.keys(this.value);-1!==c.indexOf("r")&&-1!==c.indexOf("g")&&-1!==c.indexOf("b")||console.warn("IoColor: Incorrect value type!")}const rgb=[255*this.value.r,255*this.value.g,255*this.value.b],hsv=function(rgb){let rdif,gdif,bdif,s,h=0;const r=rgb[0]/255,g=rgb[1]/255,b=rgb[2]/255,v=Math.max(r,g,b),diff=v-Math.min(r,g,b),diffc=function(c){return(v-c)/6/diff+.5};return 0===diff?(h=0,s=0):(s=diff/v,rdif=diffc(r),gdif=diffc(g),bdif=diffc(b),r===v?h=bdif-gdif:g===v?h=1/3+rdif-bdif:b===v&&(h=2/3+gdif-rdif),h<0?h+=1:h>1&&(h-=1)),[360*h,100*s,100*v]}(rgb),hsl=function(rgb){const r=rgb[0]/255,g=rgb[1]/255,b=rgb[2]/255,min=Math.min(r,g,b),max=Math.max(r,g,b),delta=max-min;let s,h=0;max===min?h=0:r===max?h=(g-b)/delta:g===max?h=2+(b-r)/delta:b===max&&(h=4+(r-g)/delta),h=Math.min(60*h,360),h<0&&(h+=360);const l=(min+max)/2;return s=max===min?0:l<=.5?delta/(max+min):delta/(2-max-min),[h,100*s,100*l]}(rgb);0!==hsv[0]&&360!==hsv[0]||(hsv[0]=360*this.hsv[0]),0!==hsl[0]&&360!==hsl[0]||(hsl[0]=360*this.hsl[0]),0===hsv[1]&&(hsv[0]=360*this.hsv[0]),0===hsl[1]&&(hsl[0]=360*this.hsl[0]),0===hsv[2]&&(hsv[1]=100*this.hsv[1]),0!==hsl[2]&&100!==hsl[2]||(hsl[0]=360*this.hsl[0],hsl[1]=100*this.hsl[1]),this.rgba[0]=rgb[0]/255,this.rgba[1]=rgb[1]/255,this.rgba[2]=rgb[2]/255,this.rgba[3]=this.value.a??1,this.hsv[0]=hsv[0]/360,this.hsv[1]=hsv[1]/100,this.hsv[2]=hsv[2]/100,this.hsl[0]=hsl[0]/360,this.hsl[1]=hsl[1]/100,this.hsl[2]=hsl[2]/100,this.setProperties({rgba:this.rgba,hsv:this.hsv,hsl:this.hsl})}};__decorateClass$m([ReactiveProperty("throttled")],IoColorBase.prototype,"reactivity",2),__decorateClass$m([ReactiveProperty({type:Object,init:{r:1,g:1,b:1,a:1}})],IoColorBase.prototype,"value",2),__decorateClass$m([ReactiveProperty({type:Array,init:[1,1,1,1]})],IoColorBase.prototype,"rgba",2),__decorateClass$m([ReactiveProperty({type:Array,init:[1,1,1]})],IoColorBase.prototype,"hsv",2),__decorateClass$m([ReactiveProperty({type:Array,init:[1,1,1]})],IoColorBase.prototype,"hsl",2),IoColorBase=__decorateClass$m([Register],IoColorBase);var __defProp$h=Object.defineProperty,__getOwnPropDesc$j=Object.getOwnPropertyDescriptor,__decorateClass$l=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$j(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$h(target,key,result),result};let IoColorSlider=class extends IoColorBase{static get Style(){return"\n      :host {\n        display: flex;\n      }\n    "}_onValueInput(event){const v=event.detail.value,oldValue=JSON.stringify(this.value);switch(this.channel){case"r":this.value.r=v;break;case"g":this.value.g=v;break;case"b":this.value.b=v;break;case"a":this.value.a=v;break;case"h":this.hsv[0]=v,this.rgbFromHsv(),this.valueFromRgb();break;case"s":this.hsv[1]=v,this.rgbFromHsv(),this.valueFromRgb();break;case"v":this.hsv[2]=v,this.rgbFromHsv(),this.valueFromRgb();break;case"l":this.hsl[2]=v,this.rgbFromHsl(),this.valueFromRgb();break;case"hs":this.hsv[0]=v[0],this.hsv[1]=v[1],this.rgbFromHsv(),this.valueFromRgb();break;case"sv":this.hsv[1]=v[0],this.hsv[2]=v[1],this.rgbFromHsv(),this.valueFromRgb();break;case"sl":this.hsl[1]=v[0],this.hsl[2]=v[1],this.rgbFromHsl(),this.valueFromRgb()}oldValue!==JSON.stringify(this.value)&&(this.value._isNode||this.dispatchMutation(this.value),this.dispatch("value-input",{property:"value",value:this.value},!1))}changed(){const c=this.channel;-1===["r","g","b","a","h","s","v","l","hs","sv","sl"].indexOf(c)&&console.warn("IoColorSlider: Incorrect channel value!",c);let slider=null;switch(c){case"r":slider=ioColorSliderR();break;case"g":slider=ioColorSliderG();break;case"b":slider=ioColorSliderB();break;case"a":slider=ioColorSliderA();break;case"h":slider=ioColorSliderH();break;case"s":slider=ioColorSliderS();break;case"v":slider=ioColorSliderV();break;case"l":slider=ioColorSliderL();break;case"hs":slider=ioColorSliderHs();break;case"sv":slider=ioColorSliderSv();break;case"sl":slider=ioColorSliderSl()}let value=0,color=[0,0,0,0],min=0,max=1,step=this.step;switch(this.channel){case"r":value=this.value.r,color=[...this.rgba];break;case"g":value=this.value.g,color=[...this.rgba];break;case"b":value=this.value.b,color=[...this.rgba];break;case"a":value=this.value.a||0,color=[...this.rgba];break;case"h":value=this.hsv[0],color=[...this.hsv,1];break;case"s":value=this.hsv[1],color=[...this.hsv,1];break;case"v":value=this.hsv[2],color=[...this.hsv,1];break;case"l":value=this.hsl[2],color=[...this.hsl,1];break;case"hs":value=[this.hsv[0],this.hsv[1]],color=[...this.hsv,1],min=[min,min],max=[max,max],step=[step,step];break;case"sv":value=[this.hsv[1],this.hsv[2]],color=[...this.hsv,1],min=[min,min],max=[max,max],step=[step,step];break;case"sl":value=[this.hsl[1],this.hsl[2]],color=[...this.hsl,1],min=[min,min],max=[max,max],step=[step,step]}slider.props={id:c,value:value,min:min,max:max,step:step,vertical:this.vertical,color:color,"@value-input":this._onValueInput},this.render([slider])}};__decorateClass$l([ReactiveProperty({type:Array,init:[0,0,0,0]})],IoColorSlider.prototype,"color",2),__decorateClass$l([ReactiveProperty({type:Number,value:.01})],IoColorSlider.prototype,"step",2),__decorateClass$l([ReactiveProperty("a")],IoColorSlider.prototype,"channel",2),__decorateClass$l([ReactiveProperty({value:!1,reflect:!0})],IoColorSlider.prototype,"vertical",2),IoColorSlider=__decorateClass$l([Register],IoColorSlider);const ioColorSlider=function(arg0){return IoColorSlider.vConstructor(arg0)};class IoColorSliderBase extends IoSlider{static get GlUtils(){return`\n      // Note: Implement in subclass!\n      // TODO: Allow GlUtils to rewrite inherited functions!\n      // vec3 getStartColor(vec2 uv) {}\n      // vec3 getEndColor(vec2 uv) {}\n      ${glsl_hue2rgb}\n      ${glsl_hsv2rgb}\n      ${glsl_hsl2rgb}\n\n      vec3 paintHorizontalLine(vec3 dstCol, vec2 p, vec3 color) {\n        float lineShape = lineHorizontal(p, io_borderWidth * 2.0);\n        return compose(dstCol, vec4(color, lineShape));\n      }\n    `}static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * vec2(uv.x, uv.y - 0.5);\n      float valueInRange = (uValue - uMin) / (uMax - uMin);\n\n      // Colors\n      vec3 finalCol = io_bgColorInput.rgb;\n      vec3 startCol = getStartColor(uv);\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 endCol = getEndColor(uv);\n      vec3 sliderCol = mix(startCol, endCol, uv.x);\n\n      vec2 linePos = translate(size * uv, 0.0, size.y / 2.);\n      finalCol = paintHorizontalLine(finalCol, linePos, sliderCol);\n\n      // Grid\n      float gridSize = size.x / abs((uMax - uMin) / uStep);\n      float gridOffset = mod(uStep - uMin, uStep) / (uMax - uMin) * size.x;\n      float gridShape = paintDerivativeGrid2D(translate(position, gridOffset, 0.0), vec2(gridSize, 0.0), io_borderWidth);\n      if (size.x * uStep < 4.0) gridShape = 0.0;\n      finalCol = compose(finalCol, vec4(sliderCol, gridShape * 0.25));\n\n      // Slider\n      float sliderShape = rectangle(position, vec2(size.x * valueInRange, size.y));\n      finalCol = compose(finalCol, vec4(sliderCol, sliderShape));\n      finalCol = compose(finalCol, vec4(io_bgColorInput.rgb, gridShape * sliderShape * 0.125));\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }"}valueMutated(){}}__decorateClass$l([ReactiveProperty({type:Array,init:[0,0,0,0]})],IoColorSliderBase.prototype,"color",2);class IoColorSlider2dBase extends IoSlider2d{static get GlUtils(){return`\n      // Note: Implement in subclass!\n      // TODO: Allow GlUtils to rewrite inherited functions!\n      // vec3 getColor(vec2 uv) {}\n      ${glsl_hue2rgb}\n      ${glsl_hsv2rgb}\n      ${glsl_hsl2rgb}\n    `}static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * (uv - vec2(0.5));\n\n      // Colors\n      vec3 finalCol = color_field(uv);\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 sliderCol = color_field(uValue);\n\n      // Grid\n      vec2 gridSize = size / abs((uMax - uMin) / uStep);\n      vec2 gridOffset = (uMax + uMin) / (uMax - uMin) * size / 2.;\n      vec2 gridPosition = translate(position, -gridOffset);\n      float gridShape = paintDerivativeGrid2D(gridPosition, gridSize, io_borderWidth);\n      if (min(size.x * uStep.x, size.y * uStep.y) < 2.0) gridShape = 0.0;\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      vec2 knobPos = uValue / (uMax - uMin) * size;\n      finalCol = paintKnob(finalCol, gridPosition, knobPos, sliderCol);\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }"}valueMutated(){}}__decorateClass$l([ReactiveProperty({type:Array,init:[0,0,0,0]})],IoColorSlider2dBase.prototype,"color",2);let IoColorSliderR=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        return vec3(uv.x, uColor[1], uColor[2]);\n      }\n      vec3 getEndColor(vec2 uv) {\n        return vec3(uv.x, uColor[1], uColor[2]);\n      }\n    "}};IoColorSliderR=__decorateClass$l([Register],IoColorSliderR);const ioColorSliderR=function(arg0){return IoColorSliderR.vConstructor(arg0)};let IoColorSliderG=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        return vec3(uColor[0], uv.x, uColor[2]);\n      }\n      vec3 getEndColor(vec2 uv) {\n        return vec3(uColor[0], uv.x, uColor[2]);\n      }\n    "}};IoColorSliderG=__decorateClass$l([Register],IoColorSliderG);const ioColorSliderG=function(arg0){return IoColorSliderG.vConstructor(arg0)};let IoColorSliderB=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        return vec3(uColor[0], uColor[1], uv.x);\n      }\n      vec3 getEndColor(vec2 uv) {\n        return vec3(uColor[0], uColor[1], uv.x);\n      }\n    "}};IoColorSliderB=__decorateClass$l([Register],IoColorSliderB);const ioColorSliderB=function(arg0){return IoColorSliderB.vConstructor(arg0)};let IoColorSliderA=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        vec2 size = uVertical == 1 ? uSize.yx : uSize;\n        vec2 position = size * (uv - vec2(0.0, 0.5));\n        return mix(vec3(0.5), vec3(1.0), checkerX(position, io_fieldHeight / 4.0));\n      }\n      vec3 getEndColor(vec2 uv) {\n        vec2 size = uVertical == 1 ? uSize.yx : uSize;\n        vec2 position = size * (uv - vec2(0.0, 0.5));\n        vec3 chkCol = mix(vec3(0.5), vec3(1.0), checkerX(position, io_fieldHeight / 4.0));\n        return mix(chkCol, uColor.rgb, 1.0);\n      }\n    "}};IoColorSliderA=__decorateClass$l([Register],IoColorSliderA);const ioColorSliderA=function(arg0){return IoColorSliderA.vConstructor(arg0)};let IoColorSliderH=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        return hsv2rgb(vec3(uv.x, uColor[1], uColor[2]));\n      }\n      vec3 getEndColor(vec2 uv) {\n        return hsv2rgb(vec3(uv.x, uColor[1], uColor[2]));\n      }\n    "}};IoColorSliderH=__decorateClass$l([Register],IoColorSliderH);const ioColorSliderH=function(arg0){return IoColorSliderH.vConstructor(arg0)};let IoColorSliderS=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        return hsv2rgb(vec3(uColor[0], uv.x, uColor[2]));\n      }\n      vec3 getEndColor(vec2 uv) {\n        return hsv2rgb(vec3(uColor[0], uv.x, uColor[2]));\n      }\n    "}};IoColorSliderS=__decorateClass$l([Register],IoColorSliderS);const ioColorSliderS=function(arg0){return IoColorSliderS.vConstructor(arg0)};let IoColorSliderV=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        return hsv2rgb(vec3(uColor[0], uColor[1], uv.x));\n      }\n      vec3 getEndColor(vec2 uv) {\n        return hsv2rgb(vec3(uColor[0], uColor[1], uv.x));\n      }\n    "}};IoColorSliderV=__decorateClass$l([Register],IoColorSliderV);const ioColorSliderV=function(arg0){return IoColorSliderV.vConstructor(arg0)};let IoColorSliderL=class extends IoColorSliderBase{static get GlUtils(){return"\n      vec3 getStartColor(vec2 uv) {\n        return hsl2rgb(vec3(uColor[0], uColor[1], uv.x));\n      }\n      vec3 getEndColor(vec2 uv) {\n        return hsl2rgb(vec3(uColor[0], uColor[1], uv.x));\n      }\n    "}};IoColorSliderL=__decorateClass$l([Register],IoColorSliderL);const ioColorSliderL=function(arg0){return IoColorSliderL.vConstructor(arg0)};let IoColorSliderHs=class extends IoColorSlider2dBase{static get GlUtils(){return"\n      vec3 color_field(vec2 uv) {\n        return hsv2rgb(vec3(uv, uColor[2]));\n      }\n    "}};IoColorSliderHs=__decorateClass$l([Register],IoColorSliderHs);const ioColorSliderHs=function(arg0){return IoColorSliderHs.vConstructor(arg0)};let IoColorSliderSv=class extends IoColorSlider2dBase{static get GlUtils(){return"\n      vec3 color_field(vec2 uv) {\n        return hsv2rgb(vec3(uColor[0], uv));\n      }\n    "}};IoColorSliderSv=__decorateClass$l([Register],IoColorSliderSv);const ioColorSliderSv=function(arg0){return IoColorSliderSv.vConstructor(arg0)};let IoColorSliderSl=class extends IoColorSlider2dBase{static get GlUtils(){return"\n      vec3 color_field(vec2 uv) {\n        return hsl2rgb(vec3(uColor[0], uv));\n      }\n    "}};IoColorSliderSl=__decorateClass$l([Register],IoColorSliderSl);const ioColorSliderSl=function(arg0){return IoColorSliderSl.vConstructor(arg0)};var __defProp$g=Object.defineProperty,__getOwnPropDesc$i=Object.getOwnPropertyDescriptor,__decorateClass$k=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$i(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$g(target,key,result),result};let IoColorPanel=class extends IoColorBase{static get Style(){return"\n    :host {\n      display: flex;\n      flex-direction: row;\n      border: var(--io_border);\n      border-color: var(--io_borderColorOutset);\n      background-color: var(--io_bgColorLight);\n      padding: var(--io_spacing2);\n      border-radius: calc(var(--io_borderRadius) + var(--io_spacing2));\n    }\n    :host:not([expanded]) {\n      display: none;\n    }\n    :host > *:not(:last-child) {\n      margin: 0 var(--io_spacing2) 0 0;\n    }\n    "}static get Listeners(){return{keydown:"onKeydown","io-focus-to":"onIoFocusTo"}}onKeydown(event){"Escape"!==event.key&&"Enter"!==event.key&&" "!==event.key||(event.preventDefault(),this.expanded=!1)}onIoFocusTo(event){const source=event.detail.source,command=event.detail.command,sliders=Array.from(this.querySelectorAll("[tabindex]")),index=Array.from(sliders).indexOf(source);"ArrowDown"===command||"ArrowLeft"===command&&0===index?(sliders[sliders.length-1].focus(),event.stopPropagation()):("ArrowUp"===command||"ArrowRight"===command&&index===sliders.length-1)&&(sliders[0].focus(),event.stopPropagation())}onValueInput(){this.dispatch("value-input",{property:"value",value:this.value},!0)}changed(){this.render([ioColorSlider({value:this.value,channel:"sv","@value-input":this.onValueInput}),ioColorSlider({value:this.value,channel:"h",vertical:!0,"@value-input":this.onValueInput}),void 0!==this.value.a?ioColorSlider({value:this.value,channel:"a","@value-input":this.onValueInput,vertical:!0}):null])}};__decorateClass$k([ReactiveProperty({value:!1,reflect:!0})],IoColorPanel.prototype,"expanded",2),IoColorPanel=__decorateClass$k([Register],IoColorPanel);const IoColorPanelSingleton=new IoColorPanel;setTimeout(()=>{IoOverlaySingleton.appendChild(IoColorPanelSingleton)},100);var __getOwnPropDesc$h=Object.getOwnPropertyDescriptor;let IoColorSwatch=class extends IoColorBase{static get Style(){return"\n      :host {\n        display: inline-block;\n        min-width: var(--io_fieldHeight);\n        height: var(--io_fieldHeight);\n        background-color: white;\n        background-image: linear-gradient(45deg, #808080 25%, transparent 25%), linear-gradient(-45deg, #808080 25%, transparent 25%), linear-gradient(45deg, transparent 75%, #808080 75%), linear-gradient(-45deg, transparent 75%, #808080 75%);\n        background-size: 12px 12px;\n        background-position: 0 0, 0 6px, 6px -6px, -6px 0px;\n        overflow: visible;\n      }\n      :host > div { \n        width: 100%;\n        height: 100%;\n      }\n    "}valueChanged(){super.valueChanged(),this.render([div$1({style:{"background-color":`rgba(${255*this.rgba[0]},${255*this.rgba[1]}, ${255*this.rgba[2]}, ${this.rgba[3]})`}})])}};IoColorSwatch=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$h(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],IoColorSwatch);var __defProp$f=Object.defineProperty,__getOwnPropDesc$g=Object.getOwnPropertyDescriptor,__decorateClass$i=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$g(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$f(target,key,result),result};let IoColorPicker=class extends IoElement{static get Style(){return"\n      :host {\n        position: relative;\n        height: var(--io_fieldHeight);\n        border: var(--io_border);\n        border-color: var(--io_borderColorInset);\n        border-radius: var(--io_borderRadius);\n        overflow: hidden;\n      }\n      :host:focus {\n        @apply --io_focus;\n      }\n      :host > io-color-swatch {\n        width: 100%;\n        height: 100%;\n      }\n    "}static get Listeners(){return{click:"onClick",keydown:"onKeydown"}}get expanded(){return IoColorPanelSingleton.expanded&&IoColorPanelSingleton.value===this.value}ready(){this.valueChanged()}onClick(){this.expanded||this.expand()}onKeydown(event){switch(event.key){case"Enter":case" ":event.preventDefault(),this.expanded||this.expand();break;default:["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Home","End","PageUp","PageDown"].includes(event.key)&&(event.preventDefault(),this.dispatch("io-focus-to",{source:this,command:event.key},!0))}}onValueSet(){this.dispatch("value-input",{property:"value",value:this.value},!0)}onPanelCollapse(){this.expanded||(IoColorPanelSingleton.removeEventListener("value-input",this.onValueSet),IoColorPanelSingleton.removeEventListener("expanded-changed",this.onPanelCollapse))}expand(){IoColorPanelSingleton.value=this.value,IoColorPanelSingleton.expanded=!0,IoColorPanelSingleton.addEventListener("value-input",this.onValueSet),IoColorPanelSingleton.addEventListener("expanded-changed",this.onPanelCollapse),nudge(IoColorPanelSingleton,this,"right"),IoColorPanelSingleton.firstChild?.firstChild?.focus()}collapse(){IoColorPanelSingleton.expanded=!1,IoColorPanelSingleton.value={r:1,g:1,b:1,a:1}}valueChanged(){var arg0;this.render([(arg0={value:this.value},IoColorSwatch.vConstructor(arg0))])}};__decorateClass$i([ReactiveProperty({value:{r:1,g:1,b:1,a:1}})],IoColorPicker.prototype,"value",2),__decorateClass$i([Property(0)],IoColorPicker.prototype,"tabIndex",2),IoColorPicker=__decorateClass$i([Register],IoColorPicker);var __getOwnPropDesc$f=Object.getOwnPropertyDescriptor;let IoColorRgba=class extends IoColorBase{static get Style(){return"\n      :host {\n        display: flex;\n        flex: 1 1 auto;\n        overflow: hidden;\n      }\n      :host > io-number {\n        flex: 1 0 0;\n      }\n      :host > io-number#r {\n        border-bottom-color: var(--io_bgColorRed);\n      }\n      :host > io-number#g {\n        border-bottom-color: var(--io_bgColorGreen);\n      }\n      :host > io-number#b {\n        border-bottom-color: var(--io_bgColorBlue);\n      }\n      :host > io-number#a {\n        border-bottom-color: var(--io_color);\n      }\n      :host > io-color-picker {\n        flex-shrink: 0;\n      }\n      :host > *:not(:last-child) {\n        margin-right: var(--io_spacing);\n      }\n    "}_onNumberValueInput(event){event.stopPropagation();const item=event.composedPath()[0];["r","g","b"].includes(item.id)&&(this.value[item.id]=event.detail.value),this.dispatch("value-input",{property:"value",value:this.value},!1)}changed(){var arg0;this.render([ioNumber({id:"r",value:this.value.r,min:0,max:1,step:.001,ladder:!0,"@value-input":this._onNumberValueInput}),ioNumber({id:"g",value:this.value.g,min:0,max:1,step:.001,ladder:!0,"@value-input":this._onNumberValueInput}),ioNumber({id:"b",value:this.value.b,min:0,max:1,step:.001,ladder:!0,"@value-input":this._onNumberValueInput}),void 0!==this.value.a?ioNumber({id:"a",value:this.value.a,min:0,max:1,step:1e-4,ladder:!0,"@value-input":this._onNumberValueInput}):null,(arg0={id:"swatch",value:this.value,"@value-input":this._onNumberValueInput},IoColorPicker.vConstructor(arg0))])}};IoColorRgba=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$f(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],IoColorRgba);const ioColorRgba=function(arg0){return IoColorRgba.vConstructor(arg0)},SKIPPED_PROPERTIES=["$","ELEMENT_NODE","ATTRIBUTE_NODE","TEXT_NODE","CDATA_SECTION_NODE","ENTITY_REFERENCE_NODE","ENTITY_NODE","PROCESSING_INSTRUCTION_NODE","COMMENT_NODE","DOCUMENT_NODE","DOCUMENT_TYPE_NODE","DOCUMENT_FRAGMENT_NODE","NOTATION_NODE","DOCUMENT_POSITION_DISCONNECTED","DOCUMENT_POSITION_PRECEDING","DOCUMENT_POSITION_FOLLOWING","DOCUMENT_POSITION_CONTAINS","DOCUMENT_POSITION_CONTAINED_BY","DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC","onbeforecopy","onbeforecut","onbeforepaste","onsearch","onfullscreenchange","onfullscreenerror","onwebkitfullscreenchange","onwebkitfullscreenerror","namespaceURI","onbeforexrselect","onabort","onbeforeinput","onbeforematch","onbeforetoggle","onblur","oncancel","oncanplay","oncanplaythrough","onchange","onclick","onclose","oncontentvisibilityautostatechange","oncontextlost","oncontextmenu","oncontextrestored","oncuechange","ondblclick","ondrag","ondragend","ondragenter","ondragleave","ondragover","ondragstart","ondrop","ondurationchange","onemptied","onended","onerror","onfocus","onformdata","oninput","oninvalid","onkeydown","onkeypress","onkeyup","onload","onloadeddata","onloadedmetadata","onloadstart","onmousedown","onmouseenter","onmouseleave","onmousemove","onmouseout","onmouseover","onmouseup","onmousewheel","onpause","onplay","onplaying","onprogress","onratechange","onreset","onresize","onscroll","onsecuritypolicyviolation","onseeked","onseeking","onselect","onslotchange","onstalled","onsubmit","onsuspend","ontimeupdate","ontoggle","onvolumechange","onwaiting","onwebkitanimationend","onwebkitanimationiteration","onwebkitanimationstart","onwebkittransitionend","onwheel","onauxclick","ongotpointercapture","onlostpointercapture","onpointerdown","onpointermove","onpointerrawupdate","onpointerup","onpointercancel","onpointerover","onpointerout","onpointerenter","onpointerleave","onselectstart","onselectionchange","onanimationend","onanimationiteration","onanimationstart","ontransitionrun","ontransitionstart","ontransitionend","ontransitioncancel","oncopy","oncut","onpaste","oncommand","onscrollend","onscrollsnapchange","onscrollsnapchangin","onscrollsnapchanging","onafterprint","onbeforeprint","onbeforeunload","onhashchange","onlanguagechange","onmessage","onmessageerror","onoffline","ononline","onpagehide","onpageshow","onpopstate","onrejectionhandled","onstorage","onunhandledrejection","onunload","onenterpictureinpicture","onreadystatechange","onpointerlockchange","onpointerlockerror","onfreeze","onprerenderingchange","onresume","onvisibilitychange","onleavepictureinpicture"];function getAllPropertyNames(obj){const allProps=[];let curr=obj;do{if(Object.getOwnPropertyNames(curr).forEach(prop=>{-1!==allProps.indexOf(prop)||SKIPPED_PROPERTIES.includes(prop)||allProps.push(prop)}),curr.constructor===window.Node)break}while(curr=Object.getPrototypeOf(curr));return allProps}const editorGroupsSingleton=/* @__PURE__ */new Map([[Object,{Hidden:["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toString","valueOf","toLocaleString",new RegExp(/^__/)],Advanced:[new RegExp(/^_(?!_)/)]}],[Array,{Hidden:["length","constructor","at","concat","copyWithin","fill","find","findIndex","findLast","findLastIndex","lastIndexOf","pop","push","reverse","shift","unshift","slice","sort","splice","includes","indexOf","join","keys","entries","values","forEach","filter","flat","flatMap","map","every","some","reduce","reduceRight","toReversed","toSorted","toSpliced","with","toLocaleString","toString"]}],[Node,{Main:["textContent"],Input:["lang","translate","dir","inert","accessKey","draggable","writingSuggestions","spellcheck","autocapitalize","editContext","contentEditable","enterKeyHint","inputMode","virtualKeyboardPolicy"],Hierarchy:["isConnected","ownerDocument","parentNode","parentElement","childNodes","firstChild","lastChild","previousSibling","nextSibling","children","firstElementChild","lastElementChild","childElementCount","previousElementSibling","nextElementSibling","elementTiming"],Layout:["scrollTop","scrollLeft","scrollWidth","scrollHeight","clientTop","clientLeft","clientWidth","clientHeight","currentCSSZoom","offsetParent","offsetTop","offsetLeft","offsetWidth","offsetHeight"],Aria:["role","ariaAtomic","ariaAutoComplete","ariaBusy","ariaBrailleLabel","ariaBrailleRoleDescription","ariaChecked","ariaColCount","ariaColIndex","ariaColSpan","ariaCurrent","ariaDescription","ariaDisabled","ariaExpanded","ariaHasPopup","ariaHidden","ariaInvalid","ariaKeyShortcuts","ariaLabel","ariaLevel","ariaLive","ariaModal","ariaMultiLine","ariaMultiSelectable","ariaOrientation","ariaPlaceholder","ariaPosInSet","ariaPressed","ariaReadOnly","ariaRelevant","ariaRequired","ariaRoleDescription","ariaRowCount","ariaRowIndex","ariaRowSpan","ariaSelected","ariaSetSize","ariaSort","ariaValueMax","ariaValueMin","ariaValueNow","ariaValueText","ariaColIndexText","ariaRowIndexText","ariaActiveDescendantElement","ariaControlsElements","ariaDescribedByElements","ariaDetailsElements","ariaErrorMessageElements","ariaFlowToElements","ariaLabelledByElements"],Hidden:[]}],[ReactiveNode,{Hidden:["reactivity","_changeQueue","_reactiveProperties","_bindings","_eventDispatcher","_parents","_protochain","_disposed","_isNode","_isIoElement"]}],[IoElement,{Hidden:["reactivity","_changeQueue","_reactiveProperties","_bindings","_eventDispatcher","_parents","_protochain","_disposed","_isNode","_isIoElement"]}]]);function registerEditorGroups(constructor,groups){const existingGroups=editorGroupsSingleton.get(constructor)||{};for(const group in groups)existingGroups[group]=existingGroups[group]||[],existingGroups[group].push(...groups[group]);editorGroupsSingleton.set(constructor,existingGroups)}const editorWidgetsSingleton=/* @__PURE__ */new Map([]);function registerEditorWidget(constructor,widget){editorWidgetsSingleton.set(constructor,widget)}var __defProp$e=Object.defineProperty,__getOwnPropDesc$e=Object.getOwnPropertyDescriptor,__decorateClass$g=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$e(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$e(target,key,result),result};let IoPropertyEditor=class extends IoElement{static get Style(){return"\n    :host {\n      display: flex;\n      flex-direction: column;\n      color: var(--io_colorInput);\n      background-color: var(--io_bgColor);\n      border-radius: calc(var(--io_borderRadius) + var(--io_spacing));\n      font-size: var(--io_fontSize);\n      overflow: auto;\n    }\n    :host > .row {\n      display: flex;\n      flex-direction: row;\n      flex: 1 1 auto;\n      margin: var(--io_spacing);\n      padding: var(--io_spacing) 0;\n      border-radius: var(--io_borderRadius);\n      margin-bottom: 0;\n      background-color: var(--io_bgColorLight);\n    }\n    :host io-property-editor {\n      margin-top: calc(var(--io_spacing) * -1) !important;\n    }\n    :host io-property-editor > .row {\n      /* margin: 0 !important; */\n      padding: 0 !important;\n    }\n    :host > .row:last-of-type {\n      margin-bottom: var(--io_spacing);\n    }\n    :host > .row > span {\n      flex: 0 0 auto;\n      padding: var(--io_borderWidth); /* TODO: verify correctness */\n      margin: var(--io_spacing);\n      margin-left: var(--io_spacing2);\n      line-height: var(--io_lineHeight);\n      height: var(--io_lineHeight);\n      text-wrap: nowrap;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n    :host > .row > span:after {\n      display: inline-block;\n      margin-left: var(--io_spacing);\n      opacity: 0.5;\n      content: ':';\n    }\n\n    :host > .row > :not(span) {\n      flex-grow: 1;\n    }\n    "}_config=null;_groups=null;_widget=null;_propertyEditors={};_onValueInput(event){event.stopImmediatePropagation();const id=event.target.id;void 0!==id?(this.value[id]=event.detail.value,this.value._isNode||this.dispatchMutation(this.value)):console.warn('IoPropertyEditor: "value-input" recieved from an input without a property id')}configChanged(){this.debounce(this.configureDebounced)}groupsChanged(){this.debounce(this.configureDebounced)}widgetChanged(){this.debounce(this.configureDebounced)}valueChanged(){null===this.value||"object"==typeof this.value||Array.isArray(this.value)||console.warn("IoPropertyEditor: value is not an object or array",this,this.value),this.debounce(this.configureDebounced)}configureDebounced(){if(this._propertyEditors={},!this.value||"object"!=typeof this.value)return this._config=null,this._groups=null,this._widget=null,void this.render([]);{this._config=function getEditorConfig(object,propertyConfigs){if(!(object&&object instanceof Object))return console.warn("`getObjectConfig` should be used with an Object instance"),{};const cachedConfig=configCache.get(object,propertyConfigs);if(cachedConfig)return cachedConfig;const aggregatedConfig=/* @__PURE__ */new Map;for(const[constructorKey,propertyTypes]of editorConfigSingleton)if(object instanceof constructorKey)for(const[PropertyIdentifier,config]of propertyTypes)aggregatedConfig.set(PropertyIdentifier,config);for(const[PropertyIdentifier,config]of propertyConfigs)aggregatedConfig.set(PropertyIdentifier,config);const configRecord={};for(const key of getAllPropertyNames(object)){const value=object[key];for(const[PropertyIdentifier,elementCandidate]of aggregatedConfig){let element;"function"==typeof PropertyIdentifier&&value instanceof PropertyIdentifier||"function"==typeof PropertyIdentifier&&value?.constructor===PropertyIdentifier?element=elementCandidate:"string"==typeof PropertyIdentifier&&key===PropertyIdentifier?"object"==typeof value&&null!==value&&"io-field"===elementCandidate.tag||(element=elementCandidate):(PropertyIdentifier instanceof RegExp&&PropertyIdentifier.test(key)||null===PropertyIdentifier&&null===value||void 0===PropertyIdentifier&&void 0===value)&&(element=elementCandidate),element&&(element={...element},element.props&&(element.props={...element.props}),configRecord[key]=element)}const vElement=configRecord[key];vElement.children&&console.warn("EditorConfig: configured element should not have children",vElement);const props=vElement.props;if(props)for(const[key2,value2]of Object.entries(props))value2 instanceof MenuOption&&(props[key2]=new MenuOption({}).fromJSON(value2.toJSON()))}for(const key of getAllPropertyNames(object)){if("textNode"===key)continue;const value=object[key];configRecord[key]||console.warn("No config found for",key,value)}return configCache.set(object,propertyConfigs,configRecord),configRecord}(this.value,this.config),this._groups=function getEditorGroups(object,propertyGroups){if(!(object&&object instanceof Object))return console.warn("`getEditorGroups` should be used with an Object instance"),{};const aggregatedGroups={Main:[]};function aggregateGroups(editorGroups){for(const[constructorKey,groups]of editorGroups)if(object instanceof constructorKey){const configKeys=Object.keys(groups),existingKeys=Object.keys(aggregatedGroups);if(configKeys.length>0&&existingKeys.length>0){const reorderedGroups={};for(const key of configKeys)reorderedGroups[key]=aggregatedGroups[key]||[];for(const key of existingKeys)key in reorderedGroups||(reorderedGroups[key]=aggregatedGroups[key]);for(const key of existingKeys)configKeys.includes(key)&&delete aggregatedGroups[key];Object.assign(aggregatedGroups,reorderedGroups)}for(const g in groups){aggregatedGroups[g]=aggregatedGroups[g]||[];for(const identifier of groups[g])if(!(identifier instanceof RegExp))for(const ag in aggregatedGroups){const idx=aggregatedGroups[ag].indexOf(identifier);-1!==idx&&aggregatedGroups[ag].splice(idx,1)}aggregatedGroups[g].push(...groups[g])}const advanced=aggregatedGroups.Advanced||[];delete aggregatedGroups.Advanced,aggregatedGroups.Advanced=advanced}}aggregateGroups(editorGroupsSingleton),aggregateGroups(/* @__PURE__ */new Map([[Object,propertyGroups]]));const allGroupedNonRegexPropertyNames=[];for(const g of Object.keys(aggregatedGroups))for(const identifier of aggregatedGroups[g])identifier instanceof RegExp||allGroupedNonRegexPropertyNames.push(identifier);const groupsRecord={Main:[]},allPropertyNames=getAllPropertyNames(object),includedProperties=/* @__PURE__ */new Set;for(const g of Object.keys(aggregatedGroups)){groupsRecord[g]=groupsRecord[g]||[];for(const identifier of aggregatedGroups[g])identifier instanceof RegExp||!allPropertyNames.includes(identifier)||(groupsRecord[g].push(identifier),includedProperties.add(identifier))}for(const key of allPropertyNames){if(includedProperties.has(key))continue;const isFunction="function"==typeof object[key];let included=!1;for(const g of Object.keys(aggregatedGroups)){for(const identifier of aggregatedGroups[g])if(!isFunction&&identifier instanceof RegExp&&!allGroupedNonRegexPropertyNames.includes(key)&&identifier.test(key)){groupsRecord[g].push(key),includedProperties.add(key),included=!0;break}if(included)break}included||isFunction||groupsRecord.Advanced?.includes(key)||groupsRecord.Main.push(key)}for(const g of Object.keys(groupsRecord))groupsRecord[g]=[...new Set(groupsRecord[g])];for(const g of Object.keys(groupsRecord))for(const g2 of Object.keys(groupsRecord))if(g!==g2)for(const key of groupsRecord[g])groupsRecord[g2].includes(key)&&console.warn(`Property "${key}" belongs to multiple groups: "${g}" and "${g2}". Removing from "${g}".`);return groupsRecord}(this.value,this.groups),this._widget=void 0!==this.widget?this.widget:function getEditorWidget(object){return object&&object instanceof Object?function getWidget(editorWidgets){let matchedWidget=null;for(const[constructorKey,widgetCandidate]of editorWidgets)object instanceof constructorKey&&(matchedWidget=widgetCandidate);return matchedWidget}(editorWidgetsSingleton):(console.warn("`getEditorGroups` should be used with an Object instance"),null)}(this.value);const config=this._config,groups=this._groups,widget=this._widget;if(!config||!groups)return;const properties=[],vChildren=[];if(widget){const widgetWithValue={tag:widget.tag,props:Object.assign({value:this.value,widget:null},widget.props),children:widget.children};vChildren.push(widgetWithValue)}void 0!==this.properties?properties.push(...this.properties):properties.push(...groups.Main);const allProps=getAllPropertyNames(this.value);for(let i=0;i<properties.length;i++)if(allProps.includes(properties[i])){const id=properties[i],value=this.value[id],tag=config[id].tag,props=config[id].props||{},finalProps={id:id,value:value,"@value-input":this._onValueInput};let children;Object.assign(finalProps,props),HTML_ELEMENTS.includes(tag)&&"string"==typeof value&&(children=value),"io-object"!==tag&&"io-property-editor"!==tag||(finalProps.config=finalProps.config||this.config,finalProps.groups=finalProps.groups||this.groups),"io-object"===tag&&(finalProps.persistentExpand=!0);const isFunction="function"==typeof value;isFunction&&(finalProps.action=value.bind(this.value),finalProps.label=finalProps.label||id);const isIoObject="io-object"===tag;isIoObject&&(finalProps.label=finalProps.label||id+": "+value?.constructor?.name||String(value));const label=finalProps.label||id,tooltip=label,hideLabel="_hidden_"===finalProps.label;finalProps.class?finalProps.class+=" io-property-editor-field":finalProps.class="io-property-editor-field",vChildren.push(div$1({class:"row"},[!this.labeled||hideLabel||isFunction||isIoObject?null:span({style:{width:this.labelWidth},title:tooltip},label),{tag:tag,props:finalProps,children:children}]))}else console.warn(`IoPropertyEditor: property "${properties[i]}" not found in value`);if(void 0===this.properties)for(const group in groups)"Main"!==group&&"Hidden"!==group&&groups[group].length&&vChildren.push(ioObject({label:group,labelWidth:this.labelWidth,persistentExpand:!0,value:this.value,widget:null,properties:groups[group],config:this.config}));this.render(vChildren);for(const child of Object.values(this.$))child.classList.contains("io-property-editor-field")&&(this._propertyEditors[child.id]=child)}}valueMutated(){this.throttle(this.changedThrottled)}changed(){this.throttle(this.changedThrottled)}changedThrottled(){if(this.value&&"object"==typeof this.value)for(const id in this._propertyEditors){if(!(id in this.value))continue;const value=this.value[id];this._propertyEditors[id].value=value}}dispose(){super.dispose(),this._propertyEditors={}}};__decorateClass$g([ReactiveProperty()],IoPropertyEditor.prototype,"value",2),__decorateClass$g([ReactiveProperty({type:Array})],IoPropertyEditor.prototype,"properties",2),__decorateClass$g([ReactiveProperty({type:String,value:""})],IoPropertyEditor.prototype,"label",2),__decorateClass$g([ReactiveProperty(!0)],IoPropertyEditor.prototype,"labeled",2),__decorateClass$g([ReactiveProperty("80px")],IoPropertyEditor.prototype,"labelWidth",2),__decorateClass$g([ReactiveProperty({type:Array,init:null})],IoPropertyEditor.prototype,"config",2),__decorateClass$g([ReactiveProperty({type:Object,init:null})],IoPropertyEditor.prototype,"groups",2),__decorateClass$g([ReactiveProperty({type:Object})],IoPropertyEditor.prototype,"widget",2),IoPropertyEditor=__decorateClass$g([Register],IoPropertyEditor);const ioPropertyEditor=function(arg0){return IoPropertyEditor.vConstructor(arg0)};var __defProp$d=Object.defineProperty,__getOwnPropDesc$d=Object.getOwnPropertyDescriptor,__decorateClass$f=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$d(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$d(target,key,result),result};let IoObject=class extends IoElement{static get Style(){return'\n    :host {\n      display: flex;\n      max-width: 100%;\n      flex-direction: column;\n      color: var(--io_colorInput);\n      background-color: var(--io_bgColor);\n      border-radius: var(--io_borderRadius);\n    }\n    :host > io-boolean {\n      padding: var(--io_spacing) var(--io_spacing2);\n      align-self: stretch;\n    }\n    :host > io-boolean:before {\n      display: inline-block;\n      width: 0.75em;\n      content: ""\n    }\n    :host > io-boolean[value]:before {\n      content: "";\n    }\n    :host > io-property-editor {\n      /* margin: var(--io_spacing); */\n      margin: calc(var(--io_spacing) * 2);\n      margin-top: calc(var(--io_spacing) * 2) !important;\n      margin-left: calc(var(--io_spacing) * 4);\n      border: var(--io_border);\n      border-color: var(--io_borderColorInset);\n    }\n    '}valueChanged(){if(!this.value)return;"object"==typeof this.value||Array.isArray(this.value)||console.warn("IoObject: value is not an object or array",this,this.value);let uuid=function genIdentifier(object){const id=object.guid||object.uuid||object.id||object.name||object.label;if(id)return"io-object-collapse-state-"+object.constructor.name+"-"+id}(this.value),storage="local";uuid||(uuid=function getTempIdentifier(object){if(!tempIdentifiers.has(object)){const randomuuid=Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);tempIdentifiers.set(object,randomuuid)}return tempIdentifiers.get(object)}(this.value),storage="none");const expandedBinding=Storage({value:this.expanded??!1,storage:storage,key:uuid+"-"+this.label}),bindingTargets=expandedBinding.targets,targetIsThis=bindingTargets.has(this);if(bindingTargets.size<1&&!targetIsThis){const targetP=this._reactiveProperties.get("expanded");targetP.binding&&targetP.binding!==expandedBinding&&targetP.binding.removeTarget(this,"expanded"),expandedBinding.addTarget(this,"expanded")}}expandedChanged(){clearFocusBacktrack()}changed(){const label=this.label||this.value.constructor.name,propCount=Object.keys(this.value).length,vChildren=[];vChildren.push(ioBoolean({appearance:"neutral",true:label,false:label,value:this.bind("expanded"),disabled:0===propCount})),this.expanded&&propCount>0&&vChildren.push(ioPropertyEditor({value:this.value,properties:this.properties,config:this.config,groups:this.groups,widget:this.widget,labeled:this.labeled,labelWidth:this.labelWidth})),this.render(vChildren),this.setAttribute("aria-expanded",String(this.expanded))}};__decorateClass$f([ReactiveProperty()],IoObject.prototype,"value",2),__decorateClass$f([ReactiveProperty({type:Array,init:null})],IoObject.prototype,"properties",2),__decorateClass$f([ReactiveProperty({type:String,value:""})],IoObject.prototype,"label",2),__decorateClass$f([ReactiveProperty(!0)],IoObject.prototype,"labeled",2),__decorateClass$f([ReactiveProperty("80px")],IoObject.prototype,"labelWidth",2),__decorateClass$f([ReactiveProperty({value:!1,reflect:!0})],IoObject.prototype,"expanded",2),__decorateClass$f([ReactiveProperty({value:!1})],IoObject.prototype,"persistentExpand",2),__decorateClass$f([ReactiveProperty({type:Array,init:null})],IoObject.prototype,"config",2),__decorateClass$f([ReactiveProperty({type:Object,init:null})],IoObject.prototype,"groups",2),__decorateClass$f([ReactiveProperty({type:Object})],IoObject.prototype,"widget",2),__decorateClass$f([Property("region")],IoObject.prototype,"role",2),IoObject=__decorateClass$f([Register],IoObject);const ioObject=function(arg0){return IoObject.vConstructor(arg0)};const tempIdentifiers=/* @__PURE__ */new WeakMap;function makeSelect(options){for(let i=0;i<options.length;i++)null===options[i]&&(options[i]={value:null,id:"Null"});const option=new MenuOption({options:options});return ioOptionSelect({option:option})}const configCache=new class ConfigCache{map=/* @__PURE__ */new WeakMap;set(key1,key2,value){let inner=this.map.get(key1);return inner||(inner=/* @__PURE__ */new WeakMap,this.map.set(key1,inner)),inner.set(key2,value),this}get(key1,key2){return this.map.get(key1)?.get(key2)}has(key1,key2){return this.map.get(key1)?.has(key2)??!1}delete(key1,key2){return this.map.get(key1)?.delete(key2)??!1}},editorConfigSingleton=/* @__PURE__ */new Map([[Object,[[String,ioString()],[Number,ioNumber({step:.01})],[Boolean,ioSwitch()],[Object,ioObject()],[null,ioField({disabled:!0})],[void 0,ioField({disabled:!0})],[Function,ioButton()]]],[Array,[[Number,ioNumber({step:.01})]]],[window.Node,[["tabIndex",ioOptionSelect({option:new MenuOption({options:[{value:"",id:"None"},"-1","0","1","2","3"]})})],["innerHTML",ioString({disabled:!0,style:{maxWidth:"10em"}})],["outerHTML",ioString({disabled:!0,style:{maxWidth:"10em"}})],["autocapitalize",ioOptionSelect({option:new MenuOption({options:["off","sentences","words","characters",{value:"",id:"None"}]})})],["writingSuggestions",ioOptionSelect({option:new MenuOption({options:["true","false"]})})],["dir",ioOptionSelect({option:new MenuOption({options:["ltr","rtl","auto",{value:"",id:"None"}]})})],["virtualKeyboardPolicy",ioOptionSelect({option:new MenuOption({options:["manual","auto",{value:"",id:"None"}]})})],["enterKeyHint",ioOptionSelect({option:new MenuOption({options:["enter","done","go","next","previous","search","send",{value:"",id:"None"}]})})],["contentEditable",ioOptionSelect({option:new MenuOption({options:["true","false","plaintext-only","inherit"]})})],["inputMode",ioOptionSelect({option:new MenuOption({options:["decimal","email","numeric","tel","search","url","text",{value:"",id:"None"}]})})],["lang",ioOptionSelect({option:new MenuOption({options:[{value:"",id:"None"},"ab","aa","af","ak","sq","am","ar","an","hy","as","av","ae","ay","az","bm","ba","eu","be","bn","bh","bi","bs","br","bg","my","ca","ch","ce","ny","zh","zh-ans","zh-ant","cv","kw","co","cr","hr","cs","da","dv","nl","dz","en","eo","et","ee","fo","fj","fi","fr","ff","gl","gd","ka","de","el","kl","gn","gu","ht","ha","he","hz","hi","ho","hu","is","io","ig","id in","ia","ie","iu","ik","ga","it","ja","jv","kn","kr","ks","kk","km","ki","rw","rn","ky","kv","kg","ko","ku","kj","lo","la","lv","li","ln","lt","lu","lg","lb","gv","mk","mg","ms","ml","mt","mi","mr","mh","mo","mn","na","nv","ng","nd","ne","no","nb","nn","oc","oj","cu","or","om","os","pi","ps","fa","pl","pt","pa","qu","rm","ro","ru","se","sm","sg","sa","sr","sh","st","tn","sn","ii","sd","si","ss","sk","sl","so","nr","es","su","sw","sv","tl","ty","tg","ta","tt","te","th","bo","ti","to","ts","tr","tk","tw","ug","uk","ur","uz","ve","vi","vo","wa","cy","wo","fy","xh","yi","ji","yo","za","zu"]})})],["role",ioOptionSelect({option:new MenuOption({options:["alert","alertdialog","application","article","banner","button","cell","checkbox","columnheader","combobox","complementary","contentinfo","definition","dialog","directory","document","feed","figure","form","grid","gridcell","group","heading","img","link","list","listbox","listitem","log","main","marquee","math","menu","menubar","menuitem","menuitemcheckbox","menuitemradio","navigation","none","note","option","presentation","progressbar","radio","radiogroup","region","row","rowgroup","rowheader","scrollbar","search","searchbox","separator","slider","spinbutton","status","switch","tab","table","tablist","tabpanel","term","textbox","timer","toolbar","tooltip","tree","treegrid","treeitem"]})})],["ariaAtomic",makeSelect(["true","false",null])],["ariaAutoComplete",ioOptionSelect({option:new MenuOption({options:["inline","list","both","none"]})})],["ariaBusy",makeSelect(["true","false",null])],["ariaBrailleLabel",ioString()],["ariaBrailleRoleDescription",ioString()],["ariaChecked",makeSelect(["true","false","mixed",null])],["ariaColCount",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaColIndex",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaColSpan",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaCurrent",makeSelect(["true","false","page","step","location","date","time",null])],["ariaDescription",ioString()],["ariaDisabled",makeSelect(["true","false",null])],["ariaExpanded",makeSelect(["true","false",null])],["ariaHasPopup",makeSelect(["true","false","menu","listbox","tree","grid","dialog",null])],["ariaHidden",makeSelect(["true","false",null])],["ariaInvalid",makeSelect(["true","false","grammar","spelling",null])],["ariaKeyShortcuts",ioString()],["ariaLabel",ioString()],["ariaLevel",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaLive",ioOptionSelect({option:new MenuOption({options:["assertive","polite","off"]})})],["ariaModal",makeSelect(["true","false",null])],["ariaMultiLine",makeSelect(["true","false",null])],["ariaMultiSelectable",makeSelect(["true","false",null])],["ariaOrientation",ioOptionSelect({option:new MenuOption({options:["horizontal","vertical","undefined"]})})],["ariaPlaceholder",ioString()],["ariaPosInSet",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaPressed",makeSelect(["true","false","mixed",null])],["ariaReadOnly",makeSelect(["true","false",null])],["ariaRequired",makeSelect(["true","false",null])],["ariaRelevant",ioOptionSelect({option:new MenuOption({options:["additions","all","removals","text"]})})],["ariaRoleDescription",ioString()],["ariaRowCount",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaRowIndex",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaRowSpan",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaSelected",makeSelect(["true","false",null])],["ariaSetSize",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaSort",ioOptionSelect({option:new MenuOption({options:["none","ascending","descending","other"]})})],["ariaValueMax",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaValueMin",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaValueNow",makeSelect([...[...Array(32)].map((_,i)=>i+1),null])],["ariaValueText",ioString()],["ariaColIndexText",ioString()],["ariaRowIndexText",ioString()]]],[Element,[]],[HTMLElement,[]],[ReactiveNode,[["reactivity",ioOptionSelect({option:new MenuOption({options:["none","debounced","immediate"]})})]]],[IoElement,[["reactivity",ioOptionSelect({option:new MenuOption({options:["none","debounced","immediate"]})})]]],[IoGl,[["size",ioObject()],["color",ioObject()]]],[Theme,[[Number,ioNumberSlider({step:1,min:0,max:20})],["themeID",ioOptionSelect({option:new MenuOption({options:["light","dark"]})})],["spacing2",ioField({disabled:!0})],["spacing3",ioField({disabled:!0})],["spacing5",ioField({disabled:!0})],["spacing8",ioField({disabled:!0})],["fieldHeight",ioField({disabled:!0})],[Color$1,ioColorRgba()]]]]);function registerEditorConfig(constructor,propertyTypes){const existingConfigs=editorConfigSingleton.get(constructor)||[];for(const[PropertyIdentifier,elementCandidate]of propertyTypes){const existingConfig=existingConfigs.find(config=>config[0]===PropertyIdentifier);existingConfig?existingConfig[1]=elementCandidate:existingConfigs.push([PropertyIdentifier,elementCandidate])}editorConfigSingleton.set(constructor,existingConfigs)}editorConfigSingleton.forEach((propertyTypes,constructor)=>{const descriptors=Object.getOwnPropertyDescriptors(constructor.prototype);for(const[key,descriptor]of Object.entries(descriptors)){const isWritable=!1!==descriptor.writable,hasGetter=void 0!==descriptor.get,hasSetter=void 0!==descriptor.set;if(hasGetter&&!hasSetter||!isWritable){const hasType=propertyTypes.find(propertyType=>propertyType[0]===key);hasType?(console.warn(constructor,`.${key} has getter but no setter or is not writable. Invalidating editor config.`),hasType.length=0,hasType.push(key,ioField({disabled:!0}))):propertyTypes.push([key,ioField({disabled:!0})])}}});var __defProp$c=Object.defineProperty,__getOwnPropDesc$c=Object.getOwnPropertyDescriptor,__decorateClass$e=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$c(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$c(target,key,result),result};let IoPropertyLink=class extends IoButton{static get Style(){return"\n    :host {\n      display: flex;\n    }\n    :host > span {\n      color: var(--io_colorBlue);\n      flex: 0 1 auto;\n      overflow: hidden;\n      text-overflow: ellipsis;\n    }\n    :host:hover > span {\n      text-decoration: underline;\n    }\n    "}valueMutated(){this.changed()}changed(){let label="";if(label=this.value instanceof Array?`${this.value.constructor.name} (${this.value.length})`:`${this.value.constructor.name}`,this.showName){const name=this.value.name||this.value.title||this.value.id;name&&(label+=` "${name}"`)}this.render([span(label)])}};__decorateClass$e([ReactiveProperty()],IoPropertyLink.prototype,"value",2),__decorateClass$e([ReactiveProperty({value:!1,type:Boolean})],IoPropertyLink.prototype,"showName",2),__decorateClass$e([ReactiveProperty({value:"neutral",type:String,reflect:!0})],IoPropertyLink.prototype,"appearance",2),IoPropertyLink=__decorateClass$e([Register],IoPropertyLink);const ioPropertyLink=function(arg0){return IoPropertyLink.vConstructor(arg0)};var __defProp$b=Object.defineProperty,__getOwnPropDesc$b=Object.getOwnPropertyDescriptor,__decorateClass$d=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$b(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$b(target,key,result),result};let IoBreadcrumbs=class extends IoElement{static get Style(){return"\n    :host {\n      display: flex;\n    }\n    :host > div {\n      display: flex;\n      flex-direction: row;\n      align-items: center;\n      flex: 1 1 auto;\n      border: var(--io_border);\n      border-color: var(--io_borderColorInset);\n      border-radius: var(--io_borderRadius);\n      background-color: var(--io_bgColorInput);\n      overflow: hidden;\n    }\n    :host > io-button {\n      padding-left: var(--io_spacing);\n      padding-right: var(--io_spacing);\n      margin: var(--io_borderWidth);\n      flex: 0 0 auto;\n    }\n    :host:not([search]) > io-button.clear-button {\n      display: none;\n    }\n    :host > div > io-property-link:last-of-type {\n      flex-shrink: 0;\n    }\n    :host > div > io-property-link:last-of-type > span {\n      flex-shrink: 0;\n      text-overflow: clip;\n    }\n    :host > div > io-property-link:not(:first-of-type):before {\n      content: '>';\n      padding-right: calc(var(--io_fontSize) / 2);\n      color: var(--io_colorStrong);\n      opacity: 0.5;\n    }\n    :host > .search-input {\n      flex: 0 0 auto;\n      overflow: hidden;\n      min-width: calc(var(--io_fieldHeight) + var(--io_borderWidth) * 2);\n      height: calc(var(--io_fieldHeight) + var(--io_borderWidth) * 2);\n      margin-left: var(--io_spacing);\n    }\n    :host > .search-input:empty::before {\n      content: '';\n      font-size: 0.9em;\n    }\n    "}valueChanged(){this._crumbs.length=0,this._crumbs.push(this.value)}selectedChanged(){const index=this._crumbs.indexOf(this.selected);-1!==index?this._crumbs.length=index+1:this._crumbs.push(this.selected)}onClearSearch(){this.search=""}changed(){const vChildren=[];this._crumbs.length>1&&vChildren.push(ioButton({icon:"io:arrow_left",class:"back-button",value:this._crumbs[this._crumbs.length-2]}));const crumbs=div$1();crumbs.children=[];for(let i=Math.max(0,this._crumbs.length-2);i<this._crumbs.length;i++)crumbs.children.push(ioPropertyLink({value:this._crumbs[i],showName:i===this._crumbs.length-1}));vChildren.push(crumbs,ioButton({icon:"io:close",class:"clear-button",action:this.onClearSearch}),ioString({id:"search",class:"search-input",value:this.bind("search"),live:!0})),this.render(vChildren)}};__decorateClass$d([ReactiveProperty({type:Object,init:null})],IoBreadcrumbs.prototype,"value",2),__decorateClass$d([ReactiveProperty({type:Object,init:null})],IoBreadcrumbs.prototype,"selected",2),__decorateClass$d([ReactiveProperty({type:String,reflect:!0})],IoBreadcrumbs.prototype,"search",2),__decorateClass$d([Property(Array)],IoBreadcrumbs.prototype,"_crumbs",2),IoBreadcrumbs=__decorateClass$d([Register],IoBreadcrumbs);var __defProp$a=Object.defineProperty,__getOwnPropDesc$a=Object.getOwnPropertyDescriptor,__decorateClass$c=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$a(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$a(target,key,result),result};let IoContextEditor=class extends IoPropertyEditor{static get Style(){return"\n      :host {\n        z-index: 2;\n      }\n      :host:not([expanded]) {\n      visibility: hidden;\n    }\n    "}static get Listeners(){return{keydown:"onKeydown","io-focus-to":"onIoFocusTo"}}onKeydown(event){"Escape"!==event.key&&"Enter"!==event.key||(event.preventDefault(),this.expanded=!1)}onIoFocusTo(event){const source=event.detail.source,cmd=event.detail.command,siblings=Array.from(this.querySelectorAll('[tabindex="0"]')),index=[...siblings].indexOf(source);let cmdOverride="";this.horizontal?("ArrowRight"===cmd&&(cmdOverride="next"),"ArrowLeft"===cmd&&(cmdOverride="prev")):("ArrowDown"===cmd&&(cmdOverride="next"),"ArrowUp"===cmd&&(cmdOverride="prev")),cmdOverride&&("next"===cmdOverride?siblings[(index+1)%siblings.length].focus():"prev"===cmdOverride?siblings[(index-1+siblings.length)%siblings.length].focus():"out"===cmdOverride&&this.$parent&&this.$parent.focus(),event.stopPropagation())}expand(props){this.setProperties({value:props.value,properties:props.properties||[],labeled:props.labeled||!0,labelWidth:props.labelWidth||"80px",config:props.config||[],groups:props.groups||{},widget:props.widget||void 0,expanded:!0}),this.onClose=props.onClose||null,nudge(this,props.source,props.direction),this.debounce(this.onExpand,void 0,2)}onExpand(){this.querySelector('[tabindex="0"]:not([inert])')?.focus()}expandedChanged(){this.expanded||(this.setProperties({value:{},properties:[],labeled:!0,config:[],groups:{},widget:void 0}),this.onClose&&(this.onClose(),this.onClose=null))}};__decorateClass$c([ReactiveProperty({type:Boolean,value:!1,reflect:!0})],IoContextEditor.prototype,"expanded",2),IoContextEditor=__decorateClass$c([Register],IoContextEditor);const IoContextEditorSingleton=new IoContextEditor;setTimeout(()=>{IoOverlaySingleton.appendChild(IoContextEditorSingleton)},100);var __defProp$9=Object.defineProperty,__getOwnPropDesc$9=Object.getOwnPropertyDescriptor,__decorateClass$b=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$9(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$9(target,key,result),result};function isNestedObject(value,selected){return value===selected||(value instanceof Array?value.some(v=>isNestedObject(v,selected)):value instanceof Object&&Object.keys(value).some(k=>isNestedObject(value[k],selected)))}let IoInspector=class extends IoElement{static get Style(){return"\n    :host {\n      display: flex;\n      flex-direction: column;\n      align-items: stretch;\n      flex: 0 1 calc(var(--io_lineHeight) * 17.5);\n      padding: var(--io_spacing);\n      background-color: var(--io_bgColor);\n      border-radius: calc(var(--io_borderRadius) + var(--io_spacing));\n    }\n    :host > io-breadcrumbs {\n      margin: 0 var(--io_spacing);\n    }\n    :host > span {\n      padding: var(--io_spacing) var(--io_spacing3);\n      color: var(--io_colorStrong);\n    }\n    :host io-property-editor > .row > span {\n      min-width: 6em;\n      text-align: right;\n    }\n    "}static get Listeners(){return{"io-button-clicked":"onLinkClicked"}}onLinkClicked(event){event.stopPropagation();const value=event.detail.value,item=event.composedPath()[0];value&&"object"==typeof value&&("io-property-link"!==item.localName&&"back-button"!==item.className||this.setProperty("selected",value))}valueChanged(){this.selected=this.value}valueMutated(){isNestedObject(this.value,this.selected)||(this.selected=this.value),this.changed()}selectedMutated(){this.changed()}selectedChanged(){this.search=""}changed(){this.debounce(this.changedDebounced)}changedDebounced(){const vChildren=[(arg0={value:this.value,selected:this.bind("selected"),search:this.bind("search")},IoBreadcrumbs.vConstructor(arg0))];var arg0;const config=[...this.config];config.push([Object,ioPropertyLink({showName:!0})]);const properties=[];if(this.search)for(const key of getAllPropertyNames(this.selected))key.toLowerCase().includes(this.search.toLowerCase())&&properties.push(key);this.search&&0===properties.length?vChildren.push(span(`No results found for "${this.search}"`)):vChildren.push(ioPropertyEditor({value:this.selected,config:config,groups:this.groups,widget:this.widget,properties:properties})),this.render(vChildren)}dispose(){super.dispose(),window.removeEventListener("io-object-mutation",this.onPropertyMutated)}};__decorateClass$b([ReactiveProperty({type:Object,init:null})],IoInspector.prototype,"value",2),__decorateClass$b([ReactiveProperty({type:Object,init:null})],IoInspector.prototype,"selected",2),__decorateClass$b([ReactiveProperty({type:String})],IoInspector.prototype,"search",2),__decorateClass$b([ReactiveProperty({type:Array,init:null})],IoInspector.prototype,"config",2),__decorateClass$b([ReactiveProperty({type:Object,init:null})],IoInspector.prototype,"groups",2),__decorateClass$b([ReactiveProperty({type:Object})],IoInspector.prototype,"widget",2),IoInspector=__decorateClass$b([Register],IoInspector);var __defProp$8=Object.defineProperty,__getOwnPropDesc$8=Object.getOwnPropertyDescriptor,__decorateClass$a=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$8(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$8(target,key,result),result};let IoBuildGeometry=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n      }\n      :host > div {\n        display: flex;\n        flex-direction: row;\n      }\n      :host > div > * {\n        flex: 1 1 auto;\n      }\n    "}constructor(args={}){super(args)}buildGeometry(){const geometry=this.value;if(!geometry)return;const parameters=geometry.parameters;if(!parameters)return void console.warn("IoBuildGeometry: geometry has no parameters property");const newGeometry=new(0,geometry.constructor)(...Object.values(parameters));geometry.copy(newGeometry),newGeometry.dispose(),geometry.computeVertexNormals(),geometry.index&&geometry.attributes.position&&geometry.attributes.normal&&geometry.attributes.uv&&geometry.computeTangents(),geometry.computeBoundingSphere(),geometry.computeBoundingBox(),this.dispatchMutation(geometry),this.dispatchMutation(geometry.boundingBox),this.dispatchMutation(geometry.boundingSphere)}changed(){const geometry=this.value;if(!geometry)return void this.render([]);const hasParameters=geometry&&geometry.parameters,hasIndexNormalsUv=geometry.index&&geometry.attributes.position&&geometry.attributes.normal&&geometry.attributes.uv;this.render([ioPropertyEditor({widget:null,value:geometry,properties:["parameters"],labeled:!1}),div$1([ioButton({label:"Build",action:()=>this.buildGeometry(),disabled:!hasParameters}),ioButton({label:"vtx",action:()=>{geometry?.computeVertexNormals()}}),ioButton({label:"tng",disabled:!hasIndexNormalsUv,action:()=>{geometry?.computeTangents()}}),ioButton({label:"bSphere",action:()=>{geometry?.computeBoundingSphere(),this.dispatchMutation(geometry.boundingSphere),this.dispatchMutation(geometry.boundingSphere.center)}}),ioButton({label:"bBox",action:()=>{geometry?.computeBoundingBox(),this.dispatchMutation(geometry.boundingBox.max),this.dispatchMutation(geometry.boundingBox.min)}})])])}};__decorateClass$a([ReactiveProperty({type:Object,init:null})],IoBuildGeometry.prototype,"value",2),IoBuildGeometry=__decorateClass$a([Register],IoBuildGeometry);const ioBuildGeometry=function(arg0){return IoBuildGeometry.vConstructor(arg0)};var __defProp$7=Object.defineProperty,__getOwnPropDesc$7=Object.getOwnPropertyDescriptor,__decorateClass$9=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$7(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$7(target,key,result),result};const _playingApplets=[];!function rAFLoop(){for(const applet of _playingApplets)applet.onRAF();requestAnimationFrame(rAFLoop)}();let ThreeApplet=class extends ReactiveNode{_renderer=null;_width=0;_height=0;_timer=new Timer;constructor(args){super(args),this._timer.connect(document),this.isPlayingChanged()}isPlayingChanged(){!0===this.isPlaying&&!1===_playingApplets.includes(this)?_playingApplets.push(this):!1===this.isPlaying&&_playingApplets.includes(this)&&_playingApplets.splice(_playingApplets.indexOf(this),1)}onRAF(){if(!this.isPlaying)return;this._timer.update();const delta=this._timer.getDelta(),time=this._timer.getElapsed();this.onAnimate(delta,time),this.dispatch("three-applet-needs-render",void 0,!0)}updateViewportSize(width,height){this._width===width&&this._height===height||width&&height&&(this._width=width,this._height=height,this.onResized(width,height))}isRendererInitialized(){return!!this._renderer&&!0===this._renderer.initialized}onRendererInitialized(renderer){this._renderer=renderer}onResized(width,height){}onAnimate(delta,time){}dispose(){this.isPlaying=!1,super.dispose()}};__decorateClass$9([ReactiveProperty({type:Scene,init:null})],ThreeApplet.prototype,"scene",2),__decorateClass$9([ReactiveProperty({type:Number,value:1})],ThreeApplet.prototype,"toneMappingExposure",2),__decorateClass$9([ReactiveProperty({type:Number,value:0})],ThreeApplet.prototype,"toneMapping",2),__decorateClass$9([ReactiveProperty({type:Boolean,value:!1})],ThreeApplet.prototype,"isPlaying",2),ThreeApplet=__decorateClass$9([Register],ThreeApplet),registerEditorConfig(ThreeApplet,[["toneMappingExposure",ioNumberSlider({min:0,max:3,step:.01,exponent:2})],["toneMapping",ioOptionSelect({option:new MenuOption({options:[{value:0,id:"NoToneMapping"},{value:1,id:"LinearToneMapping"},{value:2,id:"ReinhardToneMapping"},{value:3,id:"CineonToneMapping"},{value:4,id:"ACESFilmicToneMapping"},{value:6,id:"AgXToneMapping"},{value:7,id:"NeutralToneMapping"}]})})],["scene",ioPropertyEditor({properties:["children"],label:"_hidden_"})]]),registerEditorGroups(ThreeApplet,{Main:["scene"],Hidden:["isPlaying","toneMapping","toneMappingExposure","_renderer","_width","_height","_timer"]});var __defProp$6=Object.defineProperty;class IoThreeExample extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex: 1 1 auto;\n        flex-direction: column;\n        max-width: 100%;\n        max-height: 100%;\n      }\n      :host .property-editor {\n        position: relative;\n        display: flex;\n        flex: 1 1 auto;\n        flex-direction: column;\n      }\n      :host .property-editor > io-property-editor {\n        position: absolute;\n        min-width: 240px;\n        top: 0;\n        right: 0;\n      }\n    "}ready(){this.render([ioThreeViewport({applet:this.applet,cameraSelect:"perspective"})])}dispose(){this.applet.dispose(),super.dispose()}}((decorators,target,key)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);result&&__defProp$6(target,key,result)})([ReactiveProperty({type:ThreeApplet,init:null})],IoThreeExample.prototype,"applet"),Register(IoThreeExample);let isAvailable="undefined"!=typeof navigator&&void 0!==navigator.gpu;"undefined"!=typeof window&&isAvailable&&(isAvailable=Boolean(await navigator.gpu.requestAdapter()));const _changeEvent={type:"change"},_startEvent={type:"start"},_endEvent={type:"end"},_ray=new Ray,_plane=new Plane,_TILT_LIMIT=Math.cos(70*MathUtils.DEG2RAD),_v=new Vector3,_twoPI=2*Math.PI,_STATE_NONE=-1,_STATE_ROTATE=0,_STATE_DOLLY=1,_STATE_PAN=2,_STATE_TOUCH_ROTATE=3,_STATE_TOUCH_PAN=4,_STATE_TOUCH_DOLLY_PAN=5,_STATE_TOUCH_DOLLY_ROTATE=6,_targetMap=new WeakMap;function onPointerDown(event){!1!==this.enabled&&(0===this._pointers.length&&(this.domElement.setPointerCapture(event.pointerId),this.domElement.ownerDocument.addEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.addEventListener("pointerup",this._onPointerUp)),this._isTrackingPointer(event)||(this._addPointer(event),"touch"===event.pointerType?this._onTouchStart(event):this._onMouseDown(event)))}function onPointerMove(event){!1!==this.enabled&&("touch"===event.pointerType?this._onTouchMove(event):this._onMouseMove(event))}function onPointerUp(event){switch(this._removePointer(event),this._pointers.length){case 0:this.domElement.releasePointerCapture(event.pointerId),this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.removeEventListener("pointerup",this._onPointerUp),this.dispatchEvent(_endEvent),this.state=_STATE_NONE;break;case 1:const pointerId=this._pointers[0],position=this._pointerPositions[pointerId];this._onTouchStart({pointerId:pointerId,pageX:position.x,pageY:position.y})}}function onMouseDown(event){let mouseAction;switch(event.button){case 0:mouseAction=this.mouseButtons.LEFT;break;case 1:mouseAction=this.mouseButtons.MIDDLE;break;case 2:mouseAction=this.mouseButtons.RIGHT;break;default:mouseAction=-1}switch(mouseAction){case MOUSE_DOLLY:if(!1===this.enableZoom)return;this._handleMouseDownDolly(event),this.state=_STATE_DOLLY;break;case MOUSE_ROTATE:if(event.ctrlKey||event.metaKey||event.shiftKey){if(!1===this.enablePan)return;this._handleMouseDownPan(event),this.state=_STATE_PAN}else{if(!1===this.enableRotate)return;this._handleMouseDownRotate(event),this.state=_STATE_ROTATE}break;case MOUSE_PAN:if(event.ctrlKey||event.metaKey||event.shiftKey){if(!1===this.enableRotate)return;this._handleMouseDownRotate(event),this.state=_STATE_ROTATE}else{if(!1===this.enablePan)return;this._handleMouseDownPan(event),this.state=_STATE_PAN}break;default:this.state=_STATE_NONE}this.state!==_STATE_NONE&&this.dispatchEvent(_startEvent)}function onMouseMove(event){switch(this.state){case _STATE_ROTATE:if(!1===this.enableRotate)return;this._handleMouseMoveRotate(event);break;case _STATE_DOLLY:if(!1===this.enableZoom)return;this._handleMouseMoveDolly(event);break;case _STATE_PAN:if(!1===this.enablePan)return;this._handleMouseMovePan(event)}}function onMouseWheel(event){!1!==this.enabled&&!1!==this.enableZoom&&this.state===_STATE_NONE&&(event.preventDefault(),this.dispatchEvent(_startEvent),this._handleMouseWheel(this._customWheelEvent(event)),this.dispatchEvent(_endEvent))}function onKeyDown(event){!1!==this.enabled&&this._handleKeyDown(event)}function onTouchStart(event){switch(this._trackPointer(event),this._pointers.length){case 1:switch(this.touches.ONE){case TOUCH_ROTATE:if(!1===this.enableRotate)return;this._handleTouchStartRotate(event),this.state=_STATE_TOUCH_ROTATE;break;case TOUCH_PAN:if(!1===this.enablePan)return;this._handleTouchStartPan(event),this.state=_STATE_TOUCH_PAN;break;default:this.state=_STATE_NONE}break;case 2:switch(this.touches.TWO){case TOUCH_DOLLY_PAN:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchStartDollyPan(event),this.state=_STATE_TOUCH_DOLLY_PAN;break;case TOUCH_DOLLY_ROTATE:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchStartDollyRotate(event),this.state=_STATE_TOUCH_DOLLY_ROTATE;break;default:this.state=_STATE_NONE}break;default:this.state=_STATE_NONE}this.state!==_STATE_NONE&&this.dispatchEvent(_startEvent)}function onTouchMove(event){switch(this._trackPointer(event),this.state){case _STATE_TOUCH_ROTATE:if(!1===this.enableRotate)return;this._handleTouchMoveRotate(event),this.update();break;case _STATE_TOUCH_PAN:if(!1===this.enablePan)return;this._handleTouchMovePan(event),this.update();break;case _STATE_TOUCH_DOLLY_PAN:if(!1===this.enableZoom&&!1===this.enablePan)return;this._handleTouchMoveDollyPan(event),this.update();break;case _STATE_TOUCH_DOLLY_ROTATE:if(!1===this.enableZoom&&!1===this.enableRotate)return;this._handleTouchMoveDollyRotate(event),this.update();break;default:this.state=_STATE_NONE}}function onContextMenu(event){!1!==this.enabled&&event.preventDefault()}function interceptControlDown(event){if("Control"===event.key){this._controlActive=!0;this.domElement.getRootNode().addEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0})}}function interceptControlUp(event){if("Control"===event.key){this._controlActive=!1;this.domElement.getRootNode().removeEventListener("keyup",this._interceptControlUp,{passive:!0,capture:!0})}}var __defProp$5=Object.defineProperty,__getOwnPropDesc$6=Object.getOwnPropertyDescriptor,__decorateClass$7=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$6(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$5(target,key,result),result};const box=new Box3,sphere=new Sphere,center=new Vector3,size=new Vector3,delta=new Vector3,cameraRight=new Vector3,cameraUp=new Vector3,cameraForward=new Vector3,corner=new Vector3;let radius=0;const resetCameras=/* @__PURE__ */new WeakMap;let ViewCameras=class extends ReactiveNode{static get Listeners(){return{"frame-object":"onFrameObject"}}constructor(args){super(args),this.orbitControls.connect(this.viewport),this.orbitControls.addEventListener("change",()=>{this.dispatchMutation()}),void 0===this.camera&&(this.camera=this.defaultCameras.perspective)}cameraSelectChanged(){this.debounce(this.cameraSelectChangedDebounced)}cameraSelectChangedDebounced(){let matchedCamera;if(this.cameraSelect.startsWith("scene")){const cameraId=this.cameraSelect.split(":")[1]||"",cameras=[...this.applet.scene.getObjectsByProperty("isPerspectiveCamera",!0),...this.applet.scene.getObjectsByProperty("isOrthographicCamera",!0)];cameraId?(matchedCamera=cameras.find(camera=>camera.name===cameraId),matchedCamera||console.warn(`Camera ${cameraId} not found in the scene, using default perspective camera`)):(matchedCamera=cameras[0],matchedCamera||console.warn("No cameras found in the scene, using default perspective camera")),this.camera=matchedCamera||this.defaultCameras.perspective}else matchedCamera=this.defaultCameras.getCamera(this.cameraSelect),matchedCamera?this.camera=matchedCamera:(console.warn(`Camera ${this.cameraSelect} not found in the default cameras, using default perspective camera`),this.camera=this.defaultCameras.perspective)}cameraChanged(){this.defaultCameras.cameras.includes(this.camera)?(this.orbitControls.enabled=!0,this.orbitControls.object=this.camera,this.orbitControls.enableRotate=!!this.camera.isPerspectiveCamera):this.orbitControls.enabled=!1}appletChanged(){this.cameraSelectChangedDebounced(),this.frameObjectAll(this.applet.scene)}onFrameObject(event){this.frameObjectAll(event.detail.object,event.detail.overscan)}frameObjectAll(object,overscan=1){if(void 0!==object)for(const camera of this.defaultCameras.cameras)camera.position.copy(camera.userData.position),camera.lookAt(0,0,0),this.frameObject(object,camera,overscan);else console.error("frameObject: object is undefined")}frameObject(object,camera,overscan=1){box.setFromObject(object),!1===box.isEmpty()?(box.getCenter(center),radius=box.getBoundingSphere(sphere).radius):(center.setFromMatrixPosition(camera.matrixWorld),radius=.1),cameraRight.set(1,0,0).applyQuaternion(camera.quaternion),cameraUp.set(0,1,0).applyQuaternion(camera.quaternion),cameraForward.set(0,0,-1).applyQuaternion(camera.quaternion),box.getSize(size).multiplyScalar(.5);const halfWidth=Math.abs(size.x*cameraRight.x)+Math.abs(size.y*cameraRight.y)+Math.abs(size.z*cameraRight.z),halfHeight=Math.abs(size.x*cameraUp.x)+Math.abs(size.y*cameraUp.y)+Math.abs(size.z*cameraUp.z),halfDepth=Math.abs(size.x*cameraForward.x)+Math.abs(size.y*cameraForward.y)+Math.abs(size.z*cameraForward.z);if(camera instanceof PerspectiveCamera){const vfov=camera.fov*Math.PI/180,tanHalfVfov=Math.tan(vfov/2),aspect=camera.aspect||1;let distance=0;for(let i=0;i<8;i++){corner.set(1&i?box.max.x:box.min.x,2&i?box.max.y:box.min.y,4&i?box.max.z:box.min.z).sub(center);const x=corner.dot(cameraRight),y=corner.dot(cameraUp),z=corner.dot(cameraForward),distV=Math.abs(y)/tanHalfVfov-z,distH=Math.abs(x)/(tanHalfVfov*aspect)-z;distance=Math.max(distance,distV,distH)}delta.set(0,0,1).applyQuaternion(camera.quaternion).multiplyScalar(distance),camera.position.copy(center).add(delta),camera.near=.01*halfDepth,camera.far=distance+20*halfDepth,camera.zoom=1/overscan,camera.updateProjectionMatrix()}else camera instanceof OrthographicCamera&&(delta.set(0,0,1).applyQuaternion(camera.quaternion).multiplyScalar(radius),camera.position.copy(center).add(delta),camera.lookAt(center),camera.left=-halfWidth,camera.right=halfWidth,camera.bottom=-halfHeight,camera.top=halfHeight,camera.zoom=1/overscan,camera.near=0,camera.far=radius+20*halfDepth,camera.updateProjectionMatrix());this.orbitControls.target.copy(center)}setOverscan(width,height,overscan){const camera=this.camera,resetCamera=resetCameras.get(camera)||camera.clone(!1);resetCamera.copy(camera,!1),resetCameras.set(camera,resetCamera);const viewportAspect=width/height;if(camera instanceof PerspectiveCamera){const originalAspect=camera.aspect;camera.aspect=viewportAspect;const halfFovRad=camera.fov*Math.PI/360,aspectContain=Math.max(1,originalAspect/viewportAspect);camera.fov=2*Math.atan(Math.tan(halfFovRad)*aspectContain)*180/Math.PI,camera.zoom=1/overscan}else if(camera instanceof OrthographicCamera){const frustumHeight=camera.top-camera.bottom,frustumWidth=camera.right-camera.left;frustumWidth/frustumHeight>viewportAspect?(camera.top=frustumWidth/2/viewportAspect,camera.bottom=-frustumWidth/2/viewportAspect):(camera.left=-frustumHeight/2*viewportAspect,camera.right=frustumHeight/2*viewportAspect),camera.top*=overscan,camera.bottom*=overscan,camera.left*=overscan,camera.right*=overscan}camera.updateProjectionMatrix()}resetOverscan(){const camera=this.camera,resetCamera=resetCameras.get(camera);resetCamera&&camera.copy(resetCamera,!1)}dispose(){this.orbitControls.dispose(),super.dispose()}};__decorateClass$7([Property()],ViewCameras.prototype,"viewport",2),__decorateClass$7([ReactiveProperty({type:ThreeApplet})],ViewCameras.prototype,"applet",2),__decorateClass$7([ReactiveProperty({type:String,value:"perspective"})],ViewCameras.prototype,"cameraSelect",2),__decorateClass$7([ReactiveProperty({type:Camera})],ViewCameras.prototype,"camera",2),__decorateClass$7([ReactiveProperty({type:class DefaultCameras{perspective;top;bottom;left;right;front;back;constructor(){this.perspective=new PerspectiveCamera(50,1,.1,1e3),this.top=new OrthographicCamera(-1,1,1,-1,0,1e3),this.bottom=new OrthographicCamera(-1,1,1,-1,0,1e3),this.left=new OrthographicCamera(-1,1,1,-1,0,1e3),this.right=new OrthographicCamera(-1,1,1,-1,0,1e3),this.front=new OrthographicCamera(-1,1,1,-1,0,1e3),this.back=new OrthographicCamera(-1,1,1,-1,0,1e3),this.perspective.userData.position=new Vector3(.5,.25,1),this.perspective.position.copy(this.perspective.userData.position),this.perspective.lookAt(0,0,0),this.perspective.name="perspective",this.top.userData.position=new Vector3(0,1,0),this.top.position.copy(this.top.userData.position),this.top.lookAt(0,0,0),this.top.name="top",this.bottom.userData.position=new Vector3(0,-1,0),this.bottom.position.copy(this.bottom.userData.position),this.bottom.lookAt(0,0,0),this.bottom.name="bottom",this.left.userData.position=new Vector3(-1,0,0),this.left.position.copy(this.left.userData.position),this.left.lookAt(0,0,0),this.left.name="left",this.right.userData.position=new Vector3(1,0,0),this.right.position.copy(this.right.userData.position),this.right.lookAt(0,0,0),this.right.name="right",this.front.userData.position=new Vector3(0,0,1),this.front.position.copy(this.front.userData.position),this.front.lookAt(0,0,0),this.front.name="front",this.back.userData.position=new Vector3(0,0,-1),this.back.position.copy(this.back.userData.position),this.back.lookAt(0,0,0),this.back.name="back"}get cameras(){return[this.perspective,this.top,this.bottom,this.left,this.right,this.front,this.back]}getCamera(name){return this.cameras.find(camera=>camera.name===name)}},init:null})],ViewCameras.prototype,"defaultCameras",2),__decorateClass$7([ReactiveProperty({type:class OrbitControls extends Controls{constructor(object,domElement=null){super(object,domElement),this.state=_STATE_NONE,this.cursor=new Vector3,this.minDistance=0,this.maxDistance=Infinity,this.minZoom=0,this.maxZoom=Infinity,this.minTargetRadius=0,this.maxTargetRadius=Infinity,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-Infinity,this.maxAzimuthAngle=Infinity,this.enableDamping=!1,this.dampingFactor=.05,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.keyRotateSpeed=1,this.enablePan=!0,this.panSpeed=1,this.screenSpacePanning=!0,this.keyPanSpeed=7,this.zoomToCursor=!1,this.autoRotate=!1,this.autoRotateSpeed=2,this.keys={LEFT:"ArrowLeft",UP:"ArrowUp",RIGHT:"ArrowRight",BOTTOM:"ArrowDown"},this.mouseButtons={LEFT:MOUSE_ROTATE,MIDDLE:MOUSE_DOLLY,RIGHT:MOUSE_PAN},this.touches={ONE:TOUCH_ROTATE,TWO:TOUCH_DOLLY_PAN},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this._domElementKeyEvents=null,this._lastPosition=new Vector3,this._lastQuaternion=new Quaternion,this._lastTargetPosition=new Vector3,this._quat=(new Quaternion).setFromUnitVectors(object.up,new Vector3(0,1,0)),this._quatInverse=this._quat.clone().invert(),this._spherical=new Spherical,this._sphericalDelta=new Spherical,this._scale=1,this._panOffset=new Vector3,this._rotateStart=new Vector2,this._rotateEnd=new Vector2,this._rotateDelta=new Vector2,this._panStart=new Vector2,this._panEnd=new Vector2,this._panDelta=new Vector2,this._dollyStart=new Vector2,this._dollyEnd=new Vector2,this._dollyDelta=new Vector2,this._dollyDirection=new Vector3,this._mouse=new Vector2,this._performCursorZoom=!1,this._pointers=[],this._pointerPositions={},this._controlActive=!1,this._onPointerMove=onPointerMove.bind(this),this._onPointerDown=onPointerDown.bind(this),this._onPointerUp=onPointerUp.bind(this),this._onContextMenu=onContextMenu.bind(this),this._onMouseWheel=onMouseWheel.bind(this),this._onKeyDown=onKeyDown.bind(this),this._onTouchStart=onTouchStart.bind(this),this._onTouchMove=onTouchMove.bind(this),this._onMouseDown=onMouseDown.bind(this),this._onMouseMove=onMouseMove.bind(this),this._interceptControlDown=interceptControlDown.bind(this),this._interceptControlUp=interceptControlUp.bind(this),null!==this.domElement&&this.connect(this.domElement),this.update()}connect(element){super.connect(element),this.domElement.addEventListener("pointerdown",this._onPointerDown),this.domElement.addEventListener("pointercancel",this._onPointerUp),this.domElement.addEventListener("contextmenu",this._onContextMenu),this.domElement.addEventListener("wheel",this._onMouseWheel,{passive:!1});this.domElement.getRootNode().addEventListener("keydown",this._interceptControlDown,{passive:!0,capture:!0}),this.domElement.style.touchAction="none"}disconnect(){this.domElement.removeEventListener("pointerdown",this._onPointerDown),this.domElement.ownerDocument.removeEventListener("pointermove",this._onPointerMove),this.domElement.ownerDocument.removeEventListener("pointerup",this._onPointerUp),this.domElement.removeEventListener("pointercancel",this._onPointerUp),this.domElement.removeEventListener("wheel",this._onMouseWheel),this.domElement.removeEventListener("contextmenu",this._onContextMenu),this.stopListenToKeyEvents();this.domElement.getRootNode().removeEventListener("keydown",this._interceptControlDown,{capture:!0}),this.domElement.style.touchAction="auto"}dispose(){this.disconnect()}get target(){if(_targetMap.has(this.object))return _targetMap.get(this.object);{const target=new Vector3;return _targetMap.set(this.object,target),target}}set target(value){_targetMap.set(this.object,value)}getPolarAngle(){return this._spherical.phi}getAzimuthalAngle(){return this._spherical.theta}getDistance(){return this.object.position.distanceTo(this.target)}listenToKeyEvents(domElement){domElement.addEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=domElement}stopListenToKeyEvents(){null!==this._domElementKeyEvents&&(this._domElementKeyEvents.removeEventListener("keydown",this._onKeyDown),this._domElementKeyEvents=null)}saveState(){this.target0.copy(this.target),this.position0.copy(this.object.position),this.zoom0=this.object.zoom}reset(){this.target.copy(this.target0),this.object.position.copy(this.position0),this.object.zoom=this.zoom0,this.object.updateProjectionMatrix(),this.dispatchEvent(_changeEvent),this.update(),this.state=_STATE_NONE}pan(deltaX,deltaY){this._pan(deltaX,deltaY),this.update()}dollyIn(dollyScale){this._dollyIn(dollyScale),this.update()}dollyOut(dollyScale){this._dollyOut(dollyScale),this.update()}rotateLeft(angle){this._rotateLeft(angle),this.update()}rotateUp(angle){this._rotateUp(angle),this.update()}update(deltaTime=null){const position=this.object.position;_v.copy(position).sub(this.target),_v.applyQuaternion(this._quat),this._spherical.setFromVector3(_v),this.autoRotate&&this.state===_STATE_NONE&&this._rotateLeft(this._getAutoRotationAngle(deltaTime)),this.enableDamping?(this._spherical.theta+=this._sphericalDelta.theta*this.dampingFactor,this._spherical.phi+=this._sphericalDelta.phi*this.dampingFactor):(this._spherical.theta+=this._sphericalDelta.theta,this._spherical.phi+=this._sphericalDelta.phi);let min=this.minAzimuthAngle,max=this.maxAzimuthAngle;isFinite(min)&&isFinite(max)&&(min<-Math.PI?min+=_twoPI:min>Math.PI&&(min-=_twoPI),max<-Math.PI?max+=_twoPI:max>Math.PI&&(max-=_twoPI),this._spherical.theta=min<=max?Math.max(min,Math.min(max,this._spherical.theta)):this._spherical.theta>(min+max)/2?Math.max(min,this._spherical.theta):Math.min(max,this._spherical.theta)),this._spherical.phi=Math.max(this.minPolarAngle,Math.min(this.maxPolarAngle,this._spherical.phi)),this._spherical.makeSafe(),!0===this.enableDamping?this.target.addScaledVector(this._panOffset,this.dampingFactor):this.target.add(this._panOffset),this.target.sub(this.cursor),this.target.clampLength(this.minTargetRadius,this.maxTargetRadius),this.target.add(this.cursor);let zoomChanged=!1;if(this.zoomToCursor&&this._performCursorZoom||this.object.isOrthographicCamera)this._spherical.radius=this._clampDistance(this._spherical.radius);else{const prevRadius=this._spherical.radius;this._spherical.radius=this._clampDistance(this._spherical.radius*this._scale),zoomChanged=prevRadius!=this._spherical.radius}if(_v.setFromSpherical(this._spherical),_v.applyQuaternion(this._quatInverse),position.copy(this.target).add(_v),this.object.lookAt(this.target),!0===this.enableDamping?(this._sphericalDelta.theta*=1-this.dampingFactor,this._sphericalDelta.phi*=1-this.dampingFactor,this._panOffset.multiplyScalar(1-this.dampingFactor)):(this._sphericalDelta.set(0,0,0),this._panOffset.set(0,0,0)),this.zoomToCursor&&this._performCursorZoom){let newRadius=null;if(this.object.isPerspectiveCamera){const prevRadius=_v.length();newRadius=this._clampDistance(prevRadius*this._scale);const radiusDelta=prevRadius-newRadius;this.object.position.addScaledVector(this._dollyDirection,radiusDelta),this.object.updateMatrixWorld(),zoomChanged=!!radiusDelta}else if(this.object.isOrthographicCamera){const mouseBefore=new Vector3(this._mouse.x,this._mouse.y,0);mouseBefore.unproject(this.object);const prevZoom=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),this.object.updateProjectionMatrix(),zoomChanged=prevZoom!==this.object.zoom;const mouseAfter=new Vector3(this._mouse.x,this._mouse.y,0);mouseAfter.unproject(this.object),this.object.position.sub(mouseAfter).add(mouseBefore),this.object.updateMatrixWorld(),newRadius=_v.length()}else console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),this.zoomToCursor=!1;null!==newRadius&&(this.screenSpacePanning?this.target.set(0,0,-1).transformDirection(this.object.matrix).multiplyScalar(newRadius).add(this.object.position):(_ray.origin.copy(this.object.position),_ray.direction.set(0,0,-1).transformDirection(this.object.matrix),Math.abs(this.object.up.dot(_ray.direction))<_TILT_LIMIT?this.object.lookAt(this.target):(_plane.setFromNormalAndCoplanarPoint(this.object.up,this.target),_ray.intersectPlane(_plane,this.target))))}else if(this.object.isOrthographicCamera){const prevZoom=this.object.zoom;this.object.zoom=Math.max(this.minZoom,Math.min(this.maxZoom,this.object.zoom/this._scale)),prevZoom!==this.object.zoom&&(this.object.updateProjectionMatrix(),zoomChanged=!0)}return this._scale=1,this._performCursorZoom=!1,!!(zoomChanged||this._lastPosition.distanceToSquared(this.object.position)>1e-6||8*(1-this._lastQuaternion.dot(this.object.quaternion))>1e-6||this._lastTargetPosition.distanceToSquared(this.target)>1e-6)&&(this.dispatchEvent(_changeEvent),this._lastPosition.copy(this.object.position),this._lastQuaternion.copy(this.object.quaternion),this._lastTargetPosition.copy(this.target),!0)}_getAutoRotationAngle(deltaTime){return null!==deltaTime?_twoPI/60*this.autoRotateSpeed*deltaTime:_twoPI/60/60*this.autoRotateSpeed}_getZoomScale(delta){const normalizedDelta=Math.abs(.01*delta);return Math.pow(.95,this.zoomSpeed*normalizedDelta)}_rotateLeft(angle){this._sphericalDelta.theta-=angle}_rotateUp(angle){this._sphericalDelta.phi-=angle}_panLeft(distance,objectMatrix){_v.setFromMatrixColumn(objectMatrix,0),_v.multiplyScalar(-distance),this._panOffset.add(_v)}_panUp(distance,objectMatrix){!0===this.screenSpacePanning?_v.setFromMatrixColumn(objectMatrix,1):(_v.setFromMatrixColumn(objectMatrix,0),_v.crossVectors(this.object.up,_v)),_v.multiplyScalar(distance),this._panOffset.add(_v)}_pan(deltaX,deltaY){const element=this.domElement;if(this.object.isPerspectiveCamera){const position=this.object.position;_v.copy(position).sub(this.target);let targetDistance=_v.length();targetDistance*=Math.tan(this.object.fov/2*Math.PI/180),this._panLeft(2*deltaX*targetDistance/element.clientHeight,this.object.matrix),this._panUp(2*deltaY*targetDistance/element.clientHeight,this.object.matrix)}else this.object.isOrthographicCamera?(this._panLeft(deltaX*(this.object.right-this.object.left)/this.object.zoom/element.clientWidth,this.object.matrix),this._panUp(deltaY*(this.object.top-this.object.bottom)/this.object.zoom/element.clientHeight,this.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),this.enablePan=!1)}_dollyOut(dollyScale){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale/=dollyScale:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_dollyIn(dollyScale){this.object.isPerspectiveCamera||this.object.isOrthographicCamera?this._scale*=dollyScale:(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),this.enableZoom=!1)}_updateZoomParameters(x,y){if(!this.zoomToCursor)return;this._performCursorZoom=!0;const rect=this.domElement.getBoundingClientRect(),dx=x-rect.left,dy=y-rect.top,w=rect.width,h=rect.height;this._mouse.x=dx/w*2-1,this._mouse.y=-dy/h*2+1,this._dollyDirection.set(this._mouse.x,this._mouse.y,1).unproject(this.object).sub(this.object.position).normalize()}_clampDistance(dist){return Math.max(this.minDistance,Math.min(this.maxDistance,dist))}_handleMouseDownRotate(event){this._rotateStart.set(event.clientX,event.clientY)}_handleMouseDownDolly(event){this._updateZoomParameters(event.clientX,event.clientX),this._dollyStart.set(event.clientX,event.clientY)}_handleMouseDownPan(event){this._panStart.set(event.clientX,event.clientY)}_handleMouseMoveRotate(event){this._rotateEnd.set(event.clientX,event.clientY),this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const element=this.domElement;this._rotateLeft(_twoPI*this._rotateDelta.x/element.clientHeight),this._rotateUp(_twoPI*this._rotateDelta.y/element.clientHeight),this._rotateStart.copy(this._rotateEnd),this.update()}_handleMouseMoveDolly(event){this._dollyEnd.set(event.clientX,event.clientY),this._dollyDelta.subVectors(this._dollyEnd,this._dollyStart),this._dollyDelta.y>0?this._dollyOut(this._getZoomScale(this._dollyDelta.y)):this._dollyDelta.y<0&&this._dollyIn(this._getZoomScale(this._dollyDelta.y)),this._dollyStart.copy(this._dollyEnd),this.update()}_handleMouseMovePan(event){this._panEnd.set(event.clientX,event.clientY),this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd),this.update()}_handleMouseWheel(event){this._updateZoomParameters(event.clientX,event.clientY),event.deltaY<0?this._dollyIn(this._getZoomScale(event.deltaY)):event.deltaY>0&&this._dollyOut(this._getZoomScale(event.deltaY)),this.update()}_handleKeyDown(event){let needsUpdate=!1;switch(event.code){case this.keys.UP:event.ctrlKey||event.metaKey||event.shiftKey?this.enableRotate&&this._rotateUp(_twoPI*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,this.keyPanSpeed),needsUpdate=!0;break;case this.keys.BOTTOM:event.ctrlKey||event.metaKey||event.shiftKey?this.enableRotate&&this._rotateUp(-_twoPI*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(0,-this.keyPanSpeed),needsUpdate=!0;break;case this.keys.LEFT:event.ctrlKey||event.metaKey||event.shiftKey?this.enableRotate&&this._rotateLeft(_twoPI*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(this.keyPanSpeed,0),needsUpdate=!0;break;case this.keys.RIGHT:event.ctrlKey||event.metaKey||event.shiftKey?this.enableRotate&&this._rotateLeft(-_twoPI*this.keyRotateSpeed/this.domElement.clientHeight):this.enablePan&&this._pan(-this.keyPanSpeed,0),needsUpdate=!0}needsUpdate&&(event.preventDefault(),this.update())}_handleTouchStartRotate(event){if(1===this._pointers.length)this._rotateStart.set(event.pageX,event.pageY);else{const position=this._getSecondPointerPosition(event),x=.5*(event.pageX+position.x),y=.5*(event.pageY+position.y);this._rotateStart.set(x,y)}}_handleTouchStartPan(event){if(1===this._pointers.length)this._panStart.set(event.pageX,event.pageY);else{const position=this._getSecondPointerPosition(event),x=.5*(event.pageX+position.x),y=.5*(event.pageY+position.y);this._panStart.set(x,y)}}_handleTouchStartDolly(event){const position=this._getSecondPointerPosition(event),dx=event.pageX-position.x,dy=event.pageY-position.y,distance=Math.sqrt(dx*dx+dy*dy);this._dollyStart.set(0,distance)}_handleTouchStartDollyPan(event){this.enableZoom&&this._handleTouchStartDolly(event),this.enablePan&&this._handleTouchStartPan(event)}_handleTouchStartDollyRotate(event){this.enableZoom&&this._handleTouchStartDolly(event),this.enableRotate&&this._handleTouchStartRotate(event)}_handleTouchMoveRotate(event){if(1==this._pointers.length)this._rotateEnd.set(event.pageX,event.pageY);else{const position=this._getSecondPointerPosition(event),x=.5*(event.pageX+position.x),y=.5*(event.pageY+position.y);this._rotateEnd.set(x,y)}this._rotateDelta.subVectors(this._rotateEnd,this._rotateStart).multiplyScalar(this.rotateSpeed);const element=this.domElement;this._rotateLeft(_twoPI*this._rotateDelta.x/element.clientHeight),this._rotateUp(_twoPI*this._rotateDelta.y/element.clientHeight),this._rotateStart.copy(this._rotateEnd)}_handleTouchMovePan(event){if(1===this._pointers.length)this._panEnd.set(event.pageX,event.pageY);else{const position=this._getSecondPointerPosition(event),x=.5*(event.pageX+position.x),y=.5*(event.pageY+position.y);this._panEnd.set(x,y)}this._panDelta.subVectors(this._panEnd,this._panStart).multiplyScalar(this.panSpeed),this._pan(this._panDelta.x,this._panDelta.y),this._panStart.copy(this._panEnd)}_handleTouchMoveDolly(event){const position=this._getSecondPointerPosition(event),dx=event.pageX-position.x,dy=event.pageY-position.y,distance=Math.sqrt(dx*dx+dy*dy);this._dollyEnd.set(0,distance),this._dollyDelta.set(0,Math.pow(this._dollyEnd.y/this._dollyStart.y,this.zoomSpeed)),this._dollyOut(this._dollyDelta.y),this._dollyStart.copy(this._dollyEnd);const centerX=.5*(event.pageX+position.x),centerY=.5*(event.pageY+position.y);this._updateZoomParameters(centerX,centerY)}_handleTouchMoveDollyPan(event){this.enableZoom&&this._handleTouchMoveDolly(event),this.enablePan&&this._handleTouchMovePan(event)}_handleTouchMoveDollyRotate(event){this.enableZoom&&this._handleTouchMoveDolly(event),this.enableRotate&&this._handleTouchMoveRotate(event)}_addPointer(event){this._pointers.push(event.pointerId)}_removePointer(event){delete this._pointerPositions[event.pointerId];for(let i=0;i<this._pointers.length;i++)if(this._pointers[i]==event.pointerId)return void this._pointers.splice(i,1)}_isTrackingPointer(event){for(let i=0;i<this._pointers.length;i++)if(this._pointers[i]==event.pointerId)return!0;return!1}_trackPointer(event){let position=this._pointerPositions[event.pointerId];void 0===position&&(position=new Vector2,this._pointerPositions[event.pointerId]=position),position.set(event.pageX,event.pageY)}_getSecondPointerPosition(event){const pointerId=event.pointerId===this._pointers[0]?this._pointers[1]:this._pointers[0];return this._pointerPositions[pointerId]}_customWheelEvent(event){const mode=event.deltaMode,newEvent={clientX:event.clientX,clientY:event.clientY,deltaY:event.deltaY};switch(mode){case 1:newEvent.deltaY*=16;break;case 2:newEvent.deltaY*=100}return event.ctrlKey&&!this._controlActive&&(newEvent.deltaY*=10),newEvent}},init:["this.defaultCameras.perspective"]})],ViewCameras.prototype,"orbitControls",2),ViewCameras=__decorateClass$7([Register],ViewCameras);var __getOwnPropDesc$5=Object.getOwnPropertyDescriptor;const _raycaster=new Raycaster;let ToolBase=class extends ReactiveNode{viewports=[];constructor(args){super(args)}registerViewport(viewport){this.viewports.push(viewport),viewport.addEventListener("pointerdown",this._onPointerDown),viewport.addEventListener("pointermove",this._onPointerMove),viewport.addEventListener("pointerup",this._onPointerUp),viewport.addEventListener("pointercancel",this._onPointerCancel)}unregisterViewport(viewport){this.viewports.splice(this.viewports.indexOf(viewport),1),viewport.removeEventListener("pointerdown",this._onPointerDown),viewport.removeEventListener("pointermove",this._onPointerMove),viewport.removeEventListener("pointerup",this._onPointerUp),viewport.removeEventListener("pointercancel",this._onPointerCancel)}_activePointers={};_onPointerDown(event){event.stopPropagation(),event.preventDefault();event.target.setPointerCapture(event.pointerId);const pointer3D=this.pointerTo3D(event);this._activePointers[event.pointerId]=pointer3D,this.on3DPointerDown(Object.values(this._activePointers))}_onPointerMove(event){if(event.stopPropagation(),event.preventDefault(),!this._activePointers[event.pointerId])return;const pointer3D=this.pointerTo3D(event);this._activePointers[event.pointerId]=pointer3D,this.on3DPointerMove(Object.values(this._activePointers))}_onPointerUp(event){event.stopPropagation(),event.preventDefault();event.target.releasePointerCapture(event.pointerId),this._activePointers[event.pointerId]&&(delete this._activePointers[event.pointerId],this.on3DPointerUp(Object.values(this._activePointers)))}_onPointerCancel(event){event.stopPropagation(),event.preventDefault();event.target.releasePointerCapture(event.pointerId),this._activePointers[event.pointerId]&&(delete this._activePointers[event.pointerId],this.on3DPointerCancel(Object.values(this._activePointers)))}on3DPointerDown(pointers){console.log("on3DPointerDown",pointers)}on3DPointerMove(pointers){console.log("on3DPointerMove",pointers)}on3DPointerUp(pointers){console.log("on3DPointerUp",pointers)}on3DPointerCancel(pointers){console.log("on3DPointerCancel",pointers)}pointerTo3D(event){const _viewport=event.target,_rect=_viewport.getBoundingClientRect(),screen=new Vector2((event.clientX-_rect.left)/_rect.width*2-1,-(event.clientY-_rect.top)/_rect.height*2+1);_viewport.viewCameras.setOverscan(_viewport.width,_viewport.height,_viewport.overscan);const camera=_viewport.viewCameras.camera;_raycaster.setFromCamera(screen,camera),_viewport.viewCameras.resetOverscan();const{origin:origin,direction:direction}=_raycaster.ray,previousPointer3D=this._activePointers[event.pointerId];return previousPointer3D?{event:event,screen:screen,screenStart:previousPointer3D.screenStart.clone(),screenMovement:screen.clone().sub(previousPointer3D.screen),ray:new Ray(origin.clone(),direction.clone()),rayStart:new Ray(previousPointer3D.rayStart.origin.clone(),previousPointer3D.rayStart.direction.clone()),rayMovement:new Ray(origin.clone().sub(previousPointer3D.ray.origin),direction.clone().sub(previousPointer3D.ray.direction))}:{event:event,screen:screen,screenStart:screen.clone(),screenMovement:new Vector2(0,0),ray:new Ray(origin.clone(),direction.clone()),rayStart:new Ray(origin.clone(),direction.clone()),rayMovement:new Ray(origin.clone(),direction.clone())}}};ToolBase=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$5(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],ToolBase);var __defProp$4=Object.defineProperty,__getOwnPropDesc$4=Object.getOwnPropertyDescriptor,__decorateClass$5=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$4(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$4(target,key,result),result};if(!1===class WebGPU{static isAvailable(){return Boolean(isAvailable)}static getErrorMessage(){const element=document.createElement("div");return element.id="webgpumessage",element.style.fontFamily="monospace",element.style.fontSize="13px",element.style.fontWeight="normal",element.style.textAlign="center",element.style.background="#fff",element.style.color="#000",element.style.padding="1.5em",element.style.maxWidth="400px",element.style.margin="5em auto 0",element.innerHTML='Your browser does not support <a href="https://gpuweb.github.io/gpuweb/" style="color:blue">WebGPU</a> yet',element}}.isAvailable())throw new Error("No WebGPU support");const observer=new IntersectionObserver(entries=>{entries.forEach(entry=>{entry.target.visible=entry.isIntersecting})}),_renderer=new WebGPURenderer({antialias:!1,alpha:!0});_renderer.toneMapping=7,_renderer.setPixelRatio(window.devicePixelRatio),_renderer.shadowMap.enabled=!0,_renderer.init();let IoThreeViewport=class extends IoElement{width=0;height=0;visible=!1;static get Style(){return"\n      :host {\n        position: relative;\n        display: flex;\n        flex: 1 1 auto;\n        flex-direction: column;\n        max-width: 100%;\n        max-height: 100%;\n        overflow: hidden;\n        border: var(--io_border);\n        border-color: transparent;\n      }\n      :host > canvas {\n        position: absolute;\n        pointer-events: none;\n      }\n      :host:focus {\n        border: var(--io_border);\n        border-color: var(--io_colorWhite);\n      }\n    "}static get Listeners(){return{"three-applet-needs-render":"onAppletNeedsRender"}}constructor(args){super(args),this.viewCameras=new ViewCameras({viewport:this,applet:this.bind("applet"),cameraSelect:this.bind("cameraSelect")}),this.debounce(this.renderViewportDebounced)}init(){this.renderTarget=new CanvasTarget(document.createElement("canvas")),this.appendChild(this.renderTarget.domElement)}connectedCallback(){super.connectedCallback(),observer.observe(this)}disconnectedCallback(){super.disconnectedCallback(),observer.unobserve(this),this.visible=!1}toolChanged(change){const newTool=change.value,oldTool=change.oldValue;oldTool&&oldTool.unregisterViewport(this),newTool&&newTool.registerViewport(this)}onAppletNeedsRender(event){event.stopPropagation(),this.visible&&this.debounce(this.renderViewportDebounced)}onResized(){const rect=this.getBoundingClientRect();this.width=Math.floor(rect.width),this.height=Math.floor(rect.height),this.renderTarget.setSize(this.width,this.height),this.renderTarget.setPixelRatio(window.devicePixelRatio),this.renderViewportDebounced()}appletChanged(){this.debounce(this.renderViewportDebounced)}appletMutated(){this.debounce(this.renderViewportDebounced)}viewCamerasMutated(){this.debounce(this.renderViewportDebounced)}changed(){this.debounce(this.renderViewportDebounced)}renderViewportDebounced(){!1!==this.renderer.initialized?(this.applet.updateViewportSize(this.width,this.height),this.renderViewport()):this.debounce(this.renderViewportDebounced,void 0,2)}renderViewport(){if(!1===this.renderer.initialized)return;if(!1===this.applet.isRendererInitialized()&&this.applet.onRendererInitialized(this.renderer),!this.width||!this.height)return;this.renderer.setCanvasTarget(this.renderTarget),this.renderer.setClearColor(this.clearColor,this.clearAlpha),this.renderer.setSize(this.width,this.height),this.renderer.clear(),this.applet.updateViewportSize(this.width,this.height);const toneMapping=this.renderer.toneMapping,toneMappingExposure=this.renderer.toneMappingExposure;this.renderer.toneMapping=this.applet.toneMapping,this.renderer.toneMappingExposure=this.applet.toneMappingExposure,this.viewCameras.setOverscan(this.width,this.height,this.overscan),this.renderer.render(this.applet.scene,this.viewCameras.camera),this.viewCameras.resetOverscan(),this.renderer.toneMapping=toneMapping,this.renderer.toneMappingExposure=toneMappingExposure}dispose(){delete this.applet,this.renderTarget.dispose(),this.viewCameras.dispose(),this.tool.unregisterViewport(this),super.dispose()}};__decorateClass$5([ReactiveProperty({type:Number,value:1.1})],IoThreeViewport.prototype,"overscan",2),__decorateClass$5([ReactiveProperty({type:Number,value:0})],IoThreeViewport.prototype,"clearColor",2),__decorateClass$5([ReactiveProperty({type:Number,value:1})],IoThreeViewport.prototype,"clearAlpha",2),__decorateClass$5([ReactiveProperty({type:String,value:"throttled"})],IoThreeViewport.prototype,"reactivity",2),__decorateClass$5([ReactiveProperty({type:ThreeApplet,init:null})],IoThreeViewport.prototype,"applet",2),__decorateClass$5([ReactiveProperty({type:String,value:"perspective"})],IoThreeViewport.prototype,"cameraSelect",2),__decorateClass$5([ReactiveProperty({type:WebGPURenderer,value:_renderer})],IoThreeViewport.prototype,"renderer",2),__decorateClass$5([ReactiveProperty({type:ViewCameras})],IoThreeViewport.prototype,"viewCameras",2),__decorateClass$5([ReactiveProperty({type:ToolBase})],IoThreeViewport.prototype,"tool",2),__decorateClass$5([Property(0)],IoThreeViewport.prototype,"tabIndex",2),IoThreeViewport=__decorateClass$5([Register],IoThreeViewport);const ioThreeViewport=function(arg0){return IoThreeViewport.vConstructor(arg0)};var arg0;registerEditorConfig(FogExp2,[["density",ioNumberSlider({min:0,max:.1,step:1e-4,exponent:3})]]),registerEditorGroups(FogExp2,{Main:["name","color","density"]}),registerEditorConfig(Object,[[FogExp2,ioObject({labelWidth:"52px"})]]),registerEditorConfig(Fog,[["near",ioNumber({min:0,max:Infinity,step:.1})],["far",ioNumber({min:0,max:Infinity,step:1})]]),registerEditorGroups(Fog,{Main:["name","color","near","far"]}),registerEditorConfig(Object,[[Fog,ioObject({labelWidth:"52px"})]]),registerEditorConfig(Object3D,[["renderOrder",ioNumberSlider({min:0,max:100,step:1})],["up",ioVector3({min:-1,max:1,step:.01})],["position",ioVector3({step:.001})],["quaternion",ioQuaternion({step:.001})],["scale",ioVector3({step:.001,linkable:!0})],["rotation",ioEuler({min:-2*Math.PI,max:2*Math.PI,step:Math.PI/180*.1,conversion:1/Math.PI*180})]]),registerEditorGroups(Object3D,{Main:["name","visible","position","rotation","scale"],Rendering:["castShadow","receiveShadow","frustumCulled","renderOrder","layers","customDepthMaterial","customDistanceMaterial"],Animation:["animations"],Advanced:["quaternion","up","matrix","matrixWorld","normalMatrix","matrixWorldInverse","modelViewMatrix","matrixAutoUpdate","matrixWorldAutoUpdate","matrixWorldNeedsUpdate"],Hidden:["static","parent","children"]}),registerEditorConfig(Scene,[["backgroundBlurriness",ioNumberSlider({min:0,max:1,step:.01})],["backgroundIntensity",ioNumberSlider({min:0,max:1,step:.01})],["backgroundRotation",ioEuler({min:-360,max:360,step:1})],["environmentIntensity",ioNumberSlider({min:0,max:1,step:.01})],["environmentRotation",ioEuler({min:-360,max:360,step:1})]]),registerEditorGroups(Scene,{Rendering:["background","environment","fog","backgroundBlurriness","backgroundIntensity","backgroundRotation","environmentIntensity","environmentRotation","overrideMaterial"],Advanced:[""]}),registerEditorGroups(Mesh,{Rendering:["count"],Morphing:["morphTargetInfluences","morphTargetDictionary"]}),registerEditorConfig(SkinnedMesh,[["bindMode",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:"attached",id:"Attached"},{value:"detached",id:"Detached"}]})})]]),registerEditorGroups(SkinnedMesh,{Main:["skeleton","bindMode","bindMatrix","bindMatrixInverse"],Rendering:["boundingBox","boundingSphere"]}),registerEditorConfig(InstancedMesh,[["count",ioNumber({min:0,step:1})]]),registerEditorGroups(InstancedMesh,{Main:["count","instanceMatrix","instanceColor","morphTexture"],Rendering:["boundingBox","boundingSphere"],Hidden:["previousInstanceMatrix"]}),registerEditorGroups(class BatchedMesh extends Mesh{constructor(maxInstanceCount,maxVertexCount,maxIndexCount=2*maxVertexCount,material){super(new BufferGeometry,material),this.isBatchedMesh=!0,this.perObjectFrustumCulled=!0,this.sortObjects=!0,this.boundingBox=null,this.boundingSphere=null,this.customSort=null,this._instanceInfo=[],this._geometryInfo=[],this._availableInstanceIds=[],this._availableGeometryIds=[],this._nextIndexStart=0,this._nextVertexStart=0,this._geometryCount=0,this._visibilityChanged=!0,this._geometryInitialized=!1,this._maxInstanceCount=maxInstanceCount,this._maxVertexCount=maxVertexCount,this._maxIndexCount=maxIndexCount,this._multiDrawCounts=new Int32Array(maxInstanceCount),this._multiDrawStarts=new Int32Array(maxInstanceCount),this._multiDrawCount=0,this._multiDrawInstances=null,this._matricesTexture=null,this._indirectTexture=null,this._colorsTexture=null,this._initMatricesTexture(),this._initIndirectTexture()}get maxInstanceCount(){return this._maxInstanceCount}get instanceCount(){return this._instanceInfo.length-this._availableInstanceIds.length}get unusedVertexCount(){return this._maxVertexCount-this._nextVertexStart}get unusedIndexCount(){return this._maxIndexCount-this._nextIndexStart}_initMatricesTexture(){let size=Math.sqrt(4*this._maxInstanceCount);size=4*Math.ceil(size/4),size=Math.max(size,4);const matricesArray=new Float32Array(size*size*4),matricesTexture=new DataTexture(matricesArray,size,size,1023,1015);this._matricesTexture=matricesTexture}_initIndirectTexture(){let size=Math.sqrt(this._maxInstanceCount);size=Math.ceil(size);const indirectArray=new Uint32Array(size*size),indirectTexture=new DataTexture(indirectArray,size,size,1029,1014);this._indirectTexture=indirectTexture}_initColorsTexture(){let size=Math.sqrt(this._maxInstanceCount);size=Math.ceil(size);const colorsArray=new Float32Array(size*size*4).fill(1),colorsTexture=new DataTexture(colorsArray,size,size,1023,1015);colorsTexture.colorSpace=ColorManagement.workingColorSpace,this._colorsTexture=colorsTexture}_initializeGeometry(reference){const geometry=this.geometry,maxVertexCount=this._maxVertexCount,maxIndexCount=this._maxIndexCount;if(!1===this._geometryInitialized){for(const attributeName in reference.attributes){const srcAttribute=reference.getAttribute(attributeName),{array:array,itemSize:itemSize,normalized:normalized}=srcAttribute,dstArray=new array.constructor(maxVertexCount*itemSize),dstAttribute=new BufferAttribute(dstArray,itemSize,normalized);geometry.setAttribute(attributeName,dstAttribute)}if(null!==reference.getIndex()){const indexArray=maxVertexCount>65535?new Uint32Array(maxIndexCount):new Uint16Array(maxIndexCount);geometry.setIndex(new BufferAttribute(indexArray,1))}this._geometryInitialized=!0}}_validateGeometry(geometry){const batchGeometry=this.geometry;if(Boolean(geometry.getIndex())!==Boolean(batchGeometry.getIndex()))throw new Error('THREE.BatchedMesh: All geometries must consistently have "index".');for(const attributeName in batchGeometry.attributes){if(!geometry.hasAttribute(attributeName))throw new Error(`THREE.BatchedMesh: Added geometry missing "${attributeName}". All geometries must have consistent attributes.`);const srcAttribute=geometry.getAttribute(attributeName),dstAttribute=batchGeometry.getAttribute(attributeName);if(srcAttribute.itemSize!==dstAttribute.itemSize||srcAttribute.normalized!==dstAttribute.normalized)throw new Error("THREE.BatchedMesh: All attributes must have a consistent itemSize and normalized value.")}}validateInstanceId(instanceId){const instanceInfo=this._instanceInfo;if(instanceId<0||instanceId>=instanceInfo.length||!1===instanceInfo[instanceId].active)throw new Error(`THREE.BatchedMesh: Invalid instanceId ${instanceId}. Instance is either out of range or has been deleted.`)}validateGeometryId(geometryId){const geometryInfoList=this._geometryInfo;if(geometryId<0||geometryId>=geometryInfoList.length||!1===geometryInfoList[geometryId].active)throw new Error(`THREE.BatchedMesh: Invalid geometryId ${geometryId}. Geometry is either out of range or has been deleted.`)}setCustomSort(func){return this.customSort=func,this}computeBoundingBox(){null===this.boundingBox&&(this.boundingBox=new Box3);const boundingBox=this.boundingBox,instanceInfo=this._instanceInfo;boundingBox.makeEmpty();for(let i=0,l=instanceInfo.length;i<l;i++){if(!1===instanceInfo[i].active)continue;const geometryId=instanceInfo[i].geometryIndex;this.getMatrixAt(i,_matrix$1),this.getBoundingBoxAt(geometryId,_box$1).applyMatrix4(_matrix$1),boundingBox.union(_box$1)}}computeBoundingSphere(){null===this.boundingSphere&&(this.boundingSphere=new Sphere);const boundingSphere=this.boundingSphere,instanceInfo=this._instanceInfo;boundingSphere.makeEmpty();for(let i=0,l=instanceInfo.length;i<l;i++){if(!1===instanceInfo[i].active)continue;const geometryId=instanceInfo[i].geometryIndex;this.getMatrixAt(i,_matrix$1),this.getBoundingSphereAt(geometryId,_sphere$2).applyMatrix4(_matrix$1),boundingSphere.union(_sphere$2)}}addInstance(geometryId){if(this._instanceInfo.length>=this.maxInstanceCount&&0===this._availableInstanceIds.length)throw new Error("THREE.BatchedMesh: Maximum item count reached.");const instanceInfo={visible:!0,active:!0,geometryIndex:geometryId};let drawId=null;this._availableInstanceIds.length>0?(this._availableInstanceIds.sort(ascIdSort),drawId=this._availableInstanceIds.shift(),this._instanceInfo[drawId]=instanceInfo):(drawId=this._instanceInfo.length,this._instanceInfo.push(instanceInfo));const matricesTexture=this._matricesTexture;_matrix$1.identity().toArray(matricesTexture.image.data,16*drawId),matricesTexture.needsUpdate=!0;const colorsTexture=this._colorsTexture;return colorsTexture&&(_whiteColor.toArray(colorsTexture.image.data,4*drawId),colorsTexture.needsUpdate=!0),this._visibilityChanged=!0,drawId}addGeometry(geometry,reservedVertexCount=-1,reservedIndexCount=-1){this._initializeGeometry(geometry),this._validateGeometry(geometry);const geometryInfo={vertexStart:-1,vertexCount:-1,reservedVertexCount:-1,indexStart:-1,indexCount:-1,reservedIndexCount:-1,start:-1,count:-1,boundingBox:null,boundingSphere:null,active:!0},geometryInfoList=this._geometryInfo;geometryInfo.vertexStart=this._nextVertexStart,geometryInfo.reservedVertexCount=-1===reservedVertexCount?geometry.getAttribute("position").count:reservedVertexCount;const index=geometry.getIndex();if(null!==index&&(geometryInfo.indexStart=this._nextIndexStart,geometryInfo.reservedIndexCount=-1===reservedIndexCount?index.count:reservedIndexCount),-1!==geometryInfo.indexStart&&geometryInfo.indexStart+geometryInfo.reservedIndexCount>this._maxIndexCount||geometryInfo.vertexStart+geometryInfo.reservedVertexCount>this._maxVertexCount)throw new Error("THREE.BatchedMesh: Reserved space request exceeds the maximum buffer size.");let geometryId;return this._availableGeometryIds.length>0?(this._availableGeometryIds.sort(ascIdSort),geometryId=this._availableGeometryIds.shift(),geometryInfoList[geometryId]=geometryInfo):(geometryId=this._geometryCount,this._geometryCount++,geometryInfoList.push(geometryInfo)),this.setGeometryAt(geometryId,geometry),this._nextIndexStart=geometryInfo.indexStart+geometryInfo.reservedIndexCount,this._nextVertexStart=geometryInfo.vertexStart+geometryInfo.reservedVertexCount,geometryId}setGeometryAt(geometryId,geometry){if(geometryId>=this._geometryCount)throw new Error("THREE.BatchedMesh: Maximum geometry count reached.");this._validateGeometry(geometry);const batchGeometry=this.geometry,hasIndex=null!==batchGeometry.getIndex(),dstIndex=batchGeometry.getIndex(),srcIndex=geometry.getIndex(),geometryInfo=this._geometryInfo[geometryId];if(hasIndex&&srcIndex.count>geometryInfo.reservedIndexCount||geometry.attributes.position.count>geometryInfo.reservedVertexCount)throw new Error("THREE.BatchedMesh: Reserved space not large enough for provided geometry.");const vertexStart=geometryInfo.vertexStart,reservedVertexCount=geometryInfo.reservedVertexCount;geometryInfo.vertexCount=geometry.getAttribute("position").count;for(const attributeName in batchGeometry.attributes){const srcAttribute=geometry.getAttribute(attributeName),dstAttribute=batchGeometry.getAttribute(attributeName);copyAttributeData(srcAttribute,dstAttribute,vertexStart);const itemSize=srcAttribute.itemSize;for(let i=srcAttribute.count,l=reservedVertexCount;i<l;i++){const index=vertexStart+i;for(let c=0;c<itemSize;c++)dstAttribute.setComponent(index,c,0)}dstAttribute.needsUpdate=!0,dstAttribute.addUpdateRange(vertexStart*itemSize,reservedVertexCount*itemSize)}if(hasIndex){const indexStart=geometryInfo.indexStart,reservedIndexCount=geometryInfo.reservedIndexCount;geometryInfo.indexCount=geometry.getIndex().count;for(let i=0;i<srcIndex.count;i++)dstIndex.setX(indexStart+i,vertexStart+srcIndex.getX(i));for(let i=srcIndex.count,l=reservedIndexCount;i<l;i++)dstIndex.setX(indexStart+i,vertexStart);dstIndex.needsUpdate=!0,dstIndex.addUpdateRange(indexStart,geometryInfo.reservedIndexCount)}return geometryInfo.start=hasIndex?geometryInfo.indexStart:geometryInfo.vertexStart,geometryInfo.count=hasIndex?geometryInfo.indexCount:geometryInfo.vertexCount,geometryInfo.boundingBox=null,null!==geometry.boundingBox&&(geometryInfo.boundingBox=geometry.boundingBox.clone()),geometryInfo.boundingSphere=null,null!==geometry.boundingSphere&&(geometryInfo.boundingSphere=geometry.boundingSphere.clone()),this._visibilityChanged=!0,geometryId}deleteGeometry(geometryId){const geometryInfoList=this._geometryInfo;if(geometryId>=geometryInfoList.length||!1===geometryInfoList[geometryId].active)return this;const instanceInfo=this._instanceInfo;for(let i=0,l=instanceInfo.length;i<l;i++)instanceInfo[i].active&&instanceInfo[i].geometryIndex===geometryId&&this.deleteInstance(i);return geometryInfoList[geometryId].active=!1,this._availableGeometryIds.push(geometryId),this._visibilityChanged=!0,this}deleteInstance(instanceId){return this.validateInstanceId(instanceId),this._instanceInfo[instanceId].active=!1,this._availableInstanceIds.push(instanceId),this._visibilityChanged=!0,this}optimize(){let nextVertexStart=0,nextIndexStart=0;const geometryInfoList=this._geometryInfo,indices=geometryInfoList.map((e,i)=>i).sort((a,b)=>geometryInfoList[a].vertexStart-geometryInfoList[b].vertexStart),geometry=this.geometry;for(let i=0,l=geometryInfoList.length;i<l;i++){const index=indices[i],geometryInfo=geometryInfoList[index];if(!1!==geometryInfo.active){if(null!==geometry.index){if(geometryInfo.indexStart!==nextIndexStart){const{indexStart:indexStart,vertexStart:vertexStart,reservedIndexCount:reservedIndexCount}=geometryInfo,index=geometry.index,array=index.array,elementDelta=nextVertexStart-vertexStart;for(let j=indexStart;j<indexStart+reservedIndexCount;j++)array[j]=array[j]+elementDelta;index.array.copyWithin(nextIndexStart,indexStart,indexStart+reservedIndexCount),index.addUpdateRange(nextIndexStart,reservedIndexCount),index.needsUpdate=!0,geometryInfo.indexStart=nextIndexStart}nextIndexStart+=geometryInfo.reservedIndexCount}if(geometryInfo.vertexStart!==nextVertexStart){const{vertexStart:vertexStart,reservedVertexCount:reservedVertexCount}=geometryInfo,attributes=geometry.attributes;for(const key in attributes){const attribute=attributes[key],{array:array,itemSize:itemSize}=attribute;array.copyWithin(nextVertexStart*itemSize,vertexStart*itemSize,(vertexStart+reservedVertexCount)*itemSize),attribute.addUpdateRange(nextVertexStart*itemSize,reservedVertexCount*itemSize),attribute.needsUpdate=!0}geometryInfo.vertexStart=nextVertexStart}nextVertexStart+=geometryInfo.reservedVertexCount,geometryInfo.start=geometry.index?geometryInfo.indexStart:geometryInfo.vertexStart}}return this._nextIndexStart=nextIndexStart,this._nextVertexStart=nextVertexStart,this._visibilityChanged=!0,this}getBoundingBoxAt(geometryId,target){if(geometryId>=this._geometryCount)return null;const geometry=this.geometry,geometryInfo=this._geometryInfo[geometryId];if(null===geometryInfo.boundingBox){const box=new Box3,index=geometry.index,position=geometry.attributes.position;for(let i=geometryInfo.start,l=geometryInfo.start+geometryInfo.count;i<l;i++){let iv=i;index&&(iv=index.getX(iv)),box.expandByPoint(_vector$5.fromBufferAttribute(position,iv))}geometryInfo.boundingBox=box}return target.copy(geometryInfo.boundingBox),target}getBoundingSphereAt(geometryId,target){if(geometryId>=this._geometryCount)return null;const geometry=this.geometry,geometryInfo=this._geometryInfo[geometryId];if(null===geometryInfo.boundingSphere){const sphere=new Sphere;this.getBoundingBoxAt(geometryId,_box$1),_box$1.getCenter(sphere.center);const index=geometry.index,position=geometry.attributes.position;let maxRadiusSq=0;for(let i=geometryInfo.start,l=geometryInfo.start+geometryInfo.count;i<l;i++){let iv=i;index&&(iv=index.getX(iv)),_vector$5.fromBufferAttribute(position,iv),maxRadiusSq=Math.max(maxRadiusSq,sphere.center.distanceToSquared(_vector$5))}sphere.radius=Math.sqrt(maxRadiusSq),geometryInfo.boundingSphere=sphere}return target.copy(geometryInfo.boundingSphere),target}setMatrixAt(instanceId,matrix){this.validateInstanceId(instanceId);const matricesTexture=this._matricesTexture,matricesArray=this._matricesTexture.image.data;return matrix.toArray(matricesArray,16*instanceId),matricesTexture.needsUpdate=!0,this}getMatrixAt(instanceId,matrix){return this.validateInstanceId(instanceId),matrix.fromArray(this._matricesTexture.image.data,16*instanceId)}setColorAt(instanceId,color){return this.validateInstanceId(instanceId),null===this._colorsTexture&&this._initColorsTexture(),color.toArray(this._colorsTexture.image.data,4*instanceId),this._colorsTexture.needsUpdate=!0,this}getColorAt(instanceId,color){return this.validateInstanceId(instanceId),color.fromArray(this._colorsTexture.image.data,4*instanceId)}setVisibleAt(instanceId,visible){return this.validateInstanceId(instanceId),this._instanceInfo[instanceId].visible===visible||(this._instanceInfo[instanceId].visible=visible,this._visibilityChanged=!0),this}getVisibleAt(instanceId){return this.validateInstanceId(instanceId),this._instanceInfo[instanceId].visible}setGeometryIdAt(instanceId,geometryId){return this.validateInstanceId(instanceId),this.validateGeometryId(geometryId),this._instanceInfo[instanceId].geometryIndex=geometryId,this}getGeometryIdAt(instanceId){return this.validateInstanceId(instanceId),this._instanceInfo[instanceId].geometryIndex}getGeometryRangeAt(geometryId,target={}){this.validateGeometryId(geometryId);const geometryInfo=this._geometryInfo[geometryId];return target.vertexStart=geometryInfo.vertexStart,target.vertexCount=geometryInfo.vertexCount,target.reservedVertexCount=geometryInfo.reservedVertexCount,target.indexStart=geometryInfo.indexStart,target.indexCount=geometryInfo.indexCount,target.reservedIndexCount=geometryInfo.reservedIndexCount,target.start=geometryInfo.start,target.count=geometryInfo.count,target}setInstanceCount(maxInstanceCount){const availableInstanceIds=this._availableInstanceIds,instanceInfo=this._instanceInfo;for(availableInstanceIds.sort(ascIdSort);availableInstanceIds[availableInstanceIds.length-1]===instanceInfo.length-1;)instanceInfo.pop(),availableInstanceIds.pop();if(maxInstanceCount<instanceInfo.length)throw new Error(`BatchedMesh: Instance ids outside the range ${maxInstanceCount} are being used. Cannot shrink instance count.`);const multiDrawCounts=new Int32Array(maxInstanceCount),multiDrawStarts=new Int32Array(maxInstanceCount);copyArrayContents(this._multiDrawCounts,multiDrawCounts),copyArrayContents(this._multiDrawStarts,multiDrawStarts),this._multiDrawCounts=multiDrawCounts,this._multiDrawStarts=multiDrawStarts,this._maxInstanceCount=maxInstanceCount;const indirectTexture=this._indirectTexture,matricesTexture=this._matricesTexture,colorsTexture=this._colorsTexture;indirectTexture.dispose(),this._initIndirectTexture(),copyArrayContents(indirectTexture.image.data,this._indirectTexture.image.data),matricesTexture.dispose(),this._initMatricesTexture(),copyArrayContents(matricesTexture.image.data,this._matricesTexture.image.data),colorsTexture&&(colorsTexture.dispose(),this._initColorsTexture(),copyArrayContents(colorsTexture.image.data,this._colorsTexture.image.data))}setGeometrySize(maxVertexCount,maxIndexCount){const validRanges=[...this._geometryInfo].filter(info=>info.active);if(Math.max(...validRanges.map(range=>range.vertexStart+range.reservedVertexCount))>maxVertexCount)throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${maxIndexCount}. Cannot shrink further.`);if(this.geometry.index){if(Math.max(...validRanges.map(range=>range.indexStart+range.reservedIndexCount))>maxIndexCount)throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${maxIndexCount}. Cannot shrink further.`)}const oldGeometry=this.geometry;oldGeometry.dispose(),this._maxVertexCount=maxVertexCount,this._maxIndexCount=maxIndexCount,this._geometryInitialized&&(this._geometryInitialized=!1,this.geometry=new BufferGeometry,this._initializeGeometry(oldGeometry));const geometry=this.geometry;oldGeometry.index&&copyArrayContents(oldGeometry.index.array,geometry.index.array);for(const key in oldGeometry.attributes)copyArrayContents(oldGeometry.attributes[key].array,geometry.attributes[key].array)}raycast(raycaster,intersects){const instanceInfo=this._instanceInfo,geometryInfoList=this._geometryInfo,matrixWorld=this.matrixWorld,batchGeometry=this.geometry;_mesh.material=this.material,_mesh.geometry.index=batchGeometry.index,_mesh.geometry.attributes=batchGeometry.attributes,null===_mesh.geometry.boundingBox&&(_mesh.geometry.boundingBox=new Box3),null===_mesh.geometry.boundingSphere&&(_mesh.geometry.boundingSphere=new Sphere);for(let i=0,l=instanceInfo.length;i<l;i++){if(!instanceInfo[i].visible||!instanceInfo[i].active)continue;const geometryId=instanceInfo[i].geometryIndex,geometryInfo=geometryInfoList[geometryId];_mesh.geometry.setDrawRange(geometryInfo.start,geometryInfo.count),this.getMatrixAt(i,_mesh.matrixWorld).premultiply(matrixWorld),this.getBoundingBoxAt(geometryId,_mesh.geometry.boundingBox),this.getBoundingSphereAt(geometryId,_mesh.geometry.boundingSphere),_mesh.raycast(raycaster,_batchIntersects);for(let j=0,l=_batchIntersects.length;j<l;j++){const intersect=_batchIntersects[j];intersect.object=this,intersect.batchId=i,intersects.push(intersect)}_batchIntersects.length=0}_mesh.material=null,_mesh.geometry.index=null,_mesh.geometry.attributes={},_mesh.geometry.setDrawRange(0,Infinity)}copy(source){return super.copy(source),this.geometry=source.geometry.clone(),this.perObjectFrustumCulled=source.perObjectFrustumCulled,this.sortObjects=source.sortObjects,this.boundingBox=null!==source.boundingBox?source.boundingBox.clone():null,this.boundingSphere=null!==source.boundingSphere?source.boundingSphere.clone():null,this._geometryInfo=source._geometryInfo.map(info=>({...info,boundingBox:null!==info.boundingBox?info.boundingBox.clone():null,boundingSphere:null!==info.boundingSphere?info.boundingSphere.clone():null})),this._instanceInfo=source._instanceInfo.map(info=>({...info})),this._availableInstanceIds=source._availableInstanceIds.slice(),this._availableGeometryIds=source._availableGeometryIds.slice(),this._nextIndexStart=source._nextIndexStart,this._nextVertexStart=source._nextVertexStart,this._geometryCount=source._geometryCount,this._maxInstanceCount=source._maxInstanceCount,this._maxVertexCount=source._maxVertexCount,this._maxIndexCount=source._maxIndexCount,this._geometryInitialized=source._geometryInitialized,this._multiDrawCounts=source._multiDrawCounts.slice(),this._multiDrawStarts=source._multiDrawStarts.slice(),this._indirectTexture=source._indirectTexture.clone(),this._indirectTexture.image.data=this._indirectTexture.image.data.slice(),this._matricesTexture=source._matricesTexture.clone(),this._matricesTexture.image.data=this._matricesTexture.image.data.slice(),null!==this._colorsTexture&&(this._colorsTexture=source._colorsTexture.clone(),this._colorsTexture.image.data=this._colorsTexture.image.data.slice()),this}dispose(){this.geometry.dispose(),this._matricesTexture.dispose(),this._matricesTexture=null,this._indirectTexture.dispose(),this._indirectTexture=null,null!==this._colorsTexture&&(this._colorsTexture.dispose(),this._colorsTexture=null)}onBeforeRender(renderer,scene,camera,geometry,material){if(!this._visibilityChanged&&!this.perObjectFrustumCulled&&!this.sortObjects)return;const index=geometry.getIndex();let bytesPerElement=null===index?1:index.array.BYTES_PER_ELEMENT,multiDrawMultiplier=1;material.wireframe&&(multiDrawMultiplier=2,bytesPerElement=geometry.attributes.position.count>65535?4:2);const instanceInfo=this._instanceInfo,multiDrawStarts=this._multiDrawStarts,multiDrawCounts=this._multiDrawCounts,geometryInfoList=this._geometryInfo,perObjectFrustumCulled=this.perObjectFrustumCulled,indirectTexture=this._indirectTexture,indirectArray=indirectTexture.image.data,frustum=camera.isArrayCamera?_frustumArray$1:_frustum$2;perObjectFrustumCulled&&!camera.isArrayCamera&&(_matrix$1.multiplyMatrices(camera.projectionMatrix,camera.matrixWorldInverse).multiply(this.matrixWorld),_frustum$2.setFromProjectionMatrix(_matrix$1,camera.coordinateSystem,camera.reversedDepth));let multiDrawCount=0;if(this.sortObjects){_matrix$1.copy(this.matrixWorld).invert(),_vector$5.setFromMatrixPosition(camera.matrixWorld).applyMatrix4(_matrix$1),_forward$1.set(0,0,-1).transformDirection(camera.matrixWorld).transformDirection(_matrix$1);for(let i=0,l=instanceInfo.length;i<l;i++)if(instanceInfo[i].visible&&instanceInfo[i].active){const geometryId=instanceInfo[i].geometryIndex;this.getMatrixAt(i,_matrix$1),this.getBoundingSphereAt(geometryId,_sphere$2).applyMatrix4(_matrix$1);let culled=!1;if(perObjectFrustumCulled&&(culled=!frustum.intersectsSphere(_sphere$2,camera)),!culled){const geometryInfo=geometryInfoList[geometryId],z=_temp.subVectors(_sphere$2.center,_vector$5).dot(_forward$1);_renderList.push(geometryInfo.start,geometryInfo.count,z,i)}}const list=_renderList.list,customSort=this.customSort;null===customSort?list.sort(material.transparent?sortTransparent:sortOpaque):customSort.call(this,list,camera);for(let i=0,l=list.length;i<l;i++){const item=list[i];multiDrawStarts[multiDrawCount]=item.start*bytesPerElement*multiDrawMultiplier,multiDrawCounts[multiDrawCount]=item.count*multiDrawMultiplier,indirectArray[multiDrawCount]=item.index,multiDrawCount++}_renderList.reset()}else for(let i=0,l=instanceInfo.length;i<l;i++)if(instanceInfo[i].visible&&instanceInfo[i].active){const geometryId=instanceInfo[i].geometryIndex;let culled=!1;if(perObjectFrustumCulled&&(this.getMatrixAt(i,_matrix$1),this.getBoundingSphereAt(geometryId,_sphere$2).applyMatrix4(_matrix$1),culled=!frustum.intersectsSphere(_sphere$2,camera)),!culled){const geometryInfo=geometryInfoList[geometryId];multiDrawStarts[multiDrawCount]=geometryInfo.start*bytesPerElement*multiDrawMultiplier,multiDrawCounts[multiDrawCount]=geometryInfo.count*multiDrawMultiplier,indirectArray[multiDrawCount]=i,multiDrawCount++}}indirectTexture.needsUpdate=!0,this._multiDrawCount=multiDrawCount,this._visibilityChanged=!1}onBeforeShadow(renderer,object,camera,shadowCamera,geometry,depthMaterial){this.onBeforeRender(renderer,null,shadowCamera,geometry,depthMaterial)}},{Rendering:["perObjectFrustumCulled","sortObjects","customSort","boundingBox","boundingSphere"],Advanced:["maxInstanceCount","instanceCount","unusedVertexCount","unusedIndexCount"]}),registerEditorGroups(class ClippingGroup extends Group{constructor(){super(),this.isClippingGroup=!0,this.clippingPlanes=[],this.enabled=!0,this.clipIntersection=!1,this.clipShadows=!1}},{Main:["clippingPlanes","enabled","clipIntersection","clipShadows"]}),registerEditorGroups(Line,{Morphing:["morphTargetInfluences","morphTargetDictionary"]}),registerEditorGroups(class Points extends Object3D{constructor(geometry=new BufferGeometry,material=new PointsMaterial){super(),this.isPoints=!0,this.type="Points",this.geometry=geometry,this.material=material,this.morphTargetDictionary=void 0,this.morphTargetInfluences=void 0,this.updateMorphTargets()}copy(source,recursive){return super.copy(source,recursive),this.material=Array.isArray(source.material)?source.material.slice():source.material,this.geometry=source.geometry,this}raycast(raycaster,intersects){const geometry=this.geometry,matrixWorld=this.matrixWorld,threshold=raycaster.params.Points.threshold,drawRange=geometry.drawRange;if(null===geometry.boundingSphere&&geometry.computeBoundingSphere(),_sphere$7.copy(geometry.boundingSphere),_sphere$7.applyMatrix4(matrixWorld),_sphere$7.radius+=threshold,!1===raycaster.ray.intersectsSphere(_sphere$7))return;_inverseMatrix.copy(matrixWorld).invert(),_ray$4.copy(raycaster.ray).applyMatrix4(_inverseMatrix);const localThreshold=threshold/((this.scale.x+this.scale.y+this.scale.z)/3),localThresholdSq=localThreshold*localThreshold,index=geometry.index,positionAttribute=geometry.attributes.position;if(null!==index){for(let i=Math.max(0,drawRange.start),il=Math.min(index.count,drawRange.start+drawRange.count);i<il;i++){const a=index.getX(i);_position$3.fromBufferAttribute(positionAttribute,a),testPoint(_position$3,a,localThresholdSq,matrixWorld,raycaster,intersects,this)}}else{for(let i=Math.max(0,drawRange.start),l=Math.min(positionAttribute.count,drawRange.start+drawRange.count);i<l;i++)_position$3.fromBufferAttribute(positionAttribute,i),testPoint(_position$3,i,localThresholdSq,matrixWorld,raycaster,intersects,this)}}updateMorphTargets(){const morphAttributes=this.geometry.morphAttributes,keys=Object.keys(morphAttributes);if(keys.length>0){const morphAttribute=morphAttributes[keys[0]];if(void 0!==morphAttribute){this.morphTargetInfluences=[],this.morphTargetDictionary={};for(let m=0,ml=morphAttribute.length;m<ml;m++){const name=morphAttribute[m].name||String(m);this.morphTargetInfluences.push(0),this.morphTargetDictionary[name]=m}}}}},{Morphing:["morphTargetInfluences","morphTargetDictionary"]}),registerEditorConfig(Sprite,[["count",ioNumber({min:1,step:1})]]),registerEditorGroups(Sprite,{Main:["geometry","material","center","count"]}),registerEditorGroups(Skeleton,{Main:["bones","boneInverses","boneMatrices","previousBoneMatrices","boneTexture"]}),registerEditorGroups(class LOD extends Object3D{constructor(){super(),this.isLOD=!0,this._currentLevel=0,this.type="LOD",Object.defineProperties(this,{levels:{enumerable:!0,value:[]}}),this.autoUpdate=!0}copy(source){super.copy(source,!1);const levels=source.levels;for(let i=0,l=levels.length;i<l;i++){const level=levels[i];this.addLevel(level.object.clone(),level.distance,level.hysteresis)}return this.autoUpdate=source.autoUpdate,this}addLevel(object,distance=0,hysteresis=0){distance=Math.abs(distance);const levels=this.levels;let l;for(l=0;l<levels.length&&!(distance<levels[l].distance);l++);return levels.splice(l,0,{distance:distance,hysteresis:hysteresis,object:object}),this.add(object),this}removeLevel(distance){const levels=this.levels;for(let i=0;i<levels.length;i++)if(levels[i].distance===distance){const removedElements=levels.splice(i,1);return this.remove(removedElements[0].object),!0}return!1}getCurrentLevel(){return this._currentLevel}getObjectForDistance(distance){const levels=this.levels;if(levels.length>0){let i,l;for(i=1,l=levels.length;i<l;i++){let levelDistance=levels[i].distance;if(levels[i].object.visible&&(levelDistance-=levelDistance*levels[i].hysteresis),distance<levelDistance)break}return levels[i-1].object}return null}raycast(raycaster,intersects){if(this.levels.length>0){_v1$2.setFromMatrixPosition(this.matrixWorld);const distance=raycaster.ray.origin.distanceTo(_v1$2);this.getObjectForDistance(distance).raycast(raycaster,intersects)}}update(camera){const levels=this.levels;if(levels.length>1){_v1$2.setFromMatrixPosition(camera.matrixWorld),_v2$1.setFromMatrixPosition(this.matrixWorld);const distance=_v1$2.distanceTo(_v2$1)/camera.zoom;let i,l;for(levels[0].object.visible=!0,i=1,l=levels.length;i<l;i++){let levelDistance=levels[i].distance;if(levels[i].object.visible&&(levelDistance-=levelDistance*levels[i].hysteresis),!(distance>=levelDistance))break;levels[i-1].object.visible=!1,levels[i].object.visible=!0}for(this._currentLevel=i-1;i<l;i++)levels[i].object.visible=!1}}toJSON(meta){const data=super.toJSON(meta);!1===this.autoUpdate&&(data.object.autoUpdate=!1),data.object.levels=[];const levels=this.levels;for(let i=0,l=levels.length;i<l;i++){const level=levels[i];data.object.levels.push({object:level.object.uuid,distance:level.distance,hysteresis:level.hysteresis})}return data}},{Main:["levels","autoUpdate"],Hidden:["_currentLevel"]}),registerEditorConfig(Source,[["needsUpdate",ioSwitch({value:!1})]]),registerEditorGroups(Source,{Advanced:["version"]}),registerEditorConfig(Texture,[["mapping",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:300,id:"UV"},{value:301,id:"Cube Reflection"},{value:302,id:"Cube Refraction"},{value:303,id:"Equirect Reflection"},{value:304,id:"Equirect Refraction"},{value:306,id:"CubeUV Reflection"}]})})],["channel",ioNumber({min:0,max:3,step:1})],["wrapS",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1001,id:"Clamp"},{value:1e3,id:"Repeat"},{value:1002,id:"Mirrored"}]})})],["wrapT",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1001,id:"Clamp"},{value:1e3,id:"Repeat"},{value:1002,id:"Mirrored"}]})})],["magFilter",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1003,id:"Nearest"},{value:1006,id:"Linear"}]})})],["minFilter",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1003,id:"Nearest"},{value:1004,id:"Nearest Mipmap Nearest"},{value:1005,id:"Nearest Mipmap Linear"},{value:1006,id:"Linear"},{value:1007,id:"Linear Mipmap Nearest"},{value:1008,id:"Linear Mipmap Linear"}]})})],["anisotropy",ioNumberSlider({min:1,max:16,step:1})],["format",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1021,id:"Alpha"},{value:1022,id:"RGB"},{value:1023,id:"RGBA"},{value:1026,id:"Depth"},{value:1027,id:"Depth Stencil"},{value:1028,id:"Red"},{value:1030,id:"RG"}]})})],["type",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1009,id:"Unsigned Byte"},{value:1010,id:"Byte"},{value:1011,id:"Short"},{value:1012,id:"Unsigned Short"},{value:1013,id:"Int"},{value:1014,id:"Unsigned Int"},{value:1015,id:"Float"},{value:HalfFloatType,id:"Half Float"}]})})],["colorSpace",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:"",id:"None"},{value:"srgb",id:"sRGB"},{value:"srgb-linear",id:"Linear sRGB"}]})})],["rotation",ioNumberSlider({min:-Math.PI,max:Math.PI,step:.01})],["unpackAlignment",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1,id:"1 (byte)"},{value:2,id:"2 (even)"},{value:4,id:"4 (word)"},{value:8,id:"8 (double-word)"}]})})],["needsUpdate",ioSwitch({value:!1})],["needsPMREMUpdate",ioSwitch({value:!1})]]),registerEditorGroups(Texture,{Source:["source","image","renderTarget","width","height","depth"],Mapping:["mapping","channel","offset","repeat","center","rotation","matrixAutoUpdate","matrix","flipY"],Filtering:["magFilter","minFilter","anisotropy","mipmaps","generateMipmaps"],Wrapping:["wrapS","wrapT"],Format:["format","internalFormat","unpackAlignment","colorSpace","premultiplyAlpha"],Advanced:["version","pmremVersion","updateRanges"],Hidden:["onUpdate"]}),registerEditorGroups(class VideoTexture extends Texture{constructor(video,mapping,wrapS,wrapT,magFilter=1006,minFilter=1006,format,type,anisotropy){super(video,mapping,wrapS,wrapT,magFilter,minFilter,format,type,anisotropy),this.isVideoTexture=!0,this.generateMipmaps=!1,this._requestVideoFrameCallbackId=0;const scope=this;"requestVideoFrameCallback"in video&&(this._requestVideoFrameCallbackId=video.requestVideoFrameCallback(function updateVideo(){scope.needsUpdate=!0,scope._requestVideoFrameCallbackId=video.requestVideoFrameCallback(updateVideo)}))}clone(){return new this.constructor(this.image).copy(this)}update(){const video=this.image;!1==="requestVideoFrameCallback"in video&&video.readyState>=video.HAVE_CURRENT_DATA&&(this.needsUpdate=!0)}dispose(){0!==this._requestVideoFrameCallbackId&&(this.source.data.cancelVideoFrameCallback(this._requestVideoFrameCallbackId),this._requestVideoFrameCallbackId=0),super.dispose()}},{Hidden:["_requestVideoFrameCallbackId"]}),registerEditorGroups(CubeTexture,{Source:["images"]}),registerEditorConfig(Data3DTexture,[["wrapR",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1001,id:"Clamp"},{value:1e3,id:"Repeat"},{value:1002,id:"Mirrored"}]})})]]),registerEditorGroups(Data3DTexture,{Wrapping:["wrapR"]}),registerEditorConfig(DataArrayTexture,[["wrapR",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1001,id:"Clamp"},{value:1e3,id:"Repeat"},{value:1002,id:"Mirrored"}]})})]]),registerEditorGroups(DataArrayTexture,{Hidden:["layerUpdates"],Wrapping:["wrapR"]}),registerEditorConfig(DepthTexture,[["compareFunction",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:null,id:"None"},{value:512,id:"Never"},{value:513,id:"Less"},{value:514,id:"Equal"},{value:515,id:"Less Equal"},{value:516,id:"Greater"},{value:517,id:"Not Equal"},{value:518,id:"Greater Equal"},{value:519,id:"Always"}]})})]]),registerEditorConfig(CompressedArrayTexture,[["wrapR",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1001,id:"Clamp"},{value:1e3,id:"Repeat"},{value:1002,id:"Mirrored"}]})})]]),registerEditorGroups(CompressedArrayTexture,{Source:["layerUpdates"],Wrapping:["wrapR"]}),registerEditorGroups(class ExternalTexture extends Texture{constructor(sourceTexture=null){super(),this.sourceTexture=sourceTexture,this.isExternalTexture=!0}copy(source){return super.copy(source),this.sourceTexture=source.sourceTexture,this}},{Source:["sourceTexture"]}),registerEditorWidget(BoxGeometry,ioBuildGeometry()),registerEditorConfig(BoxGeometry,[["parameters",ioPropertyEditor({config:[["width",ioNumberSlider({min:0,max:1e3,step:.1})],["height",ioNumberSlider({min:0,max:1e3,step:.1})],["depth",ioNumberSlider({min:0,max:1e3,step:.1})],["widthSegments",ioNumberSlider({min:1,max:64,step:1})],["heightSegments",ioNumberSlider({min:1,max:64,step:1})],["depthSegments",ioNumberSlider({min:1,max:64,step:1})]]})]]),registerEditorGroups(BoxGeometry,{Hidden:["parameters"]}),registerEditorWidget(SphereGeometry,ioBuildGeometry()),registerEditorConfig(SphereGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["widthSegments",ioNumberSlider({min:3,max:64,step:1})],["heightSegments",ioNumberSlider({min:2,max:32,step:1})],["phiStart",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["phiLength",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["thetaStart",ioNumberSlider({min:0,max:Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["thetaLength",ioNumberSlider({min:0,max:Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorGroups(SphereGeometry,{Hidden:["parameters"]}),registerEditorWidget(PlaneGeometry,ioBuildGeometry()),registerEditorConfig(PlaneGeometry,[["parameters",ioPropertyEditor({config:[["width",ioNumberSlider({min:0,max:1e3,step:.1})],["height",ioNumberSlider({min:0,max:1e3,step:.1})],["widthSegments",ioNumberSlider({min:1,max:64,step:1})],["heightSegments",ioNumberSlider({min:1,max:64,step:1})]]})]]),registerEditorGroups(PlaneGeometry,{Hidden:["parameters"]}),registerEditorWidget(CylinderGeometry,ioBuildGeometry()),registerEditorConfig(CylinderGeometry,[["parameters",ioPropertyEditor({config:[["radiusTop",ioNumberSlider({min:0,max:1e3,step:.1})],["radiusBottom",ioNumberSlider({min:0,max:1e3,step:.1})],["height",ioNumberSlider({min:0,max:1e3,step:.1})],["radialSegments",ioNumberSlider({min:3,max:64,step:1})],["heightSegments",ioNumberSlider({min:1,max:64,step:1})],["openEnded",ioSwitch({})],["thetaStart",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["thetaLength",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorGroups(CylinderGeometry,{Hidden:["parameters"]}),registerEditorWidget(ConeGeometry,ioBuildGeometry()),registerEditorConfig(ConeGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["height",ioNumberSlider({min:0,max:1e3,step:.1})],["radialSegments",ioNumberSlider({min:3,max:64,step:1})],["heightSegments",ioNumberSlider({min:1,max:64,step:1})],["openEnded",ioSwitch({})],["thetaStart",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["thetaLength",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorGroups(ConeGeometry,{Hidden:["parameters"]}),registerEditorWidget(TorusGeometry,ioBuildGeometry()),registerEditorConfig(TorusGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:3,max:1e3,step:.1})],["tube",ioNumberSlider({min:3,max:1e3,step:.1})],["radialSegments",ioNumberSlider({min:3,max:32,step:1})],["tubularSegments",ioNumberSlider({min:3,max:128,step:1})],["arc",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorGroups(TorusGeometry,{Hidden:["parameters"]}),registerEditorWidget(TorusKnotGeometry,ioBuildGeometry()),registerEditorConfig(TorusKnotGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:3,max:1e3,step:.1})],["tube",ioNumberSlider({min:3,max:1e3,step:.1})],["tubularSegments",ioNumberSlider({min:3,max:256,step:1})],["radialSegments",ioNumberSlider({min:3,max:32,step:1})],["p",ioNumberSlider({min:1,max:10,step:1})],["q",ioNumberSlider({min:1,max:10,step:1})]]})]]),registerEditorGroups(TorusKnotGeometry,{Hidden:["parameters"]}),registerEditorWidget(RingGeometry,ioBuildGeometry()),registerEditorConfig(RingGeometry,[["parameters",ioPropertyEditor({config:[["innerRadius",ioNumberSlider({min:0,max:1e3,step:.1})],["outerRadius",ioNumberSlider({min:0,max:1e3,step:.1})],["thetaSegments",ioNumberSlider({min:3,max:64,step:1})],["phiSegments",ioNumberSlider({min:1,max:64,step:1})],["thetaStart",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["thetaLength",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorGroups(RingGeometry,{Hidden:["parameters"]}),registerEditorWidget(CircleGeometry,ioBuildGeometry()),registerEditorConfig(CircleGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["segments",ioNumberSlider({min:3,max:64,step:1})],["thetaStart",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["thetaLength",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorGroups(CircleGeometry,{Hidden:["parameters"]}),registerEditorWidget(CapsuleGeometry,ioBuildGeometry()),registerEditorConfig(CapsuleGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["height",ioNumberSlider({min:0,max:1e3,step:.1})],["capSegments",ioNumberSlider({min:1,max:64,step:1})],["radialSegments",ioNumberSlider({min:1,max:64,step:1})],["heightSegments",ioNumberSlider({min:1,max:64,step:1})]]})]]),registerEditorGroups(CapsuleGeometry,{Hidden:["parameters"]}),registerEditorWidget(LatheGeometry,ioBuildGeometry()),registerEditorConfig(LatheGeometry,[["parameters",ioPropertyEditor({config:[["segments",ioNumberSlider({min:3,max:64,step:1})],["phiStart",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["phiLength",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorGroups(LatheGeometry,{Hidden:["parameters"]}),registerEditorWidget(TubeGeometry,ioBuildGeometry()),registerEditorConfig(TubeGeometry,[["parameters",ioPropertyEditor({config:[["tubularSegments",ioNumberSlider({min:3,max:256,step:1})],["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["radialSegments",ioNumberSlider({min:3,max:32,step:1})],["closed",ioSwitch({})]]})]]),registerEditorGroups(TubeGeometry,{Hidden:["parameters"]}),registerEditorWidget(ExtrudeGeometry,ioBuildGeometry()),registerEditorConfig(ExtrudeGeometry,[["parameters",ioPropertyEditor({config:[]})]]),registerEditorGroups(ExtrudeGeometry,{Hidden:["parameters"]}),registerEditorWidget(ShapeGeometry,ioBuildGeometry()),registerEditorConfig(ShapeGeometry,[["parameters",ioPropertyEditor({config:[["shapes",ioObject({})],["curveSegments",ioNumberSlider({min:1,max:64,step:1})]]})]]),registerEditorGroups(ShapeGeometry,{Hidden:["parameters"]}),registerEditorWidget(PolyhedronGeometry,ioBuildGeometry()),registerEditorConfig(PolyhedronGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["detail",ioNumberSlider({min:0,max:10,step:1})]]})]]),registerEditorGroups(PolyhedronGeometry,{Hidden:["parameters"]}),registerEditorWidget(IcosahedronGeometry,ioBuildGeometry()),registerEditorConfig(IcosahedronGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["detail",ioNumberSlider({min:0,max:10,step:1})]]})]]),registerEditorGroups(IcosahedronGeometry,{Hidden:["parameters"]}),registerEditorWidget(OctahedronGeometry,ioBuildGeometry()),registerEditorConfig(OctahedronGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["detail",ioNumberSlider({min:0,max:10,step:1})]]})]]),registerEditorGroups(OctahedronGeometry,{Hidden:["parameters"]}),registerEditorWidget(TetrahedronGeometry,ioBuildGeometry()),registerEditorConfig(TetrahedronGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["detail",ioNumberSlider({min:0,max:10,step:1})]]})]]),registerEditorGroups(TetrahedronGeometry,{Hidden:["parameters"]}),registerEditorWidget(DodecahedronGeometry,ioBuildGeometry()),registerEditorConfig(DodecahedronGeometry,[["parameters",ioPropertyEditor({config:[["radius",ioNumberSlider({min:0,max:1e3,step:.1})],["detail",ioNumberSlider({min:0,max:6,step:1})]]})]]),registerEditorGroups(DodecahedronGeometry,{Hidden:["parameters"]}),registerEditorWidget(EdgesGeometry,ioBuildGeometry()),registerEditorConfig(EdgesGeometry,[["parameters",ioPropertyEditor({config:[["thresholdAngle",ioNumberSlider({min:0,max:180,step:1})]]})]]),registerEditorGroups(EdgesGeometry,{Hidden:["parameters"]}),registerEditorWidget(WireframeGeometry,ioBuildGeometry()),registerEditorConfig(WireframeGeometry,[["parameters",ioPropertyEditor({config:[["geometry",ioObject({})]]})]]),registerEditorGroups(WireframeGeometry,{Hidden:["parameters"]}),registerEditorGroups(DirectionalLight,{Main:["target","shadow"]}),registerEditorGroups(HemisphereLight,{Main:["groundColor"]}),registerEditorConfig(PointLight,[["distance",ioNumber({min:0,step:.1})],["decay",ioNumberSlider({min:0,max:5,step:.01})]]),registerEditorGroups(PointLight,{Main:["distance","decay","power","shadow"]}),registerEditorConfig(SpotLight,[["distance",ioNumber({min:0,step:.1})],["angle",ioNumberSlider({min:0,max:Math.PI/2,step:.01})],["penumbra",ioNumberSlider({min:0,max:1,step:.01})],["decay",ioNumberSlider({min:0,max:5,step:.01})]]),registerEditorGroups(SpotLight,{Main:["target","distance","angle","penumbra","decay","power","map","shadow"]}),registerEditorConfig(RectAreaLight,[["width",ioNumber({min:0,step:.1})],["height",ioNumber({min:0,step:.1})]]),registerEditorGroups(RectAreaLight,{Main:["width","height","power"]}),registerEditorGroups(LightProbe,{Main:["sh"]}),registerEditorConfig(Camera,[]),registerEditorGroups(Camera,{Projection:["projectionMatrix","projectionMatrixInverse"],Advanced:["coordinateSystem"],Hidden:["reversedDepth","visible","castShadow","receiveShadow","frustumCulled","renderOrder","layers","customDepthMaterial","customDistanceMaterial","coordinateSystem","_reversedDepth"]}),registerEditorConfig(StereoCamera,[["aspect",ioNumber({min:.01,max:Infinity,step:.01})],["eyeSep",ioNumberSlider({min:0,max:.2,step:.001})]]),registerEditorGroups(StereoCamera,{Main:["aspect","eyeSep"],Cameras:["cameraL","cameraR"],Hidden:["_cache"]}),registerEditorWidget(PerspectiveCamera,ioPropertyEditor({properties:["fov","aspect","near","far","zoom","updateProjectionMatrix"],labelWidth:"52px"})),registerEditorConfig(PerspectiveCamera,[["fov",ioNumberSlider({min:1,max:180,step:.01})],["zoom",ioNumberSlider({min:.01,max:10,step:.01,exponent:3})],["near",ioNumber({min:.01,max:Infinity,step:.01})],["far",ioNumber({min:.1,max:Infinity,step:.01})],["aspect",ioNumber({min:.01,max:Infinity,step:.01})],["focus",ioNumber({min:0,max:Infinity,step:.01})],["filmGauge",ioNumber({min:1,max:100,step:1})],["filmOffset",ioNumber({min:-100,max:100,step:.1})]]),registerEditorGroups(PerspectiveCamera,{Film:["focus","filmGauge","filmOffset"],Advanced:["view"],Hidden:["fov","aspect","near","far","zoom"]}),registerEditorWidget(OrthographicCamera,ioPropertyEditor({properties:["left","right","top","bottom","near","far","zoom","updateProjectionMatrix"],labelWidth:"52px"})),registerEditorConfig(OrthographicCamera,[["left",ioNumber({min:-Infinity,max:Infinity,step:.01})],["right",ioNumber({min:-Infinity,max:Infinity,step:.01})],["top",ioNumber({min:-Infinity,max:Infinity,step:.01})],["bottom",ioNumber({min:-Infinity,max:Infinity,step:.01})],["zoom",ioNumberSlider({min:.01,max:10,step:.01,exponent:3})],["near",ioNumber({min:.01,max:Infinity,step:.01})],["far",ioNumber({min:.1,max:Infinity,step:.01})]]),registerEditorGroups(OrthographicCamera,{Advanced:["view"],Hidden:["left","right","top","bottom","near","far","zoom"]}),registerEditorConfig(CubeCamera,[["activeMipmapLevel",ioNumberSlider({min:0,max:10,step:1})]]),registerEditorGroups(CubeCamera,{Main:["renderTarget","activeMipmapLevel"],Hidden:["coordinateSystem"]}),registerEditorGroups(ArrayCamera,{Main:["cameras"],Hidden:["_reversedDepth"]}),registerEditorConfig(AudioListener,[["timeDelta",ioNumberSlider({min:0,max:1,step:.001})]]),registerEditorGroups(AudioListener,{Main:["timeDelta"],WebAudio:["context","gain","filter"]}),registerEditorConfig(Object,[[AudioListener,ioObject()]]),registerEditorConfig(Audio,[["loopStart",ioNumber({min:0,max:Infinity,step:.01})],["loopEnd",ioNumber({min:0,max:Infinity,step:.01})],["offset",ioNumber({min:0,max:Infinity,step:.01})],["duration",ioNumber({min:0,max:Infinity,step:.01})],["playbackRate",ioNumberSlider({min:0,max:4,step:.01})],["detune",ioNumberSlider({min:-1200,max:1200,step:1})]]),registerEditorGroups(Audio,{Main:["autoplay","isPlaying","hasPlaybackControl"],Playback:["playbackRate","detune","loop","loopStart","loopEnd"],Timing:["offset","duration"],WebAudio:["listener","context","gain","source","sourceType","buffer","filters"]}),registerEditorConfig(Object,[[Audio,ioObject({label:"Audio"})]]),registerEditorConfig(PositionalAudio,[["refDistance",ioNumber({min:0,max:Infinity,step:.1})],["rolloffFactor",ioNumberSlider({min:0,max:10,step:.01})],["maxDistance",ioNumber({min:0,max:Infinity,step:1})],["distanceModel",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:"linear",id:"Linear"},{value:"inverse",id:"Inverse"},{value:"exponential",id:"Exponential"}]})})],["coneInnerAngle",ioNumberSlider({min:0,max:360,step:1})],["coneOuterAngle",ioNumberSlider({min:0,max:360,step:1})],["coneOuterGain",ioNumberSlider({min:0,max:1,step:.01})]]),registerEditorGroups(PositionalAudio,{Spatial:["refDistance","rolloffFactor","maxDistance","distanceModel"],DirectionalCone:["coneInnerAngle","coneOuterAngle","coneOuterGain"],WebAudio:["panner"]}),registerEditorConfig(Object,[[PositionalAudio,ioObject()]]),registerEditorGroups(AudioAnalyser,{Main:["analyser","data"]}),registerEditorConfig(Object,[[AudioAnalyser,ioObject()]]),registerEditorConfig(KeyframeTrack,[["DefaultInterpolation",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:2301,id:"Linear"},{value:2300,id:"Discrete"},{value:2302,id:"Smooth"}]})})]]),registerEditorGroups(KeyframeTrack,{Main:["name","ValueTypeName"],Data:["times","values"],Advanced:["DefaultInterpolation"],Hidden:["createInterpolant","TimeBufferType","ValueBufferType","InterpolantFactoryMethodDiscrete","InterpolantFactoryMethodLinear","InterpolantFactoryMethodSmooth"]}),registerEditorConfig(Object,[[KeyframeTrack,ioObject()]]),registerEditorConfig(PropertyMixer,[["valueSize",ioNumber({min:1,max:16,step:1})],["cumulativeWeight",ioNumber({min:0,max:Infinity,step:.01})],["cumulativeWeightAdditive",ioNumber({min:0,max:Infinity,step:.01})],["useCount",ioNumber({min:0,max:Infinity,step:1})],["referenceCount",ioNumber({min:0,max:Infinity,step:1})]]),registerEditorGroups(PropertyMixer,{Main:["binding","valueSize"],Weights:["cumulativeWeight","cumulativeWeightAdditive"],Counts:["useCount","referenceCount"],Hidden:["buffer","originalValue","_mixBufferRegion","_mixBufferRegionAdditive","_setIdentity","_select","_slerp","_slerpAdditive","_lerp","_lerpAdditive"]}),registerEditorGroups(PropertyBinding,{Main:["path","parsedPath"],References:["node","rootNode"],Hidden:["BindingType","Versioning","GetterByBindingType","SetterByBindingTypeAndVersioning","getValue","setValue"]}),registerEditorGroups(AnimationObjectGroup,{Main:[],Hidden:["_objects","_nCachedObjects_","_indicesByUUID","_paths","_parsedPaths","_bindings","_bindingsIndicesByPath"]}),registerEditorConfig(Object,[[AnimationObjectGroup,ioObject()]]),registerEditorConfig(AnimationMixer,[["timeScale",ioNumberSlider({min:0,max:10,step:.01,exponent:3})]]),registerEditorGroups(AnimationMixer,{Advanced:["stats"]}),registerEditorConfig(AnimationClip,[["duration",ioNumber({min:0,max:Infinity,step:.01})],["blendMode",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:2500,id:"Normal"},{value:2501,id:"Additive"}]})})]]),registerEditorGroups(AnimationClip,{Main:["name","duration","blendMode"],Tracks:["tracks"]}),registerEditorConfig(Object,[[AnimationClip,ioObject()]]),registerEditorConfig(AnimationAction,[["blendMode",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:2501,id:"Additive"},{value:2500,id:"Normal"}]})})],["loop",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:2201,id:"LoopRepeat"},{value:2202,id:"LoopPingPong"},{value:2200,id:"LoopOnce"}]})})],["weight",ioNumberSlider({min:0,max:1,step:.01})],["repetitions",ioNumber({min:0,max:Infinity,step:1})]]),registerEditorGroups(AnimationAction,{Advanced:["zeroSlopeAtStart","zeroSlopeAtEnd","clampWhenFinished","blendMode","loop","repetitions","timeScale"]}),registerEditorConfig(Clock,[["startTime",ioNumber({min:0,max:Infinity,step:.001})],["oldTime",ioNumber({min:0,max:Infinity,step:.001})],["elapsedTime",ioNumber({min:0,max:Infinity,step:.001})]]),registerEditorGroups(Clock,{Main:["autoStart","running","startTime","oldTime","elapsedTime"]}),registerEditorConfig(Object,[[Clock,ioObject()]]),registerEditorConfig(Layers,[["mask",ioNumber({min:0,max:4294967295,step:1})]]),registerEditorGroups(Layers,{Main:["mask"]}),registerEditorConfig(Object,[[Layers,ioObject()]]),registerEditorConfig(Raycaster,[["near",ioNumber({min:0,max:Infinity,step:.01})],["far",ioNumber({min:0,max:Infinity,step:1})]]),registerEditorGroups(Raycaster,{Main:["ray","near","far"],References:["camera","layers"],Advanced:["params"]}),registerEditorConfig(Object,[[BufferAttribute,ioObject({labelWidth:"64px"})]]),registerEditorConfig(BufferAttribute,[["itemSize",ioNumber({min:1,max:16,step:1})],["usage",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:35044,id:"StaticDraw"},{value:35048,id:"DynamicDraw"},{value:35040,id:"StreamDraw"},{value:35045,id:"StaticRead"},{value:35049,id:"DynamicRead"},{value:35041,id:"StreamRead"},{value:35046,id:"StaticCopy"},{value:35050,id:"DynamicCopy"},{value:35042,id:"StreamCopy"}]})})],["gpuType",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:1015,id:"Float"},{value:1013,id:"Int"}]})})],["version",ioNumber({min:0,max:Infinity,step:1})],["needsUpdate",ioSwitch({label:"Needs Update",value:!1})]]),registerEditorGroups(BufferAttribute,{Main:["name","itemSize","count","normalized"],Data:["array","updateRanges"],GPU:["usage","gpuType","version"],Hidden:["onUploadCallback"]}),registerEditorConfig(InstancedBufferAttribute,[["meshPerAttribute",ioNumber({min:1,max:1e3,step:1})]]),registerEditorGroups(InstancedBufferAttribute,{Instancing:["meshPerAttribute"]}),registerEditorConfig(InterleavedBuffer,[["stride",ioNumber({min:1,max:64,step:1})],["usage",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:35044,id:"StaticDraw"},{value:35048,id:"DynamicDraw"},{value:35040,id:"StreamDraw"},{value:35045,id:"StaticRead"},{value:35049,id:"DynamicRead"},{value:35041,id:"StreamRead"},{value:35046,id:"StaticCopy"},{value:35050,id:"DynamicCopy"},{value:35042,id:"StreamCopy"}]})})],["version",ioNumber({min:0,max:Infinity,step:1})],["needsUpdate",ioSwitch({label:"Needs Update",value:!1})]]),registerEditorGroups(InterleavedBuffer,{Main:["array","stride","count"],GPU:["usage","version","updateRanges"],Hidden:["onUploadCallback"]}),registerEditorConfig(InstancedInterleavedBuffer,[["meshPerAttribute",ioNumber({min:1,max:1e3,step:1})],["needsUpdate",ioSwitch({label:"Needs Update",value:!1})]]),registerEditorGroups(InstancedInterleavedBuffer,{Instancing:["meshPerAttribute"]}),registerEditorConfig(InterleavedBufferAttribute,[["itemSize",ioNumber({min:1,max:16,step:1})],["offset",ioNumber({min:0,max:64,step:1})],["needsUpdate",ioSwitch({label:"Needs Update",value:!1})]]),registerEditorGroups(InterleavedBufferAttribute,{Main:["name","itemSize","offset","normalized","count"],Data:["data","array"]}),registerEditorConfig(BufferGeometry,[["index",ioObject({})],["attributes",ioObject({})]]),registerEditorGroups(BufferGeometry,{Main:["index","attributes","boundingBox","boundingSphere"],Morphing:["morphAttributes","morphTargetsRelative"],Advanced:["groups","drawRange","indirect","indirectOffset"]}),registerEditorConfig(InstancedBufferGeometry,[["instanceCount",ioNumber({min:0,max:Infinity,step:1})]]),registerEditorGroups(InstancedBufferGeometry,{Instancing:["instanceCount"]}),registerEditorGroups(class Uniform{constructor(value){this.value=value}clone(){return new Uniform(void 0===this.value.clone?this.value:this.value.clone())}},{Main:["value"]}),registerEditorConfig(UniformsGroup$1,[["usage",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:35044,id:"StaticDraw"},{value:35048,id:"DynamicDraw"},{value:35040,id:"StreamDraw"},{value:35045,id:"StaticRead"},{value:35049,id:"DynamicRead"},{value:35041,id:"StreamRead"},{value:35046,id:"StaticCopy"},{value:35050,id:"DynamicCopy"},{value:35042,id:"StreamCopy"}]})})]]),registerEditorGroups(UniformsGroup$1,{Main:["uniforms"],Advanced:["usage"]}),registerEditorConfig(RenderTarget,[["width",ioNumber({min:1,max:8192,step:1})],["height",ioNumber({min:1,max:8192,step:1})],["depth",ioNumber({min:1,max:2048,step:1})],["samples",ioNumber({min:0,max:16,step:1})]]),registerEditorGroups(RenderTarget,{Main:["width","height","depth","viewport","scissor","scissorTest"],Textures:["texture","textures","depthTexture"],Buffers:["depthBuffer","stencilBuffer","resolveDepthBuffer","resolveStencilBuffer"],Advanced:["samples","multiview"],Hidden:["_depthTexture"]}),registerEditorGroups(QuaternionLinearInterpolant,{Main:["parameterPositions","sampleValues","resultBuffer","valueSize"],Settings:["settings"],Hidden:["_cachedIndex","DefaultSettings_"]}),registerEditorGroups(LinearInterpolant,{Main:["parameterPositions","sampleValues","resultBuffer","valueSize"],Settings:["settings"],Hidden:["_cachedIndex","DefaultSettings_"]}),registerEditorGroups(DiscreteInterpolant,{Main:["parameterPositions","sampleValues","resultBuffer","valueSize"],Settings:["settings"],Hidden:["_cachedIndex","DefaultSettings_"]}),registerEditorGroups(CubicInterpolant,{Main:["parameterPositions","sampleValues","resultBuffer","valueSize"],Settings:["settings"],Hidden:["_cachedIndex","DefaultSettings_","_weightPrev","_offsetPrev","_weightNext","_offsetNext"]}),registerEditorConfig(Object,[[Triangle,ioObject({labelWidth:"18px"})]]),registerEditorConfig(Object,[[Spherical,ioObject({labelWidth:"52px",config:[["phi",ioNumberSlider({min:-2*Math.PI,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})],["theta",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorConfig(Object,[[class Cylindrical{constructor(radius=1,theta=0,y=0){this.radius=radius,this.theta=theta,this.y=y}set(radius,theta,y){return this.radius=radius,this.theta=theta,this.y=y,this}copy(other){return this.radius=other.radius,this.theta=other.theta,this.y=other.y,this}setFromVector3(v){return this.setFromCartesianCoords(v.x,v.y,v.z)}setFromCartesianCoords(x,y,z){return this.radius=Math.sqrt(x*x+z*z),this.theta=Math.atan2(x,z),this.y=y,this}clone(){return(new this.constructor).copy(this)}},ioObject({labelWidth:"52px",config:[["theta",ioNumberSlider({min:0,max:2*Math.PI,step:Math.PI/180,conversion:1/Math.PI*180})]]})]]),registerEditorConfig(Object,[[Plane,ioObject({labelWidth:"64px"})]]),registerEditorConfig(Frustum,[["planes",ioPropertyEditor({labelWidth:"18px",config:[[Plane,ioPropertyEditor({labelWidth:"62px"})]]})]]),registerEditorGroups(Frustum,{}),registerEditorConfig(Object,[[Frustum,ioObject({labeled:!1})]]),registerEditorConfig(FrustumArray,[]),registerEditorGroups(FrustumArray,{Hidden:["coordinateSystem"]}),registerEditorConfig(Object,[[FrustumArray,ioObject()]]),registerEditorConfig(Object,[[Sphere,ioObject({labelWidth:"64px"})]]),registerEditorConfig(Object,[[Ray,ioObject({labelWidth:"64px"})]]),registerEditorConfig(Matrix2,[["elements",IoMatrix2.vConstructor(arg0)]]),registerEditorConfig(Object,[[Matrix2,ioObject({labeled:!1,properties:["elements"]})]]),registerEditorConfig(Matrix3,[["elements",function(arg0){return IoMatrix3.vConstructor(arg0)}()]]),registerEditorConfig(Object,[[Matrix3,ioObject({labeled:!1,properties:["elements"]})]]),registerEditorConfig(Matrix4,[["elements",function(arg0){return IoMatrix4.vConstructor(arg0)}()]]),registerEditorConfig(Object,[[Matrix4,ioObject({labeled:!1,properties:["elements"]})]]),registerEditorConfig(Object,[[class Box2{constructor(min=new Vector2(Infinity,Infinity),max=new Vector2(-Infinity,-Infinity)){this.isBox2=!0,this.min=min,this.max=max}set(min,max){return this.min.copy(min),this.max.copy(max),this}setFromPoints(points){this.makeEmpty();for(let i=0,il=points.length;i<il;i++)this.expandByPoint(points[i]);return this}setFromCenterAndSize(center,size){const halfSize=_vector$4.copy(size).multiplyScalar(.5);return this.min.copy(center).sub(halfSize),this.max.copy(center).add(halfSize),this}clone(){return(new this.constructor).copy(this)}copy(box){return this.min.copy(box.min),this.max.copy(box.max),this}makeEmpty(){return this.min.x=this.min.y=Infinity,this.max.x=this.max.y=-Infinity,this}isEmpty(){return this.max.x<this.min.x||this.max.y<this.min.y}getCenter(target){return this.isEmpty()?target.set(0,0):target.addVectors(this.min,this.max).multiplyScalar(.5)}getSize(target){return this.isEmpty()?target.set(0,0):target.subVectors(this.max,this.min)}expandByPoint(point){return this.min.min(point),this.max.max(point),this}expandByVector(vector){return this.min.sub(vector),this.max.add(vector),this}expandByScalar(scalar){return this.min.addScalar(-scalar),this.max.addScalar(scalar),this}containsPoint(point){return point.x>=this.min.x&&point.x<=this.max.x&&point.y>=this.min.y&&point.y<=this.max.y}containsBox(box){return this.min.x<=box.min.x&&box.max.x<=this.max.x&&this.min.y<=box.min.y&&box.max.y<=this.max.y}getParameter(point,target){return target.set((point.x-this.min.x)/(this.max.x-this.min.x),(point.y-this.min.y)/(this.max.y-this.min.y))}intersectsBox(box){return box.max.x>=this.min.x&&box.min.x<=this.max.x&&box.max.y>=this.min.y&&box.min.y<=this.max.y}clampPoint(point,target){return target.copy(point).clamp(this.min,this.max)}distanceToPoint(point){return this.clampPoint(point,_vector$4).distanceTo(point)}intersect(box){return this.min.max(box.min),this.max.min(box.max),this.isEmpty()&&this.makeEmpty(),this}union(box){return this.min.min(box.min),this.max.max(box.max),this}translate(offset){return this.min.add(offset),this.max.add(offset),this}equals(box){return box.min.equals(this.min)&&box.max.equals(this.max)}},ioObject({labelWidth:"42px"})]]),registerEditorConfig(Object,[[Box3,ioObject({labelWidth:"42px"})]]),registerEditorConfig(Object,[[class Line3{constructor(start=new Vector3,end=new Vector3){this.start=start,this.end=end}set(start,end){return this.start.copy(start),this.end.copy(end),this}copy(line){return this.start.copy(line.start),this.end.copy(line.end),this}getCenter(target){return target.addVectors(this.start,this.end).multiplyScalar(.5)}delta(target){return target.subVectors(this.end,this.start)}distanceSq(){return this.start.distanceToSquared(this.end)}distance(){return this.start.distanceTo(this.end)}at(t,target){return this.delta(target).multiplyScalar(t).add(this.start)}closestPointToPointParameter(point,clampToLine){_startP.subVectors(point,this.start),_startEnd.subVectors(this.end,this.start);const startEnd2=_startEnd.dot(_startEnd);let t=_startEnd.dot(_startP)/startEnd2;return clampToLine&&(t=clamp$3(t,0,1)),t}closestPointToPoint(point,clampToLine,target){const t=this.closestPointToPointParameter(point,clampToLine);return this.delta(target).multiplyScalar(t).add(this.start)}distanceSqToLine3(line,c1=_c1,c2=_c2){const EPSILON=1e-8*1e-8;let s,t;const p1=this.start,p2=line.start,q1=this.end,q2=line.end;_d1.subVectors(q1,p1),_d2.subVectors(q2,p2),_r.subVectors(p1,p2);const a=_d1.dot(_d1),e=_d2.dot(_d2),f=_d2.dot(_r);if(a<=EPSILON&&e<=EPSILON)return c1.copy(p1),c2.copy(p2),c1.sub(c2),c1.dot(c1);if(a<=EPSILON)s=0,t=f/e,t=clamp$3(t,0,1);else{const c=_d1.dot(_r);if(e<=EPSILON)t=0,s=clamp$3(-c/a,0,1);else{const b=_d1.dot(_d2),denom=a*e-b*b;s=0!==denom?clamp$3((b*f-c*e)/denom,0,1):0,t=(b*s+f)/e,t<0?(t=0,s=clamp$3(-c/a,0,1)):t>1&&(t=1,s=clamp$3((b-c)/a,0,1))}}return c1.copy(p1).addScaledVector(_d1,s),c2.copy(p2).addScaledVector(_d2,t),c1.distanceToSquared(c2)}applyMatrix4(matrix){return this.start.applyMatrix4(matrix),this.end.applyMatrix4(matrix),this}equals(line){return line.start.equals(this.start)&&line.end.equals(this.end)}clone(){return(new this.constructor).copy(this)}},ioObject({labelWidth:"42px"})]]),registerEditorConfig(Object,[[Euler,ioEuler({min:-2*Math.PI,max:2*Math.PI,step:Math.PI/180*.1,conversion:1/Math.PI*180})]]),registerEditorConfig(Object,[[Vector4,ioVector4({min:-Infinity,max:Infinity,step:.1})]]),registerEditorConfig(Object,[[Vector3,ioVector3({min:-Infinity,max:Infinity,step:.1})]]),registerEditorConfig(Object,[[Vector2,function(arg0){return IoVector2.vConstructor(arg0)}({min:-Infinity,max:Infinity,step:.1})]]),registerEditorConfig(Object,[[Quaternion,ioQuaternion({min:-Infinity,max:Infinity,step:.1})]]),registerEditorConfig(Object,[[Color,ioColorRgba()]]),registerEditorConfig(Object,[["workingColorSpace",ioOptionSelect({option:new MenuOption({options:["srgb","srgb-linear"]})})],["unpackColorSpace",ioOptionSelect({option:new MenuOption({options:["srgb","srgb-linear"]})})],["drawingBufferColorSpace",ioOptionSelect({option:new MenuOption({options:["srgb","srgb-linear"]})})],["outputColorSpace",ioOptionSelect({option:new MenuOption({options:["srgb","srgb-linear"]})})]]),registerEditorConfig(SphericalHarmonics3,[["coefficients",ioPropertyEditor({labelWidth:"18px",config:[[Vector3,ioVector3({step:.001})]]})]]),registerEditorConfig(Object,[[SphericalHarmonics3,ioObject({labeled:!1})]]),registerEditorConfig(WebGPURenderer,[["toneMappingExposure",ioNumberSlider({min:0,max:10,step:.01,exponent:2})],["outputColorSpace",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:"srgb",id:"sRGB"},{value:"srgb-linear",id:"Linear sRGB"}]})})],["toneMapping",ioOptionSelect({selectBy:"value",option:new MenuOption({options:[{value:0,id:"None"},{value:1,id:"Linear"},{value:2,id:"Reinhard"},{value:3,id:"Cineon"},{value:4,id:"ACES Filmic"},{value:6,id:"AgX"},{value:7,id:"Neutral"},{value:5,id:"Custom"}]})})]]),registerEditorGroups(WebGPURenderer,{Main:["autoClear","autoClearColor","autoClearDepth","autoClearStencil","sortObjects","transparent","opaque"],Output:["outputColorSpace","toneMapping","toneMappingExposure"],Buffers:["alpha","depth","stencil","logarithmicDepthBuffer"],ShadowMap:["shadowMap"],Debug:["debug","info"],Advanced:["domElement","samples","xr","library","lighting","contextNode","highPrecision"],Hidden:["backend","onDeviceLost","_canvasTarget","_inspector"]}),registerEditorConfig(class BundleGroup extends Group{constructor(){super(),this.isBundleGroup=!0,this.type="BundleGroup",this.static=!0,this.version=0}set needsUpdate(value){!0===value&&this.version++}},[["version",ioNumber({disabled:!0})],["needsUpdate",ioSwitch({value:!1})]]),registerEditorConfig(CanvasTarget,[[Number,ioNumber({disabled:!0})],[Vector4,ioVector4({disabled:!0})],[Boolean,ioSwitch({disabled:!0})]]),registerEditorGroups(CanvasTarget,{Main:["colorTexture","depthTexture"],Advanced:["domElement","_width","_height","_pixelRatio","_viewport","_scissor","_scissorTest"]}),registerEditorConfig(PostProcessing,[["needsUpdate",ioSwitch({value:!1})]]),registerEditorGroups(PostProcessing,{Advanced:["context","needsUpdate","outputColorTransform"]}),registerEditorConfig(InspectorBase,[["currentFrame",ioNumber({disabled:!0})]]),registerEditorGroups(class Storage3DTexture extends Texture{constructor(width=1,height=1,depth=1){super(),this.isArrayTexture=!1,this.image={width:width,height:height,depth:depth},this.magFilter=1006,this.minFilter=1006,this.wrapR=1001,this.isStorageTexture=!0,this.is3DTexture=!0}setSize(width,height,depth){this.image.width===width&&this.image.height===height&&this.image.depth===depth||(this.image.width=width,this.image.height=height,this.image.depth=depth,this.dispose())}},{Wrapping:["wrapR"]}),registerEditorGroups(IESSpotLight,{Main:["iesMap"]}),registerEditorConfig(ProjectorLight,[["aspect",ioNumberSlider({min:.1,max:4,step:.01})]]),registerEditorGroups(ProjectorLight,{Main:["aspect"]}),registerEditorGroups(Object,{Advanced:["id","uuid","type","userData"],Hidden:[new RegExp(/^is[A-Z0-9]/),"_listeners"]});class Grid extends LineSegments{width=0;height=0;constructor(){super(new BufferGeometry,new LineBasicMaterial({transparent:!0,vertexColors:!0,toneMapped:!1,blending:2}))}update(width,height,lines,pads,terminals){if(this.width=width,this.height=height,0===width||0===height)return this.geometry.setAttribute("position",new Float32BufferAttribute([],3)),void this.geometry.setAttribute("color",new Float32BufferAttribute([],4));const linePointsL0=/* @__PURE__ */new Set,padPositions=/* @__PURE__ */new Set,padConnectionCounts=/* @__PURE__ */new Map,terminalConnectionCounts=/* @__PURE__ */new Map,cellDiagBackslash=/* @__PURE__ */new Set,cellDiagSlash=/* @__PURE__ */new Set;for(const pad of pads){const key=pad.pos[0]+","+pad.pos[1];padPositions.add(key),padConnectionCounts.set(key,0)}for(const terminal of terminals){const key=terminal.pos[0]+","+terminal.pos[1];terminalConnectionCounts.set(key,0)}for(const line of lines){if(0===line.layer){const lastIdx=line.pos.length-1;if(1===line.pos.length)continue;for(let i=0;i<=lastIdx;i++){const pos=line.pos[i],key=pos[0]+","+pos[1];(0!==i&&i!==lastIdx||terminalConnectionCounts.has(key))&&linePointsL0.add(key)}for(let i=1;i<line.pos.length;i++){const ax=line.pos[i-1][0],ay=line.pos[i-1][1],bx=line.pos[i][0],by=line.pos[i][1],dx=bx-ax,dy=by-ay;if(1===Math.abs(dx)&&1===Math.abs(dy)){const cellKey=Math.min(ax,bx)+","+Math.min(ay,by);dx>0==dy>0?cellDiagBackslash.add(cellKey):cellDiagSlash.add(cellKey)}}}const first=line.pos[0],last=line.pos[line.pos.length-1],firstKey=first[0]+","+first[1],lastKey=last[0]+","+last[1];padConnectionCounts.has(firstKey)&&padConnectionCounts.set(firstKey,padConnectionCounts.get(firstKey)+1),padConnectionCounts.has(lastKey)&&padConnectionCounts.set(lastKey,padConnectionCounts.get(lastKey)+1),terminalConnectionCounts.has(firstKey)&&terminalConnectionCounts.set(firstKey,terminalConnectionCounts.get(firstKey)+1),terminalConnectionCounts.has(lastKey)&&terminalConnectionCounts.set(lastKey,terminalConnectionCounts.get(lastKey)+1)}const isHidden=(x,y)=>{const key=x+","+y;if(linePointsL0.has(key)&&!padPositions.has(key))return!0;const padConns=padConnectionCounts.get(key);if(void 0!==padConns&&padConns>=2)return!0;const termConns=terminalConnectionCounts.get(key);return void 0!==termConns&&termConns>=1},color=new Color(6710886),color2=new Color(6710886),totalVertices=2*(width*(height+1)+height*(width+1)+width*height*2),positions=new Float32Array(3*totalVertices),colors=new Float32Array(4*totalVertices);let vi=0;const pushVertex=(x,y,c,alpha)=>{const pi=3*vi,ci=4*vi;positions[pi]=x,positions[pi+1]=y,positions[pi+2]=0,c.toArray(colors,ci),colors[ci+3]=alpha,vi++};for(let iz=0;iz<=height;iz++)for(let ix=0;ix<width;ix++){const alpha=isHidden(ix,iz)||isHidden(ix+1,iz)?0:1;pushVertex(ix,iz,color,alpha),pushVertex(ix+1,iz,color,alpha)}for(let ix=0;ix<=width;ix++)for(let iz=0;iz<height;iz++){const alpha=isHidden(ix,iz)||isHidden(ix,iz+1)?0:1;pushVertex(ix,iz,color,alpha),pushVertex(ix,iz+1,color,alpha)}for(let cz=0;cz<height;cz++)for(let cx=0;cx<width;cx++){const cellKey=cx+","+cz,a1=isHidden(cx,cz)||isHidden(cx+1,cz+1)||cellDiagSlash.has(cellKey)?0:1;pushVertex(cx,cz,color2,a1),pushVertex(cx+1,cz+1,color2,a1);const a2=isHidden(cx+1,cz)||isHidden(cx,cz+1)||cellDiagBackslash.has(cellKey)?0:1;pushVertex(cx+1,cz,color2,a2),pushVertex(cx,cz+1,color2,a2)}this.geometry.setAttribute("position",new Float32BufferAttribute(positions,3)),this.geometry.setAttribute("color",new Float32BufferAttribute(colors,4))}dispose(){this.geometry.dispose(),this.material.dispose()}}var __defProp$3=Object.defineProperty,__getOwnPropDesc$3=Object.getOwnPropertyDescriptor,__publicField=(obj,key,value)=>((obj,key,value)=>key in obj?__defProp$3(obj,key,{enumerable:!0,configurable:!0,writable:!0,value:value}):obj[key]=value)(obj,"symbol"!=typeof key?key+"":key,value);const _yAxis=new Vector3(0,1,0),_targetVector=new Vector3,_segmentDir=new Vector3,_segmentQuat=new Quaternion,_segmentScale=new Vector3,_segmentPosition=new Vector3;let ThreeScene=class extends ThreeApplet{camera=new PerspectiveCamera(25,1,.1,1e3);cameraRig=new Group;cameraTarget=new Object3D;grid=new Grid;pads;terminals;lines;_drag=new Vector3;static instanceColor(terminalColor){return new Color(TERMINAL_COLORS[terminalColor]??TERMINAL_COLORS.white)}constructor(args){super(args),this.scene.add(this.cameraRig),this.cameraRig.add(this.camera),this.cameraRig.add(this.cameraTarget),this.scene.add(this.grid),this.pads=new InstancedMesh(ThreeScene.padGeometry,ThreeScene.padMaterial,0),this.terminals=new InstancedMesh(ThreeScene.terminalGeometry,ThreeScene.terminalMaterial,0),this.lines=new InstancedMesh(ThreeScene.lineGeometry,ThreeScene.lineMaterial,0);const ambientLight=new AmbientLight(13421772,1.5);this.scene.add(ambientLight);const pointLight=new PointLight(16777215,2.5,0,0);pointLight.position.set(0,0,500),this.scene.add(pointLight)}updateDrag(screen,screenStart){this._drag.set(screen.x-screenStart.x,screen.y-screenStart.y,0)}initGrid(width,height){this.camera.aspect=width/height;const halfFovRad=this.camera.fov*Math.PI/360,gridDistance=height/(2*Math.tan(halfFovRad));this.cameraRig.position.set(width/2,height/2,0),this.camera.position.set(0,0,gridDistance)}updateGrid(width,height,lines,pads,terminals){this.grid.update(width,height,lines,pads,terminals)}updatePads(pads){if(this.pads.parent&&(this.scene.remove(this.pads),0===pads.length))return;this.pads=new InstancedMesh(ThreeScene.padGeometry,ThreeScene.padMaterial,pads.length);const matrix=new Matrix4,padColor=new Color;for(let i=0;i<pads.length;i++)matrix.makeTranslation(pads[i].pos[0],pads[i].pos[1],0),this.pads.setMatrixAt(i,matrix),padColor.copy(ThreeScene.instanceColor(pads[i].color)),this.pads.setColorAt(i,padColor);this.pads.instanceMatrix.needsUpdate=!0,this.pads.instanceColor&&(this.pads.instanceColor.needsUpdate=!0),this.scene.add(this.pads)}updateTerminals(terminals){this.terminals.parent&&this.scene.remove(this.terminals),this.terminals=new InstancedMesh(ThreeScene.terminalGeometry,ThreeScene.terminalMaterial,terminals.length);const matrix=new Matrix4,terminalColor=new Color;for(let i=0;i<terminals.length;i++)matrix.makeTranslation(terminals[i].pos[0],terminals[i].pos[1],0),this.terminals.setMatrixAt(i,matrix),terminalColor.copy(ThreeScene.instanceColor(terminals[i].color)),this.terminals.setColorAt(i,terminalColor);this.terminals.instanceMatrix.needsUpdate=!0,this.terminals.instanceColor&&(this.terminals.instanceColor.needsUpdate=!0),this.scene.add(this.terminals)}updateLines(lines){this.lines.parent&&this.scene.remove(this.lines);const segmentCount=lines.reduce((n,line)=>n+Math.max(0,line.pos.length-1),0);this.lines=new InstancedMesh(ThreeScene.lineGeometry,ThreeScene.lineMaterial,segmentCount);const matrix=new Matrix4,lineColor=new Color;let idx=0;for(const line of lines){lineColor.copy(ThreeScene.instanceColor(line.color)),-1===line.layer&&lineColor.multiplyScalar(.25);const pos=line.pos,isBehind=-1===line.layer,widthScale=isBehind?1.5:1,segmentZ=isBehind?-.25:0;for(let j=0;j<pos.length-1;j++){const ax=pos[j][0],ay=pos[j][1],bx=pos[j+1][0],by=pos[j+1][1];_segmentPosition.set((ax+bx)/2,(ay+by)/2,segmentZ);const dx=bx-ax,dy=by-ay,segmentLength=Math.sqrt(dx*dx+dy*dy)||1,effectiveLength=segmentLength>1.01?segmentLength-.07:segmentLength;_segmentDir.set(dx/segmentLength,dy/segmentLength,0),_segmentQuat.setFromUnitVectors(_yAxis,_segmentDir),_segmentScale.set(widthScale,effectiveLength/1,widthScale),matrix.compose(_segmentPosition,_segmentQuat,_segmentScale),this.lines.setMatrixAt(idx,matrix),this.lines.setColorAt(idx,lineColor),idx++}}this.lines.instanceMatrix.needsUpdate=!0,this.lines.instanceColor&&(this.lines.instanceColor.needsUpdate=!0),this.scene.add(this.lines)}onAnimate(delta,time){this.camera.position.x=(9*this.camera.position.x+.25*this._drag.x*this.grid.width)/10,this.camera.position.y=(9*this.camera.position.y+.25*this._drag.y*this.grid.height)/10,this.cameraTarget.position.x=(9*this.cameraTarget.position.x+.02*this._drag.x*this.grid.width)/10,this.cameraTarget.position.y=(9*this.cameraTarget.position.y+.02*this._drag.y*this.grid.height)/10,this.camera.lookAt(_targetVector.setFromMatrixPosition(this.cameraTarget.matrixWorld))}};__publicField(ThreeScene,"padGeometry",new SphereGeometry(.25,16,12)),__publicField(ThreeScene,"padMaterial",new MeshPhongMaterial({vertexColors:!0})),__publicField(ThreeScene,"terminalGeometry",new BoxGeometry(.5,.5,.3)),__publicField(ThreeScene,"terminalMaterial",new MeshPhongMaterial({vertexColors:!0})),__publicField(ThreeScene,"lineGeometry",new CapsuleGeometry(.12,1,4,8)),__publicField(ThreeScene,"lineMaterial",new MeshPhongMaterial({vertexColors:!0})),ThreeScene=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$3(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],ThreeScene);var __getOwnPropDesc$2=Object.getOwnPropertyDescriptor;let PointerTool=class extends ToolBase{on3DPointerDown(pointers){this.dispatch("3dpointer-down",pointers,!0)}on3DPointerMove(pointers){this.dispatch("3dpointer-move",pointers,!0)}on3DPointerUp(pointers){this.dispatch("3dpointer-up",pointers,!0)}on3DPointerCancel(pointers){this.dispatch("3dpointer-cancel",pointers,!0)}};PointerTool=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$2(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],PointerTool);var __defProp$2=Object.defineProperty,__getOwnPropDesc$1=Object.getOwnPropertyDescriptor,__decorateClass$2=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$1(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$2(target,key,result),result};let _posRaw=new Vector2;const _posHitOld=new Vector2,_posHit=new Vector2;function pointerToGrid(pointer){const ray=pointer.ray,t=-ray.origin.z/ray.direction.z;return(new Vector2).copy(ray.origin).addScaledVector(ray.direction,t)}let CircuitsBoard=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex: 1 1 auto;\n        flex-direction: column;\n        max-width: 100%;\n        max-height: 100%;\n      }\n    "}static get Listeners(){return{"3dpointer-down":"on3DPointerDown","3dpointer-move":"on3DPointerMove","3dpointer-up":"on3DPointerUp","game-init-scene":"onGameInit","game-update":"onGameUpdate","line-end-drag":"onEndDrag"}}_currentID=0;_dragging=!1;constructor(args){super(args)}onGameInit(){this.onGameUpdate(),this.applet.initGrid(this.game.width,this.game.height)}onGameUpdate(){this.applet.updateGrid(this.game.width,this.game.height,this.game.lines,this.game.pads,this.game.terminals),this.applet.updatePads(this.game.pads),this.applet.updateTerminals(this.game.terminals),this.applet.updateLines(this.game.lines),this.applet.dispatch("three-applet-needs-render",void 0,!0)}ready(){this.onGameUpdate(),this.applet.initGrid(this.game.width,this.game.height),this.render([ioThreeViewport({applet:this.applet,tool:new PointerTool({}),cameraSelect:"scene",overscan:1.2})])}on3DPointerDown(event){1===event.detail.length&&(this._dragging=!0,_posRaw=pointerToGrid(event.detail[0]),_posHit.copy(_posRaw).round(),_posHitOld.copy(_posHit),this.applet.updateDrag(event.detail[0].screen,event.detail[0].screenStart),this._currentID=Math.floor(1e5*Math.random()),"pad"===this.game.drawMode&&this.game.plotter.addPad(this._currentID,_posHit.x,_posHit.y),"terminal"===this.game.drawMode&&this.game.plotter.addTerminal(this._currentID,_posHit.x,_posHit.y,this.game.drawColor),"line"===this.game.drawMode&&this.game.plotter.addLineSegment(this._currentID,_posHit.x,_posHit.y,this.game.drawLayer),"delete"===this.game.drawMode&&this.game.plotter.delete(_posHit.x,_posHit.y))}on3DPointerMove(event){1===event.detail.length&&this._dragging&&(this.applet.updateDrag(event.detail[0].screen,event.detail[0].screenStart),_posRaw=pointerToGrid(event.detail[0]),_posHit.copy(_posRaw).round(),_posRaw.distanceTo(_posHitOld)<.95||(_posHitOld.copy(_posHit),"line"===this.game.drawMode&&_posRaw.distanceTo(_posHitOld)>0&&this.game.plotter.addLineSegment(this._currentID,_posHit.x,_posHit.y,this.game.drawLayer)))}on3DPointerUp(event){event.preventDefault(),this.onEndDrag(),this.applet.updateDrag(new Vector2(0,0),new Vector2(0,0))}onEndDrag(){this._dragging=!1,this.game&&this.game.finalizeMove(this._currentID),this.applet.updateGrid(this.game.width,this.game.height,this.game.lines,this.game.pads,this.game.terminals)}dispose(){this.applet.dispose(),super.dispose()}};__decorateClass$2([ReactiveProperty({type:ThreeScene,init:{isPlaying:!0}})],CircuitsBoard.prototype,"applet",2),__decorateClass$2([ReactiveProperty({type:Game})],CircuitsBoard.prototype,"game",2),CircuitsBoard=__decorateClass$2([Register],CircuitsBoard);const circuitsBoard=function(arg0){return CircuitsBoard.vConstructor(arg0)};var __defProp$1=Object.defineProperty,__decorateClass$1=(decorators,target,key,kind)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);return result&&__defProp$1(target,key,result),result};class CircuitsGame extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n        height: 100%;\n      }\n      :host > .game-toolbar {\n        display: flex;\n        gap: 2px;\n        padding: 2px;\n        flex-shrink: 0;\n      }\n      :host > .game-toolbar > io-button {\n        flex: 1 1 auto;\n        height: calc(var(--io_fieldHeight) * 1.5);\n        display: flex;\n        align-items: center;\n      }\n      :host > .game-toolbar > io-button > io-icon {\n        margin-left: auto;\n      }\n      :host > .game-toolbar > io-button > span {\n        margin-right: auto;\n      }\n    "}constructor(args){super(args)}ready(){this.changed()}changed(){this.render([circuitsBoard({id:"board",game:this.game}),div$1({class:"game-toolbar"},[ioButton({label:"Undo",icon:"io:undo",action:this.onUndo}),ioButton({label:"Reset",icon:"io:reload",action:this.onReset}),ioButton({label:"Redo",icon:"io:redo",action:this.onRedo})])])}levelChanged(){this.game.currentLevel=this.level}onUndo(){this.game.undo()}onRedo(){this.game.redo()}onReset(){this.game.reload()}onEdit(){this.changed()}}__decorateClass$1([ReactiveProperty({value:"",type:String})],CircuitsGame.prototype,"level"),__decorateClass$1([ReactiveProperty({type:Game,init:null})],CircuitsGame.prototype,"game"),Register(CircuitsGame);const circuitsGame=function(arg0){return CircuitsGame.vConstructor(arg0)};var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__decorateClass=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp(target,key,result),result};let CircuitsLevels=class extends IoElement{static get Style(){return"\n      :host > .app-title {\n        margin-left: 1rem;\n        font-size: 2rem;\n        font-weight: bold;\n        letter-spacing: 2px;\n        text-transform: uppercase;\n      }\n    "}_option=new MenuOption({id:"levels",options:[]});_levelIds=[];async ready(){await this._loadLevels(),this.changed()}_buildLevelOptions(levelIds,completedIds){return levelIds.map(id=>new MenuOption({id:id,label:id,disabled:completedIds.includes(id),action:()=>this.dispatch("level-select",{level:id},!0)}))}async _loadLevels(){const response=await fetch("./public/levels/index.json");this._levelIds=await response.json();const completed=this.completedLevels??[];this._option=new MenuOption({id:"levels",options:this._buildLevelOptions(this._levelIds,completed)})}refreshCompleted(completedIds){this.completedLevels=completedIds,this._option=new MenuOption({id:"levels",options:this._buildLevelOptions(this._levelIds,completedIds)}),this.changed()}changed(){this.render([ioMenuTree({option:this._option})])}};__decorateClass([ReactiveProperty({type:Array,value:[]})],CircuitsLevels.prototype,"completedLevels",2),CircuitsLevels=__decorateClass([Register],CircuitsLevels);const circuitsLevels=CircuitsLevels.vConstructor;export{CircuitsBoard,CircuitsGame,CircuitsLevels,Game,Line$1 as Line,Pad,Plotter,TERMINAL_COLORS,Terminal,circuitsBoard,circuitsGame,circuitsLevels};
//# sourceMappingURL=index.js.map
