import{ReactiveProperty,IoElement,Register,ReactiveNode,Property,Storage,canvas,div}from"@io-gui/core";import{ioSplit,Split}from"@io-gui/layout";import{MenuOption,ioMenuTree}from"@io-gui/menus";import{ioButton}from"@io-gui/inputs";var __defProp$4=Object.defineProperty,__getOwnPropDesc$4=Object.getOwnPropertyDescriptor,__decorateClass$6=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$4(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$4(target,key,result),result};let CircuitsLevels=class extends IoElement{static get Style(){return"\n      :host > .app-title {\n        margin-left: 1rem;\n        font-size: 2rem;\n        font-weight: bold;\n        letter-spacing: 2px;\n        text-transform: uppercase;\n      }\n    "}_option=new MenuOption({id:"levels",options:[]});_levelIds=[];async ready(){await this._loadLevels(),this.changed()}_buildLevelOptions(levelIds,completedIds){return levelIds.map(id=>new MenuOption({id:id,label:id,disabled:completedIds.includes(id),action:()=>this.dispatch("level-select",{level:id},!0)}))}async _loadLevels(){const response=await fetch("./public/levels/index.json");this._levelIds=await response.json();const completed=this.completedLevels??[];this._option=new MenuOption({id:"levels",options:this._buildLevelOptions(this._levelIds,completed)})}refreshCompleted(completedIds){this.completedLevels=completedIds,this._option=new MenuOption({id:"levels",options:this._buildLevelOptions(this._levelIds,completedIds)}),this.changed()}changed(){this.render([ioMenuTree({option:this._option})])}};__decorateClass$6([ReactiveProperty({type:Array,value:[]})],CircuitsLevels.prototype,"completedLevels",2),CircuitsLevels=__decorateClass$6([Register],CircuitsLevels);const circuitsLevels=CircuitsLevels.vConstructor;class Pad{id;pos;_color="white";get color(){return this._color}set color(color){this._color=color}constructor(id,pos){this.id=id,this.pos=pos}toJSON(){return{pos:this.pos,id:this.id}}static fromJSON(data){return new Pad(data.id,data.pos)}}const TERMINAL_COLORS={white:"#ffffff",red:"#e52800",green:"#005923",blue:"#06afff",pink:"#ef47cc",yellow:"#fec41a",orange:"#ff6910",purple:"#760281",brown:"#820419",grey:"#555555",black:"#222222"};class Terminal{id;pos;color;constructor(id,pos,color){this.id=id,this.pos=pos,this.color=color}toJSON(){return{id:this.id,pos:this.pos,color:this.color}}static fromJSON(data){return new Terminal(data.id,data.pos,data.color)}}class Line{id;pos;layer;_color="white";get color(){return this._color}set color(color){this._color=color}constructor(id,pos,layer){this.id=id,this.pos=[pos],this.layer=layer}hasDiagonalSegmentAt(mx,my){const pos=this.pos;for(let i=1;i<pos.length;i++){const ax=pos[i-1][0],ay=pos[i-1][1],bx=pos[i][0],by=pos[i][1];if(1===Math.abs(bx-ax)&&1===Math.abs(by-ay)&&(ax+bx)/2===mx&&(ay+by)/2===my)return!0}return!1}plotSegment(x,y){return!!this._tryEraseLastSegment(x,y)||!!this._tryAddNewSegment(x,y)}toJSON(){return{id:this.id,pos:this.pos,layer:this.layer}}static fromJSON(data){const line=new Line(data.id,data.pos[0],data.layer);for(let j=1;j<data.pos.length;j++)line.plotSegment(data.pos[j][0],data.pos[j][1]);return line}_tryAddNewSegment(x,y){const ln=this.pos.length;if(ln>1){if(y===this.pos[ln-2][1]&&1===Math.abs(x-this.pos[ln-2][0]))return this.pos.pop(),this.pos.push([x,y]),!1;if(x===this.pos[ln-2][0]&&1===Math.abs(y-this.pos[ln-2][1]))return this.pos.pop(),this.pos.push([x,y]),!1}const last=this.pos[ln-1];return Math.abs(last[0]-x)>1||(Math.abs(last[1]-y)>1||(this.pos.push([x,y]),!1))}_tryEraseLastSegment(x,y){const ln=this.pos.length;return!(ln<2)&&(x===this.pos[ln-2][0]&&y===this.pos[ln-2][1]&&(this.pos.pop(),!0))}}var __getOwnPropDesc$3=Object.getOwnPropertyDescriptor;let Plotter=class extends ReactiveNode{pads=[];terminals=[];lines=[];connect(pads,terminals,lines){this.pads=pads,this.terminals=terminals,this.lines=lines}getPointAt(x,y){for(const pad of this.pads)if(pad.pos[0]===x&&pad.pos[1]===y)return pad;for(const term of this.terminals)if(term.pos[0]===x&&term.pos[1]===y)return term}getLinesAtPoint(x,y,filter){const lines=[];for(const line of this.lines)line.pos.some(([px,py])=>px===x&&py===y)&&(filter?.(line)??1)&&lines.push(line);return lines}getLineById(id){return this.lines.find(l=>l.id===id)}checkDiagonalCrossing(line,x,y){const last=line.pos[line.pos.length-1],mx=(x+last[0])/2,my=(y+last[1])/2;for(const other of this.lines)if(other.layer===line.layer&&other.hasDiagonalSegmentAt(mx,my))return!1;return!0}addPad(id,x,y){return!this.getPointAt(x,y)&&(this.pads.push(new Pad(id,[x,y])),this.dispatch("game-render",void 0,!0),!0)}addTerminal(id,x,y,color){return!this.getPointAt(x,y)&&(this.terminals.push(new Terminal(id,[x,y],color)),this.dispatch("game-render",void 0,!0),!0)}delete(x,y){const padIdx=this.pads.findIndex(p=>p.pos[0]===x&&p.pos[1]===y);-1!==padIdx&&this.pads.splice(padIdx,1);const termIdx=this.terminals.findIndex(t=>t.pos[0]===x&&t.pos[1]===y);-1!==termIdx&&this.terminals.splice(termIdx,1);const lineIdx=this.lines.findIndex(l=>l.pos.some(([px,py])=>px===x&&py===y));-1!==lineIdx&&this.lines.splice(lineIdx,1),this.dispatch("game-render",void 0,!0)}verifyLineLegality(id){const line=this.getLineById(id);if(line){const first=line.pos[0],last=line.pos[line.pos.length-1],p1=this.getPointAt(first[0],first[1]),p2=this.getPointAt(last[0],last[1]);if(!p1||!p2||first[0]===last[0]&&first[1]===last[1]){const idx=this.lines.findIndex(l=>l.id===id);return-1!==idx&&this.lines.splice(idx,1),!1}return!0}return!1}addLineSegment(id,x,y,layer){const point=this.getPointAt(x,y),linesAtPoint=this.getLinesAtPoint(x,y,line2=>0===line2.layer),underlineLinesAtPoint=this.getLinesAtPoint(x,y,line2=>-1===line2.layer),connectionLimit=point?point instanceof Terminal?1:2:0;let added=!1,endDrag=!1;if(point&&linesAtPoint.length+underlineLinesAtPoint.length>=connectionLimit)return{added:added,endDrag:endDrag};const line=this.getLineById(id);if(line){if(!this.checkDiagonalCrossing(line,x,y))return{added:added,endDrag:endDrag};const sameLineAtPoint=this.getLinesAtPoint(x,y,line2=>line2.id===id&&0===line2.layer)?.[0]||null;if(point||linesAtPoint.length&&!sameLineAtPoint&&-1!==layer||(added=line.plotSegment(x,y)),point){if("white"!==point.color&&point.color!==line.color)return{added:!1,endDrag:!1};added=line.plotSegment(x,y),endDrag=added}}else{if(!point)return{added:!1,endDrag:!1};const newLine=new Line(id,[x,y],layer);newLine.color=point.color,this.lines.push(newLine),added=!0}return this.dispatch("game-render",void 0,!0),{added:added,endDrag:endDrag}}};Plotter=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$3(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],Plotter);var __defProp$3=Object.defineProperty,__getOwnPropDesc$2=Object.getOwnPropertyDescriptor,__decorateClass$4=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$2(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$3(target,key,result),result};let Game=class extends ReactiveNode{width=4;height=5;pads=[];terminals=[];lines=[];drawMode="line";drawColor="white";drawLayer=0;undoStack=[];redoStack=[];clear(){this.width=4,this.height=5,this.pads=[],this.terminals=[],this.lines=[],this.plotter.connect(this.pads,this.terminals,this.lines),this.drawMode="line",this.drawColor="white",this.drawLayer=0,this.redoStack=[],this.undoStack=[]}async initialize(){this.clear(),this.storedState=Storage({key:`${this.currentLevel}-level-state`,value:{},storage:"local"}),this.currentLevel&&(0===Object.keys(this.storedState.value).length?await this.load(this.currentLevel):(this.clear(),this.fromJSON(JSON.stringify(this.storedState.value)),this.propagateColors())),this.undoStack=[this.toJSON()],this.redoStack=[],this.dispatch("game-render",void 0,!0)}currentLevelChanged(){this.initialize().then(()=>{this.dispatch("game-init-scene",void 0,!0)})}reload(){this.storedState.value={},this.initialize()}async load(level){try{const resp=await fetch("./public/levels/"+level+".json");resp.ok||console.error("Level not found");const text=await resp.text();this.clear(),this.fromJSON(text),this.propagateColors(),this.save()}catch(e){console.warn("Could not load level:",level,e)}}save(){this.storedState.value={width:this.width,height:this.height,pads:this.pads.map(p=>p.toJSON()),terminals:this.terminals.map(t=>t.toJSON()),lines:this.lines.map(l=>l.toJSON())}}fromJSON(jsonText){const state=JSON.parse(jsonText);this.width=state.width,this.height=state.height,this.pads=state.pads.map(p=>Pad.fromJSON(p)),this.terminals=state.terminals.map(t=>Terminal.fromJSON(t)),this.lines=state.lines.map(l=>Line.fromJSON(l)),this.plotter.connect(this.pads,this.terminals,this.lines)}toJSON(){return JSON.stringify({width:this.width,height:this.height,pads:this.pads.map(p=>p.toJSON()),terminals:this.terminals.map(t=>t.toJSON()),lines:this.lines.map(l=>l.toJSON())})}updateUndoStack(){const state=this.toJSON();state!==this.undoStack[this.undoStack.length-1]&&this.undoStack.push(state)}undo(){if(this.undoStack.length>=2){const currentState=this.undoStack.pop();this.fromJSON(this.undoStack[this.undoStack.length-1]),this.redoStack.push(currentState),this.propagateColors(),this.save(),this.dispatch("game-render",void 0,!0)}}redo(){if(this.redoStack.length>0){const state=this.redoStack.pop();this.fromJSON(state),this.undoStack.push(state),this.propagateColors(),this.save(),this.dispatch("game-render",void 0,!0)}}resetColors(){for(const line of this.lines)line._color="white";for(const pad of this.pads)pad._color="white"}propagateColors(){this.resetColors();for(let iter=0;iter<16;iter++)for(const line of this.lines){const first=line.pos[0],last=line.pos[line.pos.length-1],p1=this.plotter.getPointAt(first[0],first[1]),p2=this.plotter.getPointAt(last[0],last[1]);if(!p1||!p2)continue;const c1=p1.color,c2=p2.color;"white"!==c1&&"white"!==c2?c1===c2&&(line._color=c1):"white"===c1&&"white"===c2?line._color="white":"white"!==c1?(line._color=c1,p2 instanceof Pad&&(p2.color=c1)):"white"!==c2&&(line._color=c2,p1 instanceof Pad&&(p1.color=c2))}this.dispatch("game-render",void 0,!0);let completed=!0;for(const term of this.terminals){1!==this.plotter.getLinesAtPoint(term.pos[0],term.pos[1]).length&&(completed=!1)}for(const pad of this.pads){2!==this.plotter.getLinesAtPoint(pad.pos[0],pad.pos[1]).length&&"white"!==pad._color&&(completed=!1)}this.dispatch("game-complete",{level:this.currentLevel,completed:completed},!0)}finalizeMove(lineID){this.plotter.verifyLineLegality(lineID)&&(this.updateUndoStack(),this.propagateColors(),this.save()),this.dispatch("game-render",void 0,!0)}};__decorateClass$4([ReactiveProperty({value:"",type:String})],Game.prototype,"currentLevel",2),__decorateClass$4([ReactiveProperty({type:Plotter,init:null})],Game.prototype,"plotter",2),__decorateClass$4([Property(Storage({key:"null-level-state",value:{},storage:"local"}))],Game.prototype,"storedState",2),Game=__decorateClass$4([Register],Game);var __defProp$2=Object.defineProperty,__decorateClass$3=(decorators,target,key,kind)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);return result&&__defProp$2(target,key,result),result};class Scene{layers={};canvasWidth=0;canvasHeight=0;gridWidth=0;gridHeight=0;gridUnit=0;gridOffsetX=0;gridOffsetY=0;markerRadius=0;init(canvases){this.layers={};for(const name in canvases){const canvas2=canvases[name],ctx=canvas2.getContext("2d");this.layers[name]={canvas:canvas2,ctx:ctx}}}initGrid(gameWidth,gameHeight,containerWidth,containerHeight){this.canvasWidth=containerWidth,this.canvasHeight=containerHeight;const dpr=window.devicePixelRatio||1;for(const name in this.layers){const{canvas:canvas2}=this.layers[name];canvas2.width=this.canvasWidth*dpr,canvas2.height=this.canvasHeight*dpr,canvas2.style.width=this.canvasWidth+"px",canvas2.style.height=this.canvasHeight+"px",this.layers[name].ctx.setTransform(dpr,0,0,dpr,0,0)}this.gridWidth=gameWidth,this.gridHeight=gameHeight,this.canvasHeight/this.gridHeight>this.canvasWidth/this.gridWidth?this.gridUnit=this.canvasWidth/(this.gridWidth+1):this.gridUnit=this.canvasHeight/(this.gridHeight+1),this.gridOffsetX=(this.canvasWidth-this.gridUnit*this.gridWidth)/2,this.gridOffsetY=(this.canvasHeight-this.gridUnit*this.gridHeight)/2;const ctx=this.layers.grid.ctx;ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight),ctx.fillStyle="rgba(255,255,255,0.2)",ctx.fillRect(this.gridOffsetX,this.gridOffsetY,this.gridWidth*this.gridUnit,this.gridHeight*this.gridUnit),ctx.strokeStyle="rgba(255,255,255,0.5)",ctx.lineWidth=1;for(let i=0;i<=gameWidth;i++){const x=i*this.gridUnit+this.gridOffsetX;ctx.beginPath(),ctx.moveTo(x,this.gridOffsetY),ctx.lineTo(x,this.gridHeight*this.gridUnit+this.gridOffsetY),ctx.stroke()}for(let j=0;j<=gameHeight;j++){const y=j*this.gridUnit+this.gridOffsetY;ctx.beginPath(),ctx.moveTo(this.gridOffsetX,y),ctx.lineTo(this.gridWidth*this.gridUnit+this.gridOffsetX,y),ctx.stroke()}this.markerRadius=.1*this.canvasWidth}render(pads,terminals,lines){const ctx0=this.layers.layer0?.ctx,ctx1=this.layers.layer1?.ctx;if(ctx0&&ctx1){ctx0.clearRect(0,0,this.canvasWidth,this.canvasHeight),ctx1.clearRect(0,0,this.canvasWidth,this.canvasHeight);for(const line of lines)this._drawLineStroke(line);for(const pad of pads)this._drawPadStroke(pad);for(const term of terminals)this._drawTerminalStroke(term);for(const line of lines)this._drawLineFill(line,line._color);for(const pad of pads)this._drawPadFill(pad,pad._color);for(const term of terminals)this._drawTerminalFill(term,term.color)}}static _layerToCanvas={[-1]:"layer0",0:"layer1"};_lineParams(line){const isBottom=-1===line.layer,layerName=Scene._layerToCanvas[line.layer]??"layer1",ctx=this.layers[layerName]?.ctx??this.layers.layer1.ctx;let radius=this.gridUnit/4,strokeW=3,strokeColor="rgba(0,0,0,1)",opacity=1;return isBottom&&(radius*=1.4,strokeW*=4,strokeColor="rgba(128,128,128,0.25)",opacity=.25),{ctx:ctx,radius:radius,strokeW:strokeW,strokeColor:strokeColor,opacity:opacity}}_buildLinePath(ctx,positions){ctx.beginPath();for(let i=0;i<positions.length;i++){const x=positions[i][0]*this.gridUnit+this.gridOffsetX,y=positions[i][1]*this.gridUnit+this.gridOffsetY;0===i?ctx.moveTo(x,y):ctx.lineTo(x,y)}}_drawLineStroke(line){if(line.pos.length<2)return;const p=this._lineParams(line);p.ctx.save(),p.ctx.globalAlpha=p.opacity,p.ctx.lineCap="round",p.ctx.lineJoin="round",this._buildLinePath(p.ctx,line.pos),p.ctx.strokeStyle=p.strokeColor,p.ctx.lineWidth=p.radius+2*p.strokeW,p.ctx.stroke(),p.ctx.restore()}_drawLineFill(line,color){if(line.pos.length<2)return;const p=this._lineParams(line);p.ctx.save(),p.ctx.globalAlpha=p.opacity,p.ctx.lineCap="round",p.ctx.lineJoin="round",this._buildLinePath(p.ctx,line.pos),p.ctx.strokeStyle=TERMINAL_COLORS[color]??"#fff",p.ctx.lineWidth=p.radius,p.ctx.stroke(),p.ctx.restore()}_drawPadStroke(pad){const ctx=this.layers.layer1.ctx,xx=pad.pos[0]*this.gridUnit+this.gridOffsetX,yy=pad.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.beginPath(),ctx.arc(xx,yy,r+3,0,2*Math.PI),ctx.fillStyle="rgba(0,0,0,1)",ctx.fill()}_drawPadFill(pad,color){const ctx=this.layers.layer1.ctx,xx=pad.pos[0]*this.gridUnit+this.gridOffsetX,yy=pad.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.beginPath(),ctx.arc(xx,yy,r,0,2*Math.PI),ctx.fillStyle=TERMINAL_COLORS[color]??"#fff",ctx.fill()}_drawTerminalStroke(terminal){const ctx=this.layers.layer1.ctx,xx=terminal.pos[0]*this.gridUnit+this.gridOffsetX,yy=terminal.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.fillStyle="rgba(0,0,0,1)",ctx.fillRect(xx-r-3,yy-r-3,2*(r+3),2*(r+3))}_drawTerminalFill(terminal,color){const ctx=this.layers.layer1.ctx,xx=terminal.pos[0]*this.gridUnit+this.gridOffsetX,yy=terminal.pos[1]*this.gridUnit+this.gridOffsetY,r=this.gridUnit/3;ctx.fillStyle=TERMINAL_COLORS[color]??"#fff",ctx.fillRect(xx-r,yy-r,2*r,2*r)}drawMarker(touchX,touchY){const ctx=this.layers.top?.ctx;if(!ctx)return;ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight);const xx=touchX*this.gridUnit+this.gridOffsetX,yy=touchY*this.gridUnit+this.gridOffsetY;ctx.beginPath(),ctx.arc(xx,yy,this.markerRadius,0,2*Math.PI),ctx.fillStyle="rgba(255,255,255,0.05)",ctx.fill()}hideMarker(){const ctx=this.layers.top?.ctx;ctx&&ctx.clearRect(0,0,this.canvasWidth,this.canvasHeight)}}class CircuitsBoard extends IoElement{static get Style(){return"\n      :host {\n        flex: 1;\n        position: relative;\n        background: rgba(0, 0, 0, 0.8);\n        border: 1px solid #99f;\n        border-radius: 12px;\n        margin: 2px;\n        overflow: hidden;\n        touch-action: none;\n      }\n      :host > canvas {\n        position: absolute;\n        top: 0;\n        left: 0;\n      }\n    "}static get Listeners(){return{pointerdown:"onPointerdown","game-init-scene":"onGameInitScene","game-render":"onGameRender"}}_touchX=0;_touchY=0;_gridX=0;_gridY=0;_gridXOld=0;_gridYOld=0;_drag=!1;_randomID=0;constructor(args={}){super(args)}ready(){this.changed()}changed(){this.render([canvas({id:"grid",style:{zIndex:"100"}}),canvas({id:"layer0",style:{zIndex:"101"}}),canvas({id:"layer1",style:{zIndex:"102"}}),canvas({id:"top",style:{zIndex:"105"}})]),this._initScene()}onResized(){this._initScene()}_initScene(){const grid=this.querySelector("#grid"),layer0=this.querySelector("#layer0"),layer1=this.querySelector("#layer1"),top=this.querySelector("#top");if(!(grid&&layer0&&layer1&&top))return;this.scene.init({grid:grid,layer0:layer0,layer1:layer1,top:top});const rect=this.getBoundingClientRect();0!==rect.width&&0!==rect.height&&this.game&&(this.scene.initGrid(this.game.width,this.game.height,rect.width,rect.height),this.scene.render(this.game.pads,this.game.terminals,this.game.lines))}gameChanged(){this._initScene()}onGameInitScene(){const rect=this.getBoundingClientRect();0!==rect.width&&0!==rect.height&&(this.scene.initGrid(this.game.width,this.game.height,rect.width,rect.height),this.scene.render(this.game.pads,this.game.terminals,this.game.lines))}onGameRender(){this.scene.render(this.game.pads,this.game.terminals,this.game.lines)}onPointerdown(event){event.preventDefault(),this.setPointerCapture(event.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),this._randomID=Math.floor(1e5*Math.random()),this._drag=!0,this._initPosition(event),this.scene.drawMarker(this._touchX,this._touchY),this.game&&("pad"===this.game.drawMode&&this.game.plotter.addPad(this._randomID,this._gridX,this._gridY),"terminal"===this.game.drawMode&&this.game.plotter.addTerminal(this._randomID,this._gridX,this._gridY,this.game.drawColor),"line"===this.game.drawMode&&this.game.plotter.addLineSegment(this._randomID,this._gridX,this._gridY,this.game.drawLayer),"delete"===this.game.drawMode&&this.game.plotter.delete(this._gridX,this._gridY))}onPointermove(event){if(event.preventDefault(),this._updatePosition(event),this.scene.drawMarker(this._gridX,this._gridY),this.game&&"line"===this.game.drawMode&&this._drag&&(this._gridX!==this._gridXOld||this._gridY!==this._gridYOld)){const{endDrag:endDrag}=this.game.plotter.addLineSegment(this._randomID,this._gridX,this._gridY,this.game.drawLayer);endDrag&&(this._drag=!1)}}onPointerup(event){event.preventDefault(),this.releasePointerCapture(event.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this._drag=!1,this.scene.hideMarker(),this.game&&this.game.finalizeMove(this._randomID)}_initPosition(event){const rect=this.getBoundingClientRect();this._touchX=(event.clientX-rect.left-this.scene.gridOffsetX)/this.scene.gridUnit,this._touchY=(event.clientY-rect.top-this.scene.gridOffsetY)/this.scene.gridUnit,this._gridX=Math.round(this._touchX),this._gridY=Math.round(this._touchY),this._gridXOld=this._gridX,this._gridYOld=this._gridY}_updatePosition(event){const rect=this.getBoundingClientRect();this._touchX=(event.clientX-rect.left-this.scene.gridOffsetX)/this.scene.gridUnit,this._touchY=(event.clientY-rect.top-this.scene.gridOffsetY)/this.scene.gridUnit;const distance=Math.sqrt(Math.pow(this._touchX-Math.round(this._touchX),2)+Math.pow(this._touchY-Math.round(this._touchY),2));this.game&&distance<.5&&this._touchX<=this.game.width+.5&&this._touchY<=this.game.height+.5&&this._touchX>=-.5&&this._touchY>=-.5&&(this._gridXOld=this._gridX,this._gridYOld=this._gridY,this._gridX=Math.round(this._touchX),this._gridY=Math.round(this._touchY),this._gridX>this._gridXOld&&(this._gridX=this._gridXOld+1),this._gridX<this._gridXOld&&(this._gridX=this._gridXOld-1),this._gridY>this._gridYOld&&(this._gridY=this._gridYOld+1),this._gridY<this._gridYOld&&(this._gridY=this._gridYOld-1))}}__decorateClass$3([ReactiveProperty({type:Game})],CircuitsBoard.prototype,"game"),__decorateClass$3([ReactiveProperty({type:Scene,init:null})],CircuitsBoard.prototype,"scene"),Register(CircuitsBoard);var __defProp$1=Object.defineProperty,__decorateClass$2=(decorators,target,key,kind)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);return result&&__defProp$1(target,key,result),result};class CircuitsGame extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n        height: 100%;\n      }\n      :host > .game-toolbar {\n        display: flex;\n        gap: 2px;\n        padding: 2px;\n        flex-shrink: 0;\n      }\n    "}static get Listeners(){return{"game-complete":"onGameComplete"}}completeFn=null;constructor(args){super(args)}ready(){this.changed()}onGameComplete(event){this.completeFn&&this.completeFn(event.detail.level,event.detail.completed)}changed(){var arg0;this.render([div({class:"game-toolbar"},[ioButton({label:"Undo",action:this.onUndo}),ioButton({label:"Edit",action:this.onEdit}),ioButton({label:"Reset",action:this.onReset}),ioButton({label:"Redo",action:this.onRedo}),ioButton({label:"Back",action:this.onBack})]),(arg0={id:"board",game:this.game},CircuitsBoard.vConstructor(arg0))])}levelChanged(){this.game.currentLevel=this.level;const board=this.querySelector("circuits-board");board&&board.gameChanged()}onUndo(){this.game.undo()}onRedo(){this.game.redo()}onReset(){this.game.reload()}onEdit(){this.changed()}onBack(){this.dispatch("back-to-levels",void 0,!0)}}__decorateClass$2([ReactiveProperty({value:"",type:String})],CircuitsGame.prototype,"level"),__decorateClass$2([ReactiveProperty({type:Game,init:null})],CircuitsGame.prototype,"game"),Register(CircuitsGame);var __getOwnPropDesc$1=Object.getOwnPropertyDescriptor;let CircuitsEditor=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n        background: rgba(0, 0, 0, 0.85);\n        align-items: center;\n        justify-content: center;\n        flex: 1 1 auto;\n        gap: 4px;\n        padding: 8px;\n      }\n      :host > io-button {\n        display: flex;\n        flex-wrap: wrap;\n        justify-content: center;\n        width: 100%;\n      }\n    "}ready(){this.changed()}changed(){this.render([ioButton({label:"Pad",action:()=>this._select("pad","white")}),...Object.keys(TERMINAL_COLORS).map(c=>ioButton({label:c,action:()=>this._select("terminal",c)})),ioButton({label:"Line (top)",action:()=>this.dispatch("editor-select",{mode:"line",layer:0},!0)}),ioButton({label:"Line (bottom)",action:()=>this.dispatch("editor-select",{mode:"line",layer:-1},!0)}),ioButton({label:"Delete",action:()=>this._select("delete","red")})])}_select(mode,color){this.dispatch("editor-select",{mode:mode,color:color},!0)}};CircuitsEditor=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$1(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],CircuitsEditor);const circuitsEditor=CircuitsEditor.vConstructor;var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__decorateClass=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp(target,key,result),result};Storage.permit();const $level=Storage({key:"level",storage:"hash",value:""}),$completed=Storage({key:"circuits-completed",storage:"local",value:"[]"});let CircuitsApp=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        position: fixed;\n        inset: 0;\n        background-color: var(--io_bgColor);\n        color: var(--io_color);\n        user-select: none;\n        -webkit-user-select: none;\n        -webkit-text-size-adjust: none;\n        -webkit-touch-callout: none;\n      }\n    "}static get Listeners(){return{"level-select":"onLevelSelect","editor-select":"onEditorSelect"}}ready(){const completedIds=this._getCompletedIds();var arg0;this.render([ioSplit({split:new Split({type:"split",children:[{type:"panel",flex:"0 0 110px",tabs:[{id:"levels"}]},{type:"panel",flex:"1 1 auto",tabs:[{id:"game"}]},{type:"panel",flex:"0 0 120px",tabs:[{id:"editor"}]}]}),elements:[circuitsLevels({id:"levels",completedLevels:completedIds}),(arg0={id:"game",level:$level,game:this.game},CircuitsGame.vConstructor(arg0)),circuitsEditor({id:"editor"})]})]);const gameEl=this.querySelector("#game");gameEl&&(gameEl.completeFn=(level,completed)=>this.onLevelComplete(level,completed))}_getCompletedIds(){try{return JSON.parse($completed.value||"[]")}catch{return[]}}_setCompletedIds(ids){$completed.value=JSON.stringify(ids)}onLevelComplete(level,completed){if(!completed)return;const ids=this._getCompletedIds();if(ids.includes(level))return;this._setCompletedIds([...ids,level]);const levelsEl=this.querySelector("#levels");levelsEl?.refreshCompleted&&levelsEl.refreshCompleted(this._getCompletedIds())}onEditorSelect(event){event.stopPropagation();const{mode:mode,color:color,layer:layer}=event.detail;this.game.drawMode=mode,"line"===mode&&void 0!==layer?this.game.drawLayer=layer:void 0!==color&&(this.game.drawColor=color),this.changed()}onLevelSelect(event){event.stopPropagation();const{level:level}=event.detail;$level.value=level}};__decorateClass([ReactiveProperty({type:Game,init:null})],CircuitsApp.prototype,"game",2),CircuitsApp=__decorateClass([Register],CircuitsApp);
//# sourceMappingURL=index.js.map
