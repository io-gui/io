import{ReactiveProperty,IoElement,Register,ReactiveNode,Property,Storage,div}from"@io-gui/core";import{ioSplit,Split}from"@io-gui/layout";import{ioButton}from"@io-gui/inputs";import{MenuOption,ioMenuTree}from"@io-gui/menus";import{Vector2}from"three";import{LineSegments,BufferGeometry,LineBasicMaterial,AdditiveBlending,Float32BufferAttribute,Color,Vector3,Quaternion,SphereGeometry,MeshPhongMaterial,BoxGeometry,CapsuleGeometry,OrthographicCamera,InstancedMesh,AmbientLight,PointLight,Matrix4}from"three/webgpu";import{ThreeApplet,ToolBase,ioThreeViewport}from"@io-gui/three";const TERMINAL_COLORS={white:"#ffffff",red:"#e52800",green:"#005923",blue:"#06afff",pink:"#ef47cc",yellow:"#fec41a",orange:"#ff6910",purple:"#760281",brown:"#820419",grey:"#555555",black:"#222222"};class Terminal{id;pos;color;constructor(id,pos,color){this.id=id,this.pos=pos,this.color=color}toJSON(){return{id:this.id,pos:this.pos,color:this.color}}static fromJSON(data){return new Terminal(data.id,data.pos,data.color)}}var __defProp$5=Object.defineProperty,__getOwnPropDesc$6=Object.getOwnPropertyDescriptor,__decorateClass$7=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$6(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$5(target,key,result),result};let CircuitsLevels=class extends IoElement{static get Style(){return"\n      :host > .app-title {\n        margin-left: 1rem;\n        font-size: 2rem;\n        font-weight: bold;\n        letter-spacing: 2px;\n        text-transform: uppercase;\n      }\n    "}_option=new MenuOption({id:"levels",options:[]});_levelIds=[];async ready(){await this._loadLevels(),this.changed()}_buildLevelOptions(levelIds,completedIds){return levelIds.map(id=>new MenuOption({id:id,label:id,disabled:completedIds.includes(id),action:()=>this.dispatch("level-select",{level:id},!0)}))}async _loadLevels(){const response=await fetch("./public/levels/index.json");this._levelIds=await response.json();const completed=this.completedLevels??[];this._option=new MenuOption({id:"levels",options:this._buildLevelOptions(this._levelIds,completed)})}refreshCompleted(completedIds){this.completedLevels=completedIds,this._option=new MenuOption({id:"levels",options:this._buildLevelOptions(this._levelIds,completedIds)}),this.changed()}changed(){this.render([ioMenuTree({option:this._option})])}};__decorateClass$7([ReactiveProperty({type:Array,value:[]})],CircuitsLevels.prototype,"completedLevels",2),CircuitsLevels=__decorateClass$7([Register],CircuitsLevels);const circuitsLevels=CircuitsLevels.vConstructor;class Pad{id;pos;_color="white";get color(){return this._color}set color(color){this._color=color}constructor(id,pos){this.id=id,this.pos=pos}toJSON(){return{pos:this.pos,id:this.id}}static fromJSON(data){return new Pad(data.id,data.pos)}}class Line{id;pos;layer;_color="white";get color(){return this._color}set color(color){this._color=color}constructor(id,pos,layer){this.id=id,this.pos=[pos],this.layer=layer}hasDiagonalSegmentAt(mx,my){const pos=this.pos;for(let i=1;i<pos.length;i++){const ax=pos[i-1][0],ay=pos[i-1][1],bx=pos[i][0],by=pos[i][1];if(1===Math.abs(bx-ax)&&1===Math.abs(by-ay)&&(ax+bx)/2===mx&&(ay+by)/2===my)return!0}return!1}plotSegment(x,y){return!!this._tryEraseLastSegment(x,y)||!!this._tryAddNewSegment(x,y)}toJSON(){return{id:this.id,pos:this.pos,layer:this.layer}}static fromJSON(data){const line=new Line(data.id,data.pos[0],data.layer);for(let j=1;j<data.pos.length;j++)line.plotSegment(data.pos[j][0],data.pos[j][1]);return line}_tryAddNewSegment(x,y){const ln=this.pos.length;if(ln>1){if(y===this.pos[ln-2][1]&&1===Math.abs(x-this.pos[ln-2][0]))return this.pos.pop(),this.pos.push([x,y]),!1;if(x===this.pos[ln-2][0]&&1===Math.abs(y-this.pos[ln-2][1]))return this.pos.pop(),this.pos.push([x,y]),!1}const last=this.pos[ln-1];return Math.abs(last[0]-x)>1||(Math.abs(last[1]-y)>1||(this.pos.push([x,y]),!1))}_tryEraseLastSegment(x,y){const ln=this.pos.length;return!(ln<2)&&(x===this.pos[ln-2][0]&&y===this.pos[ln-2][1]&&(this.pos.pop(),!0))}}var __getOwnPropDesc$5=Object.getOwnPropertyDescriptor;let Plotter=class extends ReactiveNode{width=0;height=0;pads=[];terminals=[];lines=[];connect(pads,terminals,lines,width,height){this.width=width,this.height=height,this.pads=pads,this.terminals=terminals,this.lines=lines}getPointAt(x,y){for(const pad of this.pads)if(pad.pos[0]===x&&pad.pos[1]===y)return pad;for(const term of this.terminals)if(term.pos[0]===x&&term.pos[1]===y)return term}getLinesAtPoint(x,y,filter){const lines=[];for(const line of this.lines)line.pos.some(([px,py])=>px===x&&py===y)&&(filter?.(line)??1)&&lines.push(line);return lines}getLineById(id){return this.lines.find(l=>l.id===id)}checkDiagonalCrossing(line,x,y){const last=line.pos[line.pos.length-1],mx=(x+last[0])/2,my=(y+last[1])/2;for(const other of this.lines)if(other.layer===line.layer&&other.hasDiagonalSegmentAt(mx,my))return!1;return!0}addPad(id,x,y){return!this.getPointAt(x,y)&&(this.pads.push(new Pad(id,[x,y])),this.dispatch("game-update",void 0,!0),!0)}addTerminal(id,x,y,color){return!this.getPointAt(x,y)&&(this.terminals.push(new Terminal(id,[x,y],color)),this.dispatch("game-update",void 0,!0),!0)}delete(x,y){const padIdx=this.pads.findIndex(p=>p.pos[0]===x&&p.pos[1]===y);-1!==padIdx&&this.pads.splice(padIdx,1);const termIdx=this.terminals.findIndex(t=>t.pos[0]===x&&t.pos[1]===y);-1!==termIdx&&this.terminals.splice(termIdx,1);const lineIdx=this.lines.findIndex(l=>l.pos.some(([px,py])=>px===x&&py===y));-1!==lineIdx&&this.lines.splice(lineIdx,1),this.dispatch("game-update",void 0,!0)}verifyLineLegality(id){const line=this.getLineById(id);if(line){const first=line.pos[0],last=line.pos[line.pos.length-1],p1=this.getPointAt(first[0],first[1]),p2=this.getPointAt(last[0],last[1]);if(!p1||!p2||first[0]===last[0]&&first[1]===last[1]){const idx=this.lines.findIndex(l=>l.id===id);return-1!==idx&&this.lines.splice(idx,1),!1}return!0}return!1}addLineSegment(id,x,y,layer){const point=this.getPointAt(x,y),linesAtPoint=this.getLinesAtPoint(x,y,line2=>0===line2.layer),underlineLinesAtPoint=this.getLinesAtPoint(x,y,line2=>-1===line2.layer),connectionLimit=point?point instanceof Terminal?1:2:0;let added=!1,endDrag=!1;if(point&&linesAtPoint.length+underlineLinesAtPoint.length>=connectionLimit)return{added:added,endDrag:endDrag};const line=this.getLineById(id);if(line){if(!this.checkDiagonalCrossing(line,x,y))return{added:added,endDrag:endDrag};const sameLineAtPoint=this.getLinesAtPoint(x,y,line2=>line2.id===id&&0===line2.layer)?.[0]||null;if(point||linesAtPoint.length&&!sameLineAtPoint&&-1!==layer||(added=line.plotSegment(x,y)),point){if("white"!==point.color&&"white"!==line.color&&point.color!==line.color)return{added:!1,endDrag:!1};added=line.plotSegment(x,y),endDrag=!0}}else{if(!point)return{added:!1,endDrag:!1};const newLine=new Line(id,[x,y],layer);newLine.color=point.color,this.lines.push(newLine),added=!0}return endDrag&&this.dispatch("line-end-drag",{id:id},!0),this.dispatch("game-update",void 0,!0),{added:added,endDrag:endDrag}}};Plotter=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$5(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],Plotter);var __defProp$4=Object.defineProperty,__getOwnPropDesc$4=Object.getOwnPropertyDescriptor,__decorateClass$5=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$4(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$4(target,key,result),result};let Game=class extends ReactiveNode{width=4;height=5;pads=[];terminals=[];lines=[];drawMode="line";drawColor="white";drawLayer=0;undoStack=[];redoStack=[];clear(){this.width=4,this.height=5,this.pads=[],this.terminals=[],this.lines=[],this.plotter.connect(this.pads,this.terminals,this.lines,this.width,this.height),this.drawMode="line",this.drawColor="white",this.drawLayer=0,this.redoStack=[],this.undoStack=[]}async initialize(){this.clear(),this.storedState=Storage({key:`${this.currentLevel}-level-state`,value:{},storage:"local"}),this.currentLevel&&(0===Object.keys(this.storedState.value).length?await this.load(this.currentLevel):(this.clear(),this.fromJSON(JSON.stringify(this.storedState.value)),this.propagateColors())),this.undoStack=[this.toJSON()],this.redoStack=[],this.dispatch("game-update",void 0,!0)}currentLevelChanged(){this.initialize().then(()=>{this.dispatch("game-init-scene",void 0,!0)})}reload(){this.storedState.value={},this.initialize()}async load(level){try{const resp=await fetch("./public/levels/"+level+".json");resp.ok||console.error("Level not found");const text=await resp.text();this.clear(),this.fromJSON(text),this.propagateColors(),this.save()}catch(e){console.warn("Could not load level:",level,e)}}save(){this.storedState.value={width:this.width,height:this.height,pads:this.pads.map(p=>p.toJSON()),terminals:this.terminals.map(t=>t.toJSON()),lines:this.lines.map(l=>l.toJSON())}}fromJSON(jsonText){const state=JSON.parse(jsonText);this.width=state.width,this.height=state.height,this.pads=state.pads.map(p=>Pad.fromJSON(p)),this.terminals=state.terminals.map(t=>Terminal.fromJSON(t)),this.lines=state.lines.map(l=>Line.fromJSON(l)),this.plotter.connect(this.pads,this.terminals,this.lines,this.width,this.height)}toJSON(){return JSON.stringify({width:this.width,height:this.height,pads:this.pads.map(p=>p.toJSON()),terminals:this.terminals.map(t=>t.toJSON()),lines:this.lines.map(l=>l.toJSON())})}updateUndoStack(){const state=this.toJSON();state!==this.undoStack[this.undoStack.length-1]&&this.undoStack.push(state)}undo(){if(this.undoStack.length>=2){const currentState=this.undoStack.pop();this.fromJSON(this.undoStack[this.undoStack.length-1]),this.redoStack.push(currentState),this.propagateColors(),this.save(),this.dispatch("game-update",void 0,!0)}}redo(){if(this.redoStack.length>0){const state=this.redoStack.pop();this.fromJSON(state),this.undoStack.push(state),this.propagateColors(),this.save(),this.dispatch("game-update",void 0,!0)}}resetColors(){for(const line of this.lines)line._color="white";for(const pad of this.pads)pad._color="white"}propagateColors(){this.resetColors();for(let iter=0;iter<16;iter++)for(const line of this.lines){const first=line.pos[0],last=line.pos[line.pos.length-1],p1=this.plotter.getPointAt(first[0],first[1]),p2=this.plotter.getPointAt(last[0],last[1]);if(!p1||!p2)continue;const c1=p1.color,c2=p2.color;"white"!==c1&&"white"!==c2?c1===c2&&(line._color=c1):"white"===c1&&"white"===c2?line._color="white":"white"!==c1?(line._color=c1,p2 instanceof Pad&&(p2.color=c1)):"white"!==c2&&(line._color=c2,p1 instanceof Pad&&(p1.color=c2))}this.dispatch("game-update",void 0,!0);let completed=!0;for(const term of this.terminals){1!==this.plotter.getLinesAtPoint(term.pos[0],term.pos[1]).length&&(completed=!1)}for(const pad of this.pads){2!==this.plotter.getLinesAtPoint(pad.pos[0],pad.pos[1]).length&&"white"!==pad._color&&(completed=!1)}console.log("game-complete",this.currentLevel,completed),this.dispatch("game-complete",{level:this.currentLevel,completed:completed},!0)}finalizeMove(lineID){this.plotter.verifyLineLegality(lineID)&&(this.updateUndoStack(),this.propagateColors(),this.save()),this.dispatch("game-update",void 0,!0)}};__decorateClass$5([ReactiveProperty({value:"",type:String})],Game.prototype,"currentLevel",2),__decorateClass$5([ReactiveProperty({type:Plotter,init:null})],Game.prototype,"plotter",2),__decorateClass$5([Property(Storage({key:"null-level-state",value:{},storage:"local"}))],Game.prototype,"storedState",2),Game=__decorateClass$5([Register],Game);class Grid extends LineSegments{constructor(){super(new BufferGeometry,new LineBasicMaterial({transparent:!0,vertexColors:!0,toneMapped:!1,blending:AdditiveBlending}))}update(width,height){if(0===width||0===height)return this.geometry.setAttribute("position",new Float32BufferAttribute([],3)),void this.geometry.setAttribute("color",new Float32BufferAttribute([],4));const color=new Color(6710886),color2=new Color(3355443),totalVertices=2*(width*(height+1)+height*(width+1)+width*height*4),positions=new Float32Array(3*totalVertices),colors=new Float32Array(4*totalVertices);let vi=0;const pushVertex=(x,y,c)=>{const pi=3*vi,ci=4*vi;positions[pi]=x,positions[pi+1]=y,positions[pi+2]=0,c.toArray(colors,ci),colors[ci+3]=1,vi++};for(let iz=0;iz<=height;iz++)for(let ix=0;ix<width;ix++)pushVertex(ix,iz,color),pushVertex(ix+1,iz,color);for(let ix=0;ix<=width;ix++)for(let iz=0;iz<height;iz++)pushVertex(ix,iz,color),pushVertex(ix,iz+1,color);for(let cz=0;cz<height;cz++)for(let cx=0;cx<width;cx++){const centerX=cx+.5,centerZ=cz+.5;pushVertex(centerX,centerZ,color2),pushVertex(cx,cz,color),pushVertex(centerX,centerZ,color2),pushVertex(cx+1,cz,color),pushVertex(centerX,centerZ,color2),pushVertex(cx,cz+1,color),pushVertex(centerX,centerZ,color2),pushVertex(cx+1,cz+1,color)}this.geometry.setAttribute("position",new Float32BufferAttribute(positions,3)),this.geometry.setAttribute("color",new Float32BufferAttribute(colors,4))}dispose(){this.geometry.dispose(),this.material.dispose()}}var __defProp$3=Object.defineProperty,__getOwnPropDesc$3=Object.getOwnPropertyDescriptor,__publicField=(obj,key,value)=>((obj,key,value)=>key in obj?__defProp$3(obj,key,{enumerable:!0,configurable:!0,writable:!0,value:value}):obj[key]=value)(obj,"symbol"!=typeof key?key+"":key,value);const _yAxis=new Vector3(0,1,0),_segmentDir=new Vector3,_segmentQuat=new Quaternion,_segmentScale=new Vector3,_segmentPosition=new Vector3;let ThreeScene=class extends ThreeApplet{camera;grid=new Grid;pads;terminals;lines;static instanceColor(terminalColor){return new Color(TERMINAL_COLORS[terminalColor]??TERMINAL_COLORS.white)}constructor(args){super(args),this.camera=new OrthographicCamera(-1,1,1,-1,.1,1e3),this.scene.add(this.camera),this.scene.add(this.grid),this.pads=new InstancedMesh(ThreeScene.padGeometry,ThreeScene.padMaterial,0),this.terminals=new InstancedMesh(ThreeScene.terminalGeometry,ThreeScene.terminalMaterial,0),this.lines=new InstancedMesh(ThreeScene.lineGeometry,ThreeScene.lineMaterial,0);const ambientLight=new AmbientLight(13421772,1.5);this.scene.add(ambientLight);const pointLight=new PointLight(16777215,2.5,0,0);pointLight.position.set(0,0,500),this.scene.add(pointLight)}updateGrid(width,height){this.grid.update(width,height);const size=Math.max(width,height);this.camera.left=-size/2,this.camera.right=size/2,this.camera.top=size/2,this.camera.bottom=-size/2,this.camera.position.set(width/2,height/2,10),this.camera.updateProjectionMatrix()}updatePads(pads){if(this.pads.parent&&(this.scene.remove(this.pads),0===pads.length))return;this.pads=new InstancedMesh(ThreeScene.padGeometry,ThreeScene.padMaterial,pads.length);const matrix=new Matrix4,padColor=new Color;for(let i=0;i<pads.length;i++)matrix.makeTranslation(pads[i].pos[0],pads[i].pos[1],0),this.pads.setMatrixAt(i,matrix),padColor.copy(ThreeScene.instanceColor(pads[i].color)),this.pads.setColorAt(i,padColor);this.pads.instanceMatrix.needsUpdate=!0,this.pads.instanceColor&&(this.pads.instanceColor.needsUpdate=!0),this.scene.add(this.pads)}updateTerminals(terminals){this.terminals.parent&&this.scene.remove(this.terminals),this.terminals=new InstancedMesh(ThreeScene.terminalGeometry,ThreeScene.terminalMaterial,terminals.length);const matrix=new Matrix4,terminalColor=new Color;for(let i=0;i<terminals.length;i++)matrix.makeTranslation(terminals[i].pos[0],terminals[i].pos[1],0),this.terminals.setMatrixAt(i,matrix),terminalColor.copy(ThreeScene.instanceColor(terminals[i].color)),this.terminals.setColorAt(i,terminalColor);this.terminals.instanceMatrix.needsUpdate=!0,this.terminals.instanceColor&&(this.terminals.instanceColor.needsUpdate=!0),this.scene.add(this.terminals)}updateLines(lines){this.lines.parent&&this.scene.remove(this.lines);const segmentCount=lines.reduce((n,line)=>n+Math.max(0,line.pos.length-1),0);this.lines=new InstancedMesh(ThreeScene.lineGeometry,ThreeScene.lineMaterial,segmentCount);const matrix=new Matrix4,lineColor=new Color;let idx=0;for(const line of lines){lineColor.copy(ThreeScene.instanceColor(line.color)),-1===line.layer&&lineColor.multiplyScalar(.25);const pos=line.pos,isBehind=-1===line.layer,widthScale=isBehind?1.5:1,segmentZ=isBehind?-.25:0;for(let j=0;j<pos.length-1;j++){const ax=pos[j][0],ay=pos[j][1],bx=pos[j+1][0],by=pos[j+1][1];_segmentPosition.set((ax+bx)/2,(ay+by)/2,segmentZ);const dx=bx-ax,dy=by-ay,segmentLength=Math.sqrt(dx*dx+dy*dy)||1,effectiveLength=segmentLength>1.01?segmentLength-.07:segmentLength;_segmentDir.set(dx/segmentLength,dy/segmentLength,0),_segmentQuat.setFromUnitVectors(_yAxis,_segmentDir),_segmentScale.set(widthScale,effectiveLength/1,widthScale),matrix.compose(_segmentPosition,_segmentQuat,_segmentScale),this.lines.setMatrixAt(idx,matrix),this.lines.setColorAt(idx,lineColor),idx++}}this.lines.instanceMatrix.needsUpdate=!0,this.lines.instanceColor&&(this.lines.instanceColor.needsUpdate=!0),this.scene.add(this.lines)}};__publicField(ThreeScene,"padGeometry",new SphereGeometry(.25,16,12)),__publicField(ThreeScene,"padMaterial",new MeshPhongMaterial({vertexColors:!0})),__publicField(ThreeScene,"terminalGeometry",new BoxGeometry(.5,.5,.3)),__publicField(ThreeScene,"terminalMaterial",new MeshPhongMaterial({vertexColors:!0})),__publicField(ThreeScene,"lineGeometry",new CapsuleGeometry(.12,1,4,8)),__publicField(ThreeScene,"lineMaterial",new MeshPhongMaterial({vertexColors:!0})),ThreeScene=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$3(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],ThreeScene);var __getOwnPropDesc$2=Object.getOwnPropertyDescriptor;let PointerTool=class extends ToolBase{on3DPointerDown(pointers){this.dispatch("3dpointer-down",pointers,!0)}on3DPointerMove(pointers){this.dispatch("3dpointer-move",pointers,!0)}on3DPointerUp(pointers){this.dispatch("3dpointer-up",pointers,!0)}on3DPointerCancel(pointers){this.dispatch("3dpointer-cancel",pointers,!0)}};PointerTool=((decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$2(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(result)||result);return result})([Register],PointerTool);var __defProp$2=Object.defineProperty,__getOwnPropDesc$1=Object.getOwnPropertyDescriptor,__decorateClass$2=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$1(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$2(target,key,result),result};const _pos=new Vector2,_posOld=new Vector2;let CircuitsBoard=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex: 1 1 auto;\n        flex-direction: column;\n        max-width: 100%;\n        max-height: 100%;\n      }\n    "}static get Listeners(){return{"3dpointer-down":"on3DPointerDown","3dpointer-move":"on3DPointerMove","3dpointer-up":"on3DPointerUp","game-init-scene":"onGameInit","game-update":"onGameUpdate","line-end-drag":"onEndDrag"}}_currentID=0;constructor(args){super(args)}onGameInit(){this.applet.updateGrid(this.game.width,this.game.height),this.onGameUpdate()}onGameUpdate(){this.applet.updatePads(this.game.pads),this.applet.updateTerminals(this.game.terminals),this.applet.updateLines(this.game.lines),this.applet.dispatch("three-applet-needs-render",void 0,!0)}ready(){this.render([ioThreeViewport({applet:this.applet,tool:new PointerTool({}),cameraSelect:"scene",overscan:1.2})])}on3DPointerDown(event){1===event.detail.length&&(_pos.set(Math.round(event.detail[0].origin.x),Math.round(event.detail[0].origin.y)),_posOld.copy(_pos),this._currentID=Math.floor(1e5*Math.random()),"pad"===this.game.drawMode&&(console.log(_pos.x,_pos.y),this.game.plotter.addPad(this._currentID,_pos.x,_pos.y)),"terminal"===this.game.drawMode&&this.game.plotter.addTerminal(this._currentID,_pos.x,_pos.y,this.game.drawColor),"line"===this.game.drawMode&&this.game.plotter.addLineSegment(this._currentID,_pos.x,_pos.y,this.game.drawLayer),"delete"===this.game.drawMode&&this.game.plotter.delete(_pos.x,_pos.y))}on3DPointerMove(event){1===event.detail.length&&(_pos.set(Math.round(event.detail[0].origin.x),Math.round(event.detail[0].origin.y)),"line"===this.game.drawMode&&_pos.distanceTo(_posOld)>0&&this.game.plotter.addLineSegment(this._currentID,_pos.x,_pos.y,this.game.drawLayer))}on3DPointerUp(event){event.preventDefault(),this.onEndDrag()}onEndDrag(){this.game&&this.game.finalizeMove(this._currentID)}dispose(){this.applet.dispose(),super.dispose()}};__decorateClass$2([ReactiveProperty({type:ThreeScene,init:null})],CircuitsBoard.prototype,"applet",2),__decorateClass$2([ReactiveProperty({type:Game})],CircuitsBoard.prototype,"game",2),CircuitsBoard=__decorateClass$2([Register],CircuitsBoard);var __defProp$1=Object.defineProperty,__decorateClass$1=(decorators,target,key,kind)=>{for(var decorator,result=void 0,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=decorator(target,key,result)||result);return result&&__defProp$1(target,key,result),result};class CircuitsGame extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        flex-direction: column;\n        height: 100%;\n      }\n      :host > .game-toolbar {\n        display: flex;\n        gap: 2px;\n        padding: 2px;\n        flex-shrink: 0;\n      }\n      :host > .game-toolbar > io-button {\n        flex: 1 1 auto;\n        height: calc(var(--io_fieldHeight) * 1.5);\n        display: flex;\n        align-items: center;\n      }\n      :host > .game-toolbar > io-button > io-icon {\n        margin-left: auto;\n      }\n      :host > .game-toolbar > io-button > span {\n        margin-right: auto;\n      }\n    "}static get Listeners(){return{"game-complete":"onGameComplete"}}completeFn=null;constructor(args){super(args)}ready(){this.changed()}onGameComplete(event){this.completeFn&&this.completeFn(event.detail.level,event.detail.completed)}changed(){var arg0;this.render([(arg0={id:"board",game:this.game},CircuitsBoard.vConstructor(arg0)),div({class:"game-toolbar"},[ioButton({label:"Undo",icon:"io:undo",action:this.onUndo}),ioButton({label:"Reset",icon:"io:reload",action:this.onReset}),ioButton({label:"Redo",icon:"io:redo",action:this.onRedo})])])}levelChanged(){this.game.currentLevel=this.level}onUndo(){this.game.undo()}onRedo(){this.game.redo()}onReset(){this.game.reload()}onEdit(){this.changed()}}__decorateClass$1([ReactiveProperty({value:"",type:String})],CircuitsGame.prototype,"level"),__decorateClass$1([ReactiveProperty({type:Game,init:null})],CircuitsGame.prototype,"game"),Register(CircuitsGame);var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__decorateClass=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp(target,key,result),result};Storage.permit();const $level=Storage({key:"level",storage:"hash",value:""}),$completed=Storage({key:"circuits-completed",storage:"local",value:"[]"});let CircuitsApp=class extends IoElement{static get Style(){return"\n      :host {\n        display: flex;\n        position: fixed;\n        inset: 0;\n        background-color: var(--io_bgColor);\n        color: var(--io_color);\n        user-select: none;\n        -webkit-user-select: none;\n        -webkit-text-size-adjust: none;\n        -webkit-touch-callout: none;\n      }\n    "}static get Listeners(){return{"level-select":"onLevelSelect","editor-select":"onEditorSelect"}}ready(){const completedIds=this._getCompletedIds();var arg0;this.render([ioSplit({split:new Split({type:"split",children:[{type:"panel",flex:"0 0 110px",tabs:[{id:"levels"}]},{type:"panel",flex:"1 1 auto",tabs:[{id:"game"}]},{type:"panel",flex:"0 0 120px",tabs:[{id:"editor"}]}]}),elements:[circuitsLevels({id:"levels",completedLevels:completedIds}),(arg0={id:"game",level:$level,game:this.game},CircuitsGame.vConstructor(arg0)),div({id:"editor"},[ioButton({label:"Pad",action:()=>this._select("pad","")}),...Object.keys(TERMINAL_COLORS).map(c=>ioButton({label:c,action:()=>this._select("terminal",c)})),ioButton({label:"Line (top)",action:()=>this.dispatch("editor-select",{mode:"line",layer:0},!0)}),ioButton({label:"Line (bottom)",action:()=>this.dispatch("editor-select",{mode:"line",layer:-1},!0)}),ioButton({label:"Delete",action:()=>this._select("delete","red")})])]})]);const gameEl=this.querySelector("#game");gameEl&&(gameEl.completeFn=(level,completed)=>this.onLevelComplete(level,completed))}_getCompletedIds(){try{return JSON.parse($completed.value||"[]")}catch{return[]}}_select(mode,color){this.dispatch("editor-select",{mode:mode,color:color},!0)}_setCompletedIds(ids){$completed.value=JSON.stringify(ids)}onLevelComplete(level,completed){if(!completed)return;const ids=this._getCompletedIds();if(ids.includes(level))return;this._setCompletedIds([...ids,level]);const levelsEl=this.querySelector("#levels");levelsEl?.refreshCompleted&&levelsEl.refreshCompleted(this._getCompletedIds())}onEditorSelect(event){event.stopPropagation();const{mode:mode,color:color,layer:layer}=event.detail;this.game.drawMode=mode,console.log(mode),"line"===mode&&void 0!==layer?this.game.drawLayer=layer:void 0!==color&&(this.game.drawColor=color),this.changed()}onLevelSelect(event){event.stopPropagation();const{level:level}=event.detail;$level.value=level}};__decorateClass([ReactiveProperty({type:Game,init:null})],CircuitsApp.prototype,"game",2),CircuitsApp=__decorateClass([Register],CircuitsApp);
//# sourceMappingURL=index.js.map
