// Generated by dts-bundle-generator v9.5.1

type Properties = string[];
type TargetProperties = WeakMap<IoNode, Properties>;
/**
 * Property binding class that enables two-way data synchronization between `IoNode` and `IoElement` nodes.
 *
 * It manages bindings between a source node's property and one or more target nodes and properties.
 * Using a hub-and-spoke pub/sub event system, it maintains data consistency by automatically propagating
 * changes to all bound nodes and properties.
 *
 * Key features:
 * - Listens for `[propName]-changed` events to detect changes
 * - Sets properties using `node.setProperty(propName, value)` method
 * - Supports one-to-many property bindings
 * - Prevents circular update loops
 * - Automatically cleans up listeners when disposed
 *
 * Note: `debug: {}` code blocks are used in dev/debug builds for sanity checks.
 * They print error messages if unexpected state is detected.
 * In theory, they should never be reached.
 *
 * @example
 * // Create a two-way binding between nodeA.value and nodeB.value
 * const binding = new Binding(nodeA, 'value');
 * binding.addTarget(nodeB, 'value');
 */
export declare class Binding {
	readonly node: IoNode;
	readonly property: string;
	readonly targets: IoNode[];
	readonly targetProperties: TargetProperties;
	/**
	 * Creates a binding object for specified source `node` and `property`.
	 * It attaches a `[propName]-changed` listener to the source node.
	 * @param {IoNode} node - Source node
	 * @param {string} property - Name of the sourceproperty
	 */
	constructor(node: IoNode, property: string);
	set value(value: any);
	get value(): any;
	toJSON(): string;
	/**
	 * Helper function to get target properties from WeakMap
	 * Retrieves a list of target properties for specified target node.
	 * @param {IoNode} target - Target node.
	 * @return {Properties} list of target property names.
	 */
	getTargetProperties(target: IoNode): Properties;
	/**
	 * Adds a target node and property.
	 * Sets itself as the binding reference on the target `PropertyInstance`.
	 * Adds a `[propName]-changed` listener to the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	addTarget(target: IoNode, property: string): void;
	/**
	 * Removes target node and property.
	 * If `property` is not specified, it removes all target properties.
	 * Removes binding reference from the target `PropertyInstance`.
	 * Removes `[propName]-changed` listener from the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	removeTarget(target: IoNode, property?: string): void;
	/**
	 * Event handler that updates source property when one of the targets emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onTargetChanged: (event: ChangeEvent) => void;
	/**
	 * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onSourceChanged: (event: ChangeEvent) => void;
	/**
	 * Dispose of the binding by removing all targets and listeners.
	 * Use this when node is no longer needed.
	 */
	dispose(): void;
}
/**
 * Declares default value, type and reactive behavior of the property.
 */
type PropertyDefinition$1 = {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	reactive?: boolean;
	observe?: boolean;
	init?: any;
};
/**
 * Allows loose definition of properties by specifying only partial definitions such as default value or type.
 */
export type PropertyDefinitionLoose = string | number | boolean | Array<any> | null | undefined | Constructor | Binding | PropertyDefinition$1;
/**
 * Finalized property definition created from property definition.
 */
export declare class ProtoProperty {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	reactive?: boolean;
	observe?: boolean;
	init?: any;
	/**
	 * Takes a loosely typed property definition and returns full property definition with unscpecified fileds inferred.
	 * @param {PropertyDefinitionLoose} def Loosely typed property definition
	 */
	constructor(def: PropertyDefinitionLoose);
	/**
	 * Assigns values of another ProtoProperty to itself, unless they are default values.
	 * @param {ProtoProperty} protoProp Source ProtoProperty
	 */
	assign(protoProp: ProtoProperty): void;
}
/**
 * PropertyInstance object constructed from `ProtoProperty`.
 */
export declare class PropertyInstance {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect: boolean;
	reactive: boolean;
	observe: boolean;
	init?: any;
	/**
	 * Creates the property configuration object and copies values from `ProtoProperty`.
	 * @param node owner IoNode instance
	 * @param propDef ProtoProperty object
	 */
	constructor(node: IoNode, propDef: ProtoProperty);
}
export type PropertyDefinitions = Record<string, PropertyDefinitionLoose>;
export declare const PropertyDecorators: WeakMap<Constructor, PropertyDefinitions>;
/**
 * Allows property definitions using decorator pattern.
 * @param propertyDefinition Property definition.
 * @return Property decorator function.
 */
export declare const Property: (propertyDefinition: PropertyDefinitionLoose) => (target: IoNode, propertyName: string) => void;
/**
 * Event listener types.
 */
export interface KeyboardEventListener {
	(event: KeyboardEvent): void;
}
export interface PointerEventListener {
	(event: PointerEvent): void;
}
export interface CustomEventListener {
	(event: CustomEvent): void;
}
export interface FocusEventListener {
	(event: FocusEvent): void;
}
export interface TouchEventListener {
	(event: TouchEvent): void;
}
export interface ChangeEventListener {
	(event: ChangeEvent): void;
}
export interface IoEventListener {
	(event: {
		detail: any;
		target: IoNode;
		path: IoNode[];
	}): void;
}
export type AnyEventListener = EventListener | KeyboardEventListener | PointerEventListener | CustomEventListener | FocusEventListener | TouchEventListener | ChangeEventListener | IoEventListener;
/**
 * Listener definition type.
 * The first item is a string (function name) or an event listener function.
 * The second item is an optional object of event listener options.
 */
export type ListenerDefinition = [
	string | AnyEventListener,
	AddEventListenerOptions?
];
/**
 * Loose listener definition type.
 * It can be a string (function name), an event listener function or a ListenerDefinition array.
 */
export type ListenerDefinitionLoose = string | AnyEventListener | ListenerDefinition;
/**
 * Converts a loose listener definition into a strongly typed ListenerDefinition array format.
 * This ensures consistent handling of listeners regardless of how they were initially defined.
 *
 * @param {ListenerDefinitionLoose} listenerDefinition - Loosely typed listener definition
 * @return {ListenerDefinition} Normalized listener definition in [string | listener, options?] format
 */
export declare const hardenListenerDefinition: (listenerDefinition: ListenerDefinitionLoose) => ListenerDefinition;
/**
 * Converts a listener definition into a normalized Listener tuple.
 * If the first item is a string, it looks up the method on the node.
 *
 * @param {IoNode | EventTarget} node - The node instance containing potential method references
 * @param {ListenerDefinition} def - The listener definition to normalize
 * @return {Listener} Normalized [listener, options?] tuple
 */
export declare const listenerFromDefinition: (node: IoNode | EventTarget, def: ListenerDefinition) => Listener;
export type Listener = [
	AnyEventListener,
	AddEventListenerOptions?
];
export type Listeners = Record<string, Listener[]>;
/**
 * Internal utility class responsible for handling listeners and dispatching events.
 * It makes events of all `IoNode` class instances compatible with DOM events.
 * It maintains three independent lists of listeners:
 *  - `protoListeners` specified as `get Listeners()` return value of class.
 *  - `propListeners` specified as inline properties prefixed with "@".
 *  - `addedListeners` explicitly added/removed using `addEventListener()` and `removeEventListener()`.
 */
export declare class EventDispatcher {
	readonly node: IoNode | EventTarget;
	readonly isEventTarget: boolean;
	readonly protoListeners: Listeners;
	readonly propListeners: Listeners;
	readonly addedListeners: Listeners;
	/**
	 * Creates an instance of `EventDispatcher` for specified `IoNode` instance.
	 * It initializes `protoListeners` from `ProtoChain`.
	 * @param {IoNode} node owner IoNode
	 */
	constructor(node: IoNode | EventTarget);
	/**
	 * Sets `protoListeners` specified as `get Listeners()` class definitions.
	 * Definitions from subclass replace the ones from parent class.
	 * @param {IoNode} node owner IoNode
	 */
	setProtoListeners(node: IoNode): void;
	/**
	 * Sets `propListeners` specified as inline properties prefixed with "@".
	 * It removes existing `propListeners` that are no longer specified and it replaces the ones that changed.
	 * @param {Record<string, any>} properties - Inline properties
	 */
	applyPropListeners(properties: Record<string, any>): void;
	/**
	 * Proxy for `addEventListener` method.
	 * Adds an event listener to the node's `addedListeners` collection.
	 * If the node is an EventTarget, also registers the listener with the DOM.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	 */
	addEventListener(name: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Proxy for `removeEventListener` method.
	 * Removes an event listener from the node's `addedListeners` collection.
	 * If `listener` is not specified it removes all listeners for specified `type`.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	*/
	removeEventListener(name: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Shorthand for custom event dispatch.
	 * @param {string} name - Name of the event
	 * @param {any} detail - Event detail data
	 * @param {boolean} [bubbles] - Makes event bubble
	 * @param {EventTarget} [node] - Event target override to dispatch the event from
	 */
	dispatchEvent(name: string, detail?: any, bubbles?: boolean, node?: EventTarget | IoNode): void;
	/**
	 * Disconnects all event listeners and removes all references for garbage collection.
	 * Use this when node is discarded.
	 */
	dispose(): void;
}
type ProtoConstructors = Array<IoNodeConstructor<any>>;
type ProtoFunctions = string[];
type ProtoProperties = {
	[property: string]: ProtoProperty;
};
type ProtoListeners = {
	[property: string]: ListenerDefinition[];
};
/**
 * Internal utility class that contains usefull information about class inheritance.
 * Inherited information is aggregated during prototype chain traversal in `Register()`.
 */
export declare class ProtoChain {
	/**
	 * Array of inherited class constructors ending with `HTMLElement`, `Object` or `Array`.
	 */
	readonly constructors: ProtoConstructors;
	/**
	 * Array of function names that start with "on" or "_" for auto-binding.
	 */
	readonly functions: ProtoFunctions;
	/**
	 * Aggregated property definition declared in `static get Properties()` return ojects.
	 */
	readonly properties: ProtoProperties;
	/**
	 * Aggregated listener definition declared in `static get Listeners()` return ojects.
	 */
	readonly listeners: ProtoListeners;
	/**
	 * Aggregated CSS style definition declared in `static get Style()` return strings.
	 */
	readonly styles: string;
	/**
	 * Array of property names of observed object properties.
	 */
	readonly observedObjectProperties: string[];
	/**
	 * Creates an instance of `ProtoChain` for specified class constructor.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode`-derived constructor.
	 */
	constructor(ioNodeConstructor: IoNodeConstructor<any>);
	/**
	 * Assigns source listener definition to an existing array of listener definitions.
	 * @param {string} lsnName name of the listener
	 * @param {ListenerDefinition} newListenerDefinition Source listener definition
	 */
	assignListenerDefinition: (lsnName: keyof ProtoListeners, newListenerDefinition: ListenerDefinition) => void;
	/**
	 * Binds all auto-binding functions from the `.functions` array to specified `IoNode`-derived instance.
	 * @param {IoNode} node - `IoNode` instance to bind functions to.
	 */
	autobindFunctions(node: IoNode): void;
}
export type Constructor = new (...args: any[]) => unknown;
export type ListenerDefinitions = Record<string, ListenerDefinitionLoose>;
export interface IoNodeConstructor<T> {
	new (...args: any[]): T;
	Properties?: PropertyDefinitions;
	Listeners?: ListenerDefinitions;
	Style?: string;
}
export type CallbackFunction = (arg?: any) => void;
type prefix<TKey, TPrefix extends string> = TKey extends string ? `${TPrefix}${TKey}` : never;
export type IoNodeArgs = {
	lazy?: boolean;
	[key: prefix<string, "@">]: string | ((event: CustomEvent<any>) => void);
};
/**
 * Core mixin for `Node` classes.
 * @param {function} superclass - Class to extend.
 * @return {function} - Extended class constructor with `IoNodeMixin` applied to it.
 */
export declare function IoNodeMixin<T extends IoNodeConstructor<any>>(superclass: T): {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		/**
		 * Sets the property value, connects the bindings and sets attributes for properties with attribute reflection enabled.
		 * @param {string} name Property name to set value of.
		 * @param {any} value Peroperty value.
		 * @param {boolean} [lazyDispatch] flag to skip event dispatch.
		 */
		setProperty(name: string, value: any, lazyDispatch?: boolean): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		applyProperties(props: any): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		setProperties(props: any): void;
		/**
		 * Sets value property and emits `value-input` event.
		 * Use this when value property is set by user action (e.g. mouse click).
		 * @param {*} value - Property value.
		 */
		inputValue(value: any): void;
		/**
		 * default change handler.
		 * Invoked when one of the properties change.
		 */
		changed(): void;
		init(): void;
		/**
		 * Adds property change to the queue.
		 * @param {string} prop - Property name.
		 * @param {*} value - Property value.
		 * @param {*} oldValue - Old property value.
		 */
		queue(prop: string, value: any, oldValue: any): void;
		/**
		 * Dispatches the queue in the next rAF cycle if `lazy` property is set. Otherwise it dispatches the queue immediately.
		 */
		dispatchQueue(lazy?: boolean): void;
		/**
		 * Throttles function execution to next frame (rAF) if the function has been executed in the current frame.
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for throttled function.
		 * @param {number} timeout - minimum delay in ms before executing the function.
		 */
		throttle(func: CallbackFunction, arg?: any, timeout?: number): void;
		/**
		 * Event handler for 'object-mutated' event emitted from the `window`.
		 * Node should be listening for this event if it has an observed object property
		 * @param {Object} event - Event payload.
		 * @param {Object} event.detail.object - Mutated object.
		 */
		onObjectMutated: (event: CustomEvent) => void;
		/**
		 * This function is called after `onObjectMutated()` determines that one of
		 * the object properties has mutated.
		 * @param {string} prop - Mutated object property name.
		 */
		objectMutated: (prop: string) => void;
		/**
		 * Returns a binding to a specified property`.
		 * @param {string} prop - Property to bind to.
		 * @return {Binding} Binding object.
		 */
		bind(prop: string): Binding;
		/**
		 * Unbinds a binding to a specified property`.
		 * @param {string} prop - Property to unbind.
		 */
		unbind(prop: string): void;
		/**
		 * Wrapper for addEventListener.
		 * @param {string} type - listener name.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for removeEventListener.
		 * @param {string} type - event name to listen to.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for dispatchEvent.
		 * @param {string} type - event name to dispatch.
		 * @param {Object} detail - event detail.
		 * @param {boolean} bubbles - event bubbles.
		 * @param {HTMLElement|Node} src source node/element to dispatch event from.
		 */
		dispatchEvent(type: string, detail?: {}, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		/**
		 * Shorthand for dispatching `'object-mutated'` event on window.
		 * @param {any} object - object which mutated.
		 */
		dispatchMutationEvent(object: any): void;
		/**
		 * Disposes all internals.
		 * Use this when instance is no longer needed.
		 */
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
/**
 * Register function to be called once per class.
 * @param {IoNode} ioNodeConstructor - Node class to register.
 */
export declare function Register(ioNodeConstructor: typeof IoNode): void;
declare const IoNode_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		/**
		 * Sets the property value, connects the bindings and sets attributes for properties with attribute reflection enabled.
		 * @param {string} name Property name to set value of.
		 * @param {any} value Peroperty value.
		 * @param {boolean} [lazyDispatch] flag to skip event dispatch.
		 */
		setProperty(name: string, value: any, lazyDispatch?: boolean): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		applyProperties(props: any): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		setProperties(props: any): void;
		/**
		 * Sets value property and emits `value-input` event.
		 * Use this when value property is set by user action (e.g. mouse click).
		 * @param {*} value - Property value.
		 */
		inputValue(value: any): void;
		/**
		 * default change handler.
		 * Invoked when one of the properties change.
		 */
		changed(): void;
		init(): void;
		/**
		 * Adds property change to the queue.
		 * @param {string} prop - Property name.
		 * @param {*} value - Property value.
		 * @param {*} oldValue - Old property value.
		 */
		queue(prop: string, value: any, oldValue: any): void;
		/**
		 * Dispatches the queue in the next rAF cycle if `lazy` property is set. Otherwise it dispatches the queue immediately.
		 */
		dispatchQueue(lazy?: boolean): void;
		/**
		 * Throttles function execution to next frame (rAF) if the function has been executed in the current frame.
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for throttled function.
		 * @param {number} timeout - minimum delay in ms before executing the function.
		 */
		throttle(func: CallbackFunction, arg?: any, timeout?: number): void;
		/**
		 * Event handler for 'object-mutated' event emitted from the `window`.
		 * Node should be listening for this event if it has an observed object property
		 * @param {Object} event - Event payload.
		 * @param {Object} event.detail.object - Mutated object.
		 */
		onObjectMutated: (event: CustomEvent) => void;
		/**
		 * This function is called after `onObjectMutated()` determines that one of
		 * the object properties has mutated.
		 * @param {string} prop - Mutated object property name.
		 */
		objectMutated: (prop: string) => void;
		/**
		 * Returns a binding to a specified property`.
		 * @param {string} prop - Property to bind to.
		 * @return {Binding} Binding object.
		 */
		bind(prop: string): Binding;
		/**
		 * Unbinds a binding to a specified property`.
		 * @param {string} prop - Property to unbind.
		 */
		unbind(prop: string): void;
		/**
		 * Wrapper for addEventListener.
		 * @param {string} type - listener name.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for removeEventListener.
		 * @param {string} type - event name to listen to.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for dispatchEvent.
		 * @param {string} type - event name to dispatch.
		 * @param {Object} detail - event detail.
		 * @param {boolean} bubbles - event bubbles.
		 * @param {HTMLElement|Node} src source node/element to dispatch event from.
		 */
		dispatchEvent(type: string, detail?: {}, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		/**
		 * Shorthand for dispatching `'object-mutated'` event on window.
		 * @param {any} object - object which mutated.
		 */
		dispatchMutationEvent(object: any): void;
		/**
		 * Disposes all internals.
		 * Use this when instance is no longer needed.
		 */
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
/**
 * IoNodeMixin applied to `Object` class.
 */
export declare class IoNode extends IoNode_base {
}
export interface Change {
	property: string;
	value: any;
	oldValue: any;
}
export interface ChangeEvent extends Omit<CustomEvent<Change>, "target"> {
	readonly target: IoNode;
	readonly detail: Change;
	readonly path: IoNode[];
}
export declare class MutationEvent extends CustomEvent<Object> {
	constructor(object: Object);
}
/**
 * A queue system for managing and batching property changes in `IoNode` and `IoElement` nodes.
 *
 * This class implements a First-In-First-Out (FIFO) queue that:
 * - Collects property changes and their associated values
 * - Coalesces multiple changes to the same property
 * - Dispatches changes in order through events (e.g., '[propName]-changed')
 * - Invokes corresponding change handlers (e.g., [propName]Changed())
 * - Triggers a final 'changed()' handler after processing all changes
 * - Dispatches a final 'changed' event after processing all changes
 *
 * The queue helps optimize performance by batching multiple property changes
 * and preventing redundant updates when the same property changes multiple
 * times within a single execution cycle.
 */
export declare class ChangeQueue {
	readonly node: IoNode;
	readonly changes: Change[];
	hasChanged: boolean;
	dispatching: boolean;
	/**
	 * Creates change queue for the specified owner instance of `IoNode`.
	 * @param {IoNode} node - Owner node.
	 */
	constructor(node: IoNode);
	/**
	 * Adds property change payload to the queue by specifying property name, previous and the new value.
	 * If the change is already in the queue, the new value is updated in-queue.
	 * If the new value is the same as the original value, the change is removed from the queue.
	 * @param {string} property - Property name.
	 * @param {any} value Property value.
	 * @param {any} oldValue Old property value.
	 */
	queue(property: string, value: any, oldValue: any): void;
	/**
	 * Dispatches and clears the queue.
	 * For each property change in the queue:
	 *  - It executes node's `[propName]Changed(change)` change handler function if it is defined.
	 *  - It fires the `'[propName]-changed'` `ChangeEvent` from the owner node with `Change` data as `event.detail`.
	 * After all changes are dispatched it invokes `.changed()` function of the owner node instance and fires `'changed'` event.
	 * Finally it fires global `'object-mutated'` event on the window object with the owner node as `event.detail`.
	 */
	dispatch(): void;
	/**
	 * Clears the queue and removes the node reference.
	 * Use this when node queue is no longer needed.
	 */
	dispose(): void;
}
export type IoElementArgs = IoNodeArgs & {
	tabindex?: string;
	contenteditable?: boolean;
	class?: string;
	role?: string;
	label?: string;
	name?: string;
	title?: string;
	id?: string;
	hidden?: boolean;
	disabled?: boolean;
	cache?: boolean;
	[key: string]: any;
};
export type VDOMArray = [
	string
] | [
	string,
	IoElementArgs | string | VDOMArray[]
] | [
	string,
	IoElementArgs | string,
	VDOMArray[] | string
];
export type VDOMElement = {
	name: string;
	props: IoElementArgs;
	children: VDOMElement[];
};
export declare const buildTree: () => (node: VDOMArray) => any;
export declare const disposeElementDeep: (element: IoElement) => void;
/**
 * Sets element properties.
 * @param {HTMLElement} element - Element to set properties on.
 * @param {Object} props - Element properties.
 */
export declare const applyNativeElementProps: (element: HTMLElement, props: any) => void;
declare const IoElement_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		setProperty(name: string, value: any, lazyDispatch?: boolean): void;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(prop: string, value: any, oldValue: any): void;
		dispatchQueue(lazy?: boolean): void;
		throttle(func: CallbackFunction, arg?: any, timeout?: number): void;
		onObjectMutated: (event: CustomEvent) => void;
		objectMutated: (prop: string) => void;
		bind(prop: string): Binding;
		unbind(prop: string): void;
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: {}, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispatchMutationEvent(object: any): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
/**
 * Core `IoElement` class.
 */
export declare class IoElement extends IoElement_base {
	static get Style(): string;
	$: Record<string, any>;
	tabindex: string;
	contenteditable: boolean;
	class: string;
	role: string;
	label: string;
	name: string;
	title: string;
	id: string;
	hidden: boolean;
	disabled: boolean;
	/**
	* Add resize listener if `onResized()` is defined in subclass.
	*/
	connectedCallback(): void;
	/**
	* Removes resize listener if `onResized()` is defined in subclass.
	*/
	disconnectedCallback(): void;
	/**
	 * Renders DOM from virtual DOM arrays.
	 * @param {Array} vDOM - Array of vDOM children.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	template(vDOM: Array<any>, host?: HTMLElement, cache?: boolean): void;
	/**
	 * Recurively traverses vDOM.
	 * TODO: test element.traverse() function!
	 * @param {Array} vChildren - Array of vDOM children converted by `buildTree()` for easier parsing.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	traverse(vChildren: Array<any>, host: HTMLElement, cache?: boolean): void;
	Register(ioNodeConstructor: typeof IoNode): void;
	/**
	* Helper function to flatten textContent into a single TextNode.
	* Update textContent via TextNode is better for layout performance.
	* @param {HTMLElement} element - Element to flatten.
	*/
	_flattenTextNode(element: HTMLElement | IoElement): void;
	get textNode(): any;
	set textNode(value: any);
	applyProperties(props: any): void;
	/**
	* Alias for HTMLElement setAttribute where falsey values remove the attribute.
	* @param {string} attr - Attribute name.
	* @param {*} value - Attribute value.
	*/
	setAttribute(attr: string, value: boolean | number | string): void;
	labelChanged(): void;
	disabledChanged(): void;
}
export declare class Color {
	r: number;
	g: number;
	b: number;
	a: number;
	constructor(r: number, g: number, b: number, a: number);
}
export type Theme = {
	iotSpacing: number;
	iotSpacing2: number;
	iotSpacing3: number;
	iotSpacing5: number;
	iotSpacing8: number;
	iotFontSize: number;
	iotLineHeight: number;
	iotFieldHeight: number;
	iotFieldHeight2: number;
	iotFieldHeight3: number;
	iotFieldHeight4: number;
	iotFieldHeight5: number;
	iotFieldHeight6: number;
	iotFieldHeight7: number;
	iotFieldHeight8: number;
	iotFieldHeight9: number;
	iotFieldHeight10: number;
	iotFieldHeight11: number;
	iotFieldHeight12: number;
	iotBorderRadius: number;
	iotBorderRadius2: number;
	iotBorderWidth: number;
	iotBorderColor: Color;
	iotBorderColorLight: Color;
	iotBorderColorDark: Color;
	iotBgColor: Color;
	iotBgColorStrong: Color;
	iotBgColorDimmed: Color;
	iotBgColorRed: Color;
	iotBgColorGreen: Color;
	iotBgColorBlue: Color;
	iotBgColorField: Color;
	iotColor: Color;
	iotColorStrong: Color;
	iotColorDimmed: Color;
	iotColorRed: Color;
	iotColorGreen: Color;
	iotColorBlue: Color;
	iotColorWhite: Color;
	iotColorField: Color;
	iotGradientColorStart: Color;
	iotGradientColorEnd: Color;
	iotShadowColor: Color;
};
export declare const LIGHT_THEME: Theme;
export declare const DARK_THEME: Theme;
declare class IoTheme extends IoElement {
	static get Properties(): PropertyDefinitions;
	themes: Record<string, Theme>;
	themeID: string;
	lazy: boolean;
	init(): void;
	registerTheme(themeID: string, theme: Theme): void;
	_toCss(rgba: Color): string;
	reset(): void;
	themeIDChanged(): void;
	changed(): void;
}
export declare const IoThemeSingleton: IoTheme;
interface StorageProps {
	key: string;
	value?: any;
	default?: any;
	storage?: "hash" | "local" | "none";
}
export declare function genObjectStorageID(object: Record<string, any>): string;
export declare class IoStorageNode extends IoNode {
	key: string;
	value: any;
	default: any;
	storage: "hash" | "local" | "none";
	binding: Binding;
	constructor(props: StorageProps);
	dispose(): void;
	_clearStorage(): void;
	valueChanged(): void;
	removeValueToHash(): void;
	saveValueToHash(): void;
}
export declare const IoStorage: ((props: StorageProps) => Binding) & {
	permit(): void;
	unpermit(): void;
};
export declare class IoGl extends IoElement {
	static get Style(): string;
	size: [
		number,
		number
	];
	color: [
		number,
		number,
		number,
		number
	];
	pxRatio: number;
	theme: typeof IoThemeSingleton;
	_needsResize: boolean;
	_canvas: HTMLCanvasElement;
	_ctx: CanvasRenderingContext2D;
	static get Vert(): string;
	static get GlUtils(): string;
	static get Frag(): string;
	initPropertyUniform(name: string, property: PropertyDefinition$1): string;
	initShader(): WebGLProgram;
	constructor(properties?: Record<string, any>);
	onResized(): void;
	themeMutated(): void;
	changed(): void;
	_onRender(): void;
	setShaderProgram(): void;
	updatePropertyUniform(name: string, property: PropertyInstance): void;
	updateThemeUniforms(): void;
	setUniform(name: string, value: any): void;
}
export type NudgeDirection = "none" | "pointer" | "up" | "left" | "down" | "right";
/**
 * This element is designed to be used as a singleton `IoOverlaySingleton`.
 * It is a pointer-blocking element covering the entire window at a very high z-index.
 * It is designed to be displayed on top all other elements and contain elements like modals, popovers, floating menus etc.
 * When clicked, IoOverlay collapses all child elements by setting their `expanded` property to `false`.
 * Child elements should emmit bubbling `"expanded"` event when expanded/collapsed.
 **/
export declare class IoOverlay extends IoElement {
	static get Style(): string;
	expanded: boolean;
	static get Listeners(): {
		pointerdown: (string | {
			passive: boolean;
		})[];
		pointermove: (string | {
			passive: boolean;
		})[];
		pointerup: string;
		contextmenu: string;
		focusin: string;
		scroll: string;
		wheel: (string | {
			passive: boolean;
		})[];
		mousedown: (string | {
			passive: boolean;
		})[];
		mousemove: (string | {
			passive: boolean;
		})[];
		mouseup: (string | {
			passive: boolean;
		})[];
		touchstart: (string | {
			passive: boolean;
		})[];
		touchmove: (string | {
			passive: boolean;
		})[];
		touchend: (string | {
			passive: boolean;
		})[];
		keydown: (string | {
			passive: boolean;
		})[];
		keyup: (string | {
			passive: boolean;
		})[];
	};
	constructor(properties?: Record<string, any>);
	stopPropagation(event: Event): void;
	onResized(): void;
	_onPointerup(event: PointerEvent): void;
	_onCollapse(): void;
	_onContextmenu(event: Event): void;
	_onFocusIn(event: FocusEvent): void;
	_onScroll(event: Event): void;
	nudgeDown(element: HTMLElement, x: number, y: number, elemRect: DOMRect, force?: boolean): boolean;
	nudgeUp(element: HTMLElement, x: number, y: number, elemRect: DOMRect, force?: boolean): boolean;
	nudgeRight(element: HTMLElement, x: number, y: number, elemRect: DOMRect, force?: boolean): boolean;
	nudgeLeft(element: HTMLElement, x: number, y: number, elemRect: DOMRect, force?: boolean): boolean;
	nudgePointer(element: HTMLElement, x: number, y: number, elemRect: DOMRect): boolean;
	setElementPosition(element: HTMLElement, direction: NudgeDirection, srcRect: DOMRect): void;
	appendChild(child: HTMLElement): void;
	removeChild(child: HTMLElement): void;
	onChildExpanded(): void;
	onChildExpandedDelayed(): void;
	expandedChanged(): void;
}
export declare const IoOverlaySingleton: IoOverlay;
declare const MenuOptions_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		setProperty(name: string, value: any, lazyDispatch?: boolean): void;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(prop: string, value: any, oldValue: any): void;
		dispatchQueue(lazy?: boolean): void;
		throttle(func: CallbackFunction, arg?: any, timeout?: number): void;
		onObjectMutated: (event: CustomEvent) => void;
		objectMutated: (prop: string) => void;
		bind(prop: string): Binding;
		unbind(prop: string): void;
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: {}, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispatchMutationEvent(object: any): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
export declare class MenuOptions extends MenuOptions_base {
	first: any;
	last: any;
	scroll: any;
	path: string;
	delimiter: string;
	push(...items: MenuItem[]): void;
	getItem(value: any, deep?: boolean): any;
	constructor(args?: MenuItemArgsLoose[], properties?: IoNodeArgs);
	protected addItems(items: MenuItemArgsLoose[]): void;
	pathChanged(): void;
	firstChanged(): void;
	lastChanged(): void;
	updatePaths(item?: MenuItem): void;
	_onItemSelectedChanged(event: CustomEvent): void;
	_onSubOptionsPathChanged(event: CustomEvent): void;
	selectDefault(): boolean;
	bind(prop: string): Binding;
	dispose(): void;
	changed(): void;
}
export type MenuItemSelectType = "select" | "scroll" | "toggle" | "link" | "none";
export type MenuItemArgsLoose = undefined | null | string | number | MenuItemArgs;
export type MenuItemArgs = IoElementArgs & {
	value?: any;
	icon?: string;
	hint?: string;
	action?: () => void;
	mode?: MenuItemSelectType;
	hidden?: boolean;
	disabled?: boolean;
	selected?: boolean;
	options?: MenuItemArgsLoose[] | MenuOptions;
};
export declare class MenuItem extends IoNode {
	value: any;
	label: string;
	icon: string;
	hint: string;
	hidden: boolean;
	disabled: boolean;
	action?: (value?: any) => void;
	mode: MenuItemSelectType;
	selected: boolean;
	options?: MenuOptions;
	get hasmore(): boolean;
	getSubitem(value: any): any;
	constructor(args?: MenuItemArgsLoose);
	toJSON(): Record<string, any>;
	_onSubItemSelected(): void;
	_onOptionsPathChanged(event: CustomEvent): void;
	optionsChanged(): void;
	selectedChanged(): void;
	changed(): void;
	dispose(): void;
}
export declare class IoLabel extends IoElement {
	static get Style(): string;
	labelChanged(): void;
}
export declare class IoField extends IoElement {
	static get Style(): string;
	tabindex: string;
	value: any;
	icon: string;
	appearance: "flush" | "inset" | "outset" | "neutral";
	stroke: boolean;
	selected: boolean;
	invalid: boolean;
	placeholder: string;
	static get Listeners(): {
		"focus-to": string;
		focus: string;
		pointerdown: string;
		click: string;
	};
	_onFocus(event: FocusEvent): void;
	_onBlur(event: FocusEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerleave(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onClick(): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	_onFocusTo(event: CustomEvent): void;
	focusTo(dir: string): void;
	getCaretPosition(): number;
	setCaretPosition(position: number): void;
	changed(): void;
}
/**
 * Button element.
 * When clicked or activated by space/enter key, it calls the `action` property function with optional `value` argument.
 *
 * <io-element-demo element="io-button" properties='{"label": "Button", "action": "null"}'></io-element-demo>
 **/
export declare class IoButton extends IoField {
	static get Style(): string;
	action?: any;
	value: any;
	appearance: "flush" | "inset" | "outset" | "neutral";
	pressed: boolean;
	role: string;
	_onPointerdown(event: PointerEvent): void;
	_onPointerleave(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	_onClick(): void;
	init(): void;
	changed(): void;
}
/**
 * Input element for `Boolean` data type displayed as text.
 * It can be configured to display custom `true` or `false` string or icon depending on its `value`.
 *
 * <io-element-demo element="io-boolean" properties='{"value": true, "true": "true", "false": "false"}'></io-element-demo>
 **/
export declare class IoBoolean extends IoField {
	static get Style(): string;
	value: boolean;
	true: string;
	false: string;
	role: string;
	_onClick(): void;
	toggle(): void;
	init(): void;
	changed(): void;
}
export declare class IoBoolicon extends IoBoolean {
	changed(): void;
}
/**
 * Input element for `Boolean` data type displayed as switch.
 *
 * <io-element-demo element="io-switch" properties='{"value": true}'></io-element-demo>
 **/
export declare class IoSwitch extends IoBoolean {
	static get Style(): string;
	init(): void;
	changed(): void;
	valueChanged(): void;
}
/**
 * Input element for `String` data type.
 **/
export declare class IoString extends IoField {
	static get Style(): string;
	live: boolean;
	value: string | number | boolean;
	contenteditable: boolean;
	role: string;
	appearance: "flush" | "inset" | "outset";
	_setFromTextNode(): void;
	_tryParseFromTextNode(): void;
	_onBlur(event: FocusEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	changed(): void;
	valueChanged(): void;
}
/**
 * Input element for `Number` data type.
 * It clamps the `value` to `min` / `max` and rounds it to the nearest `step` increment.
 * If `ladder` property is enabled, it displays an interactive float ladder element when clicked/taped.
 * Alternatively, ladder can be expanded by middle click or ctrl key regardless of ladder property.
 **/
export declare class IoNumber extends IoField {
	static get Style(): string;
	role: string;
	value: number;
	conversion: number;
	step: number;
	min: number;
	max: number;
	ladder: boolean;
	contenteditable: boolean;
	type: string;
	pattern: string;
	inputmode: string;
	spellcheck: string;
	appearance: "flush" | "inset" | "outset";
	private _pointer;
	_onBlur(event: FocusEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onFocus(event: FocusEvent): void;
	_expandLadder(): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	_setFromTextNode(): void;
	init(): void;
	changed(): void;
}
export declare class IoNumberLadderStep extends IoField {
	static get Style(): string;
	value: number;
	type: string;
	role: string;
	_onKeydown(event: KeyboardEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	init(): void;
	changed(): void;
}
/**
 * Interactive number ladder.
 * When dragged horizontally, it changes the value in step increments.
 * Dragging speed affects the rate of change exponentially.
 * Up/down arrow keys change the step focus while left/right change the value in step increments.
 * Escape key collapses the ladder and restores the focus to previously focused element.
 * If shift key is pressed, value is rounded to the nearest step incement.
 *
 * <io-element-demo element="io-ladder" expanded properties='{"value": 0, "step": 0.0001, "conversion": 1, "min": -10000, "max": 10000, "expanded": true}'></io-element-demo>
 **/
export declare class IoNumberLadder extends IoElement {
	static get Style(): string;
	role: string;
	src?: IoNumber;
	expanded: boolean;
	static get Listeners(): {
		"ladder-step-change": string;
		"ladder-step-collapse": string;
		focusin: string;
	};
	get value(): number;
	get min(): number;
	get max(): number;
	get step(): number;
	get conversion(): number;
	_onFocusIn(event: FocusEvent): void;
	_onFocusTo(event: CustomEvent): void;
	_onLadderStepChange(event: CustomEvent): void;
	_onLadderStepCollapse(): void;
	expandedChanged(): void;
	changed(): void;
}
export declare const IoNumberLadderSingleton: IoNumberLadder;
/**
 * SVG icon element.
 * It displays SVG content specified via `icon` parameter. Custom SVG assets need to be registered with `IoIconsetSingleton`.
 **/
export declare class IoIcon extends IoElement {
	static get Style(): string;
	icon: string;
	stroke: boolean;
	iconChanged(): void;
}
/**
 * Global database for SVG assets to be used with `IoIcon`. Icons are registered using `namespace` and `id` attribute.
 *
 * ```javascript
 * import {IoIconsetSingleton} from "./path_to/iogui.js";
 * const svgString = `<svg><g id="myicon"><path d="..."/></g></svg>`;
 *
 * // register icons under "custom" namespace
 * IoIconsetSingleton.registerIcons('custom', svgString);
 * // retrieve specific icon
 * const icon = IoIconsetSingleton.getIcon('custom:myicon');
 * ```
 **/
export declare class IoIconset extends IoNode {
	registerIcons(name: string, svg: string): void;
	getIcon(icon: string): string;
}
export declare const IoIconsetSingleton: IoIconset;
export declare class IoColorBase extends IoElement {
	value: {
		r: number;
		g: number;
		b: number;
		a?: number;
	};
	rgba: [
		number,
		number,
		number,
		number
	];
	hsv: [
		number,
		number,
		number
	];
	hsl: [
		number,
		number,
		number
	];
	cmyk: [
		number,
		number,
		number,
		number
	];
	init(): void;
	valueMutated(): void;
	rgbFromHsv(): void;
	rgbFromHsl(): void;
	rgbFromCmyk(): void;
	valueFromRgb(): void;
	valueChanged(): void;
}
export declare class IoSliderBase extends IoGl {
	static get Style(): string;
	value: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	step: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	min: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	max: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	exponent: number;
	vertical: boolean;
	noscroll: boolean;
	role: string;
	tabindex: string;
	lazy: boolean;
	_startX: number;
	_startY: number;
	_active: number;
	_rect: DOMRect | null;
	get _min(): [
		number,
		number
	];
	get _max(): [
		number,
		number
	];
	get _step(): [
		number,
		number
	];
	get _value(): [
		number,
		number
	];
	static get Listeners(): {
		focus: string;
		contextmenu: string;
		pointerdown: string;
		touchstart: (string | {
			passive: boolean;
		})[];
	};
	_onFocus(): void;
	_onBlur(): void;
	_onContextmenu(event: Event): void;
	_onTouchstart(event: TouchEvent): void;
	_onTouchmove(event: TouchEvent): void;
	_onTouchend(): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_getPointerCoord(event: PointerEvent): [
		number,
		number
	];
	_getValueFromCoord(coord: [
		number,
		number
	]): [
		number,
		number
	];
	_onPointermoveThrottled(event: PointerEvent): void;
	_inputValue(value: [
		number,
		number
	]): void;
	_onKeydown(event: KeyboardEvent): void;
	_setIncrease(): void;
	_setDecrease(): void;
	_setMin(): void;
	_setMax(): void;
	_setUp(): void;
	_setDown(): void;
	_setLeft(): void;
	_setRight(): void;
	init(): void;
	changed(): void;
}
/**
 * Input element for `Number` data type displayed as slider.
 * It can be configured to clamp the `value` to `min` / `max` and round it to the nearest `step` increment. `exponent` property can be changed for non-linear scale.
 *
 * Keys left/right/up/down+shift and pageup/pagedown change the value in step incements. Home/end keys set the value to min/max.
 *
 * <io-element-demo element="io-slider" properties='{"value": 0, "step": 0.01, "min": -0.5, "max": 0.5, "exponent": 1}'></io-element-demo>
 **/
export declare class IoSlider extends IoSliderBase {
	value: number;
	step: number;
	min: number;
	max: number;
	static get Frag(): string;
}
export declare class IoSlider2d extends IoSliderBase {
	static get Style(): string;
	value: [
		number,
		number
	];
	step: [
		number,
		number
	];
	min: [
		number,
		number
	];
	max: [
		number,
		number
	];
	noscroll: boolean;
	static get GlUtils(): string;
	static get Frag(): string;
}
/**
 * A generic color slider element.
 * It is a wrapper for channel-specific sliders which are added as a child of this element depending on the `channel` property.
 * For example, setting `channel: 'h'` will instantiate a slider for "hue" color channel and hook up necessary conversions, bindings and event callbacks.
 *
 * <io-element-demo element="io-color-slider-hs"
 * width="64px" height="64px"
 * properties='{"value": [1, 0.5, 0, 1], "horizontal": true}'
 * config='{"value": ["io-properties"]}
 * '></io-element-demo>
 **/
export declare class IoColorSlider extends IoColorBase {
	static get Style(): string;
	color: [
		number,
		number,
		number,
		number
	];
	step: number;
	channel: string;
	vertical: boolean;
	_onValueInput(event: CustomEvent): void;
	changed(): void;
}
/**
 * A base class for 1D color slider.
 * It as an incomplete implementation of a color slider desiged to be fully implemented in channel-specific subclasses.
 **/
export declare class IoColorSliderBase extends IoSlider {
	static get GlUtils(): string;
	static get Frag(): string;
}
/**
 * A base class for 2D color slider.
 * It as an incomplete implementation of a color slider desiged to be fully implemented in channel-specific subclasses.
 **/
export declare class IoColorSlider2dBase extends IoSlider2d {
	static get GlUtils(): string;
	static get Frag(): string;
}
/**
 * A 1D slider for "red" color channel.
 **/
export declare class IoColorSliderR extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "green" color channel.
 **/
export declare class IoColorSliderG extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "blue" color channel.
 **/
export declare class IoColorSliderB extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "alpha" color channel.
 **/
export declare class IoColorSliderA extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "hue" color channel.
 **/
export declare class IoColorSliderH extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "saturation" color channel.
 **/
export declare class IoColorSliderS extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "value" color channel.
 **/
export declare class IoColorSliderV extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "level" color channel.
 **/
export declare class IoColorSliderL extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "cyan" color channel.
 **/
export declare class IoColorSliderC extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "magenta" color channel.
 **/
export declare class IoColorSliderM extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "yellow" color channel.
 **/
export declare class IoColorSliderY extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "key" color channel.
 **/
export declare class IoColorSliderK extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 2D slider gor "hue" and "saturation" color channels.
 **/
export declare class IoColorSliderHs extends IoColorSlider2dBase {
	static get GlUtils(): string;
}
/**
 * A 2D slider gor "saturation" and "value" color channels.
 **/
export declare class IoColorSliderSv extends IoColorSlider2dBase {
	static get GlUtils(): string;
}
/**
 * A 2D slider gor "saturation" and "level" color channels.
 **/
export declare class IoColorSliderSL extends IoColorSlider2dBase {
	static get GlUtils(): string;
}
/**
 * Input element for color displayed as a set of sliders.
 *
 * <io-element-demo element="io-color-panel"
 * width= "192px"
 * height= "128px"
 * properties='{"mode": 0, "value": [1, 0.5, 0, 1], "horizontal": true}'
 * config='{"value": ["io-properties"], "mode": ["io-option-menu", {"options": [{"value": 0, "label": "0 - rgb"}, {"value": 1, "label": "1 - hsv"}, {"value": 2, "label": "2 - hsl"}, {"value": 3, "label": "3 - cmyk"}]}]}
 * '></io-element-demo>
 *
 * This element has a singleton instance `IoColorPanelSingleton` used by `IoColorPicker` and other elements.
 **/
export declare class IoColorPanel extends IoColorBase {
	static get Style(): string;
	expanded: boolean;
	vertical: boolean;
	inlayer: boolean;
	static get Listeners(): {
		keydown: string;
	};
	_onKeydown(event: KeyboardEvent): void;
	onValueSet(): void;
	changed(): void;
}
export declare const IoColorPanelSingleton: IoColorPanel;
/**
 * Element displaying colored square.
 *
 * <io-element-demo element="io-color-swatch"
 * properties='{"value": [1, 0.5, 0, 1]}'
 * config='{"value": ["io-properties"]}
 * '></io-element-demo>
 **/
export declare class IoColorSwatch extends IoColorBase {
	static get Style(): string;
	valueChanged(): void;
}
export declare class IoColorPicker extends IoElement {
	static get Style(): string;
	value: {
		r: number;
		g: number;
		b: number;
		a?: number;
	};
	static get Listeners(): any;
	tabindex: string;
	_onClick(event: FocusEvent): void;
	get expanded(): boolean;
	_onKeydown(event: KeyboardEvent): void;
	_onValueSet(): void;
	toggle(): void;
	expand(): void;
	collapse(): void;
	changed(): void;
}
/**
 * Input element for color displayed as vector and an interactive picker.
 **/
export declare class IoColorRgba extends IoColorBase {
	static get Style(): string;
	_onNumberValueInput(event: CustomEvent): void;
	changed(): void;
}
/**
 * An element with collapsable content.
 * When clicked or activated by space/enter key, it toggles the visibility of the child elements defined as `elements` property.
 **/
export declare class IoCollapsable extends IoElement {
	static get Style(): string;
	elements: VDOMArray[];
	label: string;
	direction: "column" | "row";
	icon: string;
	expanded: boolean;
	role: string;
	changed(): void;
}
/**
 * This elements loads a markdown file from path specified as `src` property and renders it as HTML using marked and dompurify.
 */
export declare class IoMdView extends IoElement {
	static get Style(): string;
	role: string;
	src: string;
	strip: string[];
	loading: boolean;
	sanitize: boolean;
	protected _strip(innerHTML: string): string;
	protected _parseMarkdown(markdown: string): void;
	onResized(): void;
	srcChanged(): void;
	changed(): void;
}
export declare class IoSelector extends IoElement {
	static get Style(): string;
	options: MenuOptions;
	select: "first" | "last";
	elements: VDOMArray[];
	cache: boolean;
	precache: boolean;
	precacheDelay: number;
	loading: boolean;
	private _caches;
	private _selected?;
	init(): void;
	optionsMutated(): void;
	importModule(path: string): Promise<unknown>;
	protected renderSelected(): void;
	onLoadPrecache(): void;
	dispose(): void;
}
export declare class IoScroller extends IoElement {
	static get Style(): string;
	options: MenuOptions;
	private _observer;
	init(): void;
	connectedCallback(): void;
	_domMutated(): void;
	optionsMutated(): void;
	_scrollToSelected(): void;
	dispose(): void;
}
export declare class IoNavigatorBase extends IoElement {
	static get Style(): string;
	slotted: VDOMArray[];
	elements: VDOMArray[];
	options: MenuOptions;
	menu: "top" | "left" | "bottom" | "right";
	depth: number;
	collapsed: boolean;
	collapseWidth: number;
	init(): void;
	onResized(): void;
	_computeCollapsed(): void;
	getSlotted(): VDOMArray | null;
	changed(): void;
}
export declare class IoNavigatorSelector extends IoNavigatorBase {
	select: "first" | "last";
	cache: boolean;
	precache: boolean;
	getSlotted(): VDOMArray;
}
export declare class IoNavigatorCombined extends IoNavigatorSelector {
	static get Style(): string;
	getSlotted(): VDOMArray;
}
export declare class IoNavigatorMdView extends IoNavigatorBase {
	strip: string[];
	sanitize: boolean;
	getSlotted(): VDOMArray;
}
export declare class IoNavigatorScroller extends IoNavigatorBase {
	getSlotted(): VDOMArray;
}
/**
 * Input element for vector arrays and objects.
 *
 * <io-element-demo element="io-vector" properties='{"value": {"x": 1, "y": 0.5}, "linkable": false}'></io-element-demo>
 *
 * <io-element-demo element="io-vector" properties='{"value": [0, 0.5, 1], "linkable": true}'></io-element-demo>
 **/
export declare class IoVector extends IoElement {
	static get Style(): string;
	value: {
		x: number;
		y: number;
		z?: number;
		w?: number;
	} | number[];
	conversion: number;
	step: number;
	min: number;
	max: number;
	linkable: boolean;
	linked: boolean;
	ladder: boolean;
	keys: string[];
	private _ratios;
	_onNumberPointerDown(event: PointerEvent): void;
	_onNumberValueInput(event: CustomEvent): void;
	valueChanged(): void;
	changed(): void;
	getSlotted(): Array<any> | null;
}
/**
 * Input element for vector arrays dispalayed as 2D matrices. Array `value` can have 4, 9, and 16 elements for 2x2, 3x3 and 4x4 matrices.
 *
 * <io-element-demo element="io-matrix" properties='{"value": [1, 0, 0, 1]}'></io-element-demo>
 *
 * <io-element-demo element="io-matrix" properties='{"value": [1, 0, 0, 0, 1, 0, 0, 0, 1]}'></io-element-demo>
 *
 * <io-element-demo element="io-matrix" properties='{"value": [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1]}'></io-element-demo>
 **/
export declare class IoMatrix extends IoVector {
	static get Style(): string;
	value: number[];
	columns: number;
	_onNumberValueInput(event: CustomEvent): void;
	valueChanged(): void;
}
/**
 * It generates a list of `IoMenuItem` elements from `options` property. If `horizontal` property is set, menu items are displayed in horizontal direction.
 **/
export declare class IoMenuOptions extends IoElement {
	static get Style(): string;
	options: MenuOptions;
	expanded: boolean;
	horizontal: boolean;
	searchable: boolean;
	search: string;
	direction: NudgeDirection;
	depth: number;
	noPartialCollapse: boolean;
	overflow: string;
	inlayer: boolean;
	slotted: VDOMArray[];
	role: string;
	$parent?: IoMenuItem;
	private _overflownItems;
	static get Listeners(): {
		"item-clicked": string;
		touchstart: (string | {
			passive: boolean;
		})[];
	};
	_onItemClicked(event: CustomEvent): void;
	_stopPropagation(event: MouseEvent): void;
	init(): void;
	onResized(): void;
	_onSetOverflow(): void;
	_onCollapse(): void;
	expandedChanged(): void;
	searchChanged(): void;
	_onExpandInOverlay(): void;
	_onClipHeight(): void;
	changed(): void;
}
/**
 * It displays `option.icon`, `option.label` and `option.hint` property and it creates expandable `IoMenuOptions` from the `option.options` array. Options are expand in the direction specified by `direction` property. If `selectable` property is set, selecting an option sets its `value` to the entire menu tree and `selected` atribute is set on menu items whose `option.value` matches selected value.
 **/
export declare class IoMenuItem extends IoField {
	static get Style(): string;
	item: MenuItem;
	expanded: boolean;
	direction: string;
	depth: number;
	$options?: IoMenuOptions;
	static get Listeners(): any;
	preventDefault(event: Event): void;
	get hasmore(): boolean;
	get inlayer(): boolean;
	get $parent(): any;
	connectedCallback(): void;
	disconnectedCallback(): void;
	_onOverlayPointermove(event: PointerEvent): void;
	_onOverlayPointerup(event: PointerEvent): void;
	_onClick(): void;
	_onItemClicked(event: PointerEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointerdownAction(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointermoveAction(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onPointerupAction(event: PointerEvent, skipCollapse?: boolean): void;
	_gethovered(event: PointerEvent): IoMenuElementType | undefined;
	_expandHovered(): void;
	_onKeydown(event: KeyboardEvent): void;
	_onCollapse(): void;
	_onCollapseRoot(): void;
	expandedChanged(): void;
	changed(): void;
}
type IoMenuElementType = IoMenuItem | IoMenuOptions;
export declare function getMenuDescendants(element: IoMenuElementType): IoMenuElementType[];
export declare function getMenuAncestors(element: IoMenuElementType): (IoMenuItem | IoMenuOptions)[];
export declare function getMenuRoot(element: IoMenuElementType): IoMenuElementType;
export declare class IoMenuHamburger extends IoMenuItem {
	static get Style(): string;
	changed(): void;
}
export declare function addMenuOptions(options: MenuOptions, depth: number, d?: number): VDOMArray[];
export declare function filterOptions(options: MenuOptions, search: string, depth?: number, elements?: VDOMArray[], d?: number): any;
export declare class IoMenuTree extends IoElement {
	static get Style(): string;
	options: MenuOptions;
	searchable: boolean;
	search: string;
	depth: number;
	slotted: VDOMArray[];
	role: string;
	$parent?: IoMenuItem;
	static get Listeners(): {
		"item-clicked": string;
	};
	_onItemClicked(event: CustomEvent): void;
	_onCollapse(): void;
	changed(): void;
}
/**
 * Option select element. Similar to `IoMenuItem`, except it is displayed as a button and uses `options` property instead of ~~`option.options`~~  and it is `selectable` by default. It displays selected `value` or `label` followed by the `` character.
 *
 * <io-element-demo element="io-option-menu" properties='{
 *   "label": "",
 *   "value": 0,
 *   "options": [1,2,3]}
 * ' config='{"type:object": ["io-properties"]}'></io-element-demo>
 *
 * <io-element-demo element="io-option-menu" properties='{
 *   "label": "",
 *   "value": 0,
 *   "options": [
 *     {"value": 0, "label": "zero"},
 *     {"value": 1, "label": "one"},
 *     {"value": 2, "label": "two"},
 *     {"value": 3, "label": "three"}
 *   ]
 * }' config='{"type:object": ["io-properties"]}'></io-element-demo>
 *
 * When clicked or activated by space/enter key, it expands a menu with selectable options.
 **/
export declare class IoOptionMenu extends IoElement {
	static get Style(): string;
	value: any;
	options: MenuOptions;
	role: string;
	private _item;
	_onLeafChanged(event: CustomEvent): void;
	optionsChanged(change: Change): void;
	changed(): void;
}
/**
 * An invisible element that inserts a floating menu when its `parentElement` is clicked. Menu position is set by the pointer by default but it can be configured to expand to the side of the parent element by setting the `position` property. Default `button` property for menu expansion is `0` (left mouse button), but it can be configured for other buttons. You can have multiple `IoContextMenu` instances under the same `parentElement` as long as the `button` properties are different.
 **/
export declare class IoContextMenu extends IoElement {
	options: MenuOptions;
	expanded: boolean;
	button: number;
	static get Properties(): any;
	connectedCallback(): void;
	disconnectedCallback(): void;
	getBoundingClientRect(): any;
	_onItemClicked(event: CustomEvent): void;
	_onContextmenu(event: MouseEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onOverlayPointermove(event: PointerEvent): void;
	_onClick(event: MouseEvent): void;
	_onCollapse(): void;
	optionsChanged(): void;
}
export declare class IoNotify extends IoElement {
	static get Style(): string;
	static get Properties(): any;
	static get Listeners(): {};
	constructor(props?: any);
	_onAgree(event: CustomEvent): void;
	_onDisgree(): void;
}
export declare class ObjectConfig {
	constructor(prototypes: any);
	registerObjectConfig(config: any): void;
	getObjectConfig(object: any, customConfig: any): any;
}
export declare class ObjectGroups {
	constructor(prototypes: any);
	registerObjectGroups(groups: any): void;
	getObjectGroups(object: any, customGroups: any, keys: any): any;
}
export declare class ObjectWidgets {
	constructor(prototypes: any);
	registerObjectWidgets(widgets: any): void;
	getObjectWidgets(object: any): {
		main: any;
		groups: any;
	};
}
/**
 * Breadcrumbs select element.
 * When breadcrumb item is clicked or activated by space/enter key, it sets the value to corresponding option value.
 * Optionally, it can trim the `options` array to selected option index.
 **/
export declare class IoBreadcrumbs extends IoElement {
	static get Style(): string;
	static get Properties(): any;
	_onClick(event: CustomEvent): void;
	valueChanged(): void;
	selectedChanged(): void;
	changed(): void;
}
/**
 * Object property editor. It displays a set of labeled property editors for the `value` object inside multiple `io-collapsable` elements. It can be configured to use custom property editors and display only specified properties. Properties of type `Object` are displayed as clickable links which can also be navigated in the `io-breadcrumbs` element.
 **/
export declare class IoInspector extends IoElement {
	static get Style(): string;
	value: Record<string, any> | any[];
	selected: Record<string, any> | any[];
	config: Record<string, any>;
	uuid: string;
	search: string;
	groups: Record<string, any>;
	widgets: Record<string, any>;
	static get Listeners(): {
		"io-field-clicked": string;
	};
	_onItemClicked(event: CustomEvent): void;
	valueChanged(): void;
	advancedChanged(): void;
	selectedMutated(): void;
	changed(): void;
	_onChangedThrottled(): void;
	_onChange(): void;
	static get Config(): (ObjectConstructor | ((string[] | BooleanConstructor)[] | ((string | {
		appearance: string;
		class: string;
	})[] | null)[] | ((string | {
		appearance: string;
	})[] | undefined)[] | (StringConstructor | (string | {
		appearance: string;
	})[])[] | (NumberConstructor | (string | {
		appearance: string;
		step: number;
	})[])[] | (ObjectConstructor | (string | {
		appearance: string;
		class: string;
	})[])[])[])[][];
	static get ObjectGroups(): {
		"Object|hidden": RegExp[];
		"Array|main": RegExp[];
		"HTMLElement|main": (string | RegExp)[];
		"HTMLElement|hidden": (string | RegExp)[];
		"HTMLElement|content": RegExp[];
		"HTMLElement|display": RegExp[];
		"HTMLElement|hierarchy": RegExp[];
	};
	static get ObjectWidgets(): {};
	Register(ioNodeConstructor: typeof IoNode): void;
}
type PropertyTypeKey = Constructor | string | null | undefined;
type PropertyConfig = [
	PropertyTypeKey,
	VDOMArray
];
type PropertyConfigCollection = [
	Constructor,
	PropertyConfig[]
];
export interface IoPropertiesConstructor<T> extends IoNodeConstructor<T> {
	Config?: PropertyConfigCollection[];
}
export declare class ProtoObjectConfig extends Map<Constructor, Map<PropertyTypeKey, VDOMArray>> {
	constructor(constructors: IoPropertiesConstructor<any>[]);
	getObjectConfig(object: object): Record<string, VDOMArray> | undefined;
}
/**
 * Object editor. It displays a set of labeled property editors for the `value` object. Labels can be omitted by setting `labeled` property to false.
 **/
export declare class IoProperties extends IoElement {
	static get Style(): string;
	value: Record<string, any> | any[];
	properties: string[];
	config: Record<string, any>;
	widget: VDOMArray;
	labeled: boolean;
	static get Config(): PropertyConfigCollection[];
	_onValueInput(event: CustomEvent): void;
	valueMutated(): void;
	changed(): void;
	_changedThrottled(): void;
	_onChange(): void;
	Register(ioNodeConstructor: typeof IoNode): void;
}
/**
 * Object property editor. It displays a set of labeled property editors for the `value` object inside io-collapsable element. It can be configured to use custom property editors and display only specified properties.
 **/
export declare class IoObject extends IoElement {
	static get Style(): string;
	value: Record<string, any> | any[];
	properties: string[];
	config: Record<string, any>;
	widget: VDOMArray;
	labeled: boolean;
	label: string;
	expanded: boolean;
	role: string;
	changed(): void;
}
/**
 * Input element for `Array(2)` data type displayed as slider.
 * It can be configured to clamp the `value` compoents to `min` / `max` and round it to the nearest `step` increment. `exponent` property can be changed for non-linear scale.
 *
 * Keys left/right/up/down+shift and pageup/pagedown change the value in step incements. Home/end keys set the value to min/max.
 *
 * <io-element-demo element="io-slider-range" properties='{"value": [0, 1], "step": 0.1, "min": -1, "max": 2, "exponent": 1}'></io-element-demo>
 **/
export declare class IoSliderRange extends IoSliderBase {
	value: [
		number,
		number
	];
	step: number;
	min: number;
	max: number;
	_index: number;
	_getCoordFromValue(value: [
		number,
		number
	]): number[];
	_onPointerdown(event: PointerEvent): void;
	_onPointermoveThrottled(event: PointerEvent): void;
	static get Frag(): string;
}
/**
 * Input element for `Array(2)` data type combining `IoNumber` and `IoSliderRange`
 *
 * <io-element-demo element="io-number-slider-range" properties='{"value": [0, 2], "step": 0.05, "min": -1, "max": 2}'></io-element-demo>
 **/
export declare class IoNumberSliderRange extends IoElement {
	static get Style(): string;
	value: [
		number,
		number
	];
	step: number;
	min: number;
	max: number;
	exponent: number;
	conversion: number;
	_onNumberSet(event: CustomEvent): void;
	_onSliderSet(event: CustomEvent): void;
	init(): void;
	changed(): void;
}
/**
 * Input element for `Number` data type combining `IoNumber` and `IoSlider`
 *
 * <io-element-demo element="io-number-slider" properties='{"value": 0, "step": 0.01, "conversion": 1, "min": -0.5, "max": 0.5, "exponent": 1}'></io-element-demo>
 * <io-element-demo element="io-number-slider" properties='{"value": 0, "step": 0.2617993877991494, "conversion": 57.29577951308232, "min": -6.283185307179586, "max": 6.283185307179586, "exponent": 1}'></io-element-demo>
 * <io-element-demo element="io-number-slider" properties='{"value": 0, "step": 0.1, "conversion": 0.2, "min": -0.5, "max": 0.5, "exponent": 1}'></io-element-demo>
 **/
export declare class IoNumberSlider extends IoElement {
	static get Style(): string;
	value: number;
	step: number;
	min: number;
	max: number;
	exponent: number;
	conversion: number;
	_onNumberSet(event: CustomEvent): void;
	_onSliderSet(event: CustomEvent): void;
	init(): void;
	changed(): void;
}
/** @License
 * Copyright 2024 Aleksandar (Aki) Rodic
 *
 * The MIT License
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
 * THE SOFTWARE.
 */
export declare const LICENSE = "MIT";

export {
	PropertyDefinition$1 as PropertyDefinition,
};

export {};
