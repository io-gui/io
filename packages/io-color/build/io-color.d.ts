// Generated by dts-bundle-generator v9.5.1

type Properties = string[];
type TargetProperties = WeakMap<IoNode, Properties>;
declare class Binding {
	readonly node: IoNode;
	readonly property: string;
	readonly targets: IoNode[];
	readonly targetProperties: TargetProperties;
	/**
	 * Creates a binding object for specified source `node` and `property`.
	 * It attaches a `[propName]-changed` listener to the source node.
	 * @param {IoNode} node - Source node
	 * @param {string} property - Name of the sourceproperty
	 */
	constructor(node: IoNode, property: string);
	set value(value: any);
	get value(): any;
	/**
	 * Returns a JSON representation of the binding.
	 * This is required for `JSON.stringify(protoProperties)` in `ProtoChain` to work more accurately.
	 * NOTE: this does not provide completely accurate signiture of the binding but it's good enough.
	 * @return {string} JSON representation of the binding.
	 */
	toJSON(): {
		node: string;
		property: string;
		targets: string[];
		targetProperties: Record<string, Properties>;
	};
	/**
	 * Helper function to get target properties from WeakMap
	 * Retrieves a list of target properties for specified target node.
	 * @param {IoNode} target - Target node.
	 * @return {Properties} list of target property names.
	 */
	getTargetProperties(target: IoNode): Properties;
	/**
	 * Adds a target node and property.
	 * Sets itself as the binding reference on the target `PropertyInstance`.
	 * Adds a `[propName]-changed` listener to the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	addTarget(target: IoNode, property: string): void;
	/**
	 * Removes target node and property.
	 * If `property` is not specified, it removes all target properties.
	 * Removes binding reference from the target `PropertyInstance`.
	 * Removes `[propName]-changed` listener from the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	removeTarget(target: IoNode, property?: string): void;
	/**
	 * Event handler that updates source property when one of the targets emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onTargetChanged(event: ChangeEvent): void;
	/**
	 * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onSourceChanged(event: ChangeEvent): void;
	/**
	 * Dispose of the binding by removing all targets and listeners.
	 * Use this when node is no longer needed.
	 */
	dispose(): void;
}
type PropertyDefinition$1 = {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
};
type PropertyDefinitionLoose = string | number | boolean | Array<any> | null | undefined | Constructor | Binding | PropertyDefinition$1;
declare class ProtoProperty {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
	/**
	 * Creates a property definition from various input types.
	 * @param {PropertyDefinitionLoose} def Input definition which can be:
	 * - `undefined` or `null`: Sets as value
	 * - `Constructor`: Sets as type
	 * - `Binding`: Sets value from binding and stores binding reference
	 * - `PropertyDefinition`: Copies all defined fields
	 * - Other values: Sets as value
	 * @example
	 * new ProtoProperty(String) // {type: String}
	 * new ProtoProperty('hello') // {value: 'hello'}
	 * new ProtoProperty({value: 42, type: Number}) // {value: 42, type: Number}
	 * new ProtoProperty(new Binding(node, 'value')) // {value: node.value, binding: ...}
	 */
	constructor(def: PropertyDefinitionLoose);
	/**
	 * Assigns values of another ProtoProperty to itself, unless they are default values.
	 * @param {ProtoProperty} protoProp Source ProtoProperty
	 */
	assign(protoProp: ProtoProperty): void;
	/**
	 * Creates a serializable representation of the property definition.
	 * Handles special cases for better JSON serialization:
	 * - Converts object values to their constructor names
	 * - Converts function types to their names
	 * - Only includes defined fields
	 * @returns {object} A plain object suitable for JSON serialization
	 */
	toJSON(): any;
}
declare class PropertyInstance {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect: boolean;
	init?: any;
	/**
	 * Creates the property configuration object and copies values from `ProtoProperty`.
	 * @param node owner IoNode instance
	 * @param propDef ProtoProperty object
	 */
	constructor(node: IoNode, propDef: ProtoProperty);
}
interface KeyboardEventListener {
	(event: KeyboardEvent): void;
}
interface PointerEventListener {
	(event: PointerEvent): void;
}
interface CustomEventListener {
	(event: CustomEvent): void;
}
interface FocusEventListener {
	(event: FocusEvent): void;
}
interface TouchEventListener {
	(event: TouchEvent): void;
}
interface ChangeEventListener {
	(event: ChangeEvent): void;
}
interface IoEventListener {
	(event: {
		detail: any;
		target: IoNode;
		path: IoNode[];
	}): void;
}
type AnyEventListener = EventListener | KeyboardEventListener | PointerEventListener | CustomEventListener | FocusEventListener | TouchEventListener | ChangeEventListener | IoEventListener;
type ListenerDefinition = [
	string | AnyEventListener,
	AddEventListenerOptions?
];
type ListenerDefinitionLoose = string | AnyEventListener | ListenerDefinition;
type Listener = [
	AnyEventListener,
	AddEventListenerOptions?
];
type Listeners = Record<string, Listener[]>;
declare class EventDispatcher {
	readonly node: IoNode | EventTarget;
	readonly isEventTarget: boolean;
	readonly protoListeners: Listeners;
	readonly propListeners: Listeners;
	readonly addedListeners: Listeners;
	/**
	 * Creates an instance of `EventDispatcher` for specified `IoNode` instance.
	 * It initializes `protoListeners` from `ProtoChain`.
	 * @param {IoNode} node owner IoNode
	 */
	constructor(node: IoNode | EventTarget);
	/**
	 * Sets `protoListeners` specified as `get Listeners()` class definitions.
	 * Definitions from subclass replace the ones from parent class.
	 * @param {IoNode} node owner IoNode
	 */
	setProtoListeners(node: IoNode): void;
	/**
	 * Sets `propListeners` specified as inline properties prefixed with "@".
	 * It removes existing `propListeners` that are no longer specified and it replaces the ones that changed.
	 * @param {Record<string, any>} properties - Inline properties
	 */
	applyPropListeners(properties: Record<string, any>): void;
	/**
	 * Proxy for `addEventListener` method.
	 * Adds an event listener to the node's `addedListeners` collection.
	 * If the node is an EventTarget, also registers the listener with the DOM.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	 */
	addEventListener(name: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Proxy for `removeEventListener` method.
	 * Removes an event listener from the node's `addedListeners` collection.
	 * If `listener` is not specified it removes all listeners for specified `type`.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	*/
	removeEventListener(name: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Shorthand for custom event dispatch.
	 * @param {string} name - Name of the event
	 * @param {any} detail - Event detail data
	 * @param {boolean} [bubbles] - Makes event bubble
	 * @param {EventTarget} [node] - Event target override to dispatch the event from
	 */
	dispatchEvent(name: string, detail?: any, bubbles?: boolean, node?: EventTarget | IoNode): void;
	/**
	 * Disconnects all event listeners and removes all references for garbage collection.
	 * Use this when node is discarded.
	 */
	dispose(): void;
}
type ProtoConstructors = Array<IoNodeConstructor<any>>;
type ProtoHandlers = string[];
type ProtoProperties = {
	[property: string]: ProtoProperty;
};
type ProtoListeners = {
	[property: string]: ListenerDefinition[];
};
declare class ProtoChain {
	/**
	 * Array of inherited class constructors
	 */
	constructors: ProtoConstructors;
	/**
	 * Aggregated property definition declared in `static get Properties()`
	 */
	properties: ProtoProperties;
	/**
	 * Aggregated listener definition declared in `static get Listeners()`
	 */
	listeners: ProtoListeners;
	/**
	 * Aggregated CSS style definition declared in `static get Style()`
	 */
	styles: string;
	/**
	 * Array of function names that start with "on[A-Z]" or "_on[A-Z]" for auto-binding.
	 */
	handlers: ProtoHandlers;
	/**
	 * Array of property names of mutation-observed object properties.
	 */
	observedObjectProperties: string[];
	/**
	 * Array of property names of mutation-observed IoNode properties.
	 */
	observedIoNodeProperties: string[];
	/**
	 * Creates an instance of `ProtoChain` for specified class constructor.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	constructor(ioNodeConstructor: IoNodeConstructor<any>);
	/**
	 * Adds properties defined in decorators to the properties array.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	addPropertiesFromDecorators(ioNodeConstructor: IoNodeConstructor<any>): void;
	/**
	 * Adds static properties from `static get Properties()` to the properties array.
	 * Only process properties if they differ from superclass.
	 * This prevents 'static get Properties()' from overriding subclass properties defined in decorators.
	 * @param {PropertyDefinitions} properties - Properties to add
	 * @param {string} prevHash - Previous properties hash
	 * @returns {string} - Updated properties hash
	 */
	addStaticProperties(properties?: PropertyDefinitions, prevHash?: string): string;
	/**
	 * Merges or appends a listener definitions to the existing listeners array.
	 * @param {ListenerDefinitions} listenerDefs - Listener definitions to add
	 */
	addListeners(listenerDefs?: ListenerDefinitions): void;
	/**
	 * Adds a style string to the styles array.
	 * @param {string} style - Style string to add
	 */
	addStyles(style?: string): void;
	/**
	 * Adds function names that start with "on[A-Z]" or "_on[A-Z]" to the handlers array.
	 * @param {IoNode} proto - Prototype object to search for handlers
	 */
	addHandlers(proto: IoNode): void;
	/**
	 * Creates observedObjectProperties array.
	 * @returns {string[]} - Array of property names that are observed as native objects.
	 */
	getObservedObjectProperties(): string[];
	/**
	 * Creates observedIoNodeProperties array.
	 * @returns {string[]} - Array of property names that are observed as IoNode objects.
	 */
	getObservedIoNodeProperties(): string[];
	/**
	 * Debug only.
	 * Validates property definitions.
	 * Logs warnings for incorrect property definitions.
	 * @returns {void}
	 */
	validateProperties(): void;
	/**
	 * Auto-binds event handler methods (starting with 'on[A-Z]' or '_on[A-Z]') to preserve their 'this' context.
	 * NOTE: Defining handlers as arrow functions will not work because they are not defined before constructor has finished.
	 * @param {IoNode} node - Target node instance
	 */
	autobindHandlers(node: IoNode): void;
}
type Constructor = new (...args: any[]) => unknown;
type PropertyDefinitions = Record<string, PropertyDefinitionLoose>;
type ListenerDefinitions = Record<string, ListenerDefinitionLoose>;
interface IoNodeConstructor<T> {
	new (...args: any[]): T;
	Properties?: PropertyDefinitions;
	Listeners?: ListenerDefinitions;
	Style?: string;
}
type CallbackFunction = (arg?: any) => void;
declare const IoNode_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		applyProperties(props: any): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		setProperties(props: any): void;
		/**
		 * Sets the property value, connects the bindings and sets attributes for properties with attribute reflection enabled.
		 * @param {string} name Property name to set value of.
		 * @param {any} value Peroperty value.
		 * @param {boolean} [debounce] flag to skip event dispatch.
		 */
		setProperty(name: string, value: any, debounce?: boolean): void;
		/**
		 * Sets value property and emits `value-input` event.
		 * Use this when value property is set by user action (e.g. mouse click).
		 * @param {*} value - Property value.
		 */
		inputValue(value: any): void;
		/**
		 * default change handler.
		 * Invoked when one of the properties change.
		 */
		changed(): void;
		init(): void;
		/**
		 * Adds property change to the queue.
		 * @param {string} name - Property name.
		 * @param {*} value - Property value.
		 * @param {*} oldValue - Old property value.
		 */
		queue(name: string, value: any, oldValue: any): void;
		/**
		 * Dispatches the queue in the next rAF cycle if `reactivity` property is set to `"debounced"`. Otherwise it dispatches the queue immediately.
		 */
		dispatchQueue(debounce?: boolean): void;
		/**
		 * Throttles function execution once per frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for throttled function.
		 */
		throttle(func: CallbackFunction, arg?: any): void;
		/**
		 * Debounces function execution to next frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for debounced function.
		 * @param {number} timeout - minimum delay in ms before executing the function.
		 */
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		/**
		 * Event handler for 'object-mutated' events emitted from the properties which are IoNode instances.
		 * Aditionally, it handles events emitted from the `window` object (used for observing non-IoNode object properties).
		 * NOTE: non-IoNode objects don't emit 'object-mutated' event automatically - something needs to emit this for them.
		 * This is used to evoke '[propName]Mutated()' mutation handler
		 * @param {Object} event - Event payload.
		 * @param {EventTarget} event.target - Node that emitted the event.
		 * @param {IoNode} event.detail.object - Mutated node.
		 */
		onPropertyMutated(event: CustomEvent): void;
		/**
		 * Returns a binding to a specified property`.
		 * @param {string} name - Property name to bind to.
		 * @return {Binding} Binding object.
		 */
		bind(name: string): Binding;
		/**
		 * Unbinds a binding to a specified property`.
		 * @param {string} name - Property name to unbind.
		 */
		unbind(name: string): void;
		/**
		 * Wrapper for addEventListener.
		 * @param {string} type - listener name.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for removeEventListener.
		 * @param {string} type - event name to listen to.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for dispatchEvent.
		 * @param {string} type - event name to dispatch.
		 * @param {Object} detail - event detail.
		 * @param {boolean} bubbles - event bubbles.
		 * @param {HTMLElement|Node} src source node/element to dispatch event from.
		 */
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		/**
		 * Disposes all internals.
		 * Use this when instance is no longer needed.
		 */
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoNode extends IoNode_base {
}
interface Change {
	property: string;
	value: any;
	oldValue: any;
}
interface ChangeEvent extends Omit<CustomEvent<Change>, "target"> {
	readonly target: IoNode;
	readonly detail: Change;
	readonly path: IoNode[];
}
declare class ChangeQueue {
	readonly node: IoNode;
	readonly changes: Change[];
	hasChanged: boolean;
	dispatching: boolean;
	/**
	 * Creates change queue for the specified owner instance of `IoNode`.
	 * @param {IoNode} node - Owner node.
	 */
	constructor(node: IoNode);
	/**
	 * Adds property change payload to the queue by specifying property name, previous and the new value.
	 * If the change is already in the queue, the new value is updated in-queue.
	 * If the new value is the same as the original value, the change is removed from the queue.
	 * @param {string} property - Property name.
	 * @param {any} value Property value.
	 * @param {any} oldValue Old property value.
	 */
	queue(property: string, value: any, oldValue: any): void;
	/**
	 * Dispatches and clears the queue.
	 * For each property change in the queue:
	 *  - It executes node's `[propName]Changed(change)` change handler function if it is defined.
	 *  - It fires the `'[propName]-changed'` `ChangeEvent` from the owner node with `Change` data as `event.detail`.
	 * After all changes are dispatched it invokes `.changed()` function of the owner node instance and fires `'changed'` event.
	 */
	dispatch(): void;
	/**
	 * Clears the queue and removes the node reference for garbage collection.
	 * Use this when node queue is no longer needed.
	 */
	dispose(): void;
}
declare const IoElement_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		setProperty(name: string, value: any, debounce?: boolean): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(name: string, value: any, oldValue: any): void;
		dispatchQueue(debounce?: boolean): void;
		throttle(func: CallbackFunction, arg?: any): void;
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		onPropertyMutated(event: CustomEvent): void;
		bind(name: string): Binding;
		unbind(name: string): void;
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoElement extends IoElement_base {
	static get Style(): string;
	$: Record<string, any>;
	tabindex: string;
	contenteditable: boolean;
	class: string;
	role: string;
	label: string;
	name: string;
	title: string;
	id: string;
	hidden: boolean;
	disabled: boolean;
	constructor(...args: any[]);
	/**
	* Add resize listener if `onResized()` is defined in subclass.
	*/
	connectedCallback(): void;
	/**
	* Removes resize listener if `onResized()` is defined in subclass.
	*/
	disconnectedCallback(): void;
	setProperty(name: string, value: any, debounce?: boolean): void;
	/**
	 * Renders DOM from virtual DOM arrays.
	 * @param {Array} vDOM - Array of vDOM children.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	template(vDOM: Array<any>, host?: HTMLElement, cache?: boolean): void;
	/**
	 * Recurively traverses vDOM.
	 * TODO: test element.traverse() function!
	 * @param {Array} vChildren - Array of vDOM children converted by `buildTree()` for easier parsing.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	traverse(vChildren: Array<any>, host: HTMLElement, cache?: boolean): void;
	Register(ioNodeConstructor: typeof IoNode): void;
	/**
	* Helper function to flatten textContent into a single TextNode.
	* Update textContent via TextNode is better for layout performance.
	* @param {HTMLElement} element - Element to flatten.
	*/
	_flattenTextNode(element: HTMLElement | IoElement): void;
	get textNode(): any;
	set textNode(value: any);
	applyProperties(props: any): void;
	/**
	* Alias for HTMLElement setAttribute where falsey values remove the attribute.
	* @param {string} attr - Attribute name.
	* @param {*} value - Attribute value.
	*/
	setAttribute(attr: string, value: boolean | number | string): void;
	labelChanged(): void;
	disabledChanged(): void;
}
export declare class IoColorBase extends IoElement {
	value: {
		r: number;
		g: number;
		b: number;
		a?: number;
	};
	rgba: [
		number,
		number,
		number,
		number
	];
	hsv: [
		number,
		number,
		number
	];
	hsl: [
		number,
		number,
		number
	];
	init(): void;
	valueMutated(): void;
	rgbFromHsv(): void;
	rgbFromHsl(): void;
	valueFromRgb(): void;
	valueChanged(): void;
}
type Properties$1 = string[];
type TargetProperties$1 = WeakMap<IoNode$1, Properties$1>;
declare class Binding$1 {
	readonly node: IoNode$1;
	readonly property: string;
	readonly targets: IoNode$1[];
	readonly targetProperties: TargetProperties$1;
	/**
	 * Creates a binding object for specified source `node` and `property`.
	 * It attaches a `[propName]-changed` listener to the source node.
	 * @param {IoNode} node - Source node
	 * @param {string} property - Name of the sourceproperty
	 */
	constructor(node: IoNode$1, property: string);
	set value(value: any);
	get value(): any;
	/**
	 * Returns a JSON representation of the binding.
	 * This is required for `JSON.stringify(protoProperties)` in `ProtoChain` to work more accurately.
	 * NOTE: this does not provide completely accurate signiture of the binding but it's good enough.
	 * @return {string} JSON representation of the binding.
	 */
	toJSON(): {
		node: string;
		property: string;
		targets: string[];
		targetProperties: Record<string, Properties$1>;
	};
	/**
	 * Helper function to get target properties from WeakMap
	 * Retrieves a list of target properties for specified target node.
	 * @param {IoNode} target - Target node.
	 * @return {Properties} list of target property names.
	 */
	getTargetProperties(target: IoNode$1): Properties$1;
	/**
	 * Adds a target node and property.
	 * Sets itself as the binding reference on the target `PropertyInstance`.
	 * Adds a `[propName]-changed` listener to the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	addTarget(target: IoNode$1, property: string): void;
	/**
	 * Removes target node and property.
	 * If `property` is not specified, it removes all target properties.
	 * Removes binding reference from the target `PropertyInstance`.
	 * Removes `[propName]-changed` listener from the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	removeTarget(target: IoNode$1, property?: string): void;
	/**
	 * Event handler that updates source property when one of the targets emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onTargetChanged(event: ChangeEvent$1): void;
	/**
	 * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onSourceChanged(event: ChangeEvent$1): void;
	/**
	 * Dispose of the binding by removing all targets and listeners.
	 * Use this when node is no longer needed.
	 */
	dispose(): void;
}
type PropertyDefinition$1$1 = {
	value?: any;
	type?: Constructor$1;
	binding?: Binding$1;
	reflect?: boolean;
	init?: any;
};
type PropertyDefinitionLoose$1 = string | number | boolean | Array<any> | null | undefined | Constructor$1 | Binding$1 | PropertyDefinition$1$1;
declare class ProtoProperty$1 {
	value?: any;
	type?: Constructor$1;
	binding?: Binding$1;
	reflect?: boolean;
	init?: any;
	/**
	 * Creates a property definition from various input types.
	 * @param {PropertyDefinitionLoose} def Input definition which can be:
	 * - `undefined` or `null`: Sets as value
	 * - `Constructor`: Sets as type
	 * - `Binding`: Sets value from binding and stores binding reference
	 * - `PropertyDefinition`: Copies all defined fields
	 * - Other values: Sets as value
	 * @example
	 * new ProtoProperty(String) // {type: String}
	 * new ProtoProperty('hello') // {value: 'hello'}
	 * new ProtoProperty({value: 42, type: Number}) // {value: 42, type: Number}
	 * new ProtoProperty(new Binding(node, 'value')) // {value: node.value, binding: ...}
	 */
	constructor(def: PropertyDefinitionLoose$1);
	/**
	 * Assigns values of another ProtoProperty to itself, unless they are default values.
	 * @param {ProtoProperty} protoProp Source ProtoProperty
	 */
	assign(protoProp: ProtoProperty$1): void;
	/**
	 * Creates a serializable representation of the property definition.
	 * Handles special cases for better JSON serialization:
	 * - Converts object values to their constructor names
	 * - Converts function types to their names
	 * - Only includes defined fields
	 * @returns {object} A plain object suitable for JSON serialization
	 */
	toJSON(): any;
}
declare class PropertyInstance$1 {
	value?: any;
	type?: Constructor$1;
	binding?: Binding$1;
	reflect: boolean;
	init?: any;
	/**
	 * Creates the property configuration object and copies values from `ProtoProperty`.
	 * @param node owner IoNode instance
	 * @param propDef ProtoProperty object
	 */
	constructor(node: IoNode$1, propDef: ProtoProperty$1);
}
interface KeyboardEventListener$1 {
	(event: KeyboardEvent): void;
}
interface PointerEventListener$1 {
	(event: PointerEvent): void;
}
interface CustomEventListener$1 {
	(event: CustomEvent): void;
}
interface FocusEventListener$1 {
	(event: FocusEvent): void;
}
interface TouchEventListener$1 {
	(event: TouchEvent): void;
}
interface ChangeEventListener$1 {
	(event: ChangeEvent$1): void;
}
interface IoEventListener$1 {
	(event: {
		detail: any;
		target: IoNode$1;
		path: IoNode$1[];
	}): void;
}
type AnyEventListener$1 = EventListener | KeyboardEventListener$1 | PointerEventListener$1 | CustomEventListener$1 | FocusEventListener$1 | TouchEventListener$1 | ChangeEventListener$1 | IoEventListener$1;
type ListenerDefinition$1 = [
	string | AnyEventListener$1,
	AddEventListenerOptions?
];
type ListenerDefinitionLoose$1 = string | AnyEventListener$1 | ListenerDefinition$1;
type Listener$1 = [
	AnyEventListener$1,
	AddEventListenerOptions?
];
type Listeners$1 = Record<string, Listener$1[]>;
declare class EventDispatcher$1 {
	readonly node: IoNode$1 | EventTarget;
	readonly isEventTarget: boolean;
	readonly protoListeners: Listeners$1;
	readonly propListeners: Listeners$1;
	readonly addedListeners: Listeners$1;
	/**
	 * Creates an instance of `EventDispatcher` for specified `IoNode` instance.
	 * It initializes `protoListeners` from `ProtoChain`.
	 * @param {IoNode} node owner IoNode
	 */
	constructor(node: IoNode$1 | EventTarget);
	/**
	 * Sets `protoListeners` specified as `get Listeners()` class definitions.
	 * Definitions from subclass replace the ones from parent class.
	 * @param {IoNode} node owner IoNode
	 */
	setProtoListeners(node: IoNode$1): void;
	/**
	 * Sets `propListeners` specified as inline properties prefixed with "@".
	 * It removes existing `propListeners` that are no longer specified and it replaces the ones that changed.
	 * @param {Record<string, any>} properties - Inline properties
	 */
	applyPropListeners(properties: Record<string, any>): void;
	/**
	 * Proxy for `addEventListener` method.
	 * Adds an event listener to the node's `addedListeners` collection.
	 * If the node is an EventTarget, also registers the listener with the DOM.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	 */
	addEventListener(name: string, listener: AnyEventListener$1, options?: AddEventListenerOptions): void;
	/**
	 * Proxy for `removeEventListener` method.
	 * Removes an event listener from the node's `addedListeners` collection.
	 * If `listener` is not specified it removes all listeners for specified `type`.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	*/
	removeEventListener(name: string, listener?: AnyEventListener$1, options?: AddEventListenerOptions): void;
	/**
	 * Shorthand for custom event dispatch.
	 * @param {string} name - Name of the event
	 * @param {any} detail - Event detail data
	 * @param {boolean} [bubbles] - Makes event bubble
	 * @param {EventTarget} [node] - Event target override to dispatch the event from
	 */
	dispatchEvent(name: string, detail?: any, bubbles?: boolean, node?: EventTarget | IoNode$1): void;
	/**
	 * Disconnects all event listeners and removes all references for garbage collection.
	 * Use this when node is discarded.
	 */
	dispose(): void;
}
type ProtoConstructors$1 = Array<IoNodeConstructor$1<any>>;
type ProtoHandlers$1 = string[];
type ProtoProperties$1 = {
	[property: string]: ProtoProperty$1;
};
type ProtoListeners$1 = {
	[property: string]: ListenerDefinition$1[];
};
declare class ProtoChain$1 {
	/**
	 * Array of inherited class constructors
	 */
	constructors: ProtoConstructors$1;
	/**
	 * Aggregated property definition declared in `static get Properties()`
	 */
	properties: ProtoProperties$1;
	/**
	 * Aggregated listener definition declared in `static get Listeners()`
	 */
	listeners: ProtoListeners$1;
	/**
	 * Aggregated CSS style definition declared in `static get Style()`
	 */
	styles: string;
	/**
	 * Array of function names that start with "on[A-Z]" or "_on[A-Z]" for auto-binding.
	 */
	handlers: ProtoHandlers$1;
	/**
	 * Array of property names of mutation-observed object properties.
	 */
	observedObjectProperties: string[];
	/**
	 * Array of property names of mutation-observed IoNode properties.
	 */
	observedIoNodeProperties: string[];
	/**
	 * Creates an instance of `ProtoChain` for specified class constructor.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	constructor(ioNodeConstructor: IoNodeConstructor$1<any>);
	/**
	 * Adds properties defined in decorators to the properties array.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	addPropertiesFromDecorators(ioNodeConstructor: IoNodeConstructor$1<any>): void;
	/**
	 * Adds static properties from `static get Properties()` to the properties array.
	 * Only process properties if they differ from superclass.
	 * This prevents 'static get Properties()' from overriding subclass properties defined in decorators.
	 * @param {PropertyDefinitions} properties - Properties to add
	 * @param {string} prevHash - Previous properties hash
	 * @returns {string} - Updated properties hash
	 */
	addStaticProperties(properties?: PropertyDefinitions$1, prevHash?: string): string;
	/**
	 * Merges or appends a listener definitions to the existing listeners array.
	 * @param {ListenerDefinitions} listenerDefs - Listener definitions to add
	 */
	addListeners(listenerDefs?: ListenerDefinitions$1): void;
	/**
	 * Adds a style string to the styles array.
	 * @param {string} style - Style string to add
	 */
	addStyles(style?: string): void;
	/**
	 * Adds function names that start with "on[A-Z]" or "_on[A-Z]" to the handlers array.
	 * @param {IoNode} proto - Prototype object to search for handlers
	 */
	addHandlers(proto: IoNode$1): void;
	/**
	 * Creates observedObjectProperties array.
	 * @returns {string[]} - Array of property names that are observed as native objects.
	 */
	getObservedObjectProperties(): string[];
	/**
	 * Creates observedIoNodeProperties array.
	 * @returns {string[]} - Array of property names that are observed as IoNode objects.
	 */
	getObservedIoNodeProperties(): string[];
	/**
	 * Debug only.
	 * Validates property definitions.
	 * Logs warnings for incorrect property definitions.
	 * @returns {void}
	 */
	validateProperties(): void;
	/**
	 * Auto-binds event handler methods (starting with 'on[A-Z]' or '_on[A-Z]') to preserve their 'this' context.
	 * NOTE: Defining handlers as arrow functions will not work because they are not defined before constructor has finished.
	 * @param {IoNode} node - Target node instance
	 */
	autobindHandlers(node: IoNode$1): void;
}
type Constructor$1 = new (...args: any[]) => unknown;
type PropertyDefinitions$1 = Record<string, PropertyDefinitionLoose$1>;
type ListenerDefinitions$1 = Record<string, ListenerDefinitionLoose$1>;
interface IoNodeConstructor$1<T> {
	new (...args: any[]): T;
	Properties?: PropertyDefinitions$1;
	Listeners?: ListenerDefinitions$1;
	Style?: string;
}
type CallbackFunction$1 = (arg?: any) => void;
declare const IoNode_base$1: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain$1;
		readonly _properties: Map<string, PropertyInstance$1>;
		readonly _bindings: Map<string, Binding$1>;
		readonly _changeQueue: ChangeQueue$1;
		readonly _eventDispatcher: EventDispatcher$1;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		applyProperties(props: any): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		setProperties(props: any): void;
		/**
		 * Sets the property value, connects the bindings and sets attributes for properties with attribute reflection enabled.
		 * @param {string} name Property name to set value of.
		 * @param {any} value Peroperty value.
		 * @param {boolean} [debounce] flag to skip event dispatch.
		 */
		setProperty(name: string, value: any, debounce?: boolean): void;
		/**
		 * Sets value property and emits `value-input` event.
		 * Use this when value property is set by user action (e.g. mouse click).
		 * @param {*} value - Property value.
		 */
		inputValue(value: any): void;
		/**
		 * default change handler.
		 * Invoked when one of the properties change.
		 */
		changed(): void;
		init(): void;
		/**
		 * Adds property change to the queue.
		 * @param {string} name - Property name.
		 * @param {*} value - Property value.
		 * @param {*} oldValue - Old property value.
		 */
		queue(name: string, value: any, oldValue: any): void;
		/**
		 * Dispatches the queue in the next rAF cycle if `reactivity` property is set to `"debounced"`. Otherwise it dispatches the queue immediately.
		 */
		dispatchQueue(debounce?: boolean): void;
		/**
		 * Throttles function execution once per frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for throttled function.
		 */
		throttle(func: CallbackFunction$1, arg?: any): void;
		/**
		 * Debounces function execution to next frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for debounced function.
		 * @param {number} timeout - minimum delay in ms before executing the function.
		 */
		debounce(func: CallbackFunction$1, arg?: any, timeout?: number): void;
		/**
		 * Event handler for 'object-mutated' events emitted from the properties which are IoNode instances.
		 * Aditionally, it handles events emitted from the `window` object (used for observing non-IoNode object properties).
		 * NOTE: non-IoNode objects don't emit 'object-mutated' event automatically - something needs to emit this for them.
		 * This is used to evoke '[propName]Mutated()' mutation handler
		 * @param {Object} event - Event payload.
		 * @param {EventTarget} event.target - Node that emitted the event.
		 * @param {IoNode} event.detail.object - Mutated node.
		 */
		onPropertyMutated(event: CustomEvent): void;
		/**
		 * Returns a binding to a specified property`.
		 * @param {string} name - Property name to bind to.
		 * @return {Binding} Binding object.
		 */
		bind(name: string): Binding$1;
		/**
		 * Unbinds a binding to a specified property`.
		 * @param {string} name - Property name to unbind.
		 */
		unbind(name: string): void;
		/**
		 * Wrapper for addEventListener.
		 * @param {string} type - listener name.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		addEventListener(type: string, listener: AnyEventListener$1, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for removeEventListener.
		 * @param {string} type - event name to listen to.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		removeEventListener(type: string, listener?: AnyEventListener$1, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for dispatchEvent.
		 * @param {string} type - event name to dispatch.
		 * @param {Object} detail - event detail.
		 * @param {boolean} bubbles - event bubbles.
		 * @param {HTMLElement|Node} src source node/element to dispatch event from.
		 */
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		/**
		 * Disposes all internals.
		 * Use this when instance is no longer needed.
		 */
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode$1): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions$1;
};
declare class IoNode$1 extends IoNode_base$1 {
}
interface Change$1 {
	property: string;
	value: any;
	oldValue: any;
}
interface ChangeEvent$1 extends Omit<CustomEvent<Change$1>, "target"> {
	readonly target: IoNode$1;
	readonly detail: Change$1;
	readonly path: IoNode$1[];
}
declare class ChangeQueue$1 {
	readonly node: IoNode$1;
	readonly changes: Change$1[];
	hasChanged: boolean;
	dispatching: boolean;
	/**
	 * Creates change queue for the specified owner instance of `IoNode`.
	 * @param {IoNode} node - Owner node.
	 */
	constructor(node: IoNode$1);
	/**
	 * Adds property change payload to the queue by specifying property name, previous and the new value.
	 * If the change is already in the queue, the new value is updated in-queue.
	 * If the new value is the same as the original value, the change is removed from the queue.
	 * @param {string} property - Property name.
	 * @param {any} value Property value.
	 * @param {any} oldValue Old property value.
	 */
	queue(property: string, value: any, oldValue: any): void;
	/**
	 * Dispatches and clears the queue.
	 * For each property change in the queue:
	 *  - It executes node's `[propName]Changed(change)` change handler function if it is defined.
	 *  - It fires the `'[propName]-changed'` `ChangeEvent` from the owner node with `Change` data as `event.detail`.
	 * After all changes are dispatched it invokes `.changed()` function of the owner node instance and fires `'changed'` event.
	 */
	dispatch(): void;
	/**
	 * Clears the queue and removes the node reference for garbage collection.
	 * Use this when node queue is no longer needed.
	 */
	dispose(): void;
}
declare const IoElement_base$1: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain$1;
		readonly _properties: Map<string, PropertyInstance$1>;
		readonly _bindings: Map<string, Binding$1>;
		readonly _changeQueue: ChangeQueue$1;
		readonly _eventDispatcher: EventDispatcher$1;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		setProperty(name: string, value: any, debounce?: boolean): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(name: string, value: any, oldValue: any): void;
		dispatchQueue(debounce?: boolean): void;
		throttle(func: CallbackFunction$1, arg?: any): void;
		debounce(func: CallbackFunction$1, arg?: any, timeout?: number): void;
		onPropertyMutated(event: CustomEvent): void;
		bind(name: string): Binding$1;
		unbind(name: string): void;
		addEventListener(type: string, listener: AnyEventListener$1, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener$1, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode$1): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions$1;
};
declare class IoElement$1 extends IoElement_base$1 {
	static get Style(): string;
	$: Record<string, any>;
	tabindex: string;
	contenteditable: boolean;
	class: string;
	role: string;
	label: string;
	name: string;
	title: string;
	id: string;
	hidden: boolean;
	disabled: boolean;
	constructor(...args: any[]);
	/**
	* Add resize listener if `onResized()` is defined in subclass.
	*/
	connectedCallback(): void;
	/**
	* Removes resize listener if `onResized()` is defined in subclass.
	*/
	disconnectedCallback(): void;
	setProperty(name: string, value: any, debounce?: boolean): void;
	/**
	 * Renders DOM from virtual DOM arrays.
	 * @param {Array} vDOM - Array of vDOM children.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	template(vDOM: Array<any>, host?: HTMLElement, cache?: boolean): void;
	/**
	 * Recurively traverses vDOM.
	 * TODO: test element.traverse() function!
	 * @param {Array} vChildren - Array of vDOM children converted by `buildTree()` for easier parsing.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	traverse(vChildren: Array<any>, host: HTMLElement, cache?: boolean): void;
	Register(ioNodeConstructor: typeof IoNode$1): void;
	/**
	* Helper function to flatten textContent into a single TextNode.
	* Update textContent via TextNode is better for layout performance.
	* @param {HTMLElement} element - Element to flatten.
	*/
	_flattenTextNode(element: HTMLElement | IoElement$1): void;
	get textNode(): any;
	set textNode(value: any);
	applyProperties(props: any): void;
	/**
	* Alias for HTMLElement setAttribute where falsey values remove the attribute.
	* @param {string} attr - Attribute name.
	* @param {*} value - Attribute value.
	*/
	setAttribute(attr: string, value: boolean | number | string): void;
	labelChanged(): void;
	disabledChanged(): void;
}
declare class Color {
	r: number;
	g: number;
	b: number;
	a: number;
	constructor(r: number, g: number, b: number, a: number);
	toCss(): string;
}
type Theme = {
	spacing: number;
	spacing2: number;
	spacing3: number;
	spacing5: number;
	spacing8: number;
	fontSize: number;
	lineHeight: number;
	fieldHeight: number;
	fieldHeight2: number;
	fieldHeight3: number;
	fieldHeight4: number;
	fieldHeight5: number;
	fieldHeight6: number;
	fieldHeight7: number;
	fieldHeight8: number;
	fieldHeight9: number;
	fieldHeight10: number;
	fieldHeight11: number;
	fieldHeight12: number;
	borderRadius: number;
	borderRadius2: number;
	borderWidth: number;
	borderColor: Color;
	borderColorLight: Color;
	borderColorDark: Color;
	bgColor: Color;
	bgColorStrong: Color;
	bgColorDimmed: Color;
	bgColorRed: Color;
	bgColorGreen: Color;
	bgColorBlue: Color;
	bgColorField: Color;
	color: Color;
	colorStrong: Color;
	colorDimmed: Color;
	colorRed: Color;
	colorGreen: Color;
	colorBlue: Color;
	colorWhite: Color;
	colorField: Color;
	gradientColorStart: Color;
	gradientColorEnd: Color;
	shadowColor: Color;
};
declare class IoTheme extends IoNode$1 {
	static get Properties(): PropertyDefinitions$1;
	themeDefaults: Record<string, Theme>;
	themeID: string;
	reactivity: string;
	init(): void;
	registerTheme(themeID: string, theme: Theme): void;
	reset(): void;
	themeIDChanged(): void;
	onPropertyMutated(event: CustomEvent): void;
	changed(): void;
	saveTheme(): void;
}
declare const IoThemeSingleton: IoTheme;
declare class IoGl extends IoElement$1 {
	static get Style(): string;
	transparent: boolean;
	size: [
		number,
		number
	];
	color: [
		number,
		number,
		number,
		number
	];
	pxRatio: number;
	theme: typeof IoThemeSingleton;
	reactivity: string;
	needsResize: boolean;
	canvas: HTMLCanvasElement;
	ctx: CanvasRenderingContext2D;
	static get Vert(): string;
	static get GlUtils(): string;
	static get Frag(): string;
	initPropertyUniform(name: string, property: PropertyDefinition$1$1): string;
	initShader(): WebGLProgram;
	constructor(properties?: Record<string, any>);
	onResized(): void;
	themeMutated(): void;
	changed(): void;
	_onRender(): void;
	setShaderProgram(): void;
	updatePropertyUniform(name: string, property: PropertyInstance$1): void;
	updateThemeUniforms(): void;
	setUniform(name: string, value: any): void;
	Register(ioNodeConstructor: typeof IoElement$1): void;
}
declare class IoSliderBase extends IoGl {
	static get Style(): string;
	value: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	step: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	min: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	max: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	exponent: number;
	vertical: boolean;
	noscroll: boolean;
	role: string;
	tabindex: string;
	_startX: number;
	_startY: number;
	_active: number;
	_rect: DOMRect | null;
	get _min(): [
		number,
		number
	];
	get _max(): [
		number,
		number
	];
	get _step(): [
		number,
		number
	];
	get _value(): [
		number,
		number
	];
	static get Listeners(): {
		focus: string;
		contextmenu: string;
		pointerdown: string;
		touchstart: (string | {
			passive: boolean;
		})[];
	};
	_onFocus(): void;
	_onBlur(): void;
	_onContextmenu(event: Event): void;
	_onTouchstart(event: TouchEvent): void;
	_onTouchmove(event: TouchEvent): void;
	_onTouchend(): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_getPointerCoord(event: PointerEvent): [
		number,
		number
	];
	_getValueFromCoord(coord: [
		number,
		number
	]): [
		number,
		number
	];
	_onPointermoveThrottled(event: PointerEvent): void;
	_inputValue(value: [
		number,
		number
	]): void;
	_onKeydown(event: KeyboardEvent): void;
	_setIncrease(): void;
	_setDecrease(): void;
	_setMin(): void;
	_setMax(): void;
	_setUp(): void;
	_setDown(): void;
	_setLeft(): void;
	_setRight(): void;
	init(): void;
	changed(): void;
}
declare class IoSlider2d extends IoSliderBase {
	static get Style(): string;
	value: [
		number,
		number
	];
	step: [
		number,
		number
	];
	min: [
		number,
		number
	];
	max: [
		number,
		number
	];
	noscroll: boolean;
	static get GlUtils(): string;
	static get Frag(): string;
}
declare class IoSlider extends IoSliderBase {
	value: number;
	step: number;
	min: number;
	max: number;
	static get Frag(): string;
}
/**
 * A generic color slider element.
 * It is a wrapper for channel-specific sliders which are added as a child of this element depending on the `channel` property.
 * For example, setting `channel: 'h'` will instantiate a slider for "hue" color channel and hook up necessary conversions, bindings and event callbacks.
 *
 * <io-element-demo element="io-color-slider-hs"
 * width="64px" height="64px"
 * properties='{"value": [1, 0.5, 0, 1], "horizontal": true}'
 * config='{"value": ["io-properties"]}
 * '></io-element-demo>
 **/
export declare class IoColorSlider extends IoColorBase {
	static get Style(): string;
	color: [
		number,
		number,
		number,
		number
	];
	step: number;
	channel: string;
	vertical: boolean;
	_onValueInput(event: CustomEvent): void;
	changed(): void;
}
/**
 * A base class for 1D color slider.
 * It as an incomplete implementation of a color slider desiged to be fully implemented in channel-specific subclasses.
 **/
export declare class IoColorSliderBase extends IoSlider {
	static get GlUtils(): string;
	static get Frag(): string;
}
/**
 * A base class for 2D color slider.
 * It as an incomplete implementation of a color slider desiged to be fully implemented in channel-specific subclasses.
 **/
export declare class IoColorSlider2dBase extends IoSlider2d {
	static get GlUtils(): string;
	static get Frag(): string;
}
/**
 * A 1D slider for "red" color channel.
 **/
export declare class IoColorSliderR extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "green" color channel.
 **/
export declare class IoColorSliderG extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "blue" color channel.
 **/
export declare class IoColorSliderB extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "alpha" color channel.
 **/
export declare class IoColorSliderA extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "hue" color channel.
 **/
export declare class IoColorSliderH extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "saturation" color channel.
 **/
export declare class IoColorSliderS extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "value" color channel.
 **/
export declare class IoColorSliderV extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 1D slider for "level" color channel.
 **/
export declare class IoColorSliderL extends IoColorSliderBase {
	static get GlUtils(): string;
}
/**
 * A 2D slider gor "hue" and "saturation" color channels.
 **/
export declare class IoColorSliderHs extends IoColorSlider2dBase {
	static get GlUtils(): string;
}
/**
 * A 2D slider gor "saturation" and "value" color channels.
 **/
export declare class IoColorSliderSv extends IoColorSlider2dBase {
	static get GlUtils(): string;
}
/**
 * A 2D slider gor "saturation" and "level" color channels.
 **/
export declare class IoColorSliderSL extends IoColorSlider2dBase {
	static get GlUtils(): string;
}
/**
 * Input element for color displayed as a set of sliders.
 *
 * <io-element-demo element="io-color-panel"
 * width= "192px"
 * height= "128px"
 * properties='{"mode": 0, "value": [1, 0.5, 0, 1], "horizontal": true}'
 * config='{"value": ["io-properties"], "mode": ["io-option-menu", {"options": [{"value": 0, "label": "0 - rgb"}, {"value": 1, "label": "1 - hsv"}, {"value": 2, "label": "2 - hsl"}]}]}
 * '></io-element-demo>
 *
 * This element has a singleton instance `IoColorPanelSingleton` used by `IoColorPicker` and other elements.
 **/
export declare class IoColorPanel extends IoColorBase {
	static get Style(): string;
	expanded: boolean;
	vertical: boolean;
	inlayer: boolean;
	static get Listeners(): {
		keydown: string;
	};
	_onKeydown(event: KeyboardEvent): void;
	onValueSet(): void;
	changed(): void;
}
export declare const IoColorPanelSingleton: IoColorPanel;
/**
 * Element displaying colored square.
 *
 * <io-element-demo element="io-color-swatch"
 * properties='{"value": [1, 0.5, 0, 1]}'
 * config='{"value": ["io-properties"]}
 * '></io-element-demo>
 **/
export declare class IoColorSwatch extends IoColorBase {
	static get Style(): string;
	valueChanged(): void;
}
export declare class IoColorPicker extends IoElement {
	static get Style(): string;
	value: {
		r: number;
		g: number;
		b: number;
		a?: number;
	};
	static get Listeners(): any;
	tabindex: string;
	_onClick(event: FocusEvent): void;
	get expanded(): boolean;
	_onKeydown(event: KeyboardEvent): void;
	_onValueSet(): void;
	toggle(): void;
	expand(): void;
	collapse(): void;
	changed(): void;
}
/**
 * Input element for color displayed as vector and an interactive picker.
 **/
export declare class IoColorRgba extends IoColorBase {
	static get Style(): string;
	_onNumberValueInput(event: CustomEvent): void;
	changed(): void;
}

export {};
