// Generated by dts-bundle-generator v9.5.1

type Properties = string[];
type TargetProperties = WeakMap<IoNode, Properties>;
declare class Binding {
	readonly node: IoNode;
	readonly property: string;
	readonly targets: IoNode[];
	readonly targetProperties: TargetProperties;
	/**
	 * Creates a binding object for specified source `node` and `property`.
	 * It attaches a `[propName]-changed` listener to the source node.
	 * @param {IoNode} node - Source node
	 * @param {string} property - Name of the sourceproperty
	 */
	constructor(node: IoNode, property: string);
	set value(value: any);
	get value(): any;
	/**
	 * Returns a JSON representation of the binding.
	 * This is required for `JSON.stringify(protoProperties)` in `ProtoChain` to work more accurately.
	 * NOTE: this does not provide completely accurate signiture of the binding but it's good enough.
	 * @return {string} JSON representation of the binding.
	 */
	toJSON(): {
		node: string;
		property: string;
		targets: string[];
		targetProperties: Record<string, Properties>;
	};
	/**
	 * Helper function to get target properties from WeakMap
	 * Retrieves a list of target properties for specified target node.
	 * @param {IoNode} target - Target node.
	 * @return {Properties} list of target property names.
	 */
	getTargetProperties(target: IoNode): Properties;
	/**
	 * Adds a target node and property.
	 * Sets itself as the binding reference on the target `PropertyInstance`.
	 * Adds a `[propName]-changed` listener to the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	addTarget(target: IoNode, property: string): void;
	/**
	 * Removes target node and property.
	 * If `property` is not specified, it removes all target properties.
	 * Removes binding reference from the target `PropertyInstance`.
	 * Removes `[propName]-changed` listener from the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	removeTarget(target: IoNode, property?: string): void;
	/**
	 * Event handler that updates source property when one of the targets emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onTargetChanged(event: ChangeEvent): void;
	/**
	 * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onSourceChanged(event: ChangeEvent): void;
	/**
	 * Dispose of the binding by removing all targets and listeners.
	 * Use this when node is no longer needed.
	 */
	dispose(): void;
}
type PropertyDefinition$1 = {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
};
type PropertyDefinitionLoose = string | number | boolean | Array<any> | null | undefined | Constructor | Binding | PropertyDefinition$1;
declare class ProtoProperty {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
	/**
	 * Creates a property definition from various input types.
	 * @param {PropertyDefinitionLoose} def Input definition which can be:
	 * - `undefined` or `null`: Sets as value
	 * - `Constructor`: Sets as type
	 * - `Binding`: Sets value from binding and stores binding reference
	 * - `PropertyDefinition`: Copies all defined fields
	 * - Other values: Sets as value
	 * @example
	 * new ProtoProperty(String) // {type: String}
	 * new ProtoProperty('hello') // {value: 'hello'}
	 * new ProtoProperty({value: 42, type: Number}) // {value: 42, type: Number}
	 * new ProtoProperty(new Binding(node, 'value')) // {value: node.value, binding: ...}
	 */
	constructor(def: PropertyDefinitionLoose);
	/**
	 * Assigns values of another ProtoProperty to itself, unless they are default values.
	 * @param {ProtoProperty} protoProp Source ProtoProperty
	 */
	assign(protoProp: ProtoProperty): void;
	/**
	 * Creates a serializable representation of the property definition.
	 * Handles special cases for better JSON serialization:
	 * - Converts object values to their constructor names
	 * - Converts function types to their names
	 * - Only includes defined fields
	 * @returns {object} A plain object suitable for JSON serialization
	 */
	toJSON(): any;
}
declare class PropertyInstance {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect: boolean;
	init?: any;
	/**
	 * Creates the property configuration object and copies values from `ProtoProperty`.
	 * @param node owner IoNode instance
	 * @param propDef ProtoProperty object
	 */
	constructor(node: IoNode, propDef: ProtoProperty);
}
interface KeyboardEventListener {
	(event: KeyboardEvent): void;
}
interface PointerEventListener {
	(event: PointerEvent): void;
}
interface CustomEventListener {
	(event: CustomEvent): void;
}
interface FocusEventListener {
	(event: FocusEvent): void;
}
interface TouchEventListener {
	(event: TouchEvent): void;
}
interface ChangeEventListener {
	(event: ChangeEvent): void;
}
interface IoEventListener {
	(event: {
		detail: any;
		target: IoNode;
		path: IoNode[];
	}): void;
}
type AnyEventListener = EventListener | KeyboardEventListener | PointerEventListener | CustomEventListener | FocusEventListener | TouchEventListener | ChangeEventListener | IoEventListener;
type ListenerDefinition = [
	string | AnyEventListener,
	AddEventListenerOptions?
];
type ListenerDefinitionLoose = string | AnyEventListener | ListenerDefinition;
type Listener = [
	AnyEventListener,
	AddEventListenerOptions?
];
type Listeners = Record<string, Listener[]>;
declare class EventDispatcher {
	readonly node: IoNode | EventTarget;
	readonly isEventTarget: boolean;
	readonly protoListeners: Listeners;
	readonly propListeners: Listeners;
	readonly addedListeners: Listeners;
	/**
	 * Creates an instance of `EventDispatcher` for specified `IoNode` instance.
	 * It initializes `protoListeners` from `ProtoChain`.
	 * @param {IoNode} node owner IoNode
	 */
	constructor(node: IoNode | EventTarget);
	/**
	 * Sets `protoListeners` specified as `get Listeners()` class definitions.
	 * Definitions from subclass replace the ones from parent class.
	 * @param {IoNode} node owner IoNode
	 */
	setProtoListeners(node: IoNode): void;
	/**
	 * Sets `propListeners` specified as inline properties prefixed with "@".
	 * It removes existing `propListeners` that are no longer specified and it replaces the ones that changed.
	 * @param {Record<string, any>} properties - Inline properties
	 */
	applyPropListeners(properties: Record<string, any>): void;
	/**
	 * Proxy for `addEventListener` method.
	 * Adds an event listener to the node's `addedListeners` collection.
	 * If the node is an EventTarget, also registers the listener with the DOM.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	 */
	addEventListener(name: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Proxy for `removeEventListener` method.
	 * Removes an event listener from the node's `addedListeners` collection.
	 * If `listener` is not specified it removes all listeners for specified `type`.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	*/
	removeEventListener(name: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Shorthand for custom event dispatch.
	 * @param {string} name - Name of the event
	 * @param {any} detail - Event detail data
	 * @param {boolean} [bubbles] - Makes event bubble
	 * @param {EventTarget} [node] - Event target override to dispatch the event from
	 */
	dispatchEvent(name: string, detail?: any, bubbles?: boolean, node?: EventTarget | IoNode): void;
	/**
	 * Disconnects all event listeners and removes all references for garbage collection.
	 * Use this when node is discarded.
	 */
	dispose(): void;
}
type ProtoConstructors = Array<IoNodeConstructor<any>>;
type ProtoHandlers = string[];
type ProtoProperties = {
	[property: string]: ProtoProperty;
};
type ProtoListeners = {
	[property: string]: ListenerDefinition[];
};
declare class ProtoChain {
	/**
	 * Array of inherited class constructors
	 */
	constructors: ProtoConstructors;
	/**
	 * Aggregated property definition declared in `static get Properties()`
	 */
	properties: ProtoProperties;
	/**
	 * Aggregated listener definition declared in `static get Listeners()`
	 */
	listeners: ProtoListeners;
	/**
	 * Aggregated CSS style definition declared in `static get Style()`
	 */
	styles: string;
	/**
	 * Array of function names that start with "on[A-Z]" or "_on[A-Z]" for auto-binding.
	 */
	handlers: ProtoHandlers;
	/**
	 * Array of property names of mutation-observed object properties.
	 */
	observedObjectProperties: string[];
	/**
	 * Array of property names of mutation-observed IoNode properties.
	 */
	observedIoNodeProperties: string[];
	/**
	 * Creates an instance of `ProtoChain` for specified class constructor.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	constructor(ioNodeConstructor: IoNodeConstructor<any>);
	/**
	 * Adds properties defined in decorators to the properties array.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	addPropertiesFromDecorators(ioNodeConstructor: IoNodeConstructor<any>): void;
	/**
	 * Adds static properties from `static get Properties()` to the properties array.
	 * Only process properties if they differ from superclass.
	 * This prevents 'static get Properties()' from overriding subclass properties defined in decorators.
	 * @param {PropertyDefinitions} properties - Properties to add
	 * @param {string} prevHash - Previous properties hash
	 * @returns {string} - Updated properties hash
	 */
	addStaticProperties(properties?: PropertyDefinitions, prevHash?: string): string;
	/**
	 * Merges or appends a listener definitions to the existing listeners array.
	 * @param {ListenerDefinitions} listenerDefs - Listener definitions to add
	 */
	addListeners(listenerDefs?: ListenerDefinitions): void;
	/**
	 * Adds a style string to the styles array.
	 * @param {string} style - Style string to add
	 */
	addStyles(style?: string): void;
	/**
	 * Adds function names that start with "on[A-Z]" or "_on[A-Z]" to the handlers array.
	 * @param {IoNode} proto - Prototype object to search for handlers
	 */
	addHandlers(proto: IoNode): void;
	/**
	 * Creates observedObjectProperties array.
	 * @returns {string[]} - Array of property names that are observed as native objects.
	 */
	getObservedObjectProperties(): string[];
	/**
	 * Creates observedIoNodeProperties array.
	 * @returns {string[]} - Array of property names that are observed as IoNode objects.
	 */
	getObservedIoNodeProperties(): string[];
	/**
	 * Debug only.
	 * Validates property definitions.
	 * Logs warnings for incorrect property definitions.
	 * @returns {void}
	 */
	validateProperties(): void;
	/**
	 * Auto-binds event handler methods (starting with 'on[A-Z]' or '_on[A-Z]') to preserve their 'this' context.
	 * NOTE: Defining handlers as arrow functions will not work because they are not defined before constructor has finished.
	 * @param {IoNode} node - Target node instance
	 */
	autobindHandlers(node: IoNode): void;
}
type Constructor = new (...args: any[]) => unknown;
type PropertyDefinitions = Record<string, PropertyDefinitionLoose>;
type ListenerDefinitions = Record<string, ListenerDefinitionLoose>;
interface IoNodeConstructor<T> {
	new (...args: any[]): T;
	Properties?: PropertyDefinitions;
	Listeners?: ListenerDefinitions;
	Style?: string;
}
type CallbackFunction = (arg?: any) => void;
type prefix<TKey, TPrefix extends string> = TKey extends string ? `${TPrefix}${TKey}` : never;
type IoNodeArgs = {
	reactivity?: "none" | "immediate" | "debounced";
	[key: prefix<string, "@">]: string | ((event: CustomEvent<any>) => void);
};
declare const IoNode_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		applyProperties(props: any): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		setProperties(props: any): void;
		/**
		 * Sets the property value, connects the bindings and sets attributes for properties with attribute reflection enabled.
		 * @param {string} name Property name to set value of.
		 * @param {any} value Peroperty value.
		 * @param {boolean} [debounce] flag to skip event dispatch.
		 */
		setProperty(name: string, value: any, debounce?: boolean): void;
		/**
		 * Sets value property and emits `value-input` event.
		 * Use this when value property is set by user action (e.g. mouse click).
		 * @param {*} value - Property value.
		 */
		inputValue(value: any): void;
		/**
		 * default change handler.
		 * Invoked when one of the properties change.
		 */
		changed(): void;
		init(): void;
		/**
		 * Adds property change to the queue.
		 * @param {string} name - Property name.
		 * @param {*} value - Property value.
		 * @param {*} oldValue - Old property value.
		 */
		queue(name: string, value: any, oldValue: any): void;
		/**
		 * Dispatches the queue in the next rAF cycle if `reactivity` property is set to `"debounced"`. Otherwise it dispatches the queue immediately.
		 */
		dispatchQueue(debounce?: boolean): void;
		/**
		 * Throttles function execution once per frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for throttled function.
		 */
		throttle(func: CallbackFunction, arg?: any): void;
		/**
		 * Debounces function execution to next frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for debounced function.
		 * @param {number} timeout - minimum delay in ms before executing the function.
		 */
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		/**
		 * Event handler for 'object-mutated' events emitted from the properties which are IoNode instances.
		 * Aditionally, it handles events emitted from the `window` object (used for observing non-IoNode object properties).
		 * NOTE: non-IoNode objects don't emit 'object-mutated' event automatically - something needs to emit this for them.
		 * This is used to evoke '[propName]Mutated()' mutation handler
		 * @param {Object} event - Event payload.
		 * @param {EventTarget} event.target - Node that emitted the event.
		 * @param {IoNode} event.detail.object - Mutated node.
		 */
		onPropertyMutated(event: CustomEvent): void;
		/**
		 * Returns a binding to a specified property`.
		 * @param {string} name - Property name to bind to.
		 * @return {Binding} Binding object.
		 */
		bind(name: string): Binding;
		/**
		 * Unbinds a binding to a specified property`.
		 * @param {string} name - Property name to unbind.
		 */
		unbind(name: string): void;
		/**
		 * Wrapper for addEventListener.
		 * @param {string} type - listener name.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for removeEventListener.
		 * @param {string} type - event name to listen to.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for dispatchEvent.
		 * @param {string} type - event name to dispatch.
		 * @param {Object} detail - event detail.
		 * @param {boolean} bubbles - event bubbles.
		 * @param {HTMLElement|Node} src source node/element to dispatch event from.
		 */
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		/**
		 * Disposes all internals.
		 * Use this when instance is no longer needed.
		 */
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoNode extends IoNode_base {
}
interface Change {
	property: string;
	value: any;
	oldValue: any;
}
interface ChangeEvent extends Omit<CustomEvent<Change>, "target"> {
	readonly target: IoNode;
	readonly detail: Change;
	readonly path: IoNode[];
}
declare class ChangeQueue {
	readonly node: IoNode;
	readonly changes: Change[];
	hasChanged: boolean;
	dispatching: boolean;
	/**
	 * Creates change queue for the specified owner instance of `IoNode`.
	 * @param {IoNode} node - Owner node.
	 */
	constructor(node: IoNode);
	/**
	 * Adds property change payload to the queue by specifying property name, previous and the new value.
	 * If the change is already in the queue, the new value is updated in-queue.
	 * If the new value is the same as the original value, the change is removed from the queue.
	 * @param {string} property - Property name.
	 * @param {any} value Property value.
	 * @param {any} oldValue Old property value.
	 */
	queue(property: string, value: any, oldValue: any): void;
	/**
	 * Dispatches and clears the queue.
	 * For each property change in the queue:
	 *  - It executes node's `[propName]Changed(change)` change handler function if it is defined.
	 *  - It fires the `'[propName]-changed'` `ChangeEvent` from the owner node with `Change` data as `event.detail`.
	 * After all changes are dispatched it invokes `.changed()` function of the owner node instance and fires `'changed'` event.
	 */
	dispatch(): void;
	/**
	 * Clears the queue and removes the node reference for garbage collection.
	 * Use this when node queue is no longer needed.
	 */
	dispose(): void;
}
type IoElementArgs = IoNodeArgs & {
	tabindex?: string;
	contenteditable?: boolean;
	class?: string;
	role?: string;
	label?: string;
	name?: string;
	title?: string;
	id?: string;
	hidden?: boolean;
	disabled?: boolean;
	cache?: boolean;
	[key: string]: any;
};
type VDOMArray = [
	string
] | [
	string,
	IoElementArgs | string | VDOMArray[]
] | [
	string,
	IoElementArgs | string,
	VDOMArray[] | string
];
declare const IoElement_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		setProperty(name: string, value: any, debounce?: boolean): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(name: string, value: any, oldValue: any): void;
		dispatchQueue(debounce?: boolean): void;
		throttle(func: CallbackFunction, arg?: any): void;
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		onPropertyMutated(event: CustomEvent): void;
		bind(name: string): Binding;
		unbind(name: string): void;
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoElement extends IoElement_base {
	static get Style(): string;
	$: Record<string, any>;
	tabindex: string;
	contenteditable: boolean;
	class: string;
	role: string;
	label: string;
	name: string;
	title: string;
	id: string;
	hidden: boolean;
	disabled: boolean;
	constructor(...args: any[]);
	/**
	* Add resize listener if `onResized()` is defined in subclass.
	*/
	connectedCallback(): void;
	/**
	* Removes resize listener if `onResized()` is defined in subclass.
	*/
	disconnectedCallback(): void;
	setProperty(name: string, value: any, debounce?: boolean): void;
	/**
	 * Renders DOM from virtual DOM arrays.
	 * @param {Array} vDOM - Array of vDOM children.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	template(vDOM: Array<any>, host?: HTMLElement, cache?: boolean): void;
	/**
	 * Recurively traverses vDOM.
	 * TODO: test element.traverse() function!
	 * @param {Array} vChildren - Array of vDOM children converted by `buildTree()` for easier parsing.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	traverse(vChildren: Array<any>, host: HTMLElement, cache?: boolean): void;
	Register(ioNodeConstructor: typeof IoNode): void;
	/**
	* Helper function to flatten textContent into a single TextNode.
	* Update textContent via TextNode is better for layout performance.
	* @param {HTMLElement} element - Element to flatten.
	*/
	_flattenTextNode(element: HTMLElement | IoElement): void;
	get textNode(): any;
	set textNode(value: any);
	applyProperties(props: any): void;
	/**
	* Alias for HTMLElement setAttribute where falsey values remove the attribute.
	* @param {string} attr - Attribute name.
	* @param {*} value - Attribute value.
	*/
	setAttribute(attr: string, value: boolean | number | string): void;
	labelChanged(): void;
	disabledChanged(): void;
}
type NudgeDirection = "none" | "pointer" | "up" | "left" | "down" | "right";
declare class IoField extends IoElement {
	static get Style(): string;
	tabindex: string;
	value: any;
	icon: string;
	appearance: "flush" | "inset" | "outset" | "neutral";
	stroke: boolean;
	selected: boolean;
	invalid: boolean;
	placeholder: string;
	static get Listeners(): {
		"focus-to": string;
		focus: string;
		pointerdown: string;
		click: string;
	};
	_onFocus(event: FocusEvent): void;
	_onBlur(event: FocusEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerleave(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onClick(): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	_onFocusTo(event: CustomEvent): void;
	focusTo(dir: string): void;
	getCaretPosition(): number;
	setCaretPosition(position: number): void;
	changed(): void;
}
declare const MenuOptions_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		setProperty(name: string, value: any, debounce?: boolean): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(name: string, value: any, oldValue: any): void;
		dispatchQueue(debounce?: boolean): void;
		throttle(func: CallbackFunction, arg?: any): void;
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		onPropertyMutated(event: CustomEvent): void;
		bind(name: string): Binding;
		unbind(name: string): void;
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
export declare class MenuOptions extends MenuOptions_base {
	first: any;
	last: any;
	scroll: any;
	path: string;
	delimiter: string;
	push(...items: MenuItem[]): void;
	getItem(value: any, deep?: boolean): any;
	constructor(args?: MenuItemArgsLoose[], properties?: IoNodeArgs);
	protected addItems(items: MenuItemArgsLoose[]): void;
	pathChanged(): void;
	firstChanged(): void;
	lastChanged(): void;
	updatePaths(item?: MenuItem): void;
	_onItemSelectedChanged(event: CustomEvent): void;
	_onSubOptionsPathChanged(event: CustomEvent): void;
	selectDefault(): boolean;
	bind(prop: string): Binding;
	dispose(): void;
}
export type MenuItemSelectType = "select" | "scroll" | "toggle" | "link" | "none";
export type MenuItemArgsLoose = undefined | null | string | number | MenuItemArgs;
export type MenuItemArgs = IoElementArgs & {
	value?: any;
	icon?: string;
	hint?: string;
	action?: () => void;
	mode?: MenuItemSelectType;
	hidden?: boolean;
	disabled?: boolean;
	selected?: boolean;
	options?: MenuItemArgsLoose[] | MenuOptions;
};
export declare class MenuItem extends IoNode {
	value: any;
	label: string;
	icon: string;
	hint: string;
	hidden: boolean;
	disabled: boolean;
	action?: (value?: any) => void;
	mode: MenuItemSelectType;
	selected: boolean;
	options?: MenuOptions;
	get hasmore(): boolean;
	getSubitem(value: any): any;
	constructor(args?: MenuItemArgsLoose);
	toJSON(): Record<string, any>;
	_onSubItemSelected(): void;
	_onOptionsPathChanged(event: CustomEvent): void;
	optionsChanged(): void;
	selectedChanged(): void;
	dispose(): void;
}
/**
 * It generates a list of `IoMenuItem` elements from `options` property. If `horizontal` property is set, menu items are displayed in horizontal direction.
 **/
export declare class IoMenuOptions extends IoElement {
	static get Style(): string;
	options: MenuOptions;
	expanded: boolean;
	horizontal: boolean;
	searchable: boolean;
	search: string;
	direction: NudgeDirection;
	depth: number;
	noPartialCollapse: boolean;
	overflow: string;
	inlayer: boolean;
	slotted: VDOMArray[];
	role: string;
	$parent?: IoMenuItem;
	private _overflownItems;
	static get Listeners(): {
		"item-clicked": string;
		touchstart: (string | {
			passive: boolean;
		})[];
	};
	_onItemClicked(event: CustomEvent): void;
	_stopPropagation(event: MouseEvent): void;
	init(): void;
	onResized(): void;
	_onSetOverflow(): void;
	_onCollapse(): void;
	expandedChanged(): void;
	searchChanged(): void;
	_onExpandInOverlay(): void;
	_onClipHeight(): void;
	changed(): void;
}
/**
 * It displays `option.icon`, `option.label` and `option.hint` property and it creates expandable `IoMenuOptions` from the `option.options` array. Options are expand in the direction specified by `direction` property. If `selectable` property is set, selecting an option sets its `value` to the entire menu tree and `selected` atribute is set on menu items whose `option.value` matches selected value.
 **/
export declare class IoMenuItem extends IoField {
	static get Style(): string;
	item: MenuItem;
	expanded: boolean;
	direction: string;
	depth: number;
	$options?: IoMenuOptions;
	static get Listeners(): any;
	preventDefault(event: Event): void;
	get hasmore(): boolean;
	get inlayer(): boolean;
	get $parent(): any;
	connectedCallback(): void;
	disconnectedCallback(): void;
	_onOverlayPointermove(event: PointerEvent): void;
	_onOverlayPointerup(event: PointerEvent): void;
	_onClick(): void;
	_onItemClicked(event: PointerEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointerdownAction(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointermoveAction(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onPointerupAction(event: PointerEvent, skipCollapse?: boolean): void;
	_gethovered(event: PointerEvent): IoMenuElementType | undefined;
	_expandHovered(): void;
	_onKeydown(event: KeyboardEvent): void;
	_onCollapse(): void;
	_onCollapseRoot(): void;
	expandedChanged(): void;
	itemChanged(): void;
	changed(): void;
}
type IoMenuElementType = IoMenuItem | IoMenuOptions;
export declare function getMenuDescendants(element: IoMenuElementType): IoMenuElementType[];
export declare function getMenuAncestors(element: IoMenuElementType): (IoMenuItem | IoMenuOptions)[];
export declare function getMenuRoot(element: IoMenuElementType): IoMenuElementType;
export declare class IoMenuHamburger extends IoMenuItem {
	static get Style(): string;
	changed(): void;
}
export declare function addMenuOptions(options: MenuOptions, depth: number, d?: number): VDOMArray[];
export declare function filterOptions(options: MenuOptions, search: string, depth?: number, elements?: VDOMArray[], d?: number): any;
export declare class IoMenuTree extends IoElement {
	static get Style(): string;
	options: MenuOptions;
	searchable: boolean;
	search: string;
	depth: number;
	slotted: VDOMArray[];
	role: string;
	$parent?: IoMenuItem;
	static get Listeners(): {
		"item-clicked": string;
	};
	_onItemClicked(event: CustomEvent): void;
	_onCollapse(): void;
	changed(): void;
}
/**
 * Option select element. Similar to `IoMenuItem`, except it is displayed as a button and uses `options` property instead of ~~`option.options`~~  and it is `selectable` by default. It displays selected `value` or `label` followed by the `â–¾` character.
 *
 * <io-element-demo element="io-option-menu" properties='{
 *   "label": "",
 *   "value": 0,
 *   "options": [1,2,3]}
 * ' config='{"type:object": ["io-properties"]}'></io-element-demo>
 *
 * <io-element-demo element="io-option-menu" properties='{
 *   "label": "",
 *   "value": 0,
 *   "options": [
 *     {"value": 0, "label": "zero"},
 *     {"value": 1, "label": "one"},
 *     {"value": 2, "label": "two"},
 *     {"value": 3, "label": "three"}
 *   ]
 * }' config='{"type:object": ["io-properties"]}'></io-element-demo>
 *
 * When clicked or activated by space/enter key, it expands a menu with selectable options.
 **/
export declare class IoOptionMenu extends IoElement {
	static get Style(): string;
	value: any;
	options: MenuOptions;
	role: string;
	private _item;
	_onLeafChanged(event: CustomEvent): void;
	optionsChanged(change: Change): void;
	changed(): void;
}
/**
 * An invisible element that inserts a floating menu when its `parentElement` is clicked. Menu position is set by the pointer by default but it can be configured to expand to the side of the parent element by setting the `position` property. Default `button` property for menu expansion is `0` (left mouse button), but it can be configured for other buttons. You can have multiple `IoContextMenu` instances under the same `parentElement` as long as the `button` properties are different.
 **/
export declare class IoContextMenu extends IoElement {
	options: MenuOptions;
	expanded: boolean;
	button: number;
	static get Properties(): any;
	connectedCallback(): void;
	disconnectedCallback(): void;
	getBoundingClientRect(): any;
	_onItemClicked(event: CustomEvent): void;
	_onContextmenu(event: MouseEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onOverlayPointermove(event: PointerEvent): void;
	_onClick(event: MouseEvent): void;
	_onCollapse(): void;
	optionsChanged(): void;
}

export {};
