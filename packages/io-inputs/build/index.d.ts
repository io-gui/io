// Generated by dts-bundle-generator v9.5.1

type Properties = string[];
type TargetProperties = WeakMap<IoNode, Properties>;
declare class Binding {
	readonly node: IoNode;
	readonly property: string;
	readonly targets: IoNode[];
	readonly targetProperties: TargetProperties;
	/**
	 * Creates a binding object for specified source `node` and `property`.
	 * It attaches a `[propName]-changed` listener to the source node.
	 * @param {IoNode} node - Source node
	 * @param {string} property - Name of the sourceproperty
	 */
	constructor(node: IoNode, property: string);
	set value(value: any);
	get value(): any;
	/**
	 * Returns a JSON representation of the binding.
	 * This is required for `JSON.stringify(protoProperties)` in `ProtoChain` to work more accurately.
	 * NOTE: this does not provide completely accurate signiture of the binding but it's good enough.
	 * @return {string} JSON representation of the binding.
	 */
	toJSON(): {
		node: string;
		property: string;
		targets: string[];
		targetProperties: Record<string, Properties>;
	};
	/**
	 * Helper function to get target properties from WeakMap
	 * Retrieves a list of target properties for specified target node.
	 * @param {IoNode} target - Target node.
	 * @return {Properties} list of target property names.
	 */
	getTargetProperties(target: IoNode): Properties;
	/**
	 * Adds a target node and property.
	 * Sets itself as the binding reference on the target `PropertyInstance`.
	 * Adds a `[propName]-changed` listener to the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	addTarget(target: IoNode, property: string): void;
	/**
	 * Removes target node and property.
	 * If `property` is not specified, it removes all target properties.
	 * Removes binding reference from the target `PropertyInstance`.
	 * Removes `[propName]-changed` listener from the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	removeTarget(target: IoNode, property?: string): void;
	/**
	 * Event handler that updates source property when one of the targets emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onTargetChanged(event: ChangeEvent): void;
	/**
	 * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onSourceChanged(event: ChangeEvent): void;
	/**
	 * Dispose of the binding by removing all targets and listeners.
	 * Use this when node is no longer needed.
	 */
	dispose(): void;
}
type PropertyDefinition$1 = {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
};
type PropertyDefinitionLoose = string | number | boolean | Array<any> | null | undefined | Constructor | Binding | PropertyDefinition$1;
declare class ProtoProperty {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
	/**
	 * Creates a property definition from various input types.
	 * @param {PropertyDefinitionLoose} def Input definition which can be:
	 * - `undefined` or `null`: Sets as value
	 * - `Constructor`: Sets as type
	 * - `Binding`: Sets value from binding and stores binding reference
	 * - `PropertyDefinition`: Copies all defined fields
	 * - Other values: Sets as value
	 * @example
	 * new ProtoProperty(String) // {type: String}
	 * new ProtoProperty('hello') // {value: 'hello'}
	 * new ProtoProperty({value: 42, type: Number}) // {value: 42, type: Number}
	 * new ProtoProperty(new Binding(node, 'value')) // {value: node.value, binding: ...}
	 */
	constructor(def: PropertyDefinitionLoose);
	/**
	 * Assigns values of another ProtoProperty to itself, unless they are default values.
	 * @param {ProtoProperty} protoProp Source ProtoProperty
	 */
	assign(protoProp: ProtoProperty): void;
	/**
	 * Creates a serializable representation of the property definition.
	 * Handles special cases for better JSON serialization:
	 * - Converts object values to their constructor names
	 * - Converts function types to their names
	 * - Only includes defined fields
	 * @returns {object} A plain object suitable for JSON serialization
	 */
	toJSON(): any;
}
declare class PropertyInstance {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect: boolean;
	init?: any;
	/**
	 * Creates the property configuration object and copies values from `ProtoProperty`.
	 * @param node owner IoNode instance
	 * @param propDef ProtoProperty object
	 */
	constructor(node: IoNode, propDef: ProtoProperty);
}
interface KeyboardEventListener {
	(event: KeyboardEvent): void;
}
interface PointerEventListener {
	(event: PointerEvent): void;
}
interface CustomEventListener {
	(event: CustomEvent): void;
}
interface FocusEventListener {
	(event: FocusEvent): void;
}
interface TouchEventListener {
	(event: TouchEvent): void;
}
interface ChangeEventListener {
	(event: ChangeEvent): void;
}
interface IoEventListener {
	(event: {
		detail: any;
		target: IoNode;
		path: IoNode[];
	}): void;
}
type AnyEventListener = EventListener | KeyboardEventListener | PointerEventListener | CustomEventListener | FocusEventListener | TouchEventListener | ChangeEventListener | IoEventListener;
type ListenerDefinition = [
	string | AnyEventListener,
	AddEventListenerOptions?
];
type ListenerDefinitionLoose = string | AnyEventListener | ListenerDefinition;
type Listener = [
	AnyEventListener,
	AddEventListenerOptions?
];
type Listeners = Record<string, Listener[]>;
declare class EventDispatcher {
	readonly node: IoNode | EventTarget;
	readonly isEventTarget: boolean;
	readonly protoListeners: Listeners;
	readonly propListeners: Listeners;
	readonly addedListeners: Listeners;
	/**
	 * Creates an instance of `EventDispatcher` for specified `IoNode` instance.
	 * It initializes `protoListeners` from `ProtoChain`.
	 * @param {IoNode} node owner IoNode
	 */
	constructor(node: IoNode | EventTarget);
	/**
	 * Sets `protoListeners` specified as `get Listeners()` class definitions.
	 * Definitions from subclass replace the ones from parent class.
	 * @param {IoNode} node owner IoNode
	 */
	setProtoListeners(node: IoNode): void;
	/**
	 * Sets `propListeners` specified as inline properties prefixed with "@".
	 * It removes existing `propListeners` that are no longer specified and it replaces the ones that changed.
	 * @param {Record<string, any>} properties - Inline properties
	 */
	applyPropListeners(properties: Record<string, any>): void;
	/**
	 * Proxy for `addEventListener` method.
	 * Adds an event listener to the node's `addedListeners` collection.
	 * If the node is an EventTarget, also registers the listener with the DOM.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	 */
	addEventListener(name: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Proxy for `removeEventListener` method.
	 * Removes an event listener from the node's `addedListeners` collection.
	 * If `listener` is not specified it removes all listeners for specified `type`.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	*/
	removeEventListener(name: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Shorthand for custom event dispatch.
	 * @param {string} name - Name of the event
	 * @param {any} detail - Event detail data
	 * @param {boolean} [bubbles] - Makes event bubble
	 * @param {EventTarget} [node] - Event target override to dispatch the event from
	 */
	dispatchEvent(name: string, detail?: any, bubbles?: boolean, node?: EventTarget | IoNode): void;
	/**
	 * Disconnects all event listeners and removes all references for garbage collection.
	 * Use this when node is discarded.
	 */
	dispose(): void;
}
type ProtoConstructors = Array<IoNodeConstructor<any>>;
type ProtoHandlers = string[];
type ProtoProperties = {
	[property: string]: ProtoProperty;
};
type ProtoListeners = {
	[property: string]: ListenerDefinition[];
};
declare class ProtoChain {
	/**
	 * Array of inherited class constructors
	 */
	constructors: ProtoConstructors;
	/**
	 * Aggregated property definition declared in `static get Properties()`
	 */
	properties: ProtoProperties;
	/**
	 * Aggregated listener definition declared in `static get Listeners()`
	 */
	listeners: ProtoListeners;
	/**
	 * Aggregated CSS style definition declared in `static get Style()`
	 */
	styles: string;
	/**
	 * Array of function names that start with "on[A-Z]" or "_on[A-Z]" for auto-binding.
	 */
	handlers: ProtoHandlers;
	/**
	 * Array of property names of mutation-observed object properties.
	 */
	observedObjectProperties: string[];
	/**
	 * Array of property names of mutation-observed IoNode properties.
	 */
	observedIoNodeProperties: string[];
	/**
	 * Creates an instance of `ProtoChain` for specified class constructor.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	constructor(ioNodeConstructor: IoNodeConstructor<any>);
	/**
	 * Adds properties defined in decorators to the properties array.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	addPropertiesFromDecorators(ioNodeConstructor: IoNodeConstructor<any>): void;
	/**
	 * Adds static properties from `static get Properties()` to the properties array.
	 * Only process properties if they differ from superclass.
	 * This prevents 'static get Properties()' from overriding subclass properties defined in decorators.
	 * @param {PropertyDefinitions} properties - Properties to add
	 * @param {string} prevHash - Previous properties hash
	 * @returns {string} - Updated properties hash
	 */
	addStaticProperties(properties?: PropertyDefinitions, prevHash?: string): string;
	/**
	 * Merges or appends a listener definitions to the existing listeners array.
	 * @param {ListenerDefinitions} listenerDefs - Listener definitions to add
	 */
	addListeners(listenerDefs?: ListenerDefinitions): void;
	/**
	 * Adds a style string to the styles array.
	 * @param {string} style - Style string to add
	 */
	addStyles(style?: string): void;
	/**
	 * Adds function names that start with "on[A-Z]" or "_on[A-Z]" to the handlers array.
	 * @param {IoNode} proto - Prototype object to search for handlers
	 */
	addHandlers(proto: IoNode): void;
	/**
	 * Creates observedObjectProperties array.
	 * @returns {string[]} - Array of property names that are observed as native objects.
	 */
	getObservedObjectProperties(): string[];
	/**
	 * Creates observedIoNodeProperties array.
	 * @returns {string[]} - Array of property names that are observed as IoNode objects.
	 */
	getObservedIoNodeProperties(): string[];
	/**
	 * Debug only.
	 * Validates property definitions.
	 * Logs warnings for incorrect property definitions.
	 * @returns {void}
	 */
	validateProperties(): void;
	/**
	 * Auto-binds event handler methods (starting with 'on[A-Z]' or '_on[A-Z]') to preserve their 'this' context.
	 * NOTE: Defining handlers as arrow functions will not work because they are not defined before constructor has finished.
	 * @param {IoNode} node - Target node instance
	 */
	autobindHandlers(node: IoNode): void;
}
type Constructor = new (...args: any[]) => unknown;
type PropertyDefinitions = Record<string, PropertyDefinitionLoose>;
type ListenerDefinitions = Record<string, ListenerDefinitionLoose>;
interface IoNodeConstructor<T> {
	new (...args: any[]): T;
	Properties?: PropertyDefinitions;
	Listeners?: ListenerDefinitions;
	Style?: string;
}
type CallbackFunction = (arg?: any) => void;
declare const IoNode_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		applyProperties(props: any): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		setProperties(props: any): void;
		/**
		 * Sets the property value, connects the bindings and sets attributes for properties with attribute reflection enabled.
		 * @param {string} name Property name to set value of.
		 * @param {any} value Peroperty value.
		 * @param {boolean} [debounce] flag to skip event dispatch.
		 */
		setProperty(name: string, value: any, debounce?: boolean): void;
		/**
		 * Sets value property and emits `value-input` event.
		 * Use this when value property is set by user action (e.g. mouse click).
		 * @param {*} value - Property value.
		 */
		inputValue(value: any): void;
		/**
		 * default change handler.
		 * Invoked when one of the properties change.
		 */
		changed(): void;
		init(): void;
		/**
		 * Adds property change to the queue.
		 * @param {string} name - Property name.
		 * @param {*} value - Property value.
		 * @param {*} oldValue - Old property value.
		 */
		queue(name: string, value: any, oldValue: any): void;
		/**
		 * Dispatches the queue in the next rAF cycle if `reactivity` property is set to `"debounced"`. Otherwise it dispatches the queue immediately.
		 */
		dispatchQueue(debounce?: boolean): void;
		/**
		 * Throttles function execution once per frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for throttled function.
		 */
		throttle(func: CallbackFunction, arg?: any): void;
		/**
		 * Debounces function execution to next frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for debounced function.
		 * @param {number} timeout - minimum delay in ms before executing the function.
		 */
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		/**
		 * Event handler for 'object-mutated' events emitted from the properties which are IoNode instances.
		 * Aditionally, it handles events emitted from the `window` object (used for observing non-IoNode object properties).
		 * NOTE: non-IoNode objects don't emit 'object-mutated' event automatically - something needs to emit this for them.
		 * This is used to evoke '[propName]Mutated()' mutation handler
		 * @param {Object} event - Event payload.
		 * @param {EventTarget} event.target - Node that emitted the event.
		 * @param {IoNode} event.detail.object - Mutated node.
		 */
		onPropertyMutated(event: CustomEvent): void;
		/**
		 * Returns a binding to a specified property`.
		 * @param {string} name - Property name to bind to.
		 * @return {Binding} Binding object.
		 */
		bind(name: string): Binding;
		/**
		 * Unbinds a binding to a specified property`.
		 * @param {string} name - Property name to unbind.
		 */
		unbind(name: string): void;
		/**
		 * Wrapper for addEventListener.
		 * @param {string} type - listener name.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for removeEventListener.
		 * @param {string} type - event name to listen to.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for dispatchEvent.
		 * @param {string} type - event name to dispatch.
		 * @param {Object} detail - event detail.
		 * @param {boolean} bubbles - event bubbles.
		 * @param {HTMLElement|Node} src source node/element to dispatch event from.
		 */
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		/**
		 * Disposes all internals.
		 * Use this when instance is no longer needed.
		 */
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoNode extends IoNode_base {
}
interface Change {
	property: string;
	value: any;
	oldValue: any;
}
interface ChangeEvent extends Omit<CustomEvent<Change>, "target"> {
	readonly target: IoNode;
	readonly detail: Change;
	readonly path: IoNode[];
}
declare class ChangeQueue {
	readonly node: IoNode;
	readonly changes: Change[];
	hasChanged: boolean;
	dispatching: boolean;
	/**
	 * Creates change queue for the specified owner instance of `IoNode`.
	 * @param {IoNode} node - Owner node.
	 */
	constructor(node: IoNode);
	/**
	 * Adds property change payload to the queue by specifying property name, previous and the new value.
	 * If the change is already in the queue, the new value is updated in-queue.
	 * If the new value is the same as the original value, the change is removed from the queue.
	 * @param {string} property - Property name.
	 * @param {any} value Property value.
	 * @param {any} oldValue Old property value.
	 */
	queue(property: string, value: any, oldValue: any): void;
	/**
	 * Dispatches and clears the queue.
	 * For each property change in the queue:
	 *  - It executes node's `[propName]Changed(change)` change handler function if it is defined.
	 *  - It fires the `'[propName]-changed'` `ChangeEvent` from the owner node with `Change` data as `event.detail`.
	 * After all changes are dispatched it invokes `.changed()` function of the owner node instance and fires `'changed'` event.
	 */
	dispatch(): void;
	/**
	 * Clears the queue and removes the node reference for garbage collection.
	 * Use this when node queue is no longer needed.
	 */
	dispose(): void;
}
declare const IoElement_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		setProperty(name: string, value: any, debounce?: boolean): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(name: string, value: any, oldValue: any): void;
		dispatchQueue(debounce?: boolean): void;
		throttle(func: CallbackFunction, arg?: any): void;
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		onPropertyMutated(event: CustomEvent): void;
		bind(name: string): Binding;
		unbind(name: string): void;
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoElement extends IoElement_base {
	static get Style(): string;
	$: Record<string, any>;
	tabindex: string;
	contenteditable: boolean;
	class: string;
	role: string;
	label: string;
	name: string;
	title: string;
	id: string;
	hidden: boolean;
	disabled: boolean;
	constructor(...args: any[]);
	/**
	* Add resize listener if `onResized()` is defined in subclass.
	*/
	connectedCallback(): void;
	/**
	* Removes resize listener if `onResized()` is defined in subclass.
	*/
	disconnectedCallback(): void;
	setProperty(name: string, value: any, debounce?: boolean): void;
	/**
	 * Renders DOM from virtual DOM arrays.
	 * @param {Array} vDOM - Array of vDOM children.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	template(vDOM: Array<any>, host?: HTMLElement, cache?: boolean): void;
	/**
	 * Recurively traverses vDOM.
	 * TODO: test element.traverse() function!
	 * @param {Array} vChildren - Array of vDOM children converted by `buildTree()` for easier parsing.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	traverse(vChildren: Array<any>, host: HTMLElement, cache?: boolean): void;
	Register(ioNodeConstructor: typeof IoNode): void;
	/**
	* Helper function to flatten textContent into a single TextNode.
	* Update textContent via TextNode is better for layout performance.
	* @param {HTMLElement} element - Element to flatten.
	*/
	_flattenTextNode(element: HTMLElement | IoElement): void;
	get textNode(): any;
	set textNode(value: any);
	applyProperties(props: any): void;
	/**
	* Alias for HTMLElement setAttribute where falsey values remove the attribute.
	* @param {string} attr - Attribute name.
	* @param {*} value - Attribute value.
	*/
	setAttribute(attr: string, value: boolean | number | string): void;
	labelChanged(): void;
	disabledChanged(): void;
}
declare class IoField extends IoElement {
	static get Style(): string;
	tabindex: string;
	value: any;
	icon: string;
	appearance: "flush" | "inset" | "outset" | "neutral";
	stroke: boolean;
	selected: boolean;
	invalid: boolean;
	placeholder: string;
	static get Listeners(): {
		"focus-to": string;
		focus: string;
		pointerdown: string;
		click: string;
	};
	_onFocus(event: FocusEvent): void;
	_onBlur(event: FocusEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerleave(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onClick(): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	_onFocusTo(event: CustomEvent): void;
	focusTo(dir: string): void;
	getCaretPosition(): number;
	setCaretPosition(position: number): void;
	changed(): void;
}
/**
 * Input element for `Boolean` data type displayed as text.
 * It can be configured to display custom `true` or `false` string or icon depending on its `value`.
 *
 * <io-element-demo element="io-boolean" properties='{"value": true, "true": "true", "false": "false"}'></io-element-demo>
 **/
export declare class IoBoolean extends IoField {
	static get Style(): string;
	value: boolean;
	true: string;
	false: string;
	role: string;
	_onClick(): void;
	toggle(): void;
	init(): void;
	changed(): void;
}
export declare class IoBoolicon extends IoBoolean {
	changed(): void;
}
/**
 * Button element.
 * When clicked or activated by space/enter key, it calls the `action` property function with optional `value` argument.
 *
 * <io-element-demo element="io-button" properties='{"label": "Button", "action": "null"}'></io-element-demo>
 **/
export declare class IoButton extends IoField {
	static get Style(): string;
	action?: any;
	value: any;
	appearance: "flush" | "inset" | "outset" | "neutral";
	pressed: boolean;
	role: string;
	_onPointerdown(event: PointerEvent): void;
	_onPointerleave(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	_onClick(): void;
	init(): void;
	changed(): void;
}
/**
 * Input element for `Number` data type.
 * It clamps the `value` to `min` / `max` and rounds it to the nearest `step` increment.
 * If `ladder` property is enabled, it displays an interactive float ladder element when clicked/taped.
 * Alternatively, ladder can be expanded by middle click or ctrl key regardless of ladder property.
 **/
export declare class IoNumber extends IoField {
	static get Style(): string;
	role: string;
	value: number;
	conversion: number;
	step: number;
	min: number;
	max: number;
	ladder: boolean;
	contenteditable: boolean;
	type: string;
	pattern: string;
	inputmode: string;
	spellcheck: string;
	appearance: "flush" | "inset" | "outset";
	private _pointer;
	_onBlur(event: FocusEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onFocus(event: FocusEvent): void;
	_expandLadder(): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	_setFromTextNode(): void;
	init(): void;
	changed(): void;
}
export declare class IoNumberLadderStep extends IoField {
	static get Style(): string;
	value: number;
	type: string;
	role: string;
	_onKeydown(event: KeyboardEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	init(): void;
	changed(): void;
}
/**
 * Interactive number ladder.
 * When dragged horizontally, it changes the value in step increments.
 * Dragging speed affects the rate of change exponentially.
 * Up/down arrow keys change the step focus while left/right change the value in step increments.
 * Escape key collapses the ladder and restores the focus to previously focused element.
 * If shift key is pressed, value is rounded to the nearest step incement.
 *
 * <io-element-demo element="io-ladder" expanded properties='{"value": 0, "step": 0.0001, "conversion": 1, "min": -10000, "max": 10000, "expanded": true}'></io-element-demo>
 **/
export declare class IoNumberLadder extends IoElement {
	static get Style(): string;
	role: string;
	src?: IoNumber;
	expanded: boolean;
	static get Listeners(): {
		"ladder-step-change": string;
		"ladder-step-collapse": string;
		focusin: string;
	};
	get value(): number;
	get min(): number;
	get max(): number;
	get step(): number;
	get conversion(): number;
	_onFocusIn(event: FocusEvent): void;
	_onFocusTo(event: CustomEvent): void;
	_onLadderStepChange(event: CustomEvent): void;
	_onLadderStepCollapse(): void;
	expandedChanged(): void;
	changed(): void;
}
export declare const IoNumberLadderSingleton: IoNumberLadder;
/**
 * Input element for `String` data type.
 **/
export declare class IoString extends IoField {
	static get Style(): string;
	live: boolean;
	value: string | number | boolean;
	contenteditable: boolean;
	role: string;
	appearance: "flush" | "inset" | "outset";
	_setFromTextNode(): void;
	_tryParseFromTextNode(): void;
	_onBlur(event: FocusEvent): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_onKeydown(event: KeyboardEvent): void;
	_onKeyup(event: KeyboardEvent): void;
	changed(): void;
	valueChanged(): void;
}
/**
 * Input element for `Boolean` data type displayed as switch.
 *
 * <io-element-demo element="io-switch" properties='{"value": true}'></io-element-demo>
 **/
export declare class IoSwitch extends IoBoolean {
	static get Style(): string;
	init(): void;
	changed(): void;
	valueChanged(): void;
}

export {};
