{"version":3,"file":"Queue.js","sourceRoot":"","sources":["../../src/core/Queue.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node } from '../nodes/Node.js';\nimport { IoElement } from '../elements/IoElement.js';\n\nexport type CallbackFunction = (arg?: any) => void;\n\ninterface QueueOptions {\n  node: Node | IoElement | undefined;\n  arg: any;\n  frame: number;\n}\n\nlet currentFrame = 0;\n\nconst queueSync: CallbackFunction[] = [];\nconst queue0: CallbackFunction[] = [];\nconst queue1: CallbackFunction[] = [];\nconst queueOptions0: WeakMap<CallbackFunction, QueueOptions> = new WeakMap();\nconst queueOptions1: WeakMap<CallbackFunction, QueueOptions> = new WeakMap();\nlet queue = queue0;\nlet queueOptions = queueOptions0;\n\n/**\n * Returns a promise that resolves when the next frame is rendered.\n * Used for testing purposes.\n * @returns {Promise<void>}\n */\nexport async function nextQueue(): Promise<void> {\n  return new Promise((resolve) => {\n    queue.push(resolve);\n    queueOptions.set(resolve, {\n      arg: undefined,\n      node: undefined,\n      frame: currentFrame + 1,\n    });\n  });\n}\n\n/**\n * Throttles function execution once per frame (rAF).\n * @param {CallbackFunction} func - Function to throttle.\n * @param {*} [arg] - Optional argument for throttled function.\n * @param {Node | IoElement} [node] - Node instance.\n * @param {number} [delay] - Delay in frames.\n *\n * @example\n * throttle(someFunction, 'someArg', someNode);\n */\nexport function throttle(func: CallbackFunction, arg?: any, node?: Node | IoElement, delay = 1) {\n  if (queue.indexOf(func) === -1) {\n    queue.push(func);\n  }\n  if (!queueOptions.has(func)) {\n    queueOptions.set(func, {\n      arg: arg,\n      node: node,\n      frame: currentFrame + delay,\n    });\n  } else {\n    const options = queueOptions.get(func)!;\n    options.arg = arg;\n  }\n}\n\n/**\n * Debounces function execution to next frame (rAF).\n * @param {CallbackFunction} func - Function to debounce.\n * @param {*} [arg] - Optional argument for debounced function.\n * @param {Node | IoElement} [node] - Node instance.\n * @param {number} [delay] - Delay in frames.\n *\n * @example\n * debounce(someFunction, 'someArg', someNode);\n */\nexport function debounce(func: CallbackFunction, arg?: any, node?: Node | IoElement, delay = 1) {\n  if (queue.indexOf(func) === -1) {\n    queue.push(func);\n  }\n  if (!queueOptions.has(func)) {\n    queueOptions.set(func, {\n      arg: arg,\n      node: node,\n      frame: currentFrame + delay,\n    });\n  } else {\n    const options = queueOptions.get(func)!;\n    options.arg = arg;\n    options.frame = currentFrame + delay;\n  }\n}\n\n/**\n * Executes the queue of throttled/debounced functions.\n * Internally it swaps between two queues to avoid allocating new queue items to a queue that is currently being executed.\n * Therfore, functions queued from another queued function will always move to the next queue.\n */\nfunction executeQueue () {\n\n  currentFrame++;\n\n  const activeQueue = queue;\n  const activeQueueOptions = queueOptions;\n  queue = queue === queue0 ? queue1 : queue0;\n  queueOptions = queueOptions === queueOptions0 ? queueOptions1 : queueOptions0;\n\n  for (let i = 0; i < activeQueue.length; i++) {\n    const func = activeQueue[i];\n    const options = activeQueueOptions.get(func)!;\n    activeQueueOptions.delete(func);\n\n    if (options === undefined) {\n      console.warn(func);\n    }\n    if (options.frame > currentFrame) {\n      if (queue.indexOf(func) === -1) {\n        queue.push(func);\n      }\n      if (!queueOptions.has(func)) {\n        queueOptions.set(func, options);\n      }\n      continue;\n    }\n\n    if (options.node?._disposed) continue;\n    try {\n      if (options.arg !== undefined) func(options.arg);\n      else func();\n    } catch (e) {\n      console.error(e);\n    }\n  }\n  queueSync.length = 0;\n  activeQueue.length = 0;\n  requestAnimationFrame(executeQueue);\n}\nrequestAnimationFrame(executeQueue);"]}