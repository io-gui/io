{"version":3,"file":"Queue.js","sourceRoot":"","sources":["../../src/core/Queue.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node } from '../nodes/Node.js'\nimport { IoElement } from '../elements/IoElement.js'\n\nexport type CallbackFunction = (arg?: any) => void\n\ninterface QueueOptions {\n  node: Node | IoElement | undefined\n  arg: any\n  frame: number\n}\n\nlet currentFrame = 0\n\nconst queueSync: CallbackFunction[] = []\nconst queue0: CallbackFunction[] = []\nconst queue1: CallbackFunction[] = []\nconst queueOptions0: WeakMap<CallbackFunction, QueueOptions> = new WeakMap()\nconst queueOptions1: WeakMap<CallbackFunction, QueueOptions> = new WeakMap()\nlet queue = queue0\nlet queueOptions = queueOptions0\n\n/**\n * Returns a promise that resolves when the next frame is rendered.\n * Used for testing purposes.\n * @returns {Promise<void>}\n */\nexport async function nextQueue(): Promise<void> {\n  return new Promise((resolve) => {\n    queue.push(resolve)\n    queueOptions.set(resolve, {\n      arg: undefined,\n      node: undefined,\n      frame: currentFrame + 1,\n    })\n  })\n}\n\n/**\n * Throttles function execution once per frame (rAF).\n * @param {CallbackFunction} func - Function to throttle.\n * @param {*} [arg] - Optional argument for throttled function.\n * @param {Node | IoElement} [node] - Node instance.\n * @param {number} [delay] - Delay in frames.\n *\n * @example\n * throttle(someFunction, 'someArg', someNode);\n */\nexport function throttle(func: CallbackFunction, arg?: any, node?: Node | IoElement, delay = 1) {\n  if (queue.indexOf(func) === -1) {\n    queue.push(func)\n  }\n  if (!queueOptions.has(func)) {\n    queueOptions.set(func, {\n      arg: arg,\n      node: node,\n      frame: currentFrame + delay,\n    })\n  } else {\n    const options = queueOptions.get(func)!\n    options.arg = arg\n  }\n}\n\n/**\n * Debounces function execution to next frame (rAF).\n * @param {CallbackFunction} func - Function to debounce.\n * @param {*} [arg] - Optional argument for debounced function.\n * @param {Node | IoElement} [node] - Node instance.\n * @param {number} [delay] - Delay in frames.\n *\n * @example\n * debounce(someFunction, 'someArg', someNode);\n */\nexport function debounce(func: CallbackFunction, arg?: any, node?: Node | IoElement, delay = 1) {\n  if (queue.indexOf(func) === -1) {\n    queue.push(func)\n  }\n  if (!queueOptions.has(func)) {\n    queueOptions.set(func, {\n      arg: arg,\n      node: node,\n      frame: currentFrame + delay,\n    })\n  } else {\n    const options = queueOptions.get(func)!\n    options.arg = arg\n    options.frame = currentFrame + delay\n  }\n}\n\n/**\n * Executes the queue of throttled/debounced functions.\n * Internally it swaps between two queues to avoid allocating new queue items to a queue that is currently being executed.\n * Therfore, functions queued from another queued function will always move to the next queue.\n */\nfunction executeQueue () {\n\n  currentFrame++\n\n  const activeQueue = queue\n  const activeQueueOptions = queueOptions\n  queue = queue === queue0 ? queue1 : queue0\n  queueOptions = queueOptions === queueOptions0 ? queueOptions1 : queueOptions0\n\n  for (let i = 0; i < activeQueue.length; i++) {\n    const func = activeQueue[i]\n    const options = activeQueueOptions.get(func)!\n    activeQueueOptions.delete(func)\n\n    if (options === undefined) {\n      console.warn(func)\n    }\n    if (options.frame > currentFrame) {\n      if (queue.indexOf(func) === -1) {\n        queue.push(func)\n      }\n      if (!queueOptions.has(func)) {\n        queueOptions.set(func, options)\n      }\n      continue\n    }\n\n    if (options.node?._disposed) continue\n    try {\n      if (options.arg !== undefined) func(options.arg)\n      else func()\n    } catch (e) {\n      console.error(e)\n    }\n  }\n  queueSync.length = 0\n  activeQueue.length = 0\n  requestAnimationFrame(executeQueue)\n}\nrequestAnimationFrame(executeQueue)"]}