{"version":3,"file":"gl.glsl.js","sourceRoot":"","sources":["../../src/elements/gl.glsl.ts"],"names":[],"mappings":"AAAA,MAAM,QAAQ,GAAG,UAAU,CAAA;;;;CAI1B,CAAC;AAEF,sBAAsB;AACtB,MAAM,SAAS,GAAG,UAAU,CAAA;;;;;;;CAO3B,CAAC;AAEF,gBAAgB;AAChB,MAAM,MAAM,GAAG,UAAU,CAAA;;;;CAIxB,CAAC;AACF,MAAM,SAAS,GAAG,UAAU,CAAA;;;;;;;CAO3B,CAAC;AACF,MAAM,qBAAqB,GAAG,SAAS,CAAA;;;;;;;;;;;;;;;;;;;;;CAqBtC,CAAC;AACF,MAAM,YAAY,GAAG,SAAS,CAAA;;;;CAI7B,CAAC;AACF,MAAM,cAAc,GAAG,SAAS,CAAA;;;;CAI/B,CAAC;AACF,MAAM,WAAW,GAAG,SAAS,CAAA;;;;CAI5B,CAAC;AACF,MAAM,OAAO,GAAG,SAAS,CAAA;;;;;;CAMxB,CAAC;AACF,MAAM,QAAQ,GAAG,SAAS,CAAA;;;;;;CAMzB,CAAC;AACF,MAAM,QAAQ,GAAG,SAAS,CAAA;;;;;;CAMzB,CAAC;AAEF,wBAAwB;AACxB,MAAM,OAAO,GAAG,SAAS,CAAA;;;;CAIxB,CAAC;AAEF,oBAAoB;AACpB,MAAM,mBAAmB,GAAG,SAAS,CAAA;;;;;CAKpC,CAAC;AAGF;;GAEG;AAEH,MAAM,OAAO,GAAG,SAAS,CAAA;;;;;;;;CAQxB,CAAC;AAEF,MAAM,OAAO,GAAG,SAAS,CAAA;;;;;CAKxB,CAAC;AAEF,MAAM,OAAO,GAAG,SAAS,CAAA;;;;;;CAMxB,CAAC;AAEF,MAAM,CAAC,MAAM,IAAI,GAAG;IAClB,QAAQ;IACR,SAAS;IACT,MAAM;IACN,SAAS;IACT,qBAAqB;IACrB,YAAY;IACZ,cAAc;IACd,WAAW;IACX,OAAO;IACP,QAAQ;IACR,QAAQ;IACR,OAAO;IACP,mBAAmB;IACnB,OAAO;IACP,OAAO;IACP,OAAO;CACR,CAAC","sourcesContent":["const saturate = /* glsl */`\n  #ifndef saturate\n    #define saturate(v) clamp(v, 0., 1.)\n  #endif\n`;\n\n// Transform functions\nconst translate = /* glsl */`\n  vec2 translate(vec2 samplePosition, vec2 xy){\n    return samplePosition - vec2(xy.x, xy.y);\n  }\n  vec2 translate(vec2 samplePosition, float x, float y){\n    return samplePosition - vec2(x, y);\n  }\n`;\n\n// SDF functions\nconst circle = /* glsl */`\n  float circle(vec2 samplePosition, float radius){\n    return saturate((length(samplePosition) - radius) * uPxRatio);\n  }\n`;\nconst rectangle = /* glsl */`\n  float rectangle(vec2 samplePosition, vec2 halfSize){\n    vec2 edgeDistance = abs(samplePosition) - halfSize;\n    float outside = length(max(edgeDistance, 0.));\n    float inside = min(max(edgeDistance.x, edgeDistance.y), 0.);\n    return 1.0 - saturate((outside + inside) * 1000000.0);\n  }\n`;\nconst paintDerivativeGrid2D = /* glsl*/`\n  float paintDerivativeGrid2D(vec2 samplePosition, vec2 gridWidth, float lineWidth) {\n    vec2 sp = samplePosition / gridWidth;\n    float fractx = abs(fract(sp.x - 0.5) - 0.5) * 2.0;\n    float fracty = abs(fract(sp.y - 0.5) - 0.5) * 2.0;\n\n    float sx = ((sp.x - 0.5) - 0.5) * 2.0;\n    float sy = ((sp.y - 0.5) - 0.5) * 2.0;\n    \n    float absx = abs(max(dFdx(sx), dFdy(sx)));\n    float absy = abs(max(dFdy(sy), dFdx(sy)));\n\n    float fadeX = 1.0 - dFdx(sx);\n    float fadeY = 1.0 - dFdy(sx);\n    if (fadeX <= 0.0 || fadeY <= 0.0) return 1.0;\n\n    float linex = fractx / absx - (0.5 * max(uPxRatio, 2.0) * lineWidth - 1.0) - 0.5;\n    float liney = fracty / absy - (0.5 * max(uPxRatio, 2.0) * lineWidth - 1.0) - 0.5;\n\n    return (1.0 - saturate(min(linex, liney)));\n  }\n`;\nconst lineVertical = /* glsl*/`\n  float lineVertical(vec2 samplePosition, float lineWidth) {\n    return (abs(samplePosition.x) * 2.0 > lineWidth) ? 0.0 : 1.0;\n  }\n`;\nconst lineHorizontal = /* glsl*/`\n  float lineHorizontal(vec2 samplePosition, float lineWidth) {\n    return (abs(samplePosition.y) * 2.0 > lineWidth) ? 0.0 : 1.0;\n  }\n`;\nconst lineCross2d = /* glsl*/`\n  float lineCross2d(vec2 samplePosition, float lineWidth) {\n    return (min(abs(samplePosition.x), abs(samplePosition.y)) * 2.0 > lineWidth) ? 0.0 : 1.0;\n  }\n`;\nconst checker = /* glsl*/`\n  float checker(vec2 samplePosition, float size) {\n    vec2 checkerPos = floor(samplePosition / size);\n    float checkerMask = mod(checkerPos.x + mod(checkerPos.y, 2.0), 2.0);\n    return checkerMask;\n  }\n`;\nconst checkerX = /* glsl*/`\n  float checkerX(vec2 samplePosition, float size) {\n    vec2 checkerPos = floor(samplePosition / size);\n    float checkerMask = mod(checkerPos.x, 2.0);\n    return checkerMask;\n  }\n`;\nconst checkerY = /* glsl*/`\n  float checkerY(vec2 samplePosition, float size) {\n    vec2 checkerPos = floor(samplePosition / size);\n    float checkerMask = mod(checkerPos.y, 2.0);\n    return checkerMask;\n  }\n`;\n\n// Compositing functions\nconst compose = /* glsl*/`\n  vec3 compose(vec3 dst, vec4 src) {\n    return mix(dst, src.rgb, src.a);\n  }\n`;\n\n// Painter Functions\nconst paintHorizontalLine = /* glsl*/`\n  vec3 paintHorizontalLine(vec3 dstCol, vec2 p, vec3 color) {\n    float lineShape = lineHorizontal(p, io_borderWidth);\n    return compose(dstCol, vec4(color, lineShape));\n  }\n`;\n\n\n/**\n * GLSL Color Functions\n */\n\nconst hue2rgb = /* glsl*/`\n  vec3 hue2rgb(float hue) {\n    hue = fract(hue);\n    float R = abs(hue * 6. - 3.) - 1.;\n    float G = 2. - abs(hue * 6. - 2.);\n    float B = 2. - abs(hue * 6. - 4.);\n    return saturate(vec3(R,G,B));\n  }\n`;\n\nconst hsv2rgb = /* glsl*/`\n  vec3 hsv2rgb(vec3 hsv) {\n    vec3 rgb = hue2rgb(hsv.r);\n    return ((rgb - 1.) * hsv.g + 1.) * hsv.b;\n  }\n`;\n\nconst hsl2rgb = /* glsl*/`\n  vec3 hsl2rgb(vec3 hsl) {\n    vec3 rgb = hue2rgb(hsl.x);\n    float C = (1. - abs(2. * hsl.z - 1.)) * hsl.y;\n    return (rgb - 0.5) * C + hsl.z;\n  }\n`;\n\nexport const glsl = {\n  saturate,\n  translate,\n  circle,\n  rectangle,\n  paintDerivativeGrid2D,\n  lineVertical,\n  lineHorizontal,\n  lineCross2d,\n  checker,\n  checkerX,\n  checkerY,\n  compose,\n  paintHorizontalLine,\n  hue2rgb,\n  hsv2rgb,\n  hsl2rgb,\n};\n"]}