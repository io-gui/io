import{ReactiveProperty as e,Register as t,Node as o,Binding as p,ChangeQueue as r,EventDispatcher as n,ReactiveProtoProperty as a,ReactivePropertyInstance as i,reactivePropertyDecorators as l,Property as c,ProtoChain as s,IoElement as d,throttle as u,nextQueue as b,debounce as v,constructElement as x,div as g,applyNativeElementProps as h,StorageNode as q,Storage as y,ThemeSingleton as f,IoGl as w,IoOverlaySingleton as m}from"./index.js";var __decorate$7=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};let S=class TestNode extends o{};__decorate$7([e(0)],S.prototype,"prop1",void 0),__decorate$7([e(0)],S.prototype,"prop2",void 0),S=__decorate$7([t],S);class BindingTest{run(){describe("Binding",(()=>{it("Should initialize with correct default values",(()=>{const e=new S,t=new p(e,"prop1");expect(t.node).to.be.equal(e),expect(t.property).to.be.equal("prop1"),expect(t.targets instanceof Array).to.be.equal(!0),expect(t.targets.length).to.be.equal(0),expect(t.targetProperties instanceof WeakMap).to.be.equal(!0)})),it("Should set source and target properties",(()=>{const e=new S,t=new p(e,"prop1");e.prop1=1,expect(t.value).to.be.equal(1),e.prop1=2,expect(t.value).to.be.equal(2),t.value=3,expect(e.prop1).to.be.equal(3);const o=new S;t.addTarget(o,"prop1"),expect(o.prop1).to.be.equal(3),o.prop1=4,expect(t.value).to.be.equal(4),e.prop1=5,expect(o.prop1).to.be.equal(5),expect(t.value).to.be.equal(5),t.value=6,expect(e.prop1).to.be.equal(6),expect(o.prop1).to.be.equal(6)})),it("Should add/remove target nodes+properties with `addTarget()` and `removeTarget()`",(()=>{const e=new S,t=new p(e,"prop1"),o=new p(e,"prop2"),r=new S,n=new S;t.addTarget(r,"prop1"),o.addTarget(r,"prop2"),o.addTarget(n,"prop1"),o.addTarget(n,"prop2"),expect(e._eventDispatcher.addedListeners).to.be.eql({"prop1-changed":[[t.onSourceChanged]],"prop2-changed":[[o.onSourceChanged]]}),expect(r._eventDispatcher.addedListeners).to.be.eql({"prop1-changed":[[t.onTargetChanged]],"prop2-changed":[[o.onTargetChanged]]}),expect(n._eventDispatcher.addedListeners).to.be.eql({"prop1-changed":[[o.onTargetChanged]],"prop2-changed":[[o.onTargetChanged]]}),expect(t.targets[0]).to.be.equal(r),expect(t.targets[1]).to.be.equal(void 0),expect(o.targets[0]).to.be.equal(r),expect(o.targets[1]).to.be.equal(n),expect(o.targets[2]).to.be.equal(void 0),expect(r._reactiveProperties.get("prop1").binding).to.be.equal(t),expect(r._reactiveProperties.get("prop2").binding).to.be.equal(o),expect(n._reactiveProperties.get("prop1").binding).to.be.equal(o),expect(n._reactiveProperties.get("prop2").binding).to.be.equal(o);const a=t.getTargetProperties(r),i=t.getTargetProperties(n);expect(a[0]).to.be.equal("prop1"),expect(a.length).to.be.equal(1),expect(i.length).to.be.equal(0);const l=o.getTargetProperties(r),c=o.getTargetProperties(n);expect(l[0]).to.be.equal("prop2"),expect(l.length).to.be.equal(1),expect(c[0]).to.be.equal("prop1"),expect(c[1]).to.be.equal("prop2"),expect(c.length).to.be.equal(2),o.removeTarget(n,"prop1"),expect(c[0]).to.be.equal("prop2"),expect(c.length).to.be.equal(1),expect(n._reactiveProperties.get("prop1").binding).to.be.equal(void 0),expect(n._eventDispatcher.addedListeners).to.be.eql({"prop2-changed":[[o.onTargetChanged]]}),o.addTarget(n,"prop1"),expect(c.length).to.be.equal(2),expect(n._reactiveProperties.get("prop1").binding).to.be.equal(o),o.removeTarget(n),expect(c.length).to.be.equal(0),expect(n._reactiveProperties.get("prop1").binding).to.be.equal(void 0),expect(n._reactiveProperties.get("prop2").binding).to.be.equal(void 0),expect(n._eventDispatcher.addedListeners).to.be.eql({})})),it("Should remove existing binding from target if `addTarget()` causes a binding collision",(()=>{const e=new S,t=new p(e,"prop1"),o=new S;t.addTarget(o,"prop1");const r=new S,n=new p(r,"prop1");expect(t.targets).to.be.include(o);let a=t.getTargetProperties(o);expect(a.length).to.be.equal(1),expect(a[0]).to.be.equal("prop1"),n.addTarget(o,"prop1"),expect(t.targets).to.be.eql([]),a=t.getTargetProperties(o),expect(a.length).to.be.equal(0)})),it("Should dispose correctly",(()=>{const e=new S,t=new S,o=new p(e,"prop1");o.addTarget(t,"prop1"),expect(e._eventDispatcher.addedListeners).to.be.eql({"prop1-changed":[[o.onSourceChanged]]}),expect(t._eventDispatcher.addedListeners).to.be.eql({"prop1-changed":[[o.onTargetChanged]]}),o.dispose(),expect(o.node).to.be.equal(void 0),expect(o.property).to.be.equal(void 0),expect(o.targets).to.be.equal(void 0),expect(o.targetProperties).to.be.equal(void 0),expect(t._reactiveProperties.get("prop1").binding).to.be.equal(void 0),expect(e._eventDispatcher.addedListeners).to.be.eql({}),expect(t._eventDispatcher.addedListeners).to.be.eql({})}))}))}}var __decorate$6=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};let P=class MockNode extends o{eventStack=[];changeStack=[];prop1Changed(e){this.changeStack.push(`prop1Changed ${e.property} ${e.value} ${e.oldValue}`)}prop2Changed(e){this.changeStack.push(`prop2Changed ${e.property} ${e.value} ${e.oldValue}`)}dispatchEvent(e,t){t&&t.property?this.eventStack.push(`${e} ${t.property} ${t.value} ${t.oldValue}`):this.eventStack.push(`${e}`)}changed(){this.changeStack.push("changed")}};P=__decorate$6([t],P);class ChangeQueueTest{run(){describe("ChangeQueue",(()=>{it("Should initialize with correct default values",(()=>{const e=new P,t=new r(e);expect(t.node).to.be.equal(e),expect(JSON.stringify(t.changes)).to.be.equal("[]"),expect(t.changes.length).to.be.equal(0),expect(t.dispatching).to.be.equal(!1)})),it("Should keep track of changes correctly",(()=>{const e=new P,t=new r(e);t.queue("prop1",1,0),t.queue("prop1",2,1),expect(JSON.stringify(t.changes)).to.be.equal('[{"property":"prop1","value":2,"oldValue":0}]'),t.dispatch(),expect(JSON.stringify(t.changes)).to.be.equal("[]")})),it("Should dispatch change events with correct payloads",(()=>{const e=new P,t=new r(e);t.queue("prop1",1,0),t.queue("prop1",2,1),t.dispatch(),expect(JSON.stringify(e.eventStack)).to.be.equal('["prop1-changed prop1 2 0","object-mutated"]')})),it("Should invoke handler functions with correct payloads",(()=>{const e=new P,t=new r(e);t.queue("prop1",1,0),t.queue("prop1",2,1),t.dispatch(),expect(JSON.stringify(e.changeStack)).to.be.equal('["prop1Changed prop1 2 0","changed"]')})),it("Should handle changes in first-in, first-out (FIFO) order",(()=>{const e=new P,t=new r(e);t.queue("prop1",1,0),t.queue("prop1",3,1),t.queue("prop2",2,0),t.dispatch(),expect(JSON.stringify(e.changeStack)).to.be.equal('["prop1Changed prop1 3 0","prop2Changed prop2 2 0","changed"]'),expect(JSON.stringify(e.eventStack)).to.be.equal('["prop1-changed prop1 3 0","prop2-changed prop2 2 0","object-mutated"]')})),it("Setting new value to the same value as oldValue should not trigger change event",(()=>{const e=new P,t=new r(e);t.queue("prop1",1,0),expect(JSON.stringify(t.changes)).to.be.equal('[{"property":"prop1","value":1,"oldValue":0}]'),t.queue("prop1",0,1),expect(JSON.stringify(t.changes)).to.be.equal("[]"),t.dispatch(),expect(JSON.stringify(e.changeStack)).to.be.equal("[]"),expect(JSON.stringify(e.eventStack)).to.be.equal("[]")})),it("Should skip dispatch if value is same as oldValue",(()=>{const e=new P,t=new r(e);t.queue("prop1",0,0),t.dispatch(),expect(e.changeStack).to.be.eql([]),expect(e.eventStack).to.be.eql([])})),it("Should dispose correctly",(()=>{const e=new P,t=new r(e);t.dispose(),expect(t.node).to.be.equal(void 0),expect(t.changes).to.be.equal(void 0)}))}))}}var __decorate$5=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};const handlerFunction=e=>{e.target.eventStack.push(`handlerFunction ${e.detail}`)};let E=class MockNode1 extends o{eventStack=[];static get Listeners(){return{event1:"event1Handler"}}event1Handler(e){this.eventStack.push(`event1Handler ${e.detail}`)}};E=__decorate$5([t],E);let T=class MockNode2 extends E{eventStack=[];static get Listeners(){return{event2:["event2Handler",{capture:!0}]}}event2Handler(e){this.eventStack.push(`event2Handler ${e.detail}`)}};T=__decorate$5([t],T);let C=class MockNode3 extends T{eventStack=[];static get Listeners(){return{event1:"event3Handler",event2:[handlerFunction,{passive:!0}],event3:handlerFunction}}event3Handler(e){this.eventStack.push(`event3Handler ${e.detail}`)}};C=__decorate$5([t],C);class TestDiv extends HTMLElement{eventStack=[];event1Handler(e){this.eventStack.push(`event1Handler ${e.detail}`)}}window.customElements.define("test-div",TestDiv);class EventDispatcherTest{run(){describe("EventDispatcher",(()=>{it("Should initialize with correct values",(()=>{const e=new E;let t=new n(e);expect(t.node).to.be.equal(e),expect(t.protoListeners).to.be.eql({event1:[[e.event1Handler]]}),expect(t.propListeners).to.be.eql({}),expect(t.addedListeners).to.be.eql({}),expect(t.nodeIsEventTarget).to.be.eql(!1)})),it("Should initialize listeners from ProtoChain",(()=>{const e=new E;let t=new n(e);expect(t.protoListeners).to.be.eql({event1:[[e.event1Handler]]});const o=new T;t=new n(o),expect(t.protoListeners).to.be.eql({event1:[[e.event1Handler]],event2:[[o.event2Handler,{capture:!0}]]});const p=new C;t=new n(p),expect(t.protoListeners).to.be.eql({event1:[[p.event3Handler]],event2:[[handlerFunction,{passive:!0}]],event3:[[handlerFunction]]})})),it("Should applyPropListeners() correctly",(()=>{const e=new C;let t=new n(e);const handler4=()=>{},handler5=()=>{};t.applyPropListeners({"@event3":"event3Handler","@event4":handler4}),expect(t.propListeners).to.be.eql({event3:[[e.event3Handler]],event4:[[handler4]]}),t.applyPropListeners({"@event5":["event3Handler"],"@event6":[handler4]}),expect(t.propListeners).to.be.eql({event5:[[e.event3Handler]],event6:[[handler4]]}),t.applyPropListeners({"@event7":[e.event3Handler,{capture:!0}],"@event8":[handler5,{capture:!0}]}),expect(t.propListeners).to.be.eql({event7:[[e.event3Handler,{capture:!0}]],event8:[[handler5,{capture:!0}]]}),t.applyPropListeners({}),expect(t.propListeners).to.be.eql({})})),it("Should add/remove listeners correctly",(()=>{const e=new T;let t=new n(e);const listener1=()=>{},listener2=()=>{};t.addEventListener("event1",listener1),t.addEventListener("event1",listener2,{capture:!0}),expect(t.addedListeners).to.be.eql({event1:[[listener1],[listener2,{capture:!0}]]}),t.removeEventListener("event1",listener1),expect(t.addedListeners).to.be.eql({event1:[[listener2,{capture:!0}]]}),t.removeEventListener("event1"),expect(t.addedListeners).to.be.eql({})})),it("Should not add listeners if already added",(()=>{const e=new T;let t=new n(e);const listener1=()=>{},listener2=()=>{};t.addEventListener("event1",listener1),t.addEventListener("event1",listener1),t.addEventListener("event1",listener2,{capture:!0}),expect(t.addedListeners).to.be.eql({event1:[[listener1],[listener2,{capture:!0}]]})})),it("Should remove correct listener",(()=>{const e=new T;let t=new n(e);const listener1=()=>{},listener2=()=>{};t.addEventListener("event1",listener1),t.addEventListener("event1",listener2,{capture:!0}),t.removeEventListener("event1",listener2),expect(t.addedListeners).to.be.eql({event1:[[listener1]]}),t.removeEventListener("event1",listener1),expect(t.addedListeners).to.be.eql({})})),it("Should dispatch added events with correct payloads",(()=>{const e=new C;let t=new n(e);const handler4=e=>{e.target.eventStack.push(`handler4 ${e.detail}`)},handler5=e=>{e.target.eventStack.push(`handler5 ${e.detail}`)};t.applyPropListeners({"@event3":"event3Handler","@event4":handler4}),t.addEventListener("event5",handler5),t.dispatchEvent("event1",1),t.dispatchEvent("event2",2),t.dispatchEvent("event3",3),t.dispatchEvent("event4",4),t.dispatchEvent("event5",5),expect(e.eventStack).to.be.eql(["event3Handler 1","handlerFunction 2","handlerFunction 3","event3Handler 3","handler4 4","handler5 5"]),e.eventStack=[],t.applyPropListeners({"@event4":handler4}),t.removeEventListener("event5",handler5),t.dispatchEvent("event1",1),t.dispatchEvent("event2",2),t.dispatchEvent("event3",3),t.dispatchEvent("event4",4),t.dispatchEvent("event5",5),expect(e.eventStack).to.be.eql(["event3Handler 1","handlerFunction 2","handlerFunction 3","handler4 4"])})),it("Should add/remove/dispatch events on HTML elements",(()=>{const e=document.createElement("test-div"),t=new n(e),handler3=e=>{e.target.eventStack.push(`handler3 ${e.detail}`)};t.applyPropListeners({"@event1":"event1Handler","@event2":e=>{e.target.eventStack.push(`handler2 ${e.detail}`)}}),t.addEventListener("event3",handler3),e.dispatchEvent(new CustomEvent("event1",{detail:1})),e.dispatchEvent(new CustomEvent("event2",{detail:2})),e.dispatchEvent(new CustomEvent("event3",{detail:3})),expect(e.eventStack).to.be.eql(["event1Handler 1","handler2 2","handler3 3"]),e.eventStack=[],t.applyPropListeners({}),t.removeEventListener("event3",handler3),e.dispatchEvent(new CustomEvent("event1",{detail:1})),e.dispatchEvent(new CustomEvent("event2",{detail:2})),e.dispatchEvent(new CustomEvent("event3",{detail:3})),expect(e.eventStack).to.be.eql([])})),it("Should bubble events if specified",(()=>{const e=document.createElement("test-div");e.id="element";const t=document.createElement("test-div");t.id="parentElement",t.appendChild(e);const o=new n(e),p=new n(t),handler2=function(e){this.eventStack.push(`handler2 ${e.detail}`)};o.applyPropListeners({"@event1":"event1Handler"}),o.addEventListener("event2",handler2.bind(e)),p.applyPropListeners({"@event1":"event1Handler"}),p.addEventListener("event2",handler2.bind(t)),o.dispatchEvent("event1",1,!1),o.dispatchEvent("event2",2,!1),expect(e.eventStack).to.be.eql(["event1Handler 1","handler2 2"]),expect(t.eventStack).to.be.eql([]),e.eventStack=[],t.eventStack=[],o.dispatchEvent("event1",1,!0),o.dispatchEvent("event2",2,!0),expect(e.eventStack).to.be.eql(["event1Handler 1","handler2 2"]),expect(t.eventStack).to.be.eql(["event1Handler 1","handler2 2"])})),it("Should emit event from specified target",(()=>{const e=document.createElement("div"),t=new n(e),o=document.createElement("test-div"),p=new n(o);p.applyPropListeners({"@event1":"event1Handler"});let r=null,a=null;p.addEventListener("event1",(e=>{r=e.composedPath(),a=e.target})),t.dispatchEvent("event1",1,!1,o),expect(o.eventStack).to.be.eql(["event1Handler 1"]),expect(r).to.be.eql([o]),expect(a).to.be.eql(o)})),it("Should dispose correctly",(()=>{const e=new E,t=new n(e);t.dispose(),expect(t.node).to.be.equal(void 0),expect(t.protoListeners).to.be.equal(void 0),expect(t.propListeners).to.be.equal(void 0),expect(t.addedListeners).to.be.equal(void 0)}))}))}}var __decorate$4=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};let _=class Object1{constructor(e){void 0!==e&&(this.prop=e)}prop=!0},j=class TestNode extends o{constructor(e){super(e)}};__decorate$4([e("default")],j.prototype,"label",void 0),j=__decorate$4([t],j);const k=new j;class ReactivePropertyTest{run(){describe("ReactiveProperty",(()=>{it("Should initialize correct property definitions and values from loosely typed property definitions",(()=>{let e,t;e=new a({}),t=new i(k,e),expect(e).to.be.eql({}),expect(t).to.be.eql({value:void 0,type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a(null),t=new i(k,e),expect(e).to.be.eql({value:null}),expect(t).to.be.eql({value:null,type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a(void 0),t=new i(k,e),expect(e).to.be.eql({value:void 0}),expect(t).to.be.eql({value:void 0,type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a(Number),t=new i(k,e),expect(e).to.be.eql({type:Number}),expect(t).to.be.eql({value:0,type:Number,binding:void 0,reflect:!1,init:void 0}),e=new a({type:Number}),t=new i(k,e),expect(e).to.be.eql({type:Number}),expect(t).to.be.eql({value:0,type:Number,binding:void 0,reflect:!1,init:void 0}),e=new a(1),t=new i(k,e),expect(e).to.be.eql({value:1}),expect(t).to.be.eql({value:1,type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a({value:2}),t=new i(k,e),expect(e).to.be.eql({value:2}),expect(t).to.be.eql({value:2,type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a(String),t=new i(k,e),expect(e).to.be.eql({type:String}),expect(t).to.be.eql({value:"",type:String,binding:void 0,reflect:!1,init:void 0}),e=new a({type:String}),t=new i(k,e),expect(e).to.be.eql({type:String}),expect(t).to.be.eql({value:"",type:String,binding:void 0,reflect:!1,init:void 0}),e=new a("test"),t=new i(k,e),expect(e).to.be.eql({value:"test"}),expect(t).to.be.eql({value:"test",type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a({value:"test"}),t=new i(k,e),expect(e).to.be.eql({value:"test"}),expect(t).to.be.eql({value:"test",type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a(Boolean),t=new i(k,e),expect(e).to.be.eql({type:Boolean}),expect(t).to.be.eql({value:!1,type:Boolean,binding:void 0,reflect:!1,init:void 0}),e=new a({type:Boolean}),t=new i(k,e),expect(e).to.be.eql({type:Boolean}),expect(t).to.be.eql({value:!1,type:Boolean,binding:void 0,reflect:!1,init:void 0}),e=new a(!0),t=new i(k,e),expect(e).to.be.eql({value:!0}),expect(t).to.be.eql({value:!0,type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a({value:!0}),t=new i(k,e),expect(e).to.be.eql({value:!0}),expect(t).to.be.eql({value:!0,type:void 0,binding:void 0,reflect:!1,init:void 0}),e=new a(Object),t=new i(k,e),expect(e).to.be.eql({type:Object}),expect(t).to.be.eql({value:{},type:Object,binding:void 0,reflect:!1,init:void 0}),e=new a({type:Object}),t=new i(k,e),expect(e).to.be.eql({type:Object}),expect(t).to.be.eql({value:{},type:Object,binding:void 0,reflect:!1,init:void 0}),e=new a({type:Object,init:null}),t=new i(k,e),expect(e).to.be.eql({type:Object,init:null}),expect(t).to.be.eql({value:void 0,type:Object,binding:void 0,reflect:!1,init:null});const o={prop:!0};e=new a({value:o}),t=new i(k,e),expect(e).to.be.eql({value:{prop:!0}}),expect(t).to.be.eql({value:{prop:!0},type:void 0,binding:void 0,reflect:!1,init:void 0}),expect(e.value).to.equal(o),expect(t.value).to.equal(o),e=new a(Array),t=new i(k,e),expect(e).to.be.eql({type:Array}),expect(t).to.be.eql({value:[],type:Array,binding:void 0,reflect:!1,init:void 0}),e=new a({type:Array}),t=new i(k,e),expect(e).to.be.eql({type:Array}),expect(t).to.be.eql({value:[],type:Array,binding:void 0,reflect:!1,init:void 0});const p=[1,2,3];e=new a({value:p}),t=new i(k,e),expect(e).to.be.eql({value:[1,2,3]}),expect(t).to.be.eql({value:[1,2,3],type:void 0,binding:void 0,reflect:!1,init:void 0}),expect(e.value).to.equal(p),expect(t.value).to.equal(p),e=new a({type:_,init:null}),t=new i(k,e),expect(e).to.be.eql({type:_,init:null}),expect(t).to.be.eql({value:void 0,type:_,binding:void 0,reflect:!1,init:null}),e=new a(_),t=new i(k,e),expect(e).to.be.eql({type:_}),expect(t).to.be.eql({value:new _,type:_,binding:void 0,reflect:!1,init:void 0}),e=new a({type:_,init:"test"}),t=new i(k,e),expect(e).to.be.eql({type:_,init:"test"}),expect(t).to.be.eql({value:new _("test"),type:_,binding:void 0,reflect:!1,init:"test"}),e=new a({type:_,init:"this"}),t=new i(k,e),expect(e).to.be.eql({type:_,init:"this"}),expect(t).to.be.eql({value:new _(k),type:_,binding:void 0,reflect:!1,init:"this"}),e=new a({type:_,init:"this.label"}),t=new i(k,e),expect(e).to.be.eql({type:_,init:"this.label"}),expect(t).to.be.eql({value:new _(k.label),type:_,binding:void 0,reflect:!1,init:"this.label"});const r=new _;e=new a({value:r}),t=new i(k,e),expect(e).to.be.eql({value:r}),expect(e.value).to.be.equal(r),expect(t).to.be.eql({value:r,type:void 0,binding:void 0,reflect:!1,init:void 0}),expect(t.value).to.be.equal(r),expect(e.value).to.equal(r),expect(t.value).to.equal(r),e=new a({type:_}),t=new i(k,e),expect(e).to.be.eql({type:_}),expect(t).to.be.eql({value:new _,type:_,binding:void 0,reflect:!1,init:void 0}),e=new a({reflect:!1,type:Object,init:!0}),t=new i(k,e),expect(e).to.be.eql({type:Object,reflect:!1,init:!0}),expect(t).to.be.eql({value:new Object(!0),type:Object,binding:void 0,reflect:!1,init:!0})})),it("Should register property definitions from decorators.",(()=>{class TestClass extends o{}__decorate$4([e("value1")],TestClass.prototype,"prop1",void 0),__decorate$4([e({value:"value2",type:String})],TestClass.prototype,"prop2",void 0),t(TestClass);const p=l.get(TestClass);expect(p).to.be.eql({prop1:"value1",prop2:{value:"value2",type:String}})})),it("Should initialize properties with binding correctly",(()=>{let e,t,o=new p(new j({label:"lorem"}),"label");e=new a(o),t=new i(k,e),expect(e).to.be.eql({value:"lorem",binding:o}),expect(t).to.be.eql({value:"lorem",type:void 0,binding:o,reflect:!1,init:void 0}),o=new p(new j({label:"lorem"}),"label"),e=new a({binding:o,value:"ipsum"}),t=new i(k,e),expect(e).to.be.eql({value:"lorem",binding:o}),expect(t).to.be.eql({value:"lorem",type:void 0,binding:o,reflect:!1,init:void 0})})),it("Should assign property definitions correctly",(()=>{const e=new p(new j({label:"lorem"}),"label");let t=new a({}),o=new a({value:"lorem",type:String,binding:e,reflect:!1,init:void 0});t.assign(o),expect(t).to.be.eql(o),t=new a({}),expect(t).to.be.eql({}),o=new a({value:"lorem",type:String,binding:e,reflect:!0,init:!0}),o.assign(t),expect(o).to.be.eql({value:"lorem",type:String,binding:e,reflect:!0,init:!0}),t=new a({reflect:!0,init:void 0}),o=new a({value:"lorem",type:String,reflect:!0}),o.assign(t),expect(o).to.be.eql({value:"lorem",type:String,reflect:!0,init:void 0})}))}))}}var __decorate$3=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};class Array1 extends Array{}class Array2 extends Array1{}class Array3 extends Array2{}class Object1{}class Object2 extends Object1{}class Object3 extends Object2{}class HTMLElement1 extends HTMLElement{}class HTMLElement2 extends HTMLElement1{}class HTMLElement3 extends HTMLElement2{}let N=class Node1 extends o{static get ReactiveProperties(){return{prop1:{init:!1},prop2:{}}}static get Properties(){return{sprop1:"foo"}}};__decorate$3([e({type:Object})],N.prototype,"prop2",void 0),N=__decorate$3([t],N);let L=class Node3 extends N{static get ReactiveProperties(){return{prop1:{init:!0,reflect:!0}}}};__decorate$3([e({init:!0})],L.prototype,"prop1",void 0),__decorate$3([e({value:"foo",reflect:!1})],L.prototype,"prop2",void 0),__decorate$3([e({reflect:!0})],L.prototype,"prop3",void 0),__decorate$3([c("bar")],L.prototype,"sprop2",void 0),L=__decorate$3([t],L);let O=class Node4 extends N{};__decorate$3([e({init:!0})],O.prototype,"prop1",void 0),__decorate$3([e({})],O.prototype,"prop2",void 0),__decorate$3([c("baz")],O.prototype,"sprop1",void 0),O=__decorate$3([t],O);class IoElement1 extends d{}class MockNode1{static get ReactiveProperties(){return{prop1:{init:!1}}}static get Listeners(){return{listener1:"function1",listener2:"",listener3:["_onFunction1",{capture:!0}],listener4:()=>{}}}static get Style(){return"a"}changed(){}function1(){}onFunction1(){}_onFunction1(){}}class MockNode2 extends MockNode1{function2(){}onFunction2(){}_onFunction2(){}static get ReactiveProperties(){return{prop1:{type:Object},prop2:{}}}static get Listeners(){return{listener1:"_onFunction2",listener2:["function2",{capture:!0,passive:!0}],listener3:["_onFunction1",{passive:!0}]}}static get Style(){return"b"}}class MockNode3 extends MockNode2{}class MockNode4 extends MockNode2{static get ReactiveProperties(){return{prop3:{type:o},prop4:{value:new o}}}}class ProtoChainTest{run(){describe("ProtoChain",(()=>{it("Should include an array of inherited class constructors",(()=>{let e=new s(Array3).constructors;expect(e).to.be.eql([Array3,Array2,Array1]),e=new s(Object3).constructors,expect(e).to.be.eql([Object3,Object2,Object1]),e=new s(HTMLElement3).constructors,expect(e).to.be.eql([HTMLElement3,HTMLElement2,HTMLElement1]),e=new s(o).constructors,expect(e).to.be.eql([o,Object.getPrototypeOf(o)]),e=new s(N).constructors,expect(e).to.be.eql([N,o,Object.getPrototypeOf(o)]),e=new s(IoElement1).constructors,expect(e).to.be.eql([IoElement1,d,Object.getPrototypeOf(d)])})),it("Should include properties declared in `static get Properties()` return oject",(()=>{let e=new s(N);expect(Object.keys(e.properties)).to.be.eql(["sprop1"]),expect(e.properties).to.be.eql({sprop1:"foo"})})),it("Should include reactive properties declared in `static get ReactiveProperties()` return oject",(()=>{let e=new s(MockNode1);expect(Object.keys(e.reactiveProperties)).to.be.eql(["prop1"]),expect(e.reactiveProperties).to.be.eql({prop1:{init:!1}}),e=new s(MockNode2),expect(Object.keys(e.reactiveProperties)).to.be.eql(["prop1","prop2"]),expect(e.reactiveProperties).to.be.eql({prop1:{type:Object,init:!1},prop2:{}})})),it("Should include properties declared in Property decorator",(()=>{let e=new s(L);expect(Object.keys(e.properties)).to.be.eql(["sprop1","sprop2"]),expect(e.properties).to.be.eql({sprop1:"foo",sprop2:"bar"})})),it("Should include reactive properties declared in ReactiveProperty decorator",(()=>{let e=new s(N);expect(Object.keys(e.reactiveProperties)).to.be.eql(["reactivity","prop2","prop1"]),expect(e.reactiveProperties).to.be.eql({reactivity:{value:"immediate",type:String},prop1:{init:!1},prop2:{type:Object}}),e=new s(L),expect(Object.keys(e.reactiveProperties)).to.be.eql(["reactivity","prop2","prop1","prop3"]),expect(e.reactiveProperties).to.be.eql({reactivity:{value:"immediate",type:String},prop1:{reflect:!0,init:!0},prop2:{value:"foo",type:Object,reflect:!1},prop3:{reflect:!0}})})),it("Should not override properties declared in Property decorator with inherited `static get Properties()` return oject",(()=>{const e=new s(O);expect(Object.keys(e.properties)).to.be.eql(["sprop1"]),expect(e.properties).to.be.eql({sprop1:"baz"})})),it("Should not override reactive properties declared in ReactiveProperty decorator with inherited `static get ReactiveProperties()` return oject",(()=>{const e=new s(O);expect(Object.keys(e.reactiveProperties)).to.be.eql(["reactivity","prop2","prop1"]),expect(e.reactiveProperties).to.be.eql({reactivity:{value:"immediate",type:String},prop1:{init:!0},prop2:{type:Object}})})),it("Should include listners declared in `static get Listeners()` return oject",(()=>{let e=new s(MockNode1);expect(Object.keys(e.listeners)).to.be.eql(["listener1","listener3","listener4"]),expect(e.listeners.listener1).to.be.eql([["function1"]]),expect(e.listeners.listener3).to.be.eql([["_onFunction1",{capture:!0}]]),expect(String(e.listeners.listener4)).to.be.eql(String([[()=>{}]])),e=new s(MockNode2),expect(Object.keys(e.listeners)).to.be.eql(["listener1","listener3","listener4","listener2"]),expect(e.listeners.listener1).to.be.eql([["function1"],["_onFunction2"]]),expect(e.listeners.listener2).to.be.eql([["function2",{capture:!0,passive:!0}]]),expect(e.listeners.listener3).to.be.eql([["_onFunction1",{capture:!0,passive:!0}]]),expect(String(e.listeners.listener4)).to.be.eql(String([[()=>{}]]))})),it("Should include style strings declared in `static get Style()` return string",(()=>{let e=new s(MockNode1);expect(e.style).to.be.equal("a"),e=new s(MockNode2),expect(e.style).to.be.equal("a\nb"),e=new s(MockNode3),expect(e.style).to.be.equal("a\nb")})),it('Should include an array of handler names that start with "on[A-Z]" or "_on[A-Z]" for auto-binding',(()=>{let e=new s(N);expect(e.handlers).to.be.eql(["changed","onPropertyMutated"]),e=new s(MockNode1),expect(e.handlers).to.be.eql(["changed","onFunction1","_onFunction1"]),e=new s(MockNode2),expect(e.handlers).to.be.eql(["changed","onFunction1","_onFunction1","onFunction2","_onFunction2"])})),it("Should bind auto-binding functions with `.autobindHandlers(node)` function",(()=>{const e=new s(MockNode2),t=new MockNode2;e.autobindHandlers(t),expect(t.function1.name).to.be.equal("function1"),expect(t.onFunction1.name).to.be.equal("bound onFunction1"),expect(t._onFunction1.name).to.be.equal("bound _onFunction1"),expect(t.function2.name).to.be.equal("function2"),expect(t.onFunction2.name).to.be.equal("bound onFunction2"),expect(t._onFunction2.name).to.be.equal("bound _onFunction2")})),it("Should include property names of mutation-observed object properties",(()=>{let e=new s(MockNode1);expect(e.observedObjectProperties).to.be.eql([]),e=new s(MockNode2),expect(e.observedObjectProperties).to.be.eql(["prop1"]),e=new s(MockNode4),expect(e.observedObjectProperties).to.be.eql(["prop1"]),expect(e.observedNodeProperties).to.be.eql(["prop3","prop4"])}))}))}}class QueueTest{run(){describe("Queue",(()=>{it("Should exectute throttled function immediately at first call",(async()=>{let e=0;u((()=>{e++})),expect(e).to.be.equal(1),await b(),expect(e).to.be.equal(1)})),it("Should exectute throttled function with correct argument",(async()=>{let e="";const func=t=>{e=t};u(func,"first"),u(func,"second"),expect(e).to.be.equal("first"),await b(),expect(e).to.be.equal("second"),u(func,"third"),u(func,"fourth"),u(func,"sixt"),expect(e).to.be.equal("third"),await b(),expect(e).to.be.equal("sixt")})),it("Should execute throttled function in the next frame if called multiple times",(async()=>{let e=0;const func=()=>{e++};u(func),u(func),u(func),u(func),expect(e).to.be.equal(1),await b(),expect(e).to.be.equal(2),await b(),expect(e).to.be.equal(2)})),it("Should execute throttled function after specified delay",(async()=>{let e=0;const func=()=>{e++};u(func,void 0,void 0,10),u(func,void 0,void 0,10),u(func,void 0,void 0,10),u(func,void 0,void 0,10),expect(e).to.be.equal(1),await b(),await b(),await b(),await b(),await b(),await b(),await b(),await b(),await b(),await b(),expect(e).to.be.equal(2),await b(),expect(e).to.be.equal(2)})),it("Should exectute debounced function in the next frame",(async()=>{let e=0;v((()=>{e++})),expect(e).to.be.equal(0),await b(),expect(e).to.be.equal(1)})),it("Should exectute debounced function with correct argument",(async()=>{let e="";const func=t=>{e=t};v(func,"first"),v(func,"second"),await b(),expect(e).to.be.equal("second"),await b(),v(func,"third"),v(func,"fourth"),v(func,"sixt"),await b(),expect(e).to.be.equal("sixt")})),it("Should postpone debounced function execution if called multiple times before specified delay",(async()=>{let e=0;const func=()=>{e++};v(func,void 0,void 0,2),expect(e).to.be.equal(0),await b(),v(func,void 0,void 0,2),expect(e).to.be.equal(0),await b(),v(func),expect(e).to.be.equal(0),await b(),expect(e).to.be.equal(1)})),it("Should execute debounced function after specified delay",(async()=>{let e=0;v((()=>{e++}),void 0,void 0,10),expect(e).to.be.equal(0),await b(),await b(),await b(),await b(),await b(),await b(),await b(),await b(),await b(),await b(),expect(e).to.be.equal(1)})),it("Should abort execution if node is disposed",(async()=>{let e=0;const func=()=>{e++},t=new o;v(func,void 0,t),t.dispose(),await b(),expect(e).to.be.equal(0),u(func,void 0,t),u(func,void 0,t),await b(),expect(e).to.be.equal(0),await b(),expect(e).to.be.equal(0)}))}))}}class VDOMTest{run(){describe("VDOM",(()=>{it("Should construct an native DIV element",(()=>{const e=x(g());expect(e).to.exist,expect(e.localName).to.equal("div")})),it("Should apply native element properties to the native DIV element",(()=>{const e=document.createElement("div");h(e,{tabIndex:0,contentEditable:!0,spellcheck:!1}),expect(e.tabIndex).to.equal(0),expect(e.contentEditable).to.equal("true"),expect(e.spellcheck).to.equal(!1),expect(e.getAttribute("tabindex")).to.equal("0"),expect(e.getAttribute("contenteditable")).to.equal("true"),expect(e.getAttribute("spellcheck")).to.equal("false"),h(e,{tabIndex:void 0,contentEditable:void 0,spellcheck:void 0}),expect(e.tabIndex).to.equal(-1),expect(e.contentEditable).to.equal("inherit"),expect(e.spellcheck).to.equal(!0),expect(e.getAttribute("tabindex")).to.equal(null),expect(e.getAttribute("contenteditable")).to.equal(null),expect(e.getAttribute("spellcheck")).to.equal(null)})),it("Should reset properties to defaults if they are not in the props when the element is updated after initial applyNativeElementProps",(()=>{const e=document.createElement("div");h(e,{tabIndex:0,contentEditable:!0,spellcheck:!1}),expect(e.tabIndex).to.equal(0),expect(e.contentEditable).to.equal("true"),expect(e.spellcheck).to.equal(!1),expect(e.getAttribute("tabindex")).to.equal("0"),expect(e.getAttribute("contenteditable")).to.equal("true"),expect(e.getAttribute("spellcheck")).to.equal("false"),h(e,{tabIndex:1,contentEditable:void 0,spellcheck:void 0}),expect(e.tabIndex).to.equal(1),expect(e.contentEditable).to.equal("inherit"),expect(e.spellcheck).to.equal(!0),expect(e.getAttribute("tabindex")).to.equal("1"),expect(e.getAttribute("contenteditable")).to.equal(null),expect(e.getAttribute("spellcheck")).to.equal(null)}))}))}}var __decorate$2=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};class NodeTest{run(){describe("Node",(()=>{it("Should have core API functions defined",(()=>{const e=new o;expect(e.setProperty).to.be.a("function"),expect(e.applyProperties).to.be.a("function"),expect(e.setProperties).to.be.a("function"),expect(e.inputValue).to.be.a("function"),expect(e.changed).to.be.a("function"),expect(e.queue).to.be.a("function"),expect(e.dispatchQueue).to.be.a("function"),expect(e.throttle).to.be.a("function"),expect(e.debounce).to.be.a("function"),expect(e.onPropertyMutated).to.be.a("function"),expect(e.bind).to.be.a("function"),expect(e.unbind).to.be.a("function"),expect(e.addEventListener).to.be.a("function"),expect(e.removeEventListener).to.be.a("function"),expect(e.dispatchEvent).to.be.a("function"),expect(e.dispose).to.be.a("function"),e.dispose()})),it("Should register property definitions correctly",(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop0:{type:String},prop1:{value:!1},prop2:-1,prop3:Number,prop4:Object,prop5:[0,1,2],prop6:{value:"hello",type:String},prop7:{value:!0,type:Boolean},prop8:{value:1,type:Number},prop9:{type:Array,init:[1,2,3]},prop10:{type:Array,init:null}}}};e=__decorate$2([t],e);const p=new e;expect(p.prop0).to.be.equal(""),expect(p.prop1).to.be.equal(!1),expect(p.prop2).to.be.equal(-1),expect(p.prop3).to.be.equal(0),expect(p.prop4).to.be.eql({}),expect(p.prop5).to.be.eql([0,1,2]),expect(p.prop6).to.be.equal("hello"),expect(p.prop7).to.be.equal(!0),expect(p.prop8).to.be.equal(1),expect(p.prop9).to.be.eql([1,2,3]),expect(p._reactiveProperties.get("prop0")).to.be.eql({value:"",type:String,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop1")).to.be.eql({value:!1,type:void 0,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop2")).to.be.eql({value:-1,type:void 0,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop3")).to.be.eql({value:0,type:Number,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop4")).to.be.eql({value:{},type:Object,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop5")).to.be.eql({value:[0,1,2],type:void 0,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop6")).to.be.eql({value:"hello",type:String,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop7")).to.be.eql({value:!0,type:Boolean,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop8")).to.be.eql({value:1,type:Number,binding:void 0,reflect:!1,init:void 0}),expect(p._reactiveProperties.get("prop9")).to.be.eql({value:[1,2,3],type:Array,binding:void 0,reflect:!1,init:[1,2,3]}),expect(p._reactiveProperties.get("prop10")).to.be.eql({value:void 0,type:Array,binding:void 0,reflect:!1,init:null}),p.dispose()})),it("Should aggregate property definitions from protochain",(()=>{let e=class Object1 extends o{static get ReactiveProperties(){return{prop1:{value:0},prop2:null,prop3:{value:"test",type:String,reflect:!0}}}};e=__decorate$2([t],e);let p=class Object2 extends e{static get ReactiveProperties(){return{prop1:{value:"asd",init:!1},prop2:{init:!0},prop3:""}}};p=__decorate$2([t],p);const r=new e,n=new p,a=r._protochain.reactiveProperties,i=n._protochain.reactiveProperties;expect(Array.from(r._reactiveProperties.keys())).to.be.eql(["reactivity","prop1","prop2","prop3"]),expect(Array.from(n._reactiveProperties.keys())).to.be.eql(["reactivity","prop1","prop2","prop3"]),expect(a.prop1.value).to.be.equal(0),expect(r._reactiveProperties.get("prop1")).to.be.eql({value:0,type:void 0,binding:void 0,reflect:!1,init:void 0}),expect(i.prop1.value).to.be.eql("asd"),expect(n._reactiveProperties.get("prop1")).to.be.eql({value:"asd",type:void 0,binding:void 0,reflect:!1,init:!1}),expect(n._reactiveProperties.get("prop2")).to.be.eql({value:null,type:void 0,binding:void 0,reflect:!1,init:!0}),expect(n._reactiveProperties.get("prop3")).to.be.eql({value:"",type:String,binding:void 0,reflect:!0,init:void 0})})),it("Should correctly register properties with bindigs",(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{label:""}}constructor(e){super(e)}};e=__decorate$2([t],e);const r=new p(new e({label:"label1"}),"label"),n=new p(new e({label:"label2"}),"label"),a=new p(new e({label:"label3"}),"label");let i=class Object1 extends o{static get ReactiveProperties(){return{prop1:r}}};i=__decorate$2([t],i);let l=class Object2 extends i{static get ReactiveProperties(){return{prop1:{binding:n},prop3:a}}};l=__decorate$2([t],l);const c=new i,s=new l;expect(c._reactiveProperties.get("prop1").binding).to.be.equal(r),expect(s._reactiveProperties.get("prop1").binding).to.be.equal(n),expect(s._reactiveProperties.get("prop3").binding).to.be.equal(a),expect(r.targets[0]).to.be.equal(c),expect(n.targets[0]).to.be.equal(s),expect(a.targets[0]).to.be.equal(s),expect(c._reactiveProperties.get("prop1").value).to.be.equal("label1"),expect(s._reactiveProperties.get("prop1").value).to.be.equal("label2"),expect(s._reactiveProperties.get("prop3").value).to.be.equal("label3")})),it("Should correctly get/set properties",(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop1:{value:1}}}};e=__decorate$2([t],e);const p=new e;expect(p._reactiveProperties.get("prop1").value).to.be.equal(1),expect(p.prop1).to.be.equal(1),p.setProperty("prop1",0),expect(p._reactiveProperties.get("prop1").value).to.be.equal(0),expect(p.prop1).to.be.equal(0)})),it("Should correctly get/set bound properties",(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{label:""}}constructor(e){super(e)}};e=__decorate$2([t],e);const r=new p(new e({label:"label1"}),"label"),n=new p(new e({label:"label2"}),"label");let a=class TestNode2 extends o{static get ReactiveProperties(){return{prop1:r}}};a=__decorate$2([t],a);const i=new a;expect(i._reactiveProperties.get("prop1").value).to.be.equal("label1"),expect(i.prop1).to.be.equal("label1"),expect(i._reactiveProperties.get("prop1").binding).to.be.equal(r),expect(r.targets[0]).to.be.equal(i),i.setProperty("prop1",n),expect(i._reactiveProperties.get("prop1").value).to.be.equal("label2"),expect(i.prop1).to.be.equal("label2"),expect(r.targets[0]).to.be.equal(void 0),expect(n.targets[0]).to.be.equal(i)})),it("Should execute attribute reflection on IoElement",(()=>{let e=class TestElementReflection extends d{static get ReactiveProperties(){return{label:{value:"label1",reflect:!0},label2:"label2"}}};e=__decorate$2([t],e);const o=new e;expect(o.getAttribute("label")).to.be.equal("label1"),expect(o.getAttribute("label2")).to.be.equal(null),o.label="label2",expect(o.getAttribute("label")).to.be.equal("label2"),o.setProperty("label","label3"),expect(o.getAttribute("label")).to.be.equal("label3")})),it('Should dipatch "[propName]-changed" events correctly',(async()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{propChangedEvents:Array,prop:Number}}static get Listeners(){return{"prop-changed":"onPropChanged"}}constructor(e){super(e)}onPropChanged(e){this.propChangedEvents.push(e.detail)}};e=__decorate$2([t],e);const r=new e;expect(r.propChangedEvents).to.be.eql([]),r.addEventListener("prop-changed",(()=>{expect("This should not execute").to.be.eql(!0)})),r.removeEventListener("prop-changed"),r.addEventListener("prop-changed",(e=>{const t=e.detail.oldValue,o=e.detail.value;expect(t).to.be.eql(0),expect(o).to.be.eql(1)})),r.prop=1,r.removeEventListener("prop-changed"),r.addEventListener("prop-changed",(()=>{expect("This is actually not expected to happen!").to.be.equal(!0)})),r.setProperty("prop",2,!0),r.removeEventListener("prop-changed"),expect(r.propChangedEvents).to.be.eql([{oldValue:0,property:"prop",value:1}]),await b(),expect(r.propChangedEvents).to.be.eql([{oldValue:0,property:"prop",value:1},{oldValue:1,property:"prop",value:2}]),r.setProperty("prop",3,!0),r.prop=4,await b(),expect(r.propChangedEvents).to.be.eql([{oldValue:0,property:"prop",value:1},{oldValue:1,property:"prop",value:2},{oldValue:2,property:"prop",value:4}]);const n=new e({prop:new p(r,"prop")});expect(n.propChangedEvents).to.be.eql([{oldValue:0,property:"prop",value:4}]);const a=new e({prop:-1});expect(a.propChangedEvents).to.be.eql([{oldValue:0,property:"prop",value:-1}]),a.propChangedEvents.length=0,a.reactivity="debounced",a.prop=10,expect(a.propChangedEvents).to.be.eql([]),await b(),expect(a.propChangedEvents).to.be.eql([{oldValue:-1,property:"prop",value:10}]),a.propChangedEvents.length=0,a.reactivity="none",a.prop=20,expect(a.propChangedEvents).to.be.eql([]),await b(),expect(a.propChangedEvents).to.be.eql([])})),it("Should execute throttle/debounce queue in FIFO order",(async()=>{let e=[];const t=new o;t.debounce((()=>{e.push(1)})),t.debounce((()=>{e.push(2)}));const throttleFuc=()=>{e.push(0)};t.throttle(throttleFuc),t.throttle(throttleFuc),await b(),expect(e).to.be.eql([0,1,2,0])})),it('Should add/remove "object-mutated" event listeners to properties of Node type',(async()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop:Number}}constructor(e){super(e)}};e=__decorate$2([t],e);const r=new e,n=new e({prop:r});expect(r._eventDispatcher.addedListeners["object-mutated"][0][0]).to.be.equal(n.onPropertyMutated),n.prop=null,expect(r._eventDispatcher.addedListeners["object-mutated"]).to.be.equal(void 0);const a=new e;n.prop=a,expect(a._eventDispatcher.addedListeners["object-mutated"][0][0]).to.be.equal(n.onPropertyMutated);let i=class TestNode2 extends o{static get ReactiveProperties(){return{prop:e}}};i=__decorate$2([t],i);const l=new i,c=l.prop;expect(c._eventDispatcher.addedListeners["object-mutated"][0][0]).to.be.equal(l.onPropertyMutated),l.dispose(),expect(c._eventDispatcher.addedListeners["object-mutated"]).to.be.equal(void 0);const s=new i,d=s.prop;s.prop=null,expect(d._eventDispatcher.addedListeners["object-mutated"]).to.be.equal(void 0);const u=new i,b=new i,v=u.prop,x=b.prop;u.prop=new p(b,"prop"),expect(v._eventDispatcher.addedListeners["object-mutated"]).to.be.equal(void 0),expect(x._eventDispatcher.addedListeners["object-mutated"][0][0]).to.be.equal(b.onPropertyMutated),expect(x._eventDispatcher.addedListeners["object-mutated"][1][0]).to.be.equal(u.onPropertyMutated)})),it("Should corectly invoke handler functions on change",(async()=>{let e=class TestNode extends o{changedCounter=0;prop1Changes=[];prop2Changes=[];static get ReactiveProperties(){return{prop1:String,prop2:String}}changed(){this.changedCounter++}prop1Changed(e){this.prop1Changes.push(e)}prop2Changed(e){this.prop2Changes.push(e)}};e=__decorate$2([t],e);const p=new e;expect(p.changedCounter).to.equal(0),expect(p.prop1Changes).to.be.eql([]),expect(p.prop2Changes).to.be.eql([]),p.prop1="one",expect(p.changedCounter).to.equal(1),expect(p.prop1Changes).to.be.eql([{property:"prop1",oldValue:"",value:"one"}]),expect(p.prop2Changes).to.be.eql([]),p.prop1Changes.length=0,p.prop1="two",p.prop2="test",expect(p.changedCounter).to.equal(3),expect(p.prop1Changes).to.be.eql([{property:"prop1",oldValue:"one",value:"two"}]),expect(p.prop2Changes).to.be.eql([{property:"prop2",oldValue:"",value:"test"}]),p.prop1Changes.length=0,p.prop2Changes.length=0,p.setProperties({prop1:"three",prop2:""}),expect(p.changedCounter).to.equal(4),expect(p.prop1Changes).to.be.eql([{property:"prop1",oldValue:"two",value:"three"}]),expect(p.prop2Changes).to.be.eql([{property:"prop2",oldValue:"test",value:""}]),p.prop1Changes.length=0,p.prop2Changes.length=0,p.reactivity="debounced",p.setProperties({prop1:"four",prop2:"test2"}),expect(p.prop1Changes).to.be.eql([]),expect(p.prop2Changes).to.be.eql([]),await b(),expect(p.prop1Changes).to.be.eql([{property:"prop1",oldValue:"three",value:"four"}]),expect(p.prop2Changes).to.be.eql([{property:"prop2",oldValue:"",value:"test2"}]),p.prop1Changes.length=0,p.prop2Changes.length=0,p.reactivity="none",p.setProperties({prop1:"five",prop2:"test3"}),await b(),expect(p.prop1Changes).to.be.eql([]),expect(p.prop2Changes).to.be.eql([]),p.dispose()})),it("should invoke property mutation handler functions on mutation event",(async()=>{let e=class TestSubNode extends o{static get ReactiveProperties(){return{a:{value:0}}}};e=__decorate$2([t],e);let p=class TestNode extends o{changedCounter=0;obj1MutatedCounter=0;obj2MutatedCounter=0;static get ReactiveProperties(){return{obj1:{type:e},obj2:{type:e}}}obj1Mutated(){this.obj1MutatedCounter++}obj2Mutated(){this.obj2MutatedCounter++}};p=__decorate$2([t],p);const r=new p;expect(r.changedCounter).to.equal(0),expect(r.obj1MutatedCounter).to.equal(0),r.obj1.a=1,await b(),expect(r.obj1MutatedCounter).to.equal(1),expect(r.obj2MutatedCounter).to.equal(0),r.obj2.a=1,expect(r.obj2MutatedCounter).to.equal(1),await b(),r.obj1=new p,await b(),expect(r.obj1MutatedCounter).to.equal(1),r.obj1.obj1={a:1},await b(),expect(r.obj1MutatedCounter).to.equal(2),r.dispose()})),it("should correctly bind properties",(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop1:String,prop2:String}}constructor(e){super(e)}};e=__decorate$2([t],e);const r=new e,n=r.bind("prop1");expect(n).to.be.instanceof(p),expect(n.node).to.be.equal(r),expect(n.property).to.be.equal("prop1");const a=new e({prop1:n}),i=new e({prop1:n});i.prop2=n,expect(n.targets[0]).to.be.equal(a),expect(n.targets[1]).to.be.equal(i),expect(n.targetProperties.get(a)[0]).to.be.equal("prop1"),expect(n.targetProperties.get(a)[1]).to.be.equal(void 0),expect(n.targetProperties.get(i)[0]).to.be.equal("prop1"),expect(n.targetProperties.get(i)[1]).to.be.equal("prop2"),r.prop1="one",expect(a.prop1).to.be.equal("one"),expect(a.prop2).to.be.equal(""),expect(i.prop1).to.be.equal("one"),expect(i.prop2).to.be.equal("one"),a.prop1="two",expect(r.prop1).to.be.equal("two"),expect(i.prop1).to.be.equal("two"),expect(n.targets.length).to.be.equal(2),a.dispose(),expect(n.targets.length).to.be.equal(1),i.dispose(),expect(n.targets.length).to.be.equal(0),r.dispose()})),it("Should correctly set values when setProperties() is used to re-set multiple bindings",(async()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop1:"subnode1",prop2:"subnode2",prop3:"subnode3"}}constructor(e){super(e)}};e=__decorate$2([t],e);let p=class TestNodeTarget extends o{static get ReactiveProperties(){return{subnode:e,prop1:"target1",prop2:"target2",prop3:"target3"}}ready(){this.changed()}changed(){this.subnode.setProperties({prop1:this.bind("prop1"),prop2:this.bind("prop2"),prop3:this.bind("prop3")})}};p=__decorate$2([t],p);const r=new p;expect(r.subnode.prop1).to.be.equal(r.prop1).to.be.equal("target1"),expect(r.subnode.prop2).to.be.equal(r.prop2).to.be.equal("target2"),expect(r.subnode.prop3).to.be.equal(r.prop3).to.be.equal("target3");const n=new e({prop1:"source1",prop2:"source2",prop3:"source3"});r.setProperties({prop1:n.bind("prop1"),prop2:n.bind("prop2"),prop3:n.bind("prop3")}),expect(r.subnode.prop1).to.be.equal(n.prop1).to.be.equal(r.prop1).to.be.equal("source1"),expect(r.subnode.prop2).to.be.equal(n.prop2).to.be.equal(r.prop2).to.be.equal("source2"),expect(r.subnode.prop3).to.be.equal(n.prop3).to.be.equal(r.prop3).to.be.equal("source3"),n.prop1="test1",r.prop2="test2",r.subnode.prop3="test3",expect(r.subnode.prop1).to.be.equal(n.prop1).to.be.equal(r.prop1).to.be.equal("test1"),expect(r.subnode.prop2).to.be.equal(n.prop2).to.be.equal(r.prop2).to.be.equal("test2"),expect(r.subnode.prop3).to.be.equal(n.prop3).to.be.equal(r.prop3).to.be.equal("test3"),r.setProperties({prop1:"final1",prop2:"final2",prop3:"final3"}),expect(r.subnode.prop1).to.be.equal(n.prop1).to.be.equal(r.prop1).to.be.equal("final1"),expect(r.subnode.prop2).to.be.equal(n.prop2).to.be.equal(r.prop2).to.be.equal("final2"),expect(r.subnode.prop3).to.be.equal(n.prop3).to.be.equal(r.prop3).to.be.equal("final3")})),it("Should add/remove targets and targetProperties when assigned to values",(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop1:String,prop2:String}}constructor(e){super(e)}};e=__decorate$2([t],e);const r=new e,n=new p(r,"prop1"),a=new p(r,"prop2"),i=new e;i.prop1=n,i.prop2=a;const l=new e({prop1:n}),c=new e({prop1:n,prop2:n});expect(n.targets[0]).to.be.equal(i),expect(n.targets[1]).to.be.equal(l),expect(n.targets[2]).to.be.equal(c),expect(n.targetProperties.get(i)).to.be.eql(["prop1"]),expect(n.targetProperties.get(l)).to.be.eql(["prop1"]),expect(n.targetProperties.get(c)).to.be.eql(["prop1","prop2"]),i.dispose(),l.unbind("prop1"),c.unbind("prop1"),expect(n.targetProperties.get(i)).to.be.eql([]),expect(n.targetProperties.get(l)).to.be.eql([]),expect(n.targetProperties.get(c)).to.be.eql(["prop2"]),l.prop2=n,l.prop1=n,c.prop1=n,expect(n.targetProperties.get(l)).to.be.eql(["prop2","prop1"]),expect(n.targetProperties.get(c)).to.be.eql(["prop2","prop1"])})),it('Should return existing binding or create a new on "bind()"',(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop1:String,prop2:String}}};e=__decorate$2([t],e);const p=new e,r=p.bind("prop1");expect(r).to.be.equal(p._bindings.get("prop1")),expect(r).to.be.equal(p.bind("prop1"))})),it("Should dispose bindings correctly",(()=>{let e=class TestNode extends o{static get ReactiveProperties(){return{prop1:String,prop2:String}}};e=__decorate$2([t],e);const p=new e,r=p.bind("prop1");p.unbind("prop1"),expect(p._bindings.get("prop1")).to.be.equal(void 0),expect(r.node).to.be.equal(void 0);const n=new e,a=n.bind("prop1");n.dispose(),expect(n._bindings).to.be.equal(void 0),expect(a.node).to.be.equal(void 0),expect(a.property).to.be.equal(void 0),expect(a.targets).to.be.equal(void 0),expect(a.targetProperties).to.be.equal(void 0)}))}))}}async function afterHashChange(){return new Promise((e=>{self.addEventListener("hashchange",(()=>{e()}),{once:!0})}))}localStorage.removeItem("Storage:test2"),localStorage.removeItem("Storage:test3"),localStorage.removeItem("Storage:test4"),localStorage.removeItem("Storage:test5");const R=localStorage.getItem("Storage:user-permitted");localStorage.setItem("Storage:user-permitted","true");class StorageTest{run(){describe("Storage.test.ts",(()=>{it("Should register property definitions correctly",(()=>{const e=new q({key:"test",value:"foo"});expect(e.key).to.be.equal("test"),expect(e.value).to.be.equal("foo"),expect(e.default).to.be.equal("foo"),expect(e.storage).to.be.equal("none"),expect(e._reactiveProperties.get("key")).to.eql({binding:void 0,reflect:!1,init:void 0,type:String,value:"test"}),expect(e._reactiveProperties.get("value")).to.eql({binding:void 0,reflect:!1,init:void 0,type:void 0,value:"foo"}),expect(e._reactiveProperties.get("default")).to.eql({binding:void 0,reflect:!1,init:void 0,type:void 0,value:"foo"}),expect(e._reactiveProperties.get("storage")).to.eql({binding:void 0,reflect:!1,init:void 0,type:String,value:"none"}),e.dispose()})),it("Should initialize property value from localStorage store if exists",(()=>{localStorage.setItem("Storage:test2",'"asd"');const e=new q({key:"test2",value:"buzz",storage:"local"});expect(e.key).to.be.equal("test2"),expect(e.value).to.be.equal("asd"),expect(e.default).to.be.equal("buzz"),expect(e.storage).to.be.equal("local"),e.dispose()})),it("Should initialize property value from location.hash store if exists",(async()=>{self.location.hash=self.location.hash+"&testhash=foo";const e=new q({key:"testhash",value:"buzz",storage:"hash"});expect(e.key).to.be.equal("testhash"),expect(e.value).to.be.equal("foo"),expect(e.default).to.be.equal("buzz"),expect(e.storage).to.be.equal("hash"),e.dispose()})),it("Should return a new instance only if key and store are unique",(()=>{const e=new q({key:"test3",storage:"local"}),t=new q({key:"test3",storage:"local"}),o=new q({key:"test3",storage:"hash"}),p=new q({key:"test4",storage:"local"});expect(e).to.be.equal(t),expect(e).to.not.be.equal(o),expect(e).to.not.be.equal(p),e.dispose(),o.dispose(),p.dispose()})),it("Should update localStorage store when value changes",(()=>{const e=new q({key:"test5",value:"one",storage:"local"});expect(localStorage.getItem("Storage:test5")).to.be.equal(null),e.value="two",expect(localStorage.getItem("Storage:test5")).to.be.equal('"two"'),e.value="2",expect(localStorage.getItem("Storage:test5")).to.be.equal('"2"'),e.value=2,expect(localStorage.getItem("Storage:test5")).to.be.equal("2"),e.value="one",expect(localStorage.getItem("Storage:test5")).to.be.equal(null),e.dispose()})),it("Should update location.hash store when value changes to non-default",(async()=>{const e=new q({key:"test6",value:"one",storage:"hash"});e.value="two",expect(self.location.hash).to.include("test6=two"),e.value="2",expect(self.location.hash).to.include("test6=%222%22"),e.value=!0,expect(self.location.hash).to.include("test6=true"),e.value=2,expect(self.location.hash).to.include("test6=2"),self.location.hash=self.location.hash.replace("test6=2","test6=3"),await afterHashChange(),expect(e.value).to.be.equal(3),self.location.hash=self.location.hash.replace("test6=3",'test6="3"'),await afterHashChange(),expect(e.value).to.be.equal("3"),self.location.hash=self.location.hash.replace("test6=%223%22","test6=false"),await afterHashChange(),expect(e.value).to.be.equal(!1),e.value=[0,1,2],expect(self.location.hash).to.include("test6=[0,1,2]"),e.value=[0,1,"2"],expect(self.location.hash).to.include("test6=[0,1,%222%22]"),e.value="2",expect(self.location.hash).to.include("test6=%222%22"),e.dispose(),R&&"false"!==R||localStorage.setItem("Storage:user-permitted","false")})),it("Storage should return binding to StorageNode Node",(()=>{const e=y({key:"test",storage:"hash"});e.value="foo",expect(e).to.be.instanceOf(p),e.dispose(),expect(self.location.hash).to.not.include("test=foo")}))}))}}const M=f,H=M._reactiveProperties.get("themeID").binding;class ThemeTest{run(){describe("Theme",(()=>{it("Should register property definitions correctly",(()=>{expect(M._reactiveProperties.get("themeID")).to.eql({binding:H,init:void 0,reflect:!1,type:String,value:M.themeID})}))}))}}var __decorate$1=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};const A=new d;A.style.display="none",document.body.appendChild(A);const z=[];class TestElement extends d{static get ReactiveProperties(){return{prop0:{reflect:!0,value:0}}}}t(TestElement);const I=new TestElement;class IoElementTest{run(){describe("IoElement",(()=>{it("Should have core API functions defined",(()=>{expect(A.render).to.be.a("function"),expect(A.traverse).to.be.a("function"),expect(A.setAttribute).to.be.a("function"),expect(A.$).to.be.a("object")})),it("Should initialize properties correctly",(()=>{expect(I.prop0).to.equal(0),expect(I.getAttribute("prop0")).to.equal("0")})),it("Invokes change events and functions",(()=>{class TestNode extends o{static get ReactiveProperties(){return{prop0:0,prop1:""}}prop0Changed(){z.push("TestNode: prop0Changed "+this.prop0)}prop1Changed(){z.push("TestNode: prop1Changed "+this.prop1)}changed(){z.push("TestNode: changed")}}t(TestNode);t(class TestSubelement extends d{static get ReactiveProperties(){return{prop0:0,prop1:""}}});class TestElement1 extends d{static get ReactiveProperties(){return{prop0:-1,prop1:{value:"default"},_counter:0,_prop0counter:0,_prop0Change:null,_prop1counter:0,_prop1Change:null}}constructor(...e){super(...e),this.render([{tag:"test-subelement",props:{id:"subelement",prop0:this.bind("prop0"),prop1:this.bind("prop1")}}]),this.subnode=new TestNode({prop0:this.bind("prop0"),prop1:this.bind("prop1")})}changed(){z.push("TestElement1: changed"),this._counter++}prop0Changed(e){z.push("TestElement1: prop0Changed "+this.prop0),this._prop0counter++,this._prop0Change=e}prop1Changed(e){z.push("TestElement1: prop1Changed "+this.prop1),this._prop1counter++,this._prop1Change=e}}t(TestElement1),z.length=0;const e=new TestElement1;expect(e.prop0).to.equal(-1),expect(e.subnode.prop0).to.equal(-1),expect(e.$.subelement.prop0).to.equal(-1),expect(e.$.subelement.prop1).to.equal("default"),expect(e.subnode.prop0).to.equal(-1),expect(e.subnode.prop1).to.equal("default"),expect(e._counter).to.equal(0),expect(e._prop0counter).to.equal(0),expect(e._prop0Change).to.equal(null),expect(e._prop1counter).to.equal(0),expect(e._prop1Change).to.equal(null),e.subnode.prop0=1,expect(e.prop0).to.equal(1),expect(e.subnode.prop0).to.equal(1),expect(e._counter).to.equal(1),expect(e._prop0counter).to.equal(1),expect(e._prop0Change).to.eql({property:"prop0",value:1,oldValue:-1}),expect(e._prop1counter).to.equal(0),expect(e._prop1Change).to.equal(null),e.setProperties({prop0:2,prop1:"foo"}),expect(e.prop0).to.equal(2),expect(e.subnode.prop0).to.equal(2),expect(e.$.subelement.prop0).to.equal(2),expect(e.prop1).to.equal("foo"),expect(e.subnode.prop1).to.equal("foo"),expect(e.$.subelement.prop1).to.equal("foo"),expect(e._counter).to.equal(2),expect(e._prop0counter).to.equal(2),expect(e._prop0Change).to.eql({property:"prop0",value:2,oldValue:1}),expect(e._prop1counter).to.equal(1),expect(e._prop1Change).to.eql({property:"prop1",value:"foo",oldValue:"default"}),e.subnode.setProperties({prop0:3,prop1:"buzz"}),expect(e.prop0).to.equal(3),expect(e.subnode.prop0).to.equal(3),expect(e.$.subelement.prop0).to.equal(3),expect(e.$.subelement.prop0).to.equal(3),expect(e.prop1).to.equal("buzz"),expect(e.subnode.prop1).to.equal("buzz"),expect(e.$.subelement.prop1).to.equal("buzz"),expect(e._counter).to.equal(4),expect(e._prop0counter).to.equal(3),expect(e._prop0Change).to.eql({property:"prop0",value:3,oldValue:2}),expect(e._prop1counter).to.equal(2),expect(e._prop1Change).to.eql({property:"prop1",value:"buzz",oldValue:"foo"}),expect(z).to.eql(["TestNode: prop0Changed -1","TestNode: prop1Changed default","TestNode: changed","TestNode: prop0Changed 1","TestElement1: prop0Changed 1","TestElement1: changed","TestNode: changed","TestElement1: prop0Changed 2","TestNode: prop0Changed 2","TestNode: changed","TestElement1: prop1Changed foo","TestNode: prop1Changed foo","TestNode: changed","TestElement1: changed","TestNode: prop0Changed 3","TestElement1: prop0Changed 3","TestElement1: changed","TestNode: prop1Changed buzz","TestElement1: prop1Changed buzz","TestElement1: changed","TestNode: changed"]),z.length=0;class TestElement2 extends d{static get ReactiveProperties(){return{prop0:-1,prop1:{value:""}}}changed(){this.render([{tag:"test-subelement",props:{id:"subelement",prop0:this.bind("prop0"),prop1:this.bind("prop1")}}])}}t(TestElement2);const p=new TestElement2;p.prop0=1,p.prop1="default",expect(p.prop0).to.equal(1),expect(p.$.subelement.prop0).to.equal(1),expect(p.prop1).to.equal("default"),expect(p.$.subelement.prop1).to.equal("default"),p.setProperties({prop0:2,prop1:"foo"}),expect(p.prop0).to.equal(2),expect(p.$.subelement.prop0).to.equal(2),expect(p.prop1).to.equal("foo"),expect(p.$.subelement.prop1).to.equal("foo"),p.$.subelement.setProperties({prop0:3,prop1:"buzz"}),expect(p.prop0).to.equal(3),expect(p.$.subelement.prop0).to.equal(3),expect(p.prop1).to.equal("buzz"),expect(p.$.subelement.prop1).to.equal("buzz")})),it("Should correctly set values when setProperties() is used to re-set multiple bindings",(async()=>{let e=class TestBindingElement extends d{static get ReactiveProperties(){return{prop1:"subnode1",prop2:"subnode2",prop3:"subnode3"}}};e=__decorate$1([t],e);let o=class TestBindingElementTarget extends d{static get ReactiveProperties(){return{prop1:"target1",prop2:"target2",prop3:"target3"}}ready(){this.changed()}changed(){this.render([{tag:"test-binding-element",props:{id:"testElement",prop1:this.bind("prop1"),prop2:this.bind("prop2"),prop3:this.bind("prop3")}}])}};o=__decorate$1([t],o);const p=new o;expect(p.$.testElement.prop1).to.be.equal(p.prop1).to.be.equal("target1"),expect(p.$.testElement.prop2).to.be.equal(p.prop2).to.be.equal("target2"),expect(p.$.testElement.prop3).to.be.equal(p.prop3).to.be.equal("target3");const r=new e({prop1:"source1",prop2:"source2",prop3:"source3"});p.setProperties({prop1:r.bind("prop1"),prop2:r.bind("prop2"),prop3:r.bind("prop3")}),expect(p.$.testElement.prop1).to.be.equal(r.prop1).to.be.equal(p.prop1).to.be.equal("source1"),expect(p.$.testElement.prop2).to.be.equal(r.prop2).to.be.equal(p.prop2).to.be.equal("source2"),expect(p.$.testElement.prop3).to.be.equal(r.prop3).to.be.equal(p.prop3).to.be.equal("source3"),r.prop1="test1",p.prop2="test2",p.$.testElement.prop3="test3",expect(p.$.testElement.prop1).to.be.equal(r.prop1).to.be.equal(p.prop1).to.be.equal("test1"),expect(p.$.testElement.prop2).to.be.equal(r.prop2).to.be.equal(p.prop2).to.be.equal("test2"),expect(p.$.testElement.prop3).to.be.equal(r.prop3).to.be.equal(p.prop3).to.be.equal("test3"),p.setProperties({prop1:"final1",prop2:"final2",prop3:"final3"}),expect(p.$.testElement.prop1).to.be.equal(r.prop1).to.be.equal(p.prop1).to.be.equal("final1"),expect(p.$.testElement.prop2).to.be.equal(r.prop2).to.be.equal(p.prop2).to.be.equal("final2"),expect(p.$.testElement.prop3).to.be.equal(r.prop3).to.be.equal(p.prop3).to.be.equal("final3")})),it("Should bind and unbind correctly",(()=>{const e=new TestElement,t=new TestElement;t.prop0=e.bind("prop0"),e.prop0=1,expect(e.prop0).to.equal(1),expect(t.prop0).to.equal(1),t.prop0=2,expect(e.prop0).to.equal(2),expect(t.prop0).to.equal(2),e.unbind("prop0"),e.prop0=3,expect(e.prop0).to.equal(3),expect(t.prop0).to.equal(2),t.prop0=e.bind("prop0"),expect(t.prop0).to.equal(3),e.prop0=4,expect(e.prop0).to.equal(4),expect(t.prop0).to.equal(4),t.unbind("prop0"),e.prop0=5,expect(e.prop0).to.equal(5),expect(t.prop0).to.equal(4)})),it("Should bind from constructor",(()=>{const e=new TestElement,t=new TestElement({prop0:e.bind("prop0")});e.prop0=1,expect(t.prop0).to.equal(1),t.unbind("prop0"),e.prop0=2,expect(e.prop0).to.equal(2),expect(t.prop0).to.equal(1)}))}))}}var __decorate=function(e,t,o,p){var r,n=arguments.length,a=n<3?t:null===p?p=Object.getOwnPropertyDescriptor(t,o):p;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)a=Reflect.decorate(e,t,o,p);else for(var i=e.length-1;i>=0;i--)(r=e[i])&&(a=(n<3?r(a):n>3?r(t,o,a):r(t,o))||a);return n>3&&a&&Object.defineProperty(t,o,a),a};let $=class IoGlTest extends w{static get Frag(){return"\n      void main(void) {\n        gl_FragColor = uColor;\n      }\n\n"}};__decorate([e({type:Array,init:[0,0,0,0]})],$.prototype,"color",void 0),$=__decorate([t],$);const D=new $;D.size=[0,0],D.pxRatio=1,D.style.visibility="hidden",D.style.position="fixed",D.style.left="0",D.style.bottom="0",D.style.zIndex="1000000",document.body.appendChild(D);class IoGLTest{run(){describe("IoGL",(()=>{it("Should have core API functions defined",(()=>{expect(D.initShader).to.be.a("function"),expect(D.onResized).to.be.a("function"),expect(D.themeMutated).to.be.a("function"),expect(D.setShaderProgram).to.be.a("function"),expect(D.updatePropertyUniform).to.be.a("function"),expect(D.updateThemeUniforms).to.be.a("function"),expect(D.setUniform).to.be.a("function")})),it("Should initialize properties correctly",(()=>{D.onResized(),expect(D.size).to.be.eql([0,0]),expect(D.color).to.be.eql([0,0,0,0]),expect(D.pxRatio).to.be.equal(window.devicePixelRatio),expect(D.theme).to.be.equal(f),expect(D._reactiveProperties.get("size")).to.eql({binding:void 0,init:[0,0],reflect:!1,type:Array,value:[0,0]}),expect(D._reactiveProperties.get("pxRatio")).to.eql({binding:void 0,init:void 0,reflect:!1,type:Number,value:window.devicePixelRatio}),expect(D._reactiveProperties.get("theme")).to.eql({binding:void 0,init:void 0,reflect:!1,type:o,value:f})})),it("has <canvas> element",(()=>{expect(D.children[0].localName).to.equal("canvas")})),it("has correct size and pxRatio",(()=>{D.style.border="none",D.style.width="32px",D.style.height="32px",D.onResized(),expect(D.size[0]).to.equal(32),expect(D.size[1]).to.equal(32),expect(D.pxRatio).to.equal(window.devicePixelRatio)})),it("has correct color",(()=>{let e=D.ctx.getImageData(0,0,1,1).data;expect(e).to.eql(new Uint8ClampedArray([0,0,0,0])),D.color=[1,.5,.25,1],D.onRender(),e=D.ctx.getImageData(0,0,1,1).data,expect(e).to.eql(new Uint8ClampedArray([255,128,64,255])),D.color=[1,.25,.5,.5],D.onRender(),e=D.ctx.getImageData(0,0,1,1).data,expect(e).to.eql(new Uint8ClampedArray([128,32,64,64]))}))}))}}class IoOverlayTest{run(){describe("IoOverlay",(()=>{it("Should initialize properties correctly",(()=>{expect(m.expanded).to.be.eql(!1),expect(m._reactiveProperties.get("expanded")).to.eql({binding:void 0,init:void 0,reflect:!0,type:Boolean,value:!1})}))}))}}class index_test{run(){(new BindingTest).run(),(new ChangeQueueTest).run(),(new EventDispatcherTest).run(),(new ReactivePropertyTest).run(),(new ProtoChainTest).run(),(new QueueTest).run(),(new VDOMTest).run(),(new NodeTest).run(),(new StorageTest).run(),(new ThemeTest).run(),(new IoElementTest).run(),(new IoGLTest).run(),(new IoOverlayTest).run()}}export{index_test as default};
