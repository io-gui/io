import{NODES as t,Register as i,IoElement as e,h4 as o,p as n,div as s,span as r}from"io-gui";import{ioCollapsible as c}from"io-navigation";import{ioIcon as h}from"io-icons";const a=new Map,l={id:"roots",children:[]};let d=0;function initNodeInfo(t){if(a.has(t))return a.get(t);{const i={id:"node-"+d++,node:t,children:[]};return a.set(t,i),i}}t.active.forEach(t=>{const i=initNodeInfo(t);0===t._parents.length?l.children.length<24&&l.children.push(i):t._parents.forEach(t=>{const e=initNodeInfo(t);e.children.length<24&&e.children.push(i)})});const u=document.createElement("canvas");u.width=256,u.height=256,u.style.position="absolute",u.style.bottom="0",u.style.right="0",u.style.zIndex="1000",u.style.pointerEvents="none",document.body.appendChild(u);const p=u.width/2,f=u.height/2,g=Math.min(u.width,u.height)/60,m=u.getContext("2d");class SimulatedNode{constructor(t,i,e){this.name=t,this.position=i,this.children=[],this.parent=null,this.node=e,this.createVisual(),this.setupEventListeners()}createVisual(){this.radius=.5,this.color="#2196F3",this.originalColor="#2196F3",this.connections=[]}lerpColor(t,i,e){const o=parseInt(t.replace("#",""),16),n=parseInt(i.replace("#",""),16),s=o>>16&255,r=o>>8&255,c=255&o,h=n>>16&255,a=n>>8&255,l=255&n;return`#${(Math.round(s+(h-s)*e)<<16|Math.round(r+(a-r)*e)<<8|Math.round(c+(l-c)*e)).toString(16).padStart(6,"0")}`}setupEventListeners(){this.node&&this.node.addEventListener("io-object-mutation",()=>{this.animateMutation()})}animateMutation(){const t=this.originalColor,i="#FFFF00";this.animateColor(t,i,150,()=>{this.animateColor(i,t,800)})}animateColor(t,i,e,o){const n=Date.now(),animate=()=>{const s=Date.now()-n,r=Math.min(s/e,1);this.color=this.lerpColor(t,i,r),r<1?requestAnimationFrame(animate):o&&o()};animate()}addChild(t){return this.children.push(t),t.parent=this,this.createConnection(t)}createConnection(t){const i={nodeA:this,nodeB:t,color:"#666666"};return this.connections.push(i),i}}const y=function calculateRadialPositions(t){const i={},e=t.children||[],o={};return e.forEach((t,i)=>{const n=i/e.length*Math.PI*2,s=25*Math.cos(n),r=25*Math.sin(n);o[t.id]={x:s,y:r}}),function positionNode(t,e=0,n=0,s=2*Math.PI,r=0,c=1,h={x:0,y:0}){if("roots"!==t.id){const o=4*e+3;let a;if(0===e)a=0;else if(1===e)a=r/c*Math.PI*2;else{a=n-s/2+s/c*(r+.5)}const l=o*Math.cos(a)*2,d=o*Math.sin(a)*2,u=h.x+l,p=h.y+d;i[t.id]={x:u,y:p,z:0}}if(t.children&&t.children.length>0){const i="roots"===t.id?-1:e,r="roots"===t.id?{x:0,y:0}:o[t.id]||h,c=.8/(4*(i+1)+3)*t.children.length;let a;if(-1===i)a=2*Math.PI;else{const t=Math.min(.9*s,Math.PI);a=Math.max(c,Math.min(t,.6*Math.PI))}t.children.forEach((i,s)=>{const c="roots"===t.id?0:e+1,h="roots"===t.id?0:n,l="roots"===t.id?o[i.id]||{x:0,y:0}:r;positionNode(i,c,h,a,s,t.children.length,l)})}}(t),i}(l),x=function createNodesFromTree(t,i){const e={};return function createNode(t){if("roots"!==t.id){const o=i[t.id],n=t.node,s=new SimulatedNode(t.id,o,n);e[t.id]=s}t.children&&t.children.forEach(t=>createNode(t))}(t),e}(l,y),v=function connectNodes(t,i){const e=[];return function connect(t){if("roots"!==t.id){const o=i[t.id];t.children&&o&&t.children.forEach(t=>{const n=i[t.id];if(n){const t=o.addChild(n);e.push(t)}})}t.children&&t.children.forEach(t=>{connect(t)})}(t),e}(l,x),M=new class ForceDirectedLayout{constructor(t,i){this.nodes=t,this.connections=i,this.forces={},this.velocities={},this.damping=.7,this.repulsionStrength=4,this.attractionStrength=.05,this.centerAttractionStrength=.01,this.linkLength=2,this.maxVelocity=1,this.running=!1,this.coolingRate=.99,this.temperature=.1,this.minTemperature=.1,Object.keys(t).forEach(t=>{this.forces[t]={x:0,y:0},this.velocities[t]={x:0,y:0}})}calculateRepulsionForces(){const t=Object.keys(this.nodes);t.forEach(t=>{this.forces[t].x=0,this.forces[t].y=0});for(let i=0;i<t.length;i++)for(let e=i+1;e<t.length;e++){const o=this.nodes[t[i]],n=this.nodes[t[e]],s=o.position.x-n.position.x,r=o.position.y-n.position.y,c=s*s+r*r+.01,h=Math.sqrt(c),a=this.repulsionStrength*this.temperature/(c*h),l=s/h*a,d=r/h*a;this.forces[t[i]].x+=l,this.forces[t[i]].y+=d,this.forces[t[e]].x-=l,this.forces[t[e]].y-=d}}calculateAttractionForces(){this.connections.forEach(t=>{const i=t.nodeA,e=t.nodeB,o=e.position.x-i.position.x,n=e.position.y-i.position.y,s=Math.sqrt(o*o+n*n);let r=this.linkLength;const c=i.children.length,h=e.children.length;c>0&&(r*=1+c**.25),h>0&&(r*=1+h**.25);const a=this.attractionStrength*this.temperature*(s**2-r),l=o/s*a,d=n/s*a;this.forces[i.name].x+=l,this.forces[i.name].y+=d,this.forces[e.name].x-=l,this.forces[e.name].y-=d})}updatePositions(){Object.keys(this.nodes).forEach(t=>{const i=this.nodes[t];if("roots"===t)return;this.velocities[t].x+=this.forces[t].x,this.velocities[t].y+=this.forces[t].y;const e=Math.sqrt(this.velocities[t].x**2+this.velocities[t].y**2);e>this.maxVelocity&&(this.velocities[t].x=this.velocities[t].x/e*this.maxVelocity,this.velocities[t].y=this.velocities[t].y/e*this.maxVelocity),this.velocities[t].x*=this.damping,this.velocities[t].y*=this.damping;const o=i.position.x+this.velocities[t].x,n=i.position.y+this.velocities[t].y;i.position.x=o,i.position.y=n})}calculateCenterAttractionForces(){Object.keys(this.nodes).forEach(t=>{const i=this.nodes[t];if("roots"===t)return;const e=-i.position.x,o=-i.position.y,n=Math.sqrt(e*e+o*o)+.01,s=this.centerAttractionStrength*this.temperature*n,r=e/n*s,c=o/n*s;this.forces[t].x+=r,this.forces[t].y+=c})}step(){this.calculateRepulsionForces(),this.calculateAttractionForces(),this.calculateCenterAttractionForces(),this.updatePositions(),this.temperature>this.minTemperature&&(this.temperature*=this.coolingRate)}start(){this.running=!0,this.temperature=1,this.simulate()}stop(){this.running=!1}reset(){this.temperature=1,Object.keys(this.nodes).forEach(t=>{this.forces[t]={x:0,y:0},this.velocities[t]={x:0,y:0}})}simulate(){this.running&&(this.step(),requestAnimationFrame(()=>this.simulate()))}}(x,v);M.start();const animate=()=>{!function render(){if(m.clearRect(0,0,u.width,u.height),m.fillStyle="black",m.fillRect(0,0,u.width,u.height),0===Object.keys(x).length)return m.fillStyle="red",m.font="12px Arial",void m.fillText("No nodes to render",10,20);Object.values(x).forEach(t=>{t.connections.forEach(t=>{const i=p+t.nodeA.position.x*g,e=f+t.nodeA.position.y*g,o=p+t.nodeB.position.x*g,n=f+t.nodeB.position.y*g;m.strokeStyle=t.color,m.lineWidth=2,m.beginPath(),m.moveTo(i,e),m.lineTo(o,n),m.stroke()})}),Object.values(x).forEach(t=>{const i=p+t.position.x*g,e=f+t.position.y*g,o=t.radius*g;m.fillStyle=t.color,m.beginPath(),m.arc(i,e,o,0,2*Math.PI),m.fill()})}(),requestAnimationFrame(animate)};requestAnimationFrame(animate);class IoChangeVisualization extends e{static get Style(){return"\n    :host {\n      flex: 1 1 auto;\n      overflow: hidden;\n    }\n    :host > io-collapsible {\n      position: absolute;\n      display: inline-block;\n      max-width: 250px;\n      margin: var(--io_spacing2);\n    }\n    :host h4 {\n      font-size: calc(var(--io_fontSize) * 1.1);\n      margin: var(--io_spacing) 0;\n      padding: 0 var(--io_spacing);\n    }\n    :host p {\n      font-size: calc(var(--io_fontSize) * 1);\n      margin: var(--io_spacing2) 0;\n      padding: var(--io_spacing);\n    }\n    :host span {\n      font-size: calc(var(--io_fontSize) * 1.2);\n      height: var(--io_lineHeight);\n      margin-left: var(--io_spacing2);\n      vertical-align: top;\n    }\n    "}ready(){this.render([c({label:"Legend",elements:[o("Io-GUI Node Network Visualization"),n("Interactive visualization of the node relationship network using force-directed layout."),s({class:"legend-item"},[h({class:"legend-color",value:"io:circle_fill",style:{fill:"#2196F3"}}),r("Node")])]})])}}i(IoChangeVisualization);const ioChangeVisualization=function(t){return IoChangeVisualization.vConstructor(t)};export{IoChangeVisualization,ioChangeVisualization};
