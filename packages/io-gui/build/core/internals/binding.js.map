{"version":3,"file":"binding.js","sourceRoot":"","sources":["../../../src/core/internals/binding.ts"],"names":[],"mappings":"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","sourcesContent":["import { ChangeEvent } from './changeQueue';\nimport { IoNode } from '../node';\n\ntype Properties = string[];\ntype TargetProperties = WeakMap<IoNode, Properties>;\n\n// This helper checks if both values are NaN to prevent infinite update loops.\nconst bothAreNaNs = function(value: any, oldValue: any) {\n  return typeof value === 'number' && isNaN(value) && typeof oldValue === 'number' && isNaN(oldValue);\n};\n\n/**\n * Property binding class that enables two-way data synchronization between `IoNode` and `IoElement` nodes.\n *\n * It manages bindings between a source node's property and one or more target nodes and properties.\n * Using a hub-and-spoke pub/sub event system, it maintains data consistency by automatically propagating\n * changes to all bound nodes and properties.\n *\n * Key features:\n * - Listens for `[propName]-changed` events to detect changes\n * - Sets properties using `node.setProperty(propName, value)` method\n * - Supports one-to-many property bindings\n * - Prevents circular update loops\n * - Automatically cleans up listeners when disposed\n *\n * Note: `debug: {}` code blocks are used in dev/debug builds for sanity checks.\n * They print error messages if unexpected state is detected.\n * In theory, they should never be reached.\n *\n * @example\n * // Create a two-way binding between nodeA.value and nodeB.value\n * const binding = new Binding(nodeA, 'value');\n * binding.addTarget(nodeB, 'value');\n */\nexport class Binding {\n  readonly node: IoNode;\n  readonly property: string = '';\n  readonly targets: IoNode[] = [];\n  readonly targetProperties: TargetProperties = new WeakMap();\n  /**\n   * Creates a binding object for specified source `node` and `property`.\n   * It attaches a `[propName]-changed` listener to the source node.\n   * @param {IoNode} node - Source node\n   * @param {string} property - Name of the sourceproperty\n   */\n  constructor(node: IoNode, property: string) {\n    this.node = node;\n    this.property = property;\n    this.onSourceChanged = this.onSourceChanged.bind(this);\n    this.onTargetChanged = this.onTargetChanged.bind(this);\n    this.node.addEventListener(`${this.property}-changed`, this.onSourceChanged);\n  }\n  set value(value) {\n    this.node[this.property] = value;\n  }\n  get value() {\n    return this.node[this.property];\n  }\n  /**\n   * Returns a JSON representation of the binding.\n   * This is required for `JSON.stringify(protoProperties)` in `ProtoChain` to work more accurately.\n   * NOTE: this does not provide completely accurate signiture of the binding but it's good enough.\n   * @return {string} JSON representation of the binding.\n   */\n  toJSON() {\n    const targetProperties: Record<string, Properties> = {};\n    for (let i = 0; i < this.targets.length; i++) {\n      const target = this.targets[i];\n      const props = this.getTargetProperties(target);\n      targetProperties[target.constructor.name] = props;\n    }\n    return {\n      node: this.node.constructor.name,\n      property: this.property,\n      targets: this.targets.map(t => t.constructor.name),\n      targetProperties: targetProperties,\n    };\n  }\n  /**\n   * Helper function to get target properties from WeakMap\n   * Retrieves a list of target properties for specified target node.\n   * @param {IoNode} target - Target node.\n   * @return {Properties} list of target property names.\n   */\n  getTargetProperties(target: IoNode): Properties {\n    if (!this.targetProperties.has(target)) this.targetProperties.set(target, []);\n    return this.targetProperties.get(target)!;\n  }\n  /**\n   * Adds a target node and property.\n   * Sets itself as the binding reference on the target `PropertyInstance`.\n   * Adds a `[propName]-changed` listener to the target node.\n   * @param {IoNode} target - Target node\n   * @param {string} property - Target property\n   */\n  addTarget(target: IoNode, property: string) {\n    if (this.targets.indexOf(target) === -1) this.targets.push(target);\n\n    const targetProperties = this.getTargetProperties(target);\n\n    if (targetProperties.indexOf(property) === -1) {\n      targetProperties.push(property);\n\n      const propertyInstance = target._properties.get(property)!;\n      if (propertyInstance.binding && propertyInstance.binding !== this) {\n        debug: {\n          console.warn('Binding: improper usage detected!');\n          console.info('Binding: target property is already a target of another binding. Undinding previous binding!');\n        }\n        propertyInstance.binding.removeTarget(target, property);\n      }\n      propertyInstance.binding = this;\n      target.addEventListener(`${property}-changed`, this.onTargetChanged);\n      target.setProperty(property, this.node[this.property], true);\n\n    } else debug: {\n\n      console.error('Binding: target property already added!');\n\n    }\n  }\n  /**\n   * Removes target node and property.\n   * If `property` is not specified, it removes all target properties.\n   * Removes binding reference from the target `PropertyInstance`.\n   * Removes `[propName]-changed` listener from the target node.\n   * @param {IoNode} target - Target node\n   * @param {string} property - Target property\n   */\n  removeTarget(target: IoNode, property?: string) {\n    const targetProperties = this.getTargetProperties(target);\n\n    if (property) {\n\n      const i = targetProperties.indexOf(property);\n      debug: if (i === -1) {\n        console.error('Binding: target property not found!');\n      }\n      targetProperties.splice(i, 1);\n\n      const propertyInstance = target._properties.get(property)!;\n      debug: if (propertyInstance.binding !== this) {\n        console.error('Binding: target property has a different binding!');\n      }\n      propertyInstance.binding = undefined;\n      target.removeEventListener(`${property}-changed`, this.onTargetChanged);\n\n    } else {\n\n      for (let i = targetProperties.length; i--;) {\n        const prop = targetProperties[i];\n        const propertyInstance = target._properties.get(prop)!;\n        debug: if (propertyInstance.binding !== this) {\n          console.error('Binding: target property has a different binding!');\n        }\n        propertyInstance.binding = undefined;\n        target.removeEventListener(`${prop}-changed`, this.onTargetChanged);\n      }\n      targetProperties.length = 0;\n\n    }\n\n    if (targetProperties.length === 0) this.targets.splice(this.targets.indexOf(target), 1);\n  }\n  /**\n   * Event handler that updates source property when one of the targets emits `[propName]-changed` event.\n   * @param {ChangeEvent} event - Property change event.\n   */\n  onTargetChanged(event: ChangeEvent){\n    debug: if (this.targets.indexOf(event.target) === -1) {\n      console.error('onTargetChanged() should never fire if target is not accounted for');\n    }\n    const oldValue = this.node[this.property];\n    const value = event.detail.value;\n    if (oldValue !== value) {\n      if (bothAreNaNs(value, oldValue)) return;\n      this.node.setProperty(this.property, value);\n    }\n  };\n  /**\n   * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.\n   * @param {ChangeEvent} event - Property change event.\n   */\n  onSourceChanged(event: ChangeEvent) {\n    debug: if (event.target !== this.node) {\n      console.error('onSourceChanged() should always originate form source node.');\n    }\n    const value = event.detail.value;\n    for (let i = this.targets.length; i--;) {\n      const target = this.targets[i];\n      const targetProperties = this.getTargetProperties(target);\n      for (let j = targetProperties.length; j--;) {\n        const propName = targetProperties[j];\n        const oldValue = target[propName];\n        if (oldValue !== value) {\n          if (bothAreNaNs(value, oldValue)) continue;\n          target.setProperty(propName, value);\n        }\n      }\n    }\n  };\n  /**\n   * Dispose of the binding by removing all targets and listeners.\n   * Use this when node is no longer needed.\n   */\n  dispose() {\n    this.node.removeEventListener(`${this.property}-changed`, this.onSourceChanged);\n    for (let i = this.targets.length; i--;) {\n      this.removeTarget(this.targets[i]);\n    }\n    this.targets.length = 0;\n    delete (this as any).node;\n    delete (this as any).property;\n    delete (this as any).targets;\n    delete (this as any).targetProperties;\n  }\n}\n"]}