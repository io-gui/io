import{ReactiveProperty as e,Property as t,IoGl as i,Register as n,IoElement as o}from"io-gui";import{ioNumber as r}from"io-inputs";var __decorate$5=function(e,t,i,n){var o,r=arguments.length,s=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(r<3?o(s):r>3?o(t,i,s):o(t,i))||s);return r>3&&s&&Object.defineProperty(t,i,s),s};const clamp$1=(e,t,i)=>i>t?Math.min(Math.max(e,t),i):Math.min(Math.max(e,i),t);class IoSliderBase extends i{static vConstructor;static get Style(){return"\n      :host {\n        display: flex;\n        cursor: ew-resize;\n        border: var(--io_border);\n        border-radius: var(--io_borderRadius);\n        border-color: var(--io_borderColorInset);\n        min-height: var(--io_fieldHeight);\n        min-width: var(--io_fieldHeight);\n        flex-grow: 1;\n      }\n      :host[vertical] {\n        cursor: ns-resize;\n        width: var(--io_fieldHeight);\n        min-height: calc(var(--io_fieldHeight) * 5);\n        flex-basis: var(--io_fieldHeight);\n        flex-grow: 0;\n      }\n      :host[invalid] {\n        color: var(--io_colorWhite);\n        background-color: var(--io_bgColorRed);\n        border-color: var(--io_colorRed);\n      }\n      :host:focus {\n        @apply --io_focus;\n      }\n    "}_startX=0;_startY=0;_rect=null;_active=-1;get _min(){return"number"==typeof this.min?[this.min,this.min]:this.min instanceof Array?[...this.min]:[-Infinity,-Infinity]}get _max(){return"number"==typeof this.max?[this.max,this.max]:this.max instanceof Array?[...this.max]:[Infinity,Infinity]}get _step(){return"number"==typeof this.step?[this.step,this.step]:this.step instanceof Array?[...this.step]:[.01,.01]}get _value(){return"number"==typeof this.value?[this.value,this.value]:this.value instanceof Array?[...this.value]:[NaN,NaN]}static get Listeners(){return{focus:"onFocus",contextmenu:"onContextmenu",pointerdown:"onPointerdown",touchstart:["onTouchstart",{passive:!1}]}}constructor(e={}){super(e)}onFocus(){this.addEventListener("blur",this.onBlur),this.addEventListener("keydown",this.onKeydown)}onBlur(){this.removeEventListener("blur",this.onBlur),this.removeEventListener("keydown",this.onKeydown)}onContextmenu(e){e.preventDefault()}onTouchstart(e){this._rect=this.getBoundingClientRect(),this.addEventListener("touchmove",this.onTouchmove,{passive:!1}),this.addEventListener("touchend",this.onTouchend),this._startX=e.changedTouches[0].clientX,this._startY=e.changedTouches[0].clientY,this._active=this.noscroll?1:-1}onTouchmove(e){const t=Math.abs(this._startX-e.changedTouches[0].clientX),i=Math.abs(this._startY-e.changedTouches[0].clientY);-1===this._active&&(this.vertical?i>5&&i>t&&(this._active=i>t&&t<5?1:0):t>5&&t>i&&(this._active=t>i&&i<5?1:0)),1===this._active&&e.cancelable&&e.preventDefault()}onTouchend(){this.removeEventListener("touchmove",this.onTouchmove),this.removeEventListener("touchend",this.onTouchend)}onPointerdown(e){this._rect=this.getBoundingClientRect(),this.setPointerCapture(e.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),this.addEventListener("pointercancel",this.onPointerup)}onPointermove(e){"touch"!==e.pointerType&&(this._active=1),this.throttle(this.onPointermoveThrottled,e)}onPointerup(e){this.releasePointerCapture(e.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this.removeEventListener("pointercancel",this.onPointerup),this._active=-1}_getPointerCoord(e){const t=this._rect||this.getBoundingClientRect();let i=Math.max(0,Math.min(1,(e.clientX-t.x)/t.width)),n=Math.max(0,Math.min(1,1-(e.clientY-t.y)/t.height));return i=Math.pow(i,this.exponent),n=Math.pow(n,this.exponent),this.vertical?[n,i]:[i,n]}_getValueFromCoord(e){const t=[0,0],i=this._min,n=this._max;return t[0]=i[0]*(1-e[0])+n[0]*e[0],t[1]=i[1]*(1-e[1])+n[1]*e[1],t}onPointermoveThrottled(e){if(1===this._active){document.activeElement!==this&&this.focus();const t=this._getPointerCoord(e),i=this._getValueFromCoord(t);this._inputValue(i)}}_inputValue(e){const t=this._min,i=this._max,n=this._step;if(e[0]=clamp$1(e[0],i[0],t[0]),e[1]=clamp$1(e[1],i[1],t[1]),e[0]=Math.round(e[0]/n[0])*n[0],e[1]=Math.round(e[1]/n[1])*n[1],e[0]=Number(e[0].toFixed(5)),e[1]=Number(e[1].toFixed(5)),"number"==typeof this.value){if(this.value===e[0])return;this.inputValue(e[0])}else if(this.value instanceof Array){const t=JSON.stringify(this.value);if(this.value[0]=e[0],this.value[1]=e[1],t===JSON.stringify(this.value))return;this.inputValue(this.value),this.dispatchEvent("object-mutated",{object:this.value},!1,window)}else if("object"==typeof this.value){const t=JSON.stringify(this.value),i=this.value;if(i.x=e[0],i.y=e[1],t===JSON.stringify(this.value))return;this.inputValue(this.value),this.dispatchEvent("object-mutated",{object:this.value},!1,window)}}onKeydown(e){const t="number"==typeof this.value;switch(e.key){case"ArrowLeft":if(e.shiftKey){t?this._setDecrease():this._setLeft();break}case"ArrowUp":if(e.shiftKey){t?this._setIncrease():this._setUp();break}case"ArrowRight":if(e.shiftKey){t?this._setIncrease():this._setRight();break}case"ArrowDown":if(e.shiftKey){t?this._setDecrease():this._setDown();break}default:["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Tab","Home","End","PageUp","PageDown"].includes(e.key)&&(e.preventDefault(),this.dispatchEvent("io-focus-to",{source:this,command:e.key},!0))}}_setIncrease(){const e=this._value,t=this._step;e[0]=e[0]+t[0],e[1]=e[1]+t[1],this._inputValue(e)}_setDecrease(){const e=this._value,t=this._step;e[0]=e[0]-t[0],e[1]=e[1]-t[1],this._inputValue(e)}_setMin(){const e=this._min;this._inputValue(e)}_setMax(){const e=this._max;this._inputValue(e)}_setUp(){const e=this._value,t=this._step;e[0]=e[0]+t[0],this._inputValue(e)}_setDown(){const e=this._value,t=this._step;e[0]=e[0]-t[0],this._inputValue(e)}_setLeft(){const e=this._value,t=this._step;e[1]=e[1]-t[1],this._inputValue(e)}_setRight(){const e=this._value,t=this._step;e[1]=e[1]+t[1],this._inputValue(e)}ready(){this.changed()}valueChanged(){let e=!1;this.value instanceof Array?e=isNaN(this.value[0])||isNaN(this.value[1]):isNaN(this.value)&&(e=!0),this.invalid=e}invalidChanged(){this.invalid?this.setAttribute("aria-invalid","true"):this.removeAttribute("aria-invalid")}valueMutated(){this.changed(),this.dispatchEvent("object-mutated",{object:this})}changed(){super.changed(),this.setAttribute("aria-valuemin",JSON.stringify(this.min)),this.setAttribute("aria-valuemax",JSON.stringify(this.max)),this.setAttribute("aria-valuestep",JSON.stringify(this.step));const e=this._value;"number"!=typeof e[0]||isNaN(e[0])?this.setAttribute("aria-invalid","true"):this.removeAttribute("aria-invalid"),this.setAttribute("aria-valuenow",JSON.stringify(this.value))}}__decorate$5([e({value:0})],IoSliderBase.prototype,"value",void 0),__decorate$5([e(.01)],IoSliderBase.prototype,"step",void 0),__decorate$5([e(0)],IoSliderBase.prototype,"min",void 0),__decorate$5([e(1)],IoSliderBase.prototype,"max",void 0),__decorate$5([e(1)],IoSliderBase.prototype,"exponent",void 0),__decorate$5([e({value:!1,reflect:!0})],IoSliderBase.prototype,"vertical",void 0),__decorate$5([e({value:!1,type:Boolean,reflect:!0})],IoSliderBase.prototype,"invalid",void 0),__decorate$5([t(!1)],IoSliderBase.prototype,"noscroll",void 0),__decorate$5([t("slider")],IoSliderBase.prototype,"role",void 0),__decorate$5([t("0")],IoSliderBase.prototype,"tabIndex",void 0);var __decorate$4=function(e,t,i,n){var o,r=arguments.length,s=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(r<3?o(s):r>3?o(t,i,s):o(t,i))||s);return r>3&&s&&Object.defineProperty(t,i,s),s};let s=class IoSliderRange extends IoSliderBase{static vConstructor;_index=0;constructor(e={}){super(e)}_getCoordFromValue(e){const t=[0,0],i=this._min,n=this._max;return t[0]=(e[0]-i[0])/(n[0]-i[0]),t[1]=(e[1]-i[1])/(n[1]-i[1]),t}onPointerdown(e){super.onPointerdown(e);const t=this._value,i=this._getPointerCoord(e),n=this._getCoordFromValue(t);this._index=Math.abs(n[0]-i[0])<Math.abs(n[1]-i[0])?0:1}onPointermoveThrottled(e){if(1===this._active){document.activeElement!==this&&this.focus();const t=this._value,i=this._getPointerCoord(e),n=this._getValueFromCoord(i);0===this._index?this._inputValue([n[0],t[1]]):1===this._index&&this._inputValue([t[0],n[0]])}}static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * vec2(uv.x, uv.y - 0.5);\n      vec2 expPosition = size * vec2(pow(uv.x, uExponent), uv.y - 0.5);\n\n      vec2 valueInRange = (uValue - vec2(uMin)) / (vec2(uMax) - vec2(uMin));\n\n      vec2 valueSign = sign(valueInRange);\n      vec2 expValueInRange = pow(abs(valueInRange), vec2(1./uExponent)) * valueSign;\n      float valueInRangeWidth = valueInRange[1] - valueInRange[0];\n      float valueInRangeCenter = (valueInRange[1] + valueInRange[0]) / 2.0;\n      float signRange = sign(valueInRangeWidth);\n\n      // Colors\n      vec3 finalCol = io_bgColorInput.rgb;\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 sliderCol = signRange > 0.0 ? io_bgColorBlue.rgb : io_bgColorRed.rgb;\n      vec3 lineCol1 = io_color.rgb;\n      vec3 lineCol2 = io_bgColor.rgb;\n\n      // Grid\n      float gridSize = size.x / abs((uMax - uMin) / uStep);\n      float gridOffset = mod(uStep - uMin, uStep) / (uMax - uMin) * size.x;\n      float gridShape = paintDerivativeGrid2D(translate(expPosition, gridOffset, 0.0), vec2(gridSize, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      // Slider\n      float sliderShape = rectangle(translate(expPosition, size.x * valueInRangeCenter, 0.0), vec2(size.x * abs(valueInRangeWidth) * 0.5, size.y));\n      finalCol = compose(finalCol, vec4(sliderCol, sliderShape));\n      finalCol = compose(finalCol, vec4(io_bgColorInput.rgb, gridShape * sliderShape * 0.125));\n\n      // Lines\n      float maxPos = expValueInRange[0];\n      float minPos = expValueInRange[1];\n\n      float lineMinShape1 = lineVertical(translate(position, maxPos * size.x, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol1, lineMinShape1));\n      float lineMinShape2 = lineVertical(translate(position, maxPos * size.x + io_borderWidth * signRange, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol2, lineMinShape2));\n      \n      float lineMaxShape1 = lineVertical(translate(position, minPos * size.x, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol1, lineMaxShape1));\n      float lineMaxShape2 = lineVertical(translate(position, minPos * size.x - io_borderWidth * signRange, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol2, lineMaxShape2));\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }\n    "}};__decorate$4([e({value:null,type:Array,init:[0,0]})],s.prototype,"value",void 0),__decorate$4([e(.01)],s.prototype,"step",void 0),__decorate$4([e(0)],s.prototype,"min",void 0),__decorate$4([e(1)],s.prototype,"max",void 0),s=__decorate$4([n],s);const a=s.vConstructor;var __decorate$3=function(e,t,i,n){var o,r=arguments.length,s=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(r<3?o(s):r>3?o(t,i,s):o(t,i))||s);return r>3&&s&&Object.defineProperty(t,i,s),s};let l=class IoNumberSliderRange extends o{static get Style(){return"\n    :host {\n      display: flex;\n    }\n    :host > io-number {\n      flex: 0 0 3.5em;\n    }\n    :host > io-slider-range {\n      margin-left: var(--io_spacing);\n      margin-right: var(--io_spacing);\n      flex: 1 1 3.5em;\n      min-width: 3.5em;\n    }\n    "}constructor(e={}){super(e)}_onNumberSet(e){const t=e.composedPath()[0];if(t===this.$.number0&&(this.value[0]=e.detail.value),t===this.$.number1&&(this.value[1]=e.detail.value),!this.value._isNode){const e={object:this.value};this.dispatchEvent("object-mutated",e,!1,window)}}_onSliderSet(e){this.value=e.detail.value,this.dispatchEvent("value-input",e.detail,!1)}ready(){this.changed()}changed(){this.render([r({id:"number0",value:this.value[0],step:this.step,conversion:this.conversion,"@value-input":this._onNumberSet}),a({id:"slider",value:this.value,step:this.step,min:this.min,max:this.max,exponent:this.exponent,"@value-input":this._onSliderSet}),r({id:"number1",value:this.value[1],step:this.step,conversion:this.conversion,"@value-input":this._onNumberSet})])}};__decorate$3([e({type:Array,init:[0,0]})],l.prototype,"value",void 0),__decorate$3([e(.01)],l.prototype,"step",void 0),__decorate$3([e(0)],l.prototype,"min",void 0),__decorate$3([e(1)],l.prototype,"max",void 0),__decorate$3([e(1)],l.prototype,"exponent",void 0),__decorate$3([e(1)],l.prototype,"conversion",void 0),l=__decorate$3([n],l);const h=l.vConstructor;var __decorate$2=function(e,t,i,n){var o,r=arguments.length,s=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(r<3?o(s):r>3?o(t,i,s):o(t,i))||s);return r>3&&s&&Object.defineProperty(t,i,s),s};let c=class IoSlider extends i{static vConstructor;static get Style(){return"\n      :host {\n        display: flex;\n        cursor: ew-resize;\n        border: var(--io_border);\n        border-radius: var(--io_borderRadius);\n        border-color: var(--io_borderColorInset);\n        min-height: var(--io_fieldHeight);\n        min-width: var(--io_fieldHeight);\n        flex-grow: 1;\n      }\n      :host[vertical] {\n        cursor: ns-resize;\n        width: var(--io_fieldHeight);\n        min-height: calc(var(--io_fieldHeight) * 5);\n        flex-basis: var(--io_fieldHeight);\n        flex-grow: 0;\n      }\n      :host[invalid] {\n        border-color: var(--io_colorRed);\n      }\n      :host[disabled] {\n        opacity: 0.5;\n      }\n      :host:focus {\n        @apply --io_focus;\n      }\n    "}#e=0;#t=0;#i=-1;#n=null;static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * vec2(uv.x, uv.y - 0.5);\n      vec2 expPosition = size * vec2(pow(uv.x, uExponent), uv.y - 0.5);\n      float valueInRange = (uValue - uMin) / (uMax - uMin);\n      if (uInvalid == 1) valueInRange = 0.0;\n      float valueSign = sign(valueInRange);\n      float expValueInRange = pow(abs(valueInRange), 1./uExponent) * valueSign;\n\n      // Colors\n      vec3 finalCol = io_bgColorInput.rgb;\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 sliderCol = io_bgColorBlue.rgb;\n      vec3 lineCol1 = io_color.rgb;\n      vec3 lineCol2 = io_bgColor.rgb;\n\n      // Grid\n      float gridSize = size.x / abs((uMax - uMin) / uStep);\n      float gridOffset = mod(uStep - uMin, uStep) / (uMax - uMin) * size.x;\n      float gridShape = paintDerivativeGrid2D(translate(expPosition, gridOffset, 0.0), vec2(gridSize, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      // Slider\n      float sliderShape = rectangle(expPosition, vec2(size.x * valueInRange, size.y));\n      finalCol = compose(finalCol, vec4(sliderCol, sliderShape));\n      finalCol = compose(finalCol, vec4(io_bgColorInput.rgb, gridShape * sliderShape * 0.125));\n\n      // Lines\n      float lineShape1 = lineVertical(translate(position, expValueInRange * size.x, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol1, lineShape1));\n      float lineShape2 = lineVertical(translate(position, expValueInRange * size.x - io_borderWidth, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol2, lineShape2));\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }"}static get Listeners(){return{focus:"onFocus",contextmenu:"onContextmenu",pointerdown:"onPointerdown",touchstart:["onTouchstart",{passive:!1}]}}constructor(e={}){super(e)}onFocus(){this.addEventListener("blur",this.onBlur),this.addEventListener("keydown",this.onKeydown)}onBlur(){this.removeEventListener("blur",this.onBlur),this.removeEventListener("keydown",this.onKeydown)}onContextmenu(e){e.preventDefault()}onTouchstart(e){this.#n=this.getBoundingClientRect(),this.addEventListener("touchmove",this.onTouchmove,{passive:!1}),this.addEventListener("touchend",this.onTouchend),this.#e=e.changedTouches[0].clientX,this.#t=e.changedTouches[0].clientY,this.#i=this.noscroll?1:-1}onTouchmove(e){const t=Math.abs(this.#e-e.changedTouches[0].clientX),i=Math.abs(this.#t-e.changedTouches[0].clientY);-1===this.#i&&(this.vertical?i>5&&i>t&&(this.#i=i>t&&t<5?1:0):t>5&&t>i&&(this.#i=t>i&&i<5?1:0)),1===this.#i&&e.cancelable&&e.preventDefault()}onTouchend(){this.removeEventListener("touchmove",this.onTouchmove),this.removeEventListener("touchend",this.onTouchend)}onPointerdown(e){this.#n=this.getBoundingClientRect(),this.setPointerCapture(e.pointerId),this.addEventListener("pointermove",this.onPointermove),this.addEventListener("pointerup",this.onPointerup),this.addEventListener("pointercancel",this.onPointerup)}onPointermove(e){"touch"!==e.pointerType&&(this.#i=1),this.throttle(this.onPointermoveThrottled,e)}onPointerup(e){this.releasePointerCapture(e.pointerId),this.removeEventListener("pointermove",this.onPointermove),this.removeEventListener("pointerup",this.onPointerup),this.removeEventListener("pointercancel",this.onPointerup),this.#i=-1}_getPointerCoord(e){const t=this.#n||this.getBoundingClientRect();let i=Math.max(0,Math.min(1,(e.clientX-t.x)/t.width)),n=Math.max(0,Math.min(1,1-(e.clientY-t.y)/t.height));return Math.pow(this.vertical?n:i,this.exponent)}_getValueFromCoord(e){return this.min*(1-e)+this.max*e}onPointermoveThrottled(e){if(1===this.#i){document.activeElement!==this&&this.focus();const t=this._getPointerCoord(e),i=this._getValueFromCoord(t);this._inputValue(i)}}_incrementValue(e){this._inputValue(this.value+e)}_inputValue(e){var t,i,n;t=e,i=this.max,e=(n=this.min)>i?Math.min(Math.max(t,i),n):Math.min(Math.max(t,n),i),e=Math.round(e/this.step)*this.step,e=Number(e.toFixed(5)),isNaN(e)||this.value===e||this.inputValue(e)}onKeydown(e){const t=this.max<this.min;switch(e.key){case"ArrowLeft":if(e.shiftKey){this._incrementValue(t?this.step:-this.step);break}case"ArrowUp":if(e.shiftKey){this._incrementValue(t?-this.step:this.step);break}case"ArrowRight":if(e.shiftKey){this._incrementValue(t?-this.step:this.step);break}case"ArrowDown":if(e.shiftKey){this._incrementValue(t?this.step:-this.step);break}case"Home":if(e.shiftKey){e.preventDefault(),this._inputValue(this.min);break}case"End":if(e.shiftKey){e.preventDefault(),this._inputValue(this.max);break}case"PageUp":if(e.shiftKey){e.preventDefault(),this._incrementValue(t?-this.step:this.step);break}case"PageDown":if(e.shiftKey){e.preventDefault(),this._incrementValue(t?this.step:-this.step);break}default:["ArrowLeft","ArrowRight","ArrowUp","ArrowDown","Tab","Home","End","PageUp","PageDown"].includes(e.key)&&(e.preventDefault(),this.dispatchEvent("io-focus-to",{source:this,command:e.key},!0))}}ready(){this.valueChanged(),this.minChanged(),this.maxChanged(),this.changed()}invalidChanged(){this.ariaInvalid=this.invalid}disabledChanged(){this.inert=this.disabled,this.ariaDisabled=this.disabled}valueChanged(){this.invalid=isNaN(this.value),this.ariaValueNow=this.value}minChanged(){this.ariaValueMin=this.min}maxChanged(){this.ariaValueMax=this.max}};__decorate$2([e(0)],c.prototype,"value",void 0),__decorate$2([e(.01)],c.prototype,"step",void 0),__decorate$2([e(0)],c.prototype,"min",void 0),__decorate$2([e(1)],c.prototype,"max",void 0),__decorate$2([e(1)],c.prototype,"exponent",void 0),__decorate$2([e({value:!1,reflect:!0})],c.prototype,"vertical",void 0),__decorate$2([e({value:!1,type:Boolean,reflect:!0})],c.prototype,"invalid",void 0),__decorate$2([e({value:!1,type:Boolean,reflect:!0})],c.prototype,"disabled",void 0),__decorate$2([t(!1)],c.prototype,"noscroll",void 0),__decorate$2([t("slider")],c.prototype,"role",void 0),__decorate$2([t("0")],c.prototype,"tabIndex",void 0),c=__decorate$2([n],c);const u=c.vConstructor;var __decorate$1=function(e,t,i,n){var o,r=arguments.length,s=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(r<3?o(s):r>3?o(t,i,s):o(t,i))||s);return r>3&&s&&Object.defineProperty(t,i,s),s};let v=class IoNumberSlider extends o{static vConstructor;static get Style(){return"\n    :host {\n      display: flex;\n    }\n    :host > io-number {\n      flex: 0 0 3.5em;\n      margin-right: var(--io_spacing);\n    }\n    :host > io-slider {\n      flex: 1 1 3em;\n      min-width: 3em;\n    }\n    "}constructor(e={}){super(e)}_onNumberSet(e){this.value=e.detail.value,this.dispatchEvent("value-input",e.detail,!1)}_onSliderSet(e){e.detail.value=e.detail.value/this.conversion,this.value=e.detail.value,this.dispatchEvent("value-input",e.detail,!1)}ready(){this.changed()}changed(){this.render([r({id:"number",value:this.value,step:this.step,conversion:this.conversion,"@value-input":this._onNumberSet}),u({id:"slider",value:this.value*this.conversion,step:this.step*this.conversion,min:this.min*this.conversion,max:this.max*this.conversion,exponent:this.exponent,"@value-input":this._onSliderSet})])}};__decorate$1([e({value:0})],v.prototype,"value",void 0),__decorate$1([e(.01)],v.prototype,"step",void 0),__decorate$1([e(0)],v.prototype,"min",void 0),__decorate$1([e(1)],v.prototype,"max",void 0),__decorate$1([e(1)],v.prototype,"exponent",void 0),__decorate$1([e(1)],v.prototype,"conversion",void 0),v=__decorate$1([n],v);const d=v.vConstructor;var __decorate=function(e,t,i,n){var o,r=arguments.length,s=r<3?t:null===n?n=Object.getOwnPropertyDescriptor(t,i):n;if("object"==typeof Reflect&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,i,n);else for(var a=e.length-1;a>=0;a--)(o=e[a])&&(s=(r<3?o(s):r>3?o(t,i,s):o(t,i))||s);return r>3&&s&&Object.defineProperty(t,i,s),s};let p=class IoSlider2d extends IoSliderBase{static vConstructor;static get Style(){return"\n      :host {\n        cursor: crosshair;\n        border: var(--io_border);\n        border-radius: var(--io_borderRadius);\n        border-color: var(--io_borderColorInset);\n        flex-grow: 0;\n      }\n      :host:not([vertical]),\n      :host[vertical] {\n        min-width: calc(var(--io_fieldHeight) * 5);\n        min-height: calc(var(--io_fieldHeight) * 5);\n        cursor: crosshair;\n      }\n    "}constructor(e={}){super(e)}static get GlUtils(){return"\n      vec3 paintKnob(vec3 dstCol, vec2 p, vec2 center, vec3 color) {\n        vec4 finalCol = vec4(0.0);\n        vec2 pCenter = translate(p, center);\n        float radius = io_fieldHeight * 0.25;\n        float stroke = io_borderWidth;\n        float strokeShape = circle(pCenter, radius + stroke + stroke);\n        float fillShape   = circle(pCenter, radius + stroke);\n        float colorShape  = circle(pCenter, radius);\n        finalCol = mix(io_colorStrong, finalCol, strokeShape);\n        finalCol = mix(vec4(io_bgColor.rgb, 1.0), finalCol, fillShape);\n        finalCol = mix(vec4(color, 1.0), finalCol, colorShape);\n        return compose(dstCol, finalCol);\n      }\n    "}static get Frag(){return"\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * (uv - vec2(0.5));\n\n      // Colors\n      vec3 finalCol = io_bgColorInput.rgb;\n      vec3 gridCol = io_bgColorLight.rgb;\n      vec3 sliderCol = io_bgColorBlue.rgb;\n      vec3 lineCol1 = io_color.rgb;\n      vec3 lineCol2 = io_bgColor.rgb;\n\n      // Grid\n      vec2 gridSize = size / abs((uMax - uMin) / uStep);\n      vec2 gridOffset = (uMax + uMin) / (uMax - uMin) * size / 2.;\n      vec2 gridPosition = translate(position, -gridOffset);\n      float gridShape = paintDerivativeGrid2D(gridPosition, gridSize, io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      // Axis\n      float axisShape = lineCross2d(gridPosition, io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, axisShape));\n\n      // Knob\n      vec2 knobPos = uValue / (uMax - uMin) * size;\n      finalCol = paintKnob(finalCol, gridPosition, knobPos, sliderCol);\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }"}};__decorate([e({value:null,type:Array,init:[0,0]})],p.prototype,"value",void 0),__decorate([e({value:null,type:Array,init:[.01,.01]})],p.prototype,"step",void 0),__decorate([e({value:null,type:Array,init:[-1,-1]})],p.prototype,"min",void 0),__decorate([e({value:null,type:Array,init:[1,1]})],p.prototype,"max",void 0),__decorate([t(!0)],p.prototype,"noscroll",void 0),p=__decorate([n],p);const f=p.vConstructor;export{v as IoNumberSlider,l as IoNumberSliderRange,c as IoSlider,p as IoSlider2d,IoSliderBase,s as IoSliderRange,d as ioNumberSlider,h as ioNumberSliderRange,u as ioSlider,f as ioSlider2d,a as ioSliderRange};
