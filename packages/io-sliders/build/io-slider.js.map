{"version":3,"file":"io-slider.js","sourceRoot":"","sources":["../src/io-slider.ts"],"names":[],"mappings":";;;;;;AAAA,OAAO,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,QAAQ,CAAC;AAC5C,OAAO,EAAE,YAAY,EAAE,MAAM,qBAAqB,CAAC;AAEnD;;;;;;;IAOI;AAEG,IAAM,QAAQ,GAAd,MAAM,QAAS,SAAQ,YAAY;IAcxC,MAAM,KAAK,IAAI;QACb,OAAO,UAAU,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MAsCf,CAAC;IACL,CAAC;CACF,CAAA;AApDS;IADP,QAAQ,CAAC,CAAC,CAAC;uCACU;AAGd;IADP,QAAQ,CAAC,IAAI,CAAC;sCACM;AAGb;IADP,QAAQ,CAAC,CAAC,CAAC;qCACQ;AAGZ;IADP,QAAQ,CAAC,CAAC,CAAC;qCACQ;AAZT,QAAQ;IADpB,QAAQ;GACI,QAAQ,CAuDpB","sourcesContent":["import { Register, Property } from 'io-gui';\nimport { IoSliderBase } from './io-slider-base.js';\n\n/**\n * Input element for `Number` data type displayed as slider.\n * It can be configured to clamp the `value` to `min` / `max` and round it to the nearest `step` increment. `exponent` property can be changed for non-linear scale.\n *\n * Keys left/right/up/down+shift and pageup/pagedown change the value in step incements. Home/end keys set the value to min/max.\n *\n * <io-element-demo element=\"io-slider\" properties='{\"value\": 0, \"step\": 0.01, \"min\": -0.5, \"max\": 0.5, \"exponent\": 1}'></io-element-demo>\n **/\n@Register\nexport class IoSlider extends IoSliderBase {\n\n  @Property(0)\n  declare value: number;\n\n  @Property(0.01)\n  declare step: number;\n\n  @Property(0)\n  declare min: number;\n\n  @Property(1)\n  declare max: number;\n\n  static get Frag() {\n    return /* glsl */`\n    varying vec2 vUv;\n\n    void main(void) {\n      // Dimensions\n      vec2 size = uVertical == 1 ? uSize.yx : uSize;\n      vec2 uv = uVertical == 1 ? vUv.yx : vUv;\n      vec2 position = size * vec2(uv.x, uv.y - 0.5);\n      vec2 expPosition = size * vec2(pow(uv.x, uExponent), uv.y - 0.5);\n      float valueInRange = (uValue - uMin) / (uMax - uMin);\n      float valueSign = sign(valueInRange);\n      float expValueInRange = pow(abs(valueInRange), 1./uExponent) * valueSign;\n\n      // Colors\n      vec3 finalCol = io_bgColorField.rgb;\n      vec3 gridCol = io_bgColorDimmed.rgb;\n      vec3 sliderCol = io_bgColorBlue.rgb;\n      vec3 lineCol1 = io_color.rgb;\n      vec3 lineCol2 = io_bgColor.rgb;\n\n      // Grid\n      float gridSize = size.x / abs((uMax - uMin) / uStep);\n      float gridOffset = mod(uStep - uMin, uStep) / (uMax - uMin) * size.x;\n      float gridShape = paintDerivativeGrid2D(translate(expPosition, gridOffset, 0.0), vec2(gridSize, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(gridCol, gridShape * 0.5));\n\n      // Slider\n      float sliderShape = rectangle(expPosition, vec2(size.x * valueInRange, size.y));\n      finalCol = compose(finalCol, vec4(sliderCol, sliderShape));\n      finalCol = compose(finalCol, vec4(io_bgColorField.rgb, gridShape * sliderShape * 0.125));\n\n      // Lines\n      float lineShape1 = lineVertical(translate(position, expValueInRange * size.x, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol1, lineShape1));\n      float lineShape2 = lineVertical(translate(position, expValueInRange * size.x - io_borderWidth, 0.0), io_borderWidth);\n      finalCol = compose(finalCol, vec4(lineCol2, lineShape2));\n\n      gl_FragColor = vec4(finalCol, 1.0);\n    }`;\n  }\n}\n\n"]}