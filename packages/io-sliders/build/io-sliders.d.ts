// Generated by dts-bundle-generator v9.5.1

type Properties = string[];
type TargetProperties = WeakMap<IoNode, Properties>;
declare class Binding {
	readonly node: IoNode;
	readonly property: string;
	readonly targets: IoNode[];
	readonly targetProperties: TargetProperties;
	/**
	 * Creates a binding object for specified source `node` and `property`.
	 * It attaches a `[propName]-changed` listener to the source node.
	 * @param {IoNode} node - Source node
	 * @param {string} property - Name of the sourceproperty
	 */
	constructor(node: IoNode, property: string);
	set value(value: any);
	get value(): any;
	/**
	 * Returns a JSON representation of the binding.
	 * This is required for `JSON.stringify(protoProperties)` in `ProtoChain` to work more accurately.
	 * NOTE: this does not provide completely accurate signiture of the binding but it's good enough.
	 * @return {string} JSON representation of the binding.
	 */
	toJSON(): {
		node: string;
		property: string;
		targets: string[];
		targetProperties: Record<string, Properties>;
	};
	/**
	 * Helper function to get target properties from WeakMap
	 * Retrieves a list of target properties for specified target node.
	 * @param {IoNode} target - Target node.
	 * @return {Properties} list of target property names.
	 */
	getTargetProperties(target: IoNode): Properties;
	/**
	 * Adds a target node and property.
	 * Sets itself as the binding reference on the target `PropertyInstance`.
	 * Adds a `[propName]-changed` listener to the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	addTarget(target: IoNode, property: string): void;
	/**
	 * Removes target node and property.
	 * If `property` is not specified, it removes all target properties.
	 * Removes binding reference from the target `PropertyInstance`.
	 * Removes `[propName]-changed` listener from the target node.
	 * @param {IoNode} target - Target node
	 * @param {string} property - Target property
	 */
	removeTarget(target: IoNode, property?: string): void;
	/**
	 * Event handler that updates source property when one of the targets emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onTargetChanged(event: ChangeEvent): void;
	/**
	 * Event handler that updates bound properties on target nodes when source node emits `[propName]-changed` event.
	 * @param {ChangeEvent} event - Property change event.
	 */
	onSourceChanged(event: ChangeEvent): void;
	/**
	 * Dispose of the binding by removing all targets and listeners.
	 * Use this when node is no longer needed.
	 */
	dispose(): void;
}
type PropertyDefinition$1 = {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
};
type PropertyDefinitionLoose = string | number | boolean | Array<any> | null | undefined | Constructor | Binding | PropertyDefinition$1;
declare class ProtoProperty {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect?: boolean;
	init?: any;
	/**
	 * Creates a property definition from various input types.
	 * @param {PropertyDefinitionLoose} def Input definition which can be:
	 * - `undefined` or `null`: Sets as value
	 * - `Constructor`: Sets as type
	 * - `Binding`: Sets value from binding and stores binding reference
	 * - `PropertyDefinition`: Copies all defined fields
	 * - Other values: Sets as value
	 * @example
	 * new ProtoProperty(String) // {type: String}
	 * new ProtoProperty('hello') // {value: 'hello'}
	 * new ProtoProperty({value: 42, type: Number}) // {value: 42, type: Number}
	 * new ProtoProperty(new Binding(node, 'value')) // {value: node.value, binding: ...}
	 */
	constructor(def: PropertyDefinitionLoose);
	/**
	 * Assigns values of another ProtoProperty to itself, unless they are default values.
	 * @param {ProtoProperty} protoProp Source ProtoProperty
	 */
	assign(protoProp: ProtoProperty): void;
	/**
	 * Creates a serializable representation of the property definition.
	 * Handles special cases for better JSON serialization:
	 * - Converts object values to their constructor names
	 * - Converts function types to their names
	 * - Only includes defined fields
	 * @returns {object} A plain object suitable for JSON serialization
	 */
	toJSON(): any;
}
declare class PropertyInstance {
	value?: any;
	type?: Constructor;
	binding?: Binding;
	reflect: boolean;
	init?: any;
	/**
	 * Creates the property configuration object and copies values from `ProtoProperty`.
	 * @param node owner IoNode instance
	 * @param propDef ProtoProperty object
	 */
	constructor(node: IoNode, propDef: ProtoProperty);
}
interface KeyboardEventListener {
	(event: KeyboardEvent): void;
}
interface PointerEventListener {
	(event: PointerEvent): void;
}
interface CustomEventListener {
	(event: CustomEvent): void;
}
interface FocusEventListener {
	(event: FocusEvent): void;
}
interface TouchEventListener {
	(event: TouchEvent): void;
}
interface ChangeEventListener {
	(event: ChangeEvent): void;
}
interface IoEventListener {
	(event: {
		detail: any;
		target: IoNode;
		path: IoNode[];
	}): void;
}
type AnyEventListener = EventListener | KeyboardEventListener | PointerEventListener | CustomEventListener | FocusEventListener | TouchEventListener | ChangeEventListener | IoEventListener;
type ListenerDefinition = [
	string | AnyEventListener,
	AddEventListenerOptions?
];
type ListenerDefinitionLoose = string | AnyEventListener | ListenerDefinition;
type Listener = [
	AnyEventListener,
	AddEventListenerOptions?
];
type Listeners = Record<string, Listener[]>;
declare class EventDispatcher {
	readonly node: IoNode | EventTarget;
	readonly isEventTarget: boolean;
	readonly protoListeners: Listeners;
	readonly propListeners: Listeners;
	readonly addedListeners: Listeners;
	/**
	 * Creates an instance of `EventDispatcher` for specified `IoNode` instance.
	 * It initializes `protoListeners` from `ProtoChain`.
	 * @param {IoNode} node owner IoNode
	 */
	constructor(node: IoNode | EventTarget);
	/**
	 * Sets `protoListeners` specified as `get Listeners()` class definitions.
	 * Definitions from subclass replace the ones from parent class.
	 * @param {IoNode} node owner IoNode
	 */
	setProtoListeners(node: IoNode): void;
	/**
	 * Sets `propListeners` specified as inline properties prefixed with "@".
	 * It removes existing `propListeners` that are no longer specified and it replaces the ones that changed.
	 * @param {Record<string, any>} properties - Inline properties
	 */
	applyPropListeners(properties: Record<string, any>): void;
	/**
	 * Proxy for `addEventListener` method.
	 * Adds an event listener to the node's `addedListeners` collection.
	 * If the node is an EventTarget, also registers the listener with the DOM.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	 */
	addEventListener(name: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Proxy for `removeEventListener` method.
	 * Removes an event listener from the node's `addedListeners` collection.
	 * If `listener` is not specified it removes all listeners for specified `type`.
	 * @param {string} name - Name of the event
	 * @param {AnyEventListener} listener - Event listener handler
	 * @param {AddEventListenerOptions} [options] - Event listener options
	*/
	removeEventListener(name: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
	/**
	 * Shorthand for custom event dispatch.
	 * @param {string} name - Name of the event
	 * @param {any} detail - Event detail data
	 * @param {boolean} [bubbles] - Makes event bubble
	 * @param {EventTarget} [node] - Event target override to dispatch the event from
	 */
	dispatchEvent(name: string, detail?: any, bubbles?: boolean, node?: EventTarget | IoNode): void;
	/**
	 * Disconnects all event listeners and removes all references for garbage collection.
	 * Use this when node is discarded.
	 */
	dispose(): void;
}
type ProtoConstructors = Array<IoNodeConstructor<any>>;
type ProtoHandlers = string[];
type ProtoProperties = {
	[property: string]: ProtoProperty;
};
type ProtoListeners = {
	[property: string]: ListenerDefinition[];
};
declare class ProtoChain {
	/**
	 * Array of inherited class constructors
	 */
	constructors: ProtoConstructors;
	/**
	 * Aggregated property definition declared in `static get Properties()`
	 */
	properties: ProtoProperties;
	/**
	 * Aggregated listener definition declared in `static get Listeners()`
	 */
	listeners: ProtoListeners;
	/**
	 * Aggregated CSS style definition declared in `static get Style()`
	 */
	styles: string;
	/**
	 * Array of function names that start with "on[A-Z]" or "_on[A-Z]" for auto-binding.
	 */
	handlers: ProtoHandlers;
	/**
	 * Array of property names of mutation-observed object properties.
	 */
	observedObjectProperties: string[];
	/**
	 * Array of property names of mutation-observed IoNode properties.
	 */
	observedIoNodeProperties: string[];
	/**
	 * Creates an instance of `ProtoChain` for specified class constructor.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	constructor(ioNodeConstructor: IoNodeConstructor<any>);
	/**
	 * Adds properties defined in decorators to the properties array.
	 * @param {IoNodeConstructor<any>} ioNodeConstructor - Owner `IoNode` constructor.
	 */
	addPropertiesFromDecorators(ioNodeConstructor: IoNodeConstructor<any>): void;
	/**
	 * Adds static properties from `static get Properties()` to the properties array.
	 * Only process properties if they differ from superclass.
	 * This prevents 'static get Properties()' from overriding subclass properties defined in decorators.
	 * @param {PropertyDefinitions} properties - Properties to add
	 * @param {string} prevHash - Previous properties hash
	 * @returns {string} - Updated properties hash
	 */
	addStaticProperties(properties?: PropertyDefinitions, prevHash?: string): string;
	/**
	 * Merges or appends a listener definitions to the existing listeners array.
	 * @param {ListenerDefinitions} listenerDefs - Listener definitions to add
	 */
	addListeners(listenerDefs?: ListenerDefinitions): void;
	/**
	 * Adds a style string to the styles array.
	 * @param {string} style - Style string to add
	 */
	addStyles(style?: string): void;
	/**
	 * Adds function names that start with "on[A-Z]" or "_on[A-Z]" to the handlers array.
	 * @param {IoNode} proto - Prototype object to search for handlers
	 */
	addHandlers(proto: IoNode): void;
	/**
	 * Creates observedObjectProperties array.
	 * @returns {string[]} - Array of property names that are observed as native objects.
	 */
	getObservedObjectProperties(): string[];
	/**
	 * Creates observedIoNodeProperties array.
	 * @returns {string[]} - Array of property names that are observed as IoNode objects.
	 */
	getObservedIoNodeProperties(): string[];
	/**
	 * Debug only.
	 * Validates property definitions.
	 * Logs warnings for incorrect property definitions.
	 * @returns {void}
	 */
	validateProperties(): void;
	/**
	 * Auto-binds event handler methods (starting with 'on[A-Z]' or '_on[A-Z]') to preserve their 'this' context.
	 * NOTE: Defining handlers as arrow functions will not work because they are not defined before constructor has finished.
	 * @param {IoNode} node - Target node instance
	 */
	autobindHandlers(node: IoNode): void;
}
type Constructor = new (...args: any[]) => unknown;
type PropertyDefinitions = Record<string, PropertyDefinitionLoose>;
type ListenerDefinitions = Record<string, ListenerDefinitionLoose>;
interface IoNodeConstructor<T> {
	new (...args: any[]): T;
	Properties?: PropertyDefinitions;
	Listeners?: ListenerDefinitions;
	Style?: string;
}
type CallbackFunction = (arg?: any) => void;
declare const IoNode_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		applyProperties(props: any): void;
		/**
		 * Sets multiple properties in batch.
		 * [property]-changed` events will be broadcast in the end.
		 * @param {Object} props - Map of property names and values.
		 */
		setProperties(props: any): void;
		/**
		 * Sets the property value, connects the bindings and sets attributes for properties with attribute reflection enabled.
		 * @param {string} name Property name to set value of.
		 * @param {any} value Peroperty value.
		 * @param {boolean} [debounce] flag to skip event dispatch.
		 */
		setProperty(name: string, value: any, debounce?: boolean): void;
		/**
		 * Sets value property and emits `value-input` event.
		 * Use this when value property is set by user action (e.g. mouse click).
		 * @param {*} value - Property value.
		 */
		inputValue(value: any): void;
		/**
		 * default change handler.
		 * Invoked when one of the properties change.
		 */
		changed(): void;
		init(): void;
		/**
		 * Adds property change to the queue.
		 * @param {string} name - Property name.
		 * @param {*} value - Property value.
		 * @param {*} oldValue - Old property value.
		 */
		queue(name: string, value: any, oldValue: any): void;
		/**
		 * Dispatches the queue in the next rAF cycle if `reactivity` property is set to `"debounced"`. Otherwise it dispatches the queue immediately.
		 */
		dispatchQueue(debounce?: boolean): void;
		/**
		 * Throttles function execution once per frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for throttled function.
		 */
		throttle(func: CallbackFunction, arg?: any): void;
		/**
		 * Debounces function execution to next frame (rAF).
		 * @param {function} func - Function to throttle.
		 * @param {*} arg - argument for debounced function.
		 * @param {number} timeout - minimum delay in ms before executing the function.
		 */
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		/**
		 * Event handler for 'object-mutated' events emitted from the properties which are IoNode instances.
		 * Aditionally, it handles events emitted from the `window` object (used for observing non-IoNode object properties).
		 * NOTE: non-IoNode objects don't emit 'object-mutated' event automatically - something needs to emit this for them.
		 * This is used to evoke '[propName]Mutated()' mutation handler
		 * @param {Object} event - Event payload.
		 * @param {EventTarget} event.target - Node that emitted the event.
		 * @param {IoNode} event.detail.object - Mutated node.
		 */
		onPropertyMutated(event: CustomEvent): void;
		/**
		 * Returns a binding to a specified property`.
		 * @param {string} name - Property name to bind to.
		 * @return {Binding} Binding object.
		 */
		bind(name: string): Binding;
		/**
		 * Unbinds a binding to a specified property`.
		 * @param {string} name - Property name to unbind.
		 */
		unbind(name: string): void;
		/**
		 * Wrapper for addEventListener.
		 * @param {string} type - listener name.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for removeEventListener.
		 * @param {string} type - event name to listen to.
		 * @param {function} listener - listener handler.
		 * @param {Object} options - event listener options.
		 */
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		/**
		 * Wrapper for dispatchEvent.
		 * @param {string} type - event name to dispatch.
		 * @param {Object} detail - event detail.
		 * @param {boolean} bubbles - event bubbles.
		 * @param {HTMLElement|Node} src source node/element to dispatch event from.
		 */
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		/**
		 * Disposes all internals.
		 * Use this when instance is no longer needed.
		 */
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoNode extends IoNode_base {
}
interface Change {
	property: string;
	value: any;
	oldValue: any;
}
interface ChangeEvent extends Omit<CustomEvent<Change>, "target"> {
	readonly target: IoNode;
	readonly detail: Change;
	readonly path: IoNode[];
}
declare class ChangeQueue {
	readonly node: IoNode;
	readonly changes: Change[];
	hasChanged: boolean;
	dispatching: boolean;
	/**
	 * Creates change queue for the specified owner instance of `IoNode`.
	 * @param {IoNode} node - Owner node.
	 */
	constructor(node: IoNode);
	/**
	 * Adds property change payload to the queue by specifying property name, previous and the new value.
	 * If the change is already in the queue, the new value is updated in-queue.
	 * If the new value is the same as the original value, the change is removed from the queue.
	 * @param {string} property - Property name.
	 * @param {any} value Property value.
	 * @param {any} oldValue Old property value.
	 */
	queue(property: string, value: any, oldValue: any): void;
	/**
	 * Dispatches and clears the queue.
	 * For each property change in the queue:
	 *  - It executes node's `[propName]Changed(change)` change handler function if it is defined.
	 *  - It fires the `'[propName]-changed'` `ChangeEvent` from the owner node with `Change` data as `event.detail`.
	 * After all changes are dispatched it invokes `.changed()` function of the owner node instance and fires `'changed'` event.
	 */
	dispatch(): void;
	/**
	 * Clears the queue and removes the node reference for garbage collection.
	 * Use this when node queue is no longer needed.
	 */
	dispose(): void;
}
declare const IoElement_base: {
	new (...args: any[]): {
		[x: string]: any;
		readonly _protochain: ProtoChain;
		readonly _properties: Map<string, PropertyInstance>;
		readonly _bindings: Map<string, Binding>;
		readonly _changeQueue: ChangeQueue;
		readonly _eventDispatcher: EventDispatcher;
		applyProperties(props: any): void;
		setProperties(props: any): void;
		setProperty(name: string, value: any, debounce?: boolean): void;
		inputValue(value: any): void;
		changed(): void;
		init(): void;
		queue(name: string, value: any, oldValue: any): void;
		dispatchQueue(debounce?: boolean): void;
		throttle(func: CallbackFunction, arg?: any): void;
		debounce(func: CallbackFunction, arg?: any, timeout?: number): void;
		onPropertyMutated(event: CustomEvent): void;
		bind(name: string): Binding;
		unbind(name: string): void;
		addEventListener(type: string, listener: AnyEventListener, options?: AddEventListenerOptions): void;
		removeEventListener(type: string, listener?: AnyEventListener, options?: AddEventListenerOptions): void;
		dispatchEvent(type: string, detail?: any, bubbles?: boolean, src?: Node | HTMLElement | Document | Window): void;
		dispose(): void;
		Register(ioNodeConstructor: typeof IoNode): void;
	};
	[x: string]: any;
	readonly Properties: PropertyDefinitions;
};
declare class IoElement extends IoElement_base {
	static get Style(): string;
	$: Record<string, any>;
	tabindex: string;
	contenteditable: boolean;
	class: string;
	role: string;
	label: string;
	name: string;
	title: string;
	id: string;
	hidden: boolean;
	disabled: boolean;
	constructor(...args: any[]);
	/**
	* Add resize listener if `onResized()` is defined in subclass.
	*/
	connectedCallback(): void;
	/**
	* Removes resize listener if `onResized()` is defined in subclass.
	*/
	disconnectedCallback(): void;
	setProperty(name: string, value: any, debounce?: boolean): void;
	/**
	 * Renders DOM from virtual DOM arrays.
	 * @param {Array} vDOM - Array of vDOM children.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	template(vDOM: Array<any>, host?: HTMLElement, cache?: boolean): void;
	/**
	 * Recurively traverses vDOM.
	 * TODO: test element.traverse() function!
	 * @param {Array} vChildren - Array of vDOM children converted by `buildTree()` for easier parsing.
	 * @param {HTMLElement} [host] - Optional template target.
	 * @param {boolean} [cache] - Optional don't reuse existing elements and skip dispose
	 */
	traverse(vChildren: Array<any>, host: HTMLElement, cache?: boolean): void;
	Register(ioNodeConstructor: typeof IoNode): void;
	/**
	* Helper function to flatten textContent into a single TextNode.
	* Update textContent via TextNode is better for layout performance.
	* @param {HTMLElement} element - Element to flatten.
	*/
	_flattenTextNode(element: HTMLElement | IoElement): void;
	get textNode(): any;
	set textNode(value: any);
	applyProperties(props: any): void;
	/**
	* Alias for HTMLElement setAttribute where falsey values remove the attribute.
	* @param {string} attr - Attribute name.
	* @param {*} value - Attribute value.
	*/
	setAttribute(attr: string, value: boolean | number | string): void;
	labelChanged(): void;
	disabledChanged(): void;
}
declare class Color {
	r: number;
	g: number;
	b: number;
	a: number;
	constructor(r: number, g: number, b: number, a: number);
	toCss(): string;
}
type Theme = {
	spacing: number;
	spacing2: number;
	spacing3: number;
	spacing5: number;
	spacing8: number;
	fontSize: number;
	lineHeight: number;
	fieldHeight: number;
	fieldHeight2: number;
	fieldHeight3: number;
	fieldHeight4: number;
	fieldHeight5: number;
	fieldHeight6: number;
	fieldHeight7: number;
	fieldHeight8: number;
	fieldHeight9: number;
	fieldHeight10: number;
	fieldHeight11: number;
	fieldHeight12: number;
	borderRadius: number;
	borderRadius2: number;
	borderWidth: number;
	borderColor: Color;
	borderColorLight: Color;
	borderColorDark: Color;
	bgColor: Color;
	bgColorStrong: Color;
	bgColorDimmed: Color;
	bgColorRed: Color;
	bgColorGreen: Color;
	bgColorBlue: Color;
	bgColorField: Color;
	color: Color;
	colorStrong: Color;
	colorDimmed: Color;
	colorRed: Color;
	colorGreen: Color;
	colorBlue: Color;
	colorWhite: Color;
	colorField: Color;
	gradientColorStart: Color;
	gradientColorEnd: Color;
	shadowColor: Color;
};
declare class IoTheme extends IoNode {
	static get Properties(): PropertyDefinitions;
	themeDefaults: Record<string, Theme>;
	themeID: string;
	reactivity: string;
	init(): void;
	registerTheme(themeID: string, theme: Theme): void;
	reset(): void;
	themeIDChanged(): void;
	onPropertyMutated(event: CustomEvent): void;
	changed(): void;
	saveTheme(): void;
}
declare const IoThemeSingleton: IoTheme;
declare class IoGl extends IoElement {
	static get Style(): string;
	transparent: boolean;
	size: [
		number,
		number
	];
	color: [
		number,
		number,
		number,
		number
	];
	pxRatio: number;
	theme: typeof IoThemeSingleton;
	reactivity: string;
	needsResize: boolean;
	canvas: HTMLCanvasElement;
	ctx: CanvasRenderingContext2D;
	static get Vert(): string;
	static get GlUtils(): string;
	static get Frag(): string;
	initPropertyUniform(name: string, property: PropertyDefinition$1): string;
	initShader(): WebGLProgram;
	constructor(properties?: Record<string, any>);
	onResized(): void;
	themeMutated(): void;
	changed(): void;
	_onRender(): void;
	setShaderProgram(): void;
	updatePropertyUniform(name: string, property: PropertyInstance): void;
	updateThemeUniforms(): void;
	setUniform(name: string, value: any): void;
	Register(ioNodeConstructor: typeof IoElement): void;
}
/**
 * Input element for `Array(2)` data type combining `IoNumber` and `IoSliderRange`
 *
 * <io-element-demo element="io-number-slider-range" properties='{"value": [0, 2], "step": 0.05, "min": -1, "max": 2}'></io-element-demo>
 **/
export declare class IoNumberSliderRange extends IoElement {
	static get Style(): string;
	value: [
		number,
		number
	];
	step: number;
	min: number;
	max: number;
	exponent: number;
	conversion: number;
	_onNumberSet(event: CustomEvent): void;
	_onSliderSet(event: CustomEvent): void;
	init(): void;
	changed(): void;
}
/**
 * Input element for `Number` data type combining `IoNumber` and `IoSlider`
 *
 * <io-element-demo element="io-number-slider" properties='{"value": 0, "step": 0.01, "conversion": 1, "min": -0.5, "max": 0.5, "exponent": 1}'></io-element-demo>
 * <io-element-demo element="io-number-slider" properties='{"value": 0, "step": 0.2617993877991494, "conversion": 57.29577951308232, "min": -6.283185307179586, "max": 6.283185307179586, "exponent": 1}'></io-element-demo>
 * <io-element-demo element="io-number-slider" properties='{"value": 0, "step": 0.1, "conversion": 0.2, "min": -0.5, "max": 0.5, "exponent": 1}'></io-element-demo>
 **/
export declare class IoNumberSlider extends IoElement {
	static get Style(): string;
	value: number;
	step: number;
	min: number;
	max: number;
	exponent: number;
	conversion: number;
	_onNumberSet(event: CustomEvent): void;
	_onSliderSet(event: CustomEvent): void;
	init(): void;
	changed(): void;
}
export declare class IoSliderBase extends IoGl {
	static get Style(): string;
	value: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	step: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	min: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	max: number | [
		number,
		number
	] | {
		x: number;
		y: number;
	};
	exponent: number;
	vertical: boolean;
	noscroll: boolean;
	role: string;
	tabindex: string;
	_startX: number;
	_startY: number;
	_active: number;
	_rect: DOMRect | null;
	get _min(): [
		number,
		number
	];
	get _max(): [
		number,
		number
	];
	get _step(): [
		number,
		number
	];
	get _value(): [
		number,
		number
	];
	static get Listeners(): {
		focus: string;
		contextmenu: string;
		pointerdown: string;
		touchstart: (string | {
			passive: boolean;
		})[];
	};
	_onFocus(): void;
	_onBlur(): void;
	_onContextmenu(event: Event): void;
	_onTouchstart(event: TouchEvent): void;
	_onTouchmove(event: TouchEvent): void;
	_onTouchend(): void;
	_onPointerdown(event: PointerEvent): void;
	_onPointermove(event: PointerEvent): void;
	_onPointerup(event: PointerEvent): void;
	_getPointerCoord(event: PointerEvent): [
		number,
		number
	];
	_getValueFromCoord(coord: [
		number,
		number
	]): [
		number,
		number
	];
	_onPointermoveThrottled(event: PointerEvent): void;
	_inputValue(value: [
		number,
		number
	]): void;
	_onKeydown(event: KeyboardEvent): void;
	_setIncrease(): void;
	_setDecrease(): void;
	_setMin(): void;
	_setMax(): void;
	_setUp(): void;
	_setDown(): void;
	_setLeft(): void;
	_setRight(): void;
	init(): void;
	changed(): void;
}
export declare class IoSlider2d extends IoSliderBase {
	static get Style(): string;
	value: [
		number,
		number
	];
	step: [
		number,
		number
	];
	min: [
		number,
		number
	];
	max: [
		number,
		number
	];
	noscroll: boolean;
	static get GlUtils(): string;
	static get Frag(): string;
}
/**
 * Input element for `Array(2)` data type displayed as slider.
 * It can be configured to clamp the `value` compoents to `min` / `max` and round it to the nearest `step` increment. `exponent` property can be changed for non-linear scale.
 *
 * Keys left/right/up/down+shift and pageup/pagedown change the value in step incements. Home/end keys set the value to min/max.
 *
 * <io-element-demo element="io-slider-range" properties='{"value": [0, 1], "step": 0.1, "min": -1, "max": 2, "exponent": 1}'></io-element-demo>
 **/
export declare class IoSliderRange extends IoSliderBase {
	value: [
		number,
		number
	];
	step: number;
	min: number;
	max: number;
	_index: number;
	_getCoordFromValue(value: [
		number,
		number
	]): number[];
	_onPointerdown(event: PointerEvent): void;
	_onPointermoveThrottled(event: PointerEvent): void;
	static get Frag(): string;
}
/**
 * Input element for `Number` data type displayed as slider.
 * It can be configured to clamp the `value` to `min` / `max` and round it to the nearest `step` increment. `exponent` property can be changed for non-linear scale.
 *
 * Keys left/right/up/down+shift and pageup/pagedown change the value in step incements. Home/end keys set the value to min/max.
 *
 * <io-element-demo element="io-slider" properties='{"value": 0, "step": 0.01, "min": -0.5, "max": 0.5, "exponent": 1}'></io-element-demo>
 **/
export declare class IoSlider extends IoSliderBase {
	value: number;
	step: number;
	min: number;
	max: number;
	static get Frag(): string;
}

export {};
