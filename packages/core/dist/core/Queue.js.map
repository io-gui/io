{"version":3,"file":"Queue.js","sourceRoot":"","sources":["../../src/core/Queue.ts"],"names":[],"mappings":"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","sourcesContent":["import { Node } from '../nodes/Node.js'\nimport { IoElement } from '../elements/IoElement.js'\n\nexport type CallbackFunction = (arg?: any) => void\n\ninterface QueueOptions {\n  arg: any\n  frame: number\n}\n\ntype QueueKey = { node: Node | IoElement | undefined; func: CallbackFunction }\n\nlet currentFrame = 0\n\nconst queue0: Map<QueueKey, QueueOptions> = new Map()\nconst queue1: Map<QueueKey, QueueOptions> = new Map()\nlet queue = queue0\n\n// Key registry - shared across both buffers\nconst keysByNode: WeakMap<Node | IoElement, Map<CallbackFunction, QueueKey>> = new WeakMap()\nconst keysByFunc: Map<CallbackFunction, QueueKey> = new Map()\n\n// Throttle: tracks when each node+func can next execute immediately\nconst throttleNextFrame: WeakMap<Node | IoElement, Map<CallbackFunction, number>> = new WeakMap()\nconst throttleNextFrameGlobal: Map<CallbackFunction, number> = new Map()\n\nfunction getKey(func: CallbackFunction, node?: Node | IoElement): QueueKey {\n  if (node) {\n    let funcMap = keysByNode.get(node)\n    if (!funcMap) {\n      funcMap = new Map()\n      keysByNode.set(node, funcMap)\n    }\n    let key = funcMap.get(func)\n    if (!key) {\n      key = { node, func }\n      funcMap.set(func, key)\n    }\n    return key\n  } else {\n    let key = keysByFunc.get(func)\n    if (!key) {\n      key = { node: undefined, func }\n      keysByFunc.set(func, key)\n    }\n    return key\n  }\n}\n\n/**\n * Returns a promise that resolves when the next frame is rendered.\n * @returns {Promise<void>}\n */\nexport async function nextQueue(): Promise<void> {\n  return new Promise((resolve) => {\n    const key = getKey(resolve, undefined)\n    queue.set(key, { arg: undefined, frame: currentFrame + 1 })\n  })\n}\n\n/**\n * Throttles function execution with leading + trailing edge semantics.\n * - Executes immediately on first call (leading edge)\n * - Queues trailing call with latest argument\n * - Respects delay between executions\n */\nexport function throttle(func: CallbackFunction, arg?: any, node?: Node | IoElement, delay = 1) {\n  if (node?._disposed) return\n\n  const key = getKey(func, node)\n\n  // Check if we can execute immediately (leading edge)\n  let nextAllowed: number\n  if (node) {\n    nextAllowed = throttleNextFrame.get(node)?.get(func) ?? -Infinity\n  } else {\n    nextAllowed = throttleNextFrameGlobal.get(func) ?? -Infinity\n  }\n\n  if (currentFrame >= nextAllowed) {\n    if (node) {\n      let funcMap = throttleNextFrame.get(node)\n      if (!funcMap) {\n        funcMap = new Map()\n        throttleNextFrame.set(node, funcMap)\n      }\n      funcMap.set(func, currentFrame + delay)\n    } else {\n      throttleNextFrameGlobal.set(func, currentFrame + delay)\n    }\n\n    try {\n      if (arg !== undefined) func(arg)\n      else func()\n    } catch (e) {\n      console.error(e)\n    }\n\n    // Queue trailing call (will execute after delay)\n    queue.set(key, { arg, frame: currentFrame + delay })\n  } else {\n    // Within delay period - only update arg, don't postpone\n    const existing = queue.get(key)\n    if (existing) {\n      existing.arg = arg\n    }\n  }\n}\n\nexport function debounce(func: CallbackFunction, arg?: any, node?: Node | IoElement, delay = 1) {\n  const key = getKey(func, node)\n  queue.set(key, { arg, frame: currentFrame + delay })\n}\n\nfunction executeQueue() {\n  currentFrame++\n\n  const activeQueue = queue\n  queue = queue === queue0 ? queue1 : queue0\n\n  for (const [key, options] of activeQueue) {\n    // Re-queue if target frame not reached\n    if (options.frame > currentFrame) {\n      if (!queue.has(key)) {\n        queue.set(key, options)\n      }\n      continue\n    }\n\n    if (key.node?._disposed) continue\n\n    try {\n      if (options.arg !== undefined) key.func(options.arg)\n      else key.func()\n    } catch (e) {\n      console.error(e)\n    }\n  }\n\n  activeQueue.clear()\n  requestAnimationFrame(executeQueue)\n}\nrequestAnimationFrame(executeQueue)\n"]}