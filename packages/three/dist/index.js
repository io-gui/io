import{ReactiveProperty,Node,Register,Property,IoElement}from"@io-gui/core";import{Scene,Box3,Sphere,Vector3,Camera,PerspectiveCamera,OrthographicCamera,WebGPURenderer,Clock,CanvasTarget}from"three/webgpu";import WebGPU from"three/addons/capabilities/WebGPU.js";import{OrbitControls}from"three/addons/controls/OrbitControls.js";var __defProp$2=Object.defineProperty,__getOwnPropDesc$2=Object.getOwnPropertyDescriptor,__decorateClass$2=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$2(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$2(target,key,result),result};let ThreeState=class extends Node{renderer=null;width=0;height=0;_lastAnimatedFrame=-1;setViewportSize(width,height){this.width===width&&this.height===height||width&&height&&(this.width=width,this.height=height,this.onResized(width,height))}isRendererInitialized(){return!!this.renderer&&!0===this.renderer.initialized}onRendererInitialized(renderer){this.renderer=renderer}onResized(width,height){}animate(time,delta){this._lastAnimatedFrame!==time&&(this._lastAnimatedFrame=time,this.onAnimate(delta))}onAnimate(delta){}};__decorateClass$2([ReactiveProperty({type:Scene,init:null})],ThreeState.prototype,"scene",2),ThreeState=__decorateClass$2([Register],ThreeState);var __defProp$1=Object.defineProperty,__getOwnPropDesc$1=Object.getOwnPropertyDescriptor,__decorateClass$1=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc$1(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp$1(target,key,result),result};const box=new Box3,sphere=new Sphere,center=new Vector3,delta=new Vector3;function setAspect(camera,width,height){const aspect=width/height;if(camera instanceof PerspectiveCamera)camera.aspect=aspect;else if(camera instanceof OrthographicCamera){const frustumHeight=camera.top-camera.bottom;camera.left=-frustumHeight*aspect/2,camera.right=frustumHeight*aspect/2}camera.updateProjectionMatrix()}let ViewCameras=class extends Node{static get Listeners(){return{"scene-ready":"onSceneReady"}}constructor(args){super(args),this.orbitControls.connect(this.viewport),this.orbitControls.addEventListener("change",()=>{this.state.dispatchMutation()}),void 0===this.camera&&(this.camera=this.defaultCameras.perspective)}cameraSelectChanged(){if(this.cameraSelect.startsWith("scene")){const cameraId=this.cameraSelect.split(":")[1]||"",cameras=[...this.state.scene.getObjectsByProperty("isPerspectiveCamera",!0),...this.state.scene.getObjectsByProperty("isOrthographicCamera",!0)];let matchedCamera;matchedCamera=cameraId?cameras.find(camera=>camera.name===cameraId):cameras[0],matchedCamera?this.camera=matchedCamera:(this.camera=this.defaultCameras.perspective,console.warn(`Camera ${cameraId} not found in the scene, using default perspective camera`))}else this.camera=this.defaultCameras.getCamera(this.cameraSelect)||this.defaultCameras.perspective}setSize(width,height){if(0!==width&&0!==height&&(this.width!==width||this.height!==height)){for(const camera of this.defaultCameras.cameras)setAspect(camera,width,height);this.width=width,this.height=height}}cameraChanged(){this.defaultCameras.cameras.includes(this.camera)?(this.orbitControls.enabled=!0,this.orbitControls.object=this.camera):this.orbitControls.enabled=!1}stateChanged(){for(const camera of this.defaultCameras.cameras)this.frameObject(this.state.scene,camera)}onSceneReady(){this.frameObject(this.state.scene,this.camera)}frameObject(object,camera){let distance;if(box.setFromObject(object),!1===box.isEmpty()?(box.getCenter(center),distance=box.getBoundingSphere(sphere).radius):(center.setFromMatrixPosition(camera.matrixWorld),distance=.1),delta.set(0,0,1),delta.applyQuaternion(camera.quaternion),delta.multiplyScalar(2*distance),camera instanceof PerspectiveCamera)camera.near=.001*distance,camera.far=16*distance,camera.updateProjectionMatrix(),camera.position.copy(center).add(delta);else if(camera instanceof OrthographicCamera){delta.copy(camera.userData.position).multiplyScalar(distance);const aspect=this.width/this.height;camera.top=distance,camera.bottom=-distance,camera.left=-distance*aspect,camera.right=distance*aspect,camera.near=0,camera.far=8*distance,camera.position.copy(center).add(delta),camera.lookAt(center),camera.updateProjectionMatrix()}this.orbitControls.target.copy(center)}dispose(){this.orbitControls.dispose(),super.dispose()}};__decorateClass$1([Property(0)],ViewCameras.prototype,"width",2),__decorateClass$1([Property(0)],ViewCameras.prototype,"height",2),__decorateClass$1([Property()],ViewCameras.prototype,"viewport",2),__decorateClass$1([ReactiveProperty({type:ThreeState})],ViewCameras.prototype,"state",2),__decorateClass$1([ReactiveProperty({type:String,value:"perspective"})],ViewCameras.prototype,"cameraSelect",2),__decorateClass$1([ReactiveProperty({type:Camera})],ViewCameras.prototype,"camera",2),__decorateClass$1([ReactiveProperty({type:class DefaultCameras{perspective;top;bottom;left;right;front;back;constructor(){this.perspective=new PerspectiveCamera(75,1,.1,1e3),this.top=new OrthographicCamera(-1,1,1,-1,0,1e3),this.bottom=new OrthographicCamera(-1,1,1,-1,0,1e3),this.left=new OrthographicCamera(-1,1,1,-1,0,1e3),this.right=new OrthographicCamera(-1,1,1,-1,0,1e3),this.front=new OrthographicCamera(-1,1,1,-1,0,1e3),this.back=new OrthographicCamera(-1,1,1,-1,0,1e3),this.perspective.position.set(.5,.25,1),this.perspective.lookAt(0,0,0),this.perspective.name="perspective",this.top.userData.position=new Vector3(0,1,0),this.top.position.copy(this.top.userData.position),this.top.lookAt(0,0,0),this.top.name="top",this.bottom.userData.position=new Vector3(0,-1,0),this.bottom.position.copy(this.bottom.userData.position),this.bottom.lookAt(0,0,0),this.bottom.name="bottom",this.left.userData.position=new Vector3(-1,0,0),this.left.position.copy(this.left.userData.position),this.left.lookAt(0,0,0),this.left.name="left",this.right.userData.position=new Vector3(1,0,0),this.right.position.copy(this.right.userData.position),this.right.lookAt(0,0,0),this.right.name="right",this.front.userData.position=new Vector3(0,0,1),this.front.position.copy(this.front.userData.position),this.front.lookAt(0,0,0),this.front.name="front",this.back.userData.position=new Vector3(0,0,-1),this.back.position.copy(this.back.userData.position),this.back.lookAt(0,0,0),this.back.name="back"}get cameras(){return[this.perspective,this.top,this.bottom,this.left,this.right,this.front,this.back]}getCamera(name){return this.cameras.find(camera=>camera.name===name)}},init:null})],ViewCameras.prototype,"defaultCameras",2),__decorateClass$1([ReactiveProperty({type:OrbitControls,init:["this.defaultCameras.perspective"]})],ViewCameras.prototype,"orbitControls",2),ViewCameras=__decorateClass$1([Register],ViewCameras);var __defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__decorateClass=(decorators,target,key,kind)=>{for(var decorator,result=kind>1?void 0:kind?__getOwnPropDesc(target,key):target,i=decorators.length-1;i>=0;i--)(decorator=decorators[i])&&(result=(kind?decorator(target,key,result):decorator(result))||result);return kind&&result&&__defProp(target,key,result),result};if(!1===WebGPU.isAvailable())throw new Error("No WebGPU support");const observer=new IntersectionObserver(entries=>{entries.forEach(entry=>{entry.target.visible=entry.isIntersecting})}),_renderer=new WebGPURenderer({antialias:!1,alpha:!0});_renderer.setPixelRatio(window.devicePixelRatio),_renderer.init();const _clock=new Clock,_playingViewports=[];let _currentFrameTime=-1,_currentFrameDelta=0;new Promise((resolve,reject)=>{_renderer.setAnimationLoop(time=>{_currentFrameTime=time,_currentFrameDelta=_clock.getDelta();for(const viewport of _playingViewports)viewport.onAnimate()}).then(resolve).catch(reject)}).then(()=>{console.log("animation loop initialized")}).catch(error=>{console.error("animation loop initialization failed",error)});let IoThreeViewport=class extends IoElement{width=0;height=0;visible=!1;static get Style(){return"\n      :host {\n        position: relative;\n        display: flex;\n        flex: 1 1 auto;\n        flex-direction: column;\n        max-width: 100%;\n        max-height: 100%;\n        overflow: hidden;\n      }\n      :host > canvas {\n        position: absolute;\n      }\n    "}constructor(args){super(args),this.renderViewport=this.renderViewport.bind(this),this.renderTarget=new CanvasTarget(document.createElement("canvas")),this.appendChild(this.renderTarget.domElement),this.viewCameras=new ViewCameras({viewport:this,state:this.state,cameraSelect:this.bind("cameraSelect")}),this.debounce(this.renderViewport)}connectedCallback(){super.connectedCallback(),observer.observe(this)}disconnectedCallback(){super.disconnectedCallback(),observer.unobserve(this),this.visible=!1}playingChanged(){this.playing?_playingViewports.push(this):_playingViewports.includes(this)&&_playingViewports.splice(_playingViewports.indexOf(this),1)}onAnimate(){this.visible&&this.debounce(this.renderViewport)}onResized(){const rect=this.getBoundingClientRect();this.width=Math.floor(rect.width),this.height=Math.floor(rect.height),this.renderTarget.setSize(this.width,this.height),this.renderTarget.setPixelRatio(window.devicePixelRatio),this.viewCameras.setSize(this.width,this.height),this.renderViewport()}stateChanged(){this.debounce(this.renderViewport)}stateMutated(){this.debounce(this.renderViewport)}changed(){this.debounce(this.renderViewport)}renderViewport(){!1!==_renderer.initialized?(!1===this.state.isRendererInitialized()&&this.state.onRendererInitialized(_renderer),this.width&&this.height&&(_renderer.setCanvasTarget(this.renderTarget),_renderer.setClearColor(this.clearColor,this.clearAlpha),_renderer.setSize(this.width,this.height),_renderer.clear(),this.state.setViewportSize(this.width,this.height),this.state.animate(_currentFrameTime,_currentFrameDelta),_renderer.render(this.state.scene,this.viewCameras.camera))):this.debounce(this.renderViewport)}dispose(){super.dispose(),this.renderTarget.dispose(),this.viewCameras.dispose()}};__decorateClass([ReactiveProperty({type:Number,value:0})],IoThreeViewport.prototype,"clearColor",2),__decorateClass([ReactiveProperty({type:Number,value:1})],IoThreeViewport.prototype,"clearAlpha",2),__decorateClass([ReactiveProperty({type:String,value:"throttled"})],IoThreeViewport.prototype,"reactivity",2),__decorateClass([ReactiveProperty({type:ThreeState,init:null})],IoThreeViewport.prototype,"state",2),__decorateClass([ReactiveProperty({type:Boolean})],IoThreeViewport.prototype,"playing",2),__decorateClass([ReactiveProperty({type:String,value:"perspective"})],IoThreeViewport.prototype,"cameraSelect",2),IoThreeViewport=__decorateClass([Register],IoThreeViewport);const ioThreeViewport=function(arg0){return IoThreeViewport.vConstructor(arg0)};export{IoThreeViewport,ThreeState,ioThreeViewport};
//# sourceMappingURL=index.js.map
