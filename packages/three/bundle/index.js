import{ReactiveProperty as t,Node as e,Register as i,Property as s,IoElement as o}from"@io-gui/core";import{Scene as r,Box3 as a,Sphere as n,Vector3 as h,Camera as p,PerspectiveCamera as c,OrthographicCamera as l,WebGPURenderer as d,CanvasTarget as m}from"three/webgpu";import u from"three/addons/capabilities/WebGPU.js";import{OrbitControls as f}from"three/addons/controls/OrbitControls.js";var g=Object.defineProperty,w=Object.getOwnPropertyDescriptor,b=(t,e,i,s)=>{for(var o,r=s>1?void 0:s?w(e,i):e,a=t.length-1;a>=0;a--)(o=t[a])&&(r=(s?o(e,i,r):o(r))||r);return s&&r&&g(e,i,r),r};let y=class extends e{renderer=null;width=0;height=0;setViewportSize(t,e){this.width===t&&this.height===e||t&&e&&(this.width=t,this.height=e,this.onResized(t,e))}isRendererInitialized(){return!!this.renderer&&!0===this.renderer.initialized}onRendererInitialized(t){this.renderer=t}onResized(t,e){}onAnimate(){}};b([t({type:r,init:null})],y.prototype,"scene",2),y=b([i],y);var v=Object.defineProperty,C=Object.getOwnPropertyDescriptor,k=(t,e,i,s)=>{for(var o,r=s>1?void 0:s?C(e,i):e,a=t.length-1;a>=0;a--)(o=t[a])&&(r=(s?o(e,i,r):o(r))||r);return s&&r&&v(e,i,r),r};const S=new a,P=new n,x=new h,O=new h;function j(t,e,i){const s=e/i;if(t instanceof c)t.aspect=s;else if(t instanceof l){const e=t.top-t.bottom;t.left=-e*s/2,t.right=e*s/2}t.updateProjectionMatrix()}let z=class extends e{constructor(t){super(t),this.orbitControls.connect(this.viewport),this.orbitControls.addEventListener("change",()=>{this.state.dispatchMutation()}),void 0===this.camera&&(this.camera=this.defaultCameras.perspective)}cameraSelectChanged(){if(this.cameraSelect.startsWith("scene")){const t=this.cameraSelect.split(":")[1]||"",e=[...this.state.scene.getObjectsByProperty("isPerspectiveCamera",!0),...this.state.scene.getObjectsByProperty("isOrthographicCamera",!0)];let i;i=t?e.find(e=>e.name===t):e[0],i?this.camera=i:(this.camera=this.defaultCameras.perspective,console.warn(`Camera ${t} not found in the scene, using default perspective camera`))}else this.camera=this.defaultCameras.getCamera(this.cameraSelect)||this.defaultCameras.perspective;this.orbitControls.object=this.camera}setSize(t,e){if(0!==t&&0!==e&&(this.width!==t||this.height!==e)){for(const i of this.defaultCameras.cameras)j(i,t,e);this.width=t,this.height=e}}cameraChanged(){}stateChanged(){for(const t of this.defaultCameras.cameras)this.frameObject(this.state.scene,t)}frameObject(t,e){let i;if(S.setFromObject(t),!1===S.isEmpty()?(S.getCenter(x),i=S.getBoundingSphere(P).radius):(x.setFromMatrixPosition(e.matrixWorld),i=.1),O.set(0,0,1),O.applyQuaternion(e.quaternion),O.multiplyScalar(2*i),e instanceof c)e.near=.001*i,e.far=16*i,e.updateProjectionMatrix(),e.position.copy(x).add(O);else if(e instanceof l){O.copy(e.userData.position).multiplyScalar(i);const t=this.width/this.height;e.top=i,e.bottom=-i,e.left=-i*t,e.right=i*t,e.near=0,e.far=8*i,e.position.copy(x).add(O),e.lookAt(x),e.updateProjectionMatrix()}}dispose(){this.orbitControls.dispose(),super.dispose()}};k([s(0)],z.prototype,"width",2),k([s(0)],z.prototype,"height",2),k([s()],z.prototype,"viewport",2),k([t({type:y})],z.prototype,"state",2),k([t({type:String,value:"perspective"})],z.prototype,"cameraSelect",2),k([t({type:p})],z.prototype,"camera",2),k([t({type:class{perspective;top;bottom;left;right;front;back;constructor(){this.perspective=new c(75,1,.1,1e3),this.top=new l(-1,1,1,-1,0,1e3),this.bottom=new l(-1,1,1,-1,0,1e3),this.left=new l(-1,1,1,-1,0,1e3),this.right=new l(-1,1,1,-1,0,1e3),this.front=new l(-1,1,1,-1,0,1e3),this.back=new l(-1,1,1,-1,0,1e3),this.perspective.position.set(.5,.25,1),this.perspective.lookAt(0,0,0),this.perspective.name="perspective",this.top.userData.position=new h(0,1,0),this.top.position.copy(this.top.userData.position),this.top.lookAt(0,0,0),this.top.name="top",this.bottom.userData.position=new h(0,-1,0),this.bottom.position.copy(this.bottom.userData.position),this.bottom.lookAt(0,0,0),this.bottom.name="bottom",this.left.userData.position=new h(-1,0,0),this.left.position.copy(this.left.userData.position),this.left.lookAt(0,0,0),this.left.name="left",this.right.userData.position=new h(1,0,0),this.right.position.copy(this.right.userData.position),this.right.lookAt(0,0,0),this.right.name="right",this.front.userData.position=new h(0,0,1),this.front.position.copy(this.front.userData.position),this.front.lookAt(0,0,0),this.front.name="front",this.back.userData.position=new h(0,0,-1),this.back.position.copy(this.back.userData.position),this.back.lookAt(0,0,0),this.back.name="back"}get cameras(){return[this.perspective,this.top,this.bottom,this.left,this.right,this.front,this.back]}getCamera(t){return this.cameras.find(e=>e.name===t)}},init:null})],z.prototype,"defaultCameras",2),k([t({type:f,init:["this.defaultCameras.perspective"]})],z.prototype,"orbitControls",2),z=k([i],z);var A=Object.defineProperty,D=Object.getOwnPropertyDescriptor,R=(t,e,i,s)=>{for(var o,r=s>1?void 0:s?D(e,i):e,a=t.length-1;a>=0;a--)(o=t[a])&&(r=(s?o(e,i,r):o(r))||r);return s&&r&&A(e,i,r),r};if(!1===u.isAvailable())throw new Error("No WebGPU support");const V=new IntersectionObserver(t=>{t.forEach(t=>{t.target.visible=t.isIntersecting})}),M=new d({antialias:!1,alpha:!0});M.setPixelRatio(window.devicePixelRatio),M.init();const T=[];new Promise((t,e)=>{M.setAnimationLoop(t=>{for(const e of T)e.onAnimate(t)}).then(t).catch(e)}).then(()=>{console.log("animation loop initialized")}).catch(t=>{console.error("animation loop initialization failed",t)});let E=class extends o{width=0;height=0;visible=!1;static get Style(){return"\n      :host {\n        position: relative;\n        display: flex;\n        flex: 1 1 auto;\n        flex-direction: column;\n        max-width: 100%;\n        max-height: 100%;\n        overflow: hidden;\n      }\n      :host > canvas {\n        position: absolute;\n      }\n    "}constructor(t){super(t),this.renderViewport=this.renderViewport.bind(this),this.renderTarget=new m(document.createElement("canvas")),this.appendChild(this.renderTarget.domElement),this.viewCameras=new z({viewport:this,state:this.state,cameraSelect:this.bind("cameraSelect")}),this.debounce(this.renderViewport)}connectedCallback(){super.connectedCallback(),V.observe(this)}disconnectedCallback(){super.disconnectedCallback(),V.unobserve(this),this.visible=!1}playingChanged(){this.playing?T.push(this):T.includes(this)&&T.splice(T.indexOf(this),1)}onAnimate(t){this.visible&&this.debounce(this.renderViewport)}onResized(){const t=this.getBoundingClientRect();this.width=Math.floor(t.width),this.height=Math.floor(t.height),this.renderTarget.setSize(this.width,this.height),this.renderTarget.setPixelRatio(window.devicePixelRatio),this.viewCameras.setSize(this.width,this.height),this.renderViewport()}stateChanged(){this.debounce(this.renderViewport)}stateMutated(){this.debounce(this.renderViewport)}changed(){this.debounce(this.renderViewport)}renderViewport(){!1!==M.initialized?(!1===this.state.isRendererInitialized()&&this.state.onRendererInitialized(M),this.width&&this.height&&(M.setCanvasTarget(this.renderTarget),M.setClearColor(this.clearColor,this.clearAlpha),M.setSize(this.width,this.height),M.clear(),this.state.setViewportSize(this.width,this.height),this.state.onAnimate(),M.render(this.state.scene,this.viewCameras.camera))):this.debounce(this.renderViewport)}dispose(){super.dispose(),this.renderTarget.dispose(),this.viewCameras.dispose()}};R([t({type:Number,value:0})],E.prototype,"clearColor",2),R([t({type:Number,value:1})],E.prototype,"clearAlpha",2),R([t({type:String,value:"throttled"})],E.prototype,"reactivity",2),R([t({type:y,init:null})],E.prototype,"state",2),R([t({type:Boolean})],E.prototype,"playing",2),R([t({type:String,value:"perspective"})],E.prototype,"cameraSelect",2),E=R([i],E);const I=function(t){return E.vConstructor(t)};export{E as IoThreeViewport,y as ThreeState,I as ioThreeViewport};
//# sourceMappingURL=index.js.map
