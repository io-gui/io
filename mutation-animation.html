<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Io-GUI Mutation Event Propagation</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
        #info {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.8);
            padding: 20px;
            border-radius: 8px;
            z-index: 100;
            max-width: 300px;
        }
        .legend {
            margin-top: 15px;
            font-size: 12px;
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
        }
        .legend-color {
            width: 20px;
            height: 20px;
            margin-right: 10px;
            border-radius: 50%;
        }
    </style>
</head>
<body>
    <div id="info">
        <h3>Io-GUI Mutation Event Propagation</h3>
        <p>Watch how mutation events flow through the node tree when properties change.</p>
        <div class="legend">
            <div class="legend-item">
                <div class="legend-color" style="background: #2196F3;"></div>
                <span>Node</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FF0000;"></div>
                <span>Mutation (↑)</span>
            </div>
            <div class="legend-item">
                <div class="legend-color" style="background: #FFFF00;"></div>
                <span>Change (↓)</span>
            </div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        const scene = new THREE.Scene();
        const camera = new THREE.PerspectiveCamera(25, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setClearColor(0x1a1a1a);
        document.body.appendChild(renderer.domElement);

        class SimulatedNode {
            constructor(name, position) {
                this.name = name;
                this.position = position;
                this.children = [];
                this.parent = null;
                this.observers = [];
                this.bindings = [];
                this.properties = new Map();
                this.changeQueue = [];
                this.isDispatching = false;
                this.createVisual();
            }

            createVisual() {
                const radius = this.name === 'root' ? 0.9 : 0.3; // 3x bigger for root
                const geometry = new THREE.SphereGeometry(radius, 16, 16);
                const material = new THREE.MeshBasicMaterial({ color: 0x214693 });
                material.userData.originalColor = new THREE.Color(0x2196F3);

                this.mesh = new THREE.Mesh(geometry, material);
                this.mesh.position.set(this.position.x, this.position.y, this.position.z);
                this.mesh.userData.originalScale = new THREE.Vector3(1, 1, 1);
                scene.add(this.mesh);

                this.connections = [];
            }

            addChild(child) {
                this.children.push(child);
                child.parent = this;
                return this.createConnection(child);
            }

            createConnection(child) {
                const points = [
                    new THREE.Vector3(this.position.x, this.position.y, this.position.z),
                    new THREE.Vector3(child.position.x, child.position.y, child.position.z)
                ];
                const geometry = new THREE.BufferGeometry().setFromPoints(points);
                const material = new THREE.LineBasicMaterial({ color: 0x444444 });
                material.userData.originalColor = new THREE.Color(0x444444);
                const line = new THREE.Line(geometry, material);
                scene.add(line);
                
                const connection = {
                    nodeA: this,
                    nodeB: child,
                    line: line
                };
                this.connections.push(connection);
                return connection;
            }


            setProperty(name, value) {
                const oldValue = this.properties.get(name);
                if (oldValue !== value) {
                    this.properties.set(name, value);
                    this.queueChange(name, value, oldValue);
                    this.animateChange();
                }
            }

            queueChange(property, value, oldValue) {
                const existingIndex = this.changeQueue.findIndex(change => change.property === property);
                if (existingIndex !== -1) {
                    this.changeQueue[existingIndex].value = value;
                } else {
                    this.changeQueue.push({ property, value, oldValue });
                }
                setTimeout(() => this.dispatchChanges(), 50);
            }

            dispatchChanges() {
                if (this.isDispatching || this.changeQueue.length === 0) return;
                this.isDispatching = true;

                this.changeQueue.forEach(change => {
                    this.animatePropertyChange(change);
                    setTimeout(() => this.triggerMutationEvent(), 100);
                });

                this.changeQueue = [];
                this.isDispatching = false;
            }

            triggerMutationEvent() {
                this.createMutationWave();
                if (this.parent) {
                    setTimeout(() => {
                        this.parent.onMutationReceived(this);
                    }, 100);
                }
            }

            triggerChangeEvent() {
                this.createChangeWave();
                this.children.forEach(child => {
                    setTimeout(() => {
                        child.onChangeReceived(this);
                    }, 100);
                });
            }

            createMutationWave() {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xFF4444,
                    transparent: true,
                    opacity: 0.8
                });

                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(this.mesh.position);
                scene.add(wave);

                const startScale = 0.1;
                const endScale = 2.0;
                const duration = 1000;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    const scale = startScale + (endScale - startScale) * progress;
                    wave.scale.set(scale, scale, scale);

                    const opacity = 0.8 * (1 - progress);
                    wave.material.opacity = opacity;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(wave);
                        wave.geometry.dispose();
                        wave.material.dispose();
                    }
                };
                animate();
            }

            createChangeWave() {
                const geometry = new THREE.SphereGeometry(0.1, 8, 8);
                const material = new THREE.MeshBasicMaterial({ 
                    color: 0xFFFF00,
                    transparent: true,
                    opacity: 0.8
                });

                const wave = new THREE.Mesh(geometry, material);
                wave.position.copy(this.mesh.position);
                scene.add(wave);

                const startScale = 0.1;
                const endScale = 2.0;
                const duration = 1000;
                const startTime = Date.now();

                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    const scale = startScale + (endScale - startScale) * progress;
                    wave.scale.set(scale, scale, scale);

                    const opacity = 0.8 * (1 - progress);
                    wave.material.opacity = opacity;

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else {
                        scene.remove(wave);
                        wave.geometry.dispose();
                        wave.material.dispose();
                    }
                };
                animate();
            }

            onMutationReceived(source) {
                this.createPropagationLine(source);
                this.animateReceiveMutation();
                if (this.parent) {
                    setTimeout(() => {
                        this.parent.onMutationReceived(this);
                    }, 100);
                }
            }

            onChangeReceived(source) {
                this.createChangePropagationLine(source);
                this.animateReceiveChange();
                this.children.forEach(child => {
                    setTimeout(() => {
                        child.onChangeReceived(this);
                    }, 100);
                });
            }

            createPropagationLine(source) {
                const connection = this.connections.find(conn => conn.nodeB === source);
                if (connection) {
                    const originalColor = connection.line.material.userData.originalColor;
                    const mutationColor = new THREE.Color(0xFF0000);
                    const animateColor = (from, to, duration, callback) => {
                        const startTime = Date.now();
                        const animate = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            connection.line.material.color.lerpColors(from, to, progress);
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else if (callback) {
                                callback();
                            }
                        };
                        animate();
                    };
                    
                    animateColor(originalColor, mutationColor, 150, () => {
                        animateColor(mutationColor, originalColor, 650);
                    });
                } else {
                    console.log('No connection found for mutation from', source.name, 'to', this.name);
                }
            }

            createChangePropagationLine(source) {
                // Find the existing connection line between source and this node
                const connection = source.connections.find(conn => conn.nodeB === this);
                if (connection) {
                    const originalColor = connection.line.material.userData.originalColor;
                    const changeColor = new THREE.Color(0xFFFF00);
                    
                    // Animate the existing line color
                    const animateColor = (from, to, duration, callback) => {
                        const startTime = Date.now();
                        const animate = () => {
                            const elapsed = Date.now() - startTime;
                            const progress = Math.min(elapsed / duration, 1);
                            
                            connection.line.material.color.lerpColors(from, to, progress);
                            
                            if (progress < 1) {
                                requestAnimationFrame(animate);
                            } else if (callback) {
                                callback();
                            }
                        };
                        animate();
                    };
                    
                    animateColor(originalColor, changeColor, 100, () => {
                        animateColor(changeColor, originalColor, 700);
                    });
                }
            }

            animatePropertyChange(change) {
              const originalColor = this.mesh.material.userData.originalColor;
              const mutationColor = new THREE.Color(0xFFFFFF);
              this.animateColor(originalColor, mutationColor, 100, () => {
                  this.animateColor(mutationColor, originalColor, 5000);
              });

              const originalScale = this.mesh.userData.originalScale;
                const targetScale = originalScale.clone().multiplyScalar(4);
                this.animateScale(originalScale, targetScale, 100, () => {
                    this.animateScale(targetScale, originalScale, 600);
                });
            }

            animateReceiveMutation() {
                const originalColor = this.mesh.material.userData.originalColor;
                const mutationColor = new THREE.Color(0xFF4444);

                this.animateColor(originalColor, mutationColor, 100, () => {
                    this.animateColor(mutationColor, originalColor, 600);
                });

                const originalScale = this.mesh.userData.originalScale;
                const targetScale = originalScale.clone().multiplyScalar(2);
                this.animateScale(originalScale, targetScale, 100, () => {
                    this.animateScale(targetScale, originalScale, 600);
                });
            }

            animateReceiveChange() {
                const originalColor = this.mesh.material.userData.originalColor;
                const changeColor = new THREE.Color(0xFFFF00);

                this.animateColor(originalColor, changeColor, 100, () => {
                    this.animateColor(changeColor, originalColor, 600);
                });

                const originalScale = this.mesh.userData.originalScale;
                const targetScale = originalScale.clone().multiplyScalar(2);
                this.animateScale(originalScale, targetScale, 100, () => {
                    this.animateScale(targetScale, originalScale, 600);
                });
            }

            animateChange() {
                const originalColor = this.mesh.material.userData.originalColor;
                const changeColor = new THREE.Color(0xFF4444);

                this.animateColor(originalColor, changeColor, 100, () => {
                    this.animateColor(changeColor, originalColor, 600);
                });
            }

            animateScale(from, to, duration, callback) {
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    this.mesh.scale.lerpVectors(from, to, progress);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else if (callback) {
                        callback();
                    }
                };
                animate();
            }

            animateColor(from, to, duration, callback) {
                const startTime = Date.now();
                const animate = () => {
                    const elapsed = Date.now() - startTime;
                    const progress = Math.min(elapsed / duration, 1);

                    this.mesh.material.color.lerpColors(from, to, progress);

                    if (progress < 1) {
                        requestAnimationFrame(animate);
                    } else if (callback) {
                        callback();
                    }
                };
                animate();
            }

            dispose() {
                scene.remove(this.mesh);
                this.connections.forEach(conn => scene.remove(conn));
                this.mesh.geometry.dispose();
                this.mesh.material.dispose();
            }
        }

        const treeStructure = {
            id: 'root',
            children: [
                {
                    id: 'view',
                    children: [
                        {
                            id: 'router',
                            children: [
                                { id: 'routes', children: [{ id: 'home' }, { id: 'about' }, { id: 'contact' }, { id: 'profile' }] },
                                { id: 'guard', children: [{ id: 'auth', children: [{ id: 'check', children: [] }] }, { id: 'role', children: [] }] },
                                { id: 'middleware', children: [{ id: 'cors', children: [] }, { id: 'helmet', children: [] }] }
                            ]
                        },
                        {
                            id: 'component',
                            children: [
                                { id: 'ui', children: [{ id: 'button', children: [] }, { id: 'input', children: [] }, { id: 'modal', children: [] }] },
                                { id: 'layout', children: [{ id: 'header', children: [] }, { id: 'sidebar', children: [] }, { id: 'footer', children: [] }] }
                            ]
                        }
                    ]
                },
                {
                    id: 'service',
                    children: [
                        {
                            id: 'api',
                            children: [
                                { id: 'rest', children: [{ id: 'endpoint', children: [] }] },
                                { id: 'graphql', children: [{ id: 'resolver', children: [] }] }
                            ]
                        },
                        {
                            id: 'notification',
                            children: [
                                { id: 'email', children: [{ id: 'smtp', children: [] }] },
                                { id: 'push', children: [{ id: 'fcm', children: [] }] }
                            ]
                        }
                    ]
                },
                
                {
                    id: 'config',
                    children: [
                        {
                            id: 'env',
                            children: [
                                { id: 'dev', children: [{ id: 'debug', children: [] }] },
                                { id: 'prod', children: [{ id: 'optimize', children: [] }] }
                            ]
                        },
                        {
                            id: 'database',
                            children: [
                                { id: 'connection', children: [{ id: 'pool', children: [] }] },
                                { id: 'query', children: [{ id: 'builder', children: [] }] }
                            ]
                        }
                    ]
                }
            ]
        };

        function calculateRadialPositions(treeData) {
            const positions = {};
            const levelRadius = 4;
            const levelSpacing = 3;
            const minNodeSpacing = 0.8;

            function positionNode(node, level = 0, parentAngle = 0, availableAngle = Math.PI * 2, siblingIndex = 0, siblingCount = 1) {
                const radius = level * levelRadius + levelSpacing;

                let angle;
                if (level === 0) {
                    angle = 0;
                } else {
                    if (level === 1) {
                        angle = (siblingIndex / siblingCount) * Math.PI * 2;
                    } else {
                        const angleStep = availableAngle / siblingCount;
                        angle = parentAngle - availableAngle / 2 + angleStep * (siblingIndex + 0.5);
                    }
                }
                
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                
                positions[node.id] = { x, y, z: 0 };
                
                if (node.children && node.children.length > 0) {
                    const childRadius = (level + 1) * levelRadius + levelSpacing;
                    const minAngleForSpacing = minNodeSpacing / childRadius;
                    const minTotalAngle = minAngleForSpacing * node.children.length;
                    
                    let childAngleSpan;
                    if (level === 0) {
                        childAngleSpan = Math.PI * 2;
                    } else {
                        const maxAngleFromParent = Math.min(availableAngle * 0.9, Math.PI);
                        childAngleSpan = Math.max(minTotalAngle, Math.min(maxAngleFromParent, Math.PI * 0.6));
                    }
                    
                    node.children.forEach((child, index) => {
                        positionNode(child, level + 1, angle, childAngleSpan, index, node.children.length);
                    });
                }
            }
            
            positionNode(treeData);
            return positions;
        }

        class ForceDirectedLayout {
            constructor(nodes, connections) {
                this.nodes = nodes;
                this.connections = connections;
                this.forces = {};
                this.velocities = {};
                this.damping = 0.95;
                this.repulsionStrength = 5;
                this.attractionStrength = 0.05;
                this.linkLength = 0.1;
                this.maxVelocity = 0.5;
                this.running = false;
                this.coolingRate = 0.999;
                this.temperature = 0.20;
                this.minTemperature = 0.01;
                
                Object.keys(nodes).forEach(id => {
                    this.forces[id] = { x: 0, y: 0 };
                    this.velocities[id] = { x: 0, y: 0 };
                });
            }

            calculateRepulsionForces() {
                const nodeIds = Object.keys(this.nodes);
                
                nodeIds.forEach(id => {
                    this.forces[id].x = 0;
                    this.forces[id].y = 0;
                });

                for (let i = 0; i < nodeIds.length; i++) {
                    for (let j = i + 1; j < nodeIds.length; j++) {
                        const nodeA = this.nodes[nodeIds[i]];
                        const nodeB = this.nodes[nodeIds[j]];
                        
                        const dx = nodeA.position.x - nodeB.position.x;
                        const dy = nodeA.position.y - nodeB.position.y;
                        const distance = Math.sqrt(dx * dx + dy * dy) + 0.01;
                        
                        const force = (this.repulsionStrength * this.temperature) / (distance * distance);
                        const fx = (dx / distance) * force;
                        const fy = (dy / distance) * force;
                        
                        this.forces[nodeIds[i]].x += fx;
                        this.forces[nodeIds[i]].y += fy;
                        this.forces[nodeIds[j]].x -= fx;
                        this.forces[nodeIds[j]].y -= fy;
                    }
                }
            }

            calculateAttractionForces() {
                this.connections.forEach(connection => {
                    const nodeA = connection.nodeA;
                    const nodeB = connection.nodeB;
                    
                    const dx = nodeB.position.x - nodeA.position.x;
                    const dy = nodeB.position.y - nodeA.position.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);
                    
                    const force = this.attractionStrength * this.temperature * (distance - this.linkLength);
                    const fx = (dx / distance) * force;
                    const fy = (dy / distance) * force;
                    
                    this.forces[nodeA.name].x += fx;
                    this.forces[nodeA.name].y += fy;
                    this.forces[nodeB.name].x -= fx;
                    this.forces[nodeB.name].y -= fy;
                });
            }

            updatePositions() {
                Object.keys(this.nodes).forEach(id => {
                    const node = this.nodes[id];
                    
                    // Pin root node to center
                    if (id === 'root') {
                        node.position.x = 0;
                        node.position.y = 0;
                        this.velocities[id].x = 0;
                        this.velocities[id].y = 0;
                        if (node.mesh) {
                            node.mesh.position.x = 0;
                            node.mesh.position.y = 0;
                        }
                        return;
                    }
                    
                    this.velocities[id].x += this.forces[id].x;
                    this.velocities[id].y += this.forces[id].y;
                    
                    // Clamp velocity to maximum
                    const velocity = Math.sqrt(this.velocities[id].x ** 2 + this.velocities[id].y ** 2);
                    if (velocity > this.maxVelocity) {
                        this.velocities[id].x = (this.velocities[id].x / velocity) * this.maxVelocity;
                        this.velocities[id].y = (this.velocities[id].y / velocity) * this.maxVelocity;
                    }
                    
                    this.velocities[id].x *= this.damping;
                    this.velocities[id].y *= this.damping;
                    
                    node.position.x += this.velocities[id].x;
                    node.position.y += this.velocities[id].y;
                    
                    if (node.mesh) {
                        node.mesh.position.x = node.position.x;
                        node.mesh.position.y = node.position.y;
                    }
                });
            }

            updateConnections() {
                this.connections.forEach(connection => {
                    const points = [
                        new THREE.Vector3(connection.nodeA.position.x, connection.nodeA.position.y, 0),
                        new THREE.Vector3(connection.nodeB.position.x, connection.nodeB.position.y, 0)
                    ];
                    connection.line.geometry.setFromPoints(points);
                });
            }

            step() {
                this.calculateRepulsionForces();
                this.calculateAttractionForces();
                this.updatePositions();
                this.updateConnections();
                
                // Cool down the system
                if (this.temperature > this.minTemperature) {
                    this.temperature *= this.coolingRate;
                }
            }

            start() {
                this.running = true;
                this.temperature = 1.0; // Reset temperature when starting
                this.simulate();
            }

            stop() {
                this.running = false;
            }

            reset() {
                this.temperature = 1.0;
                Object.keys(this.nodes).forEach(id => {
                    this.forces[id] = { x: 0, y: 0 };
                    this.velocities[id] = { x: 0, y: 0 };
                });
            }

            simulate() {
                if (!this.running) return;
                
                this.step();
                requestAnimationFrame(() => this.simulate());
            }
        }

        function createNodesFromTree(treeData, positions) {
            const nodes = {};
            
            function createNode(nodeData) {
                const position = positions[nodeData.id];
                const node = new SimulatedNode(nodeData.id, position);
                nodes[nodeData.id] = node;
                
                if (nodeData.children) {
                    nodeData.children.forEach(child => createNode(child));
                }
            }
            
            createNode(treeData);
            return nodes;
        }

        function connectNodes(treeData, nodes) {
            const allConnections = [];
            
            function connect(nodeData) {
                const parentNode = nodes[nodeData.id];
                if (nodeData.children) {
                    nodeData.children.forEach(childData => {
                        const childNode = nodes[childData.id];
                        const connection = parentNode.addChild(childNode);
                        allConnections.push(connection);
                        connect(childData);
                    });
                }
            }
            connect(treeData);
            return allConnections;
        }

        const positions = calculateRadialPositions(treeStructure);
        const nodes = createNodesFromTree(treeStructure, positions);
        const connections = connectNodes(treeStructure, nodes);
        
        // Initialize force-directed layout
        const forceLayout = new ForceDirectedLayout(nodes, connections);
        forceLayout.start();

        camera.position.set(20, 15, 180);
        camera.lookAt(0, 0, 0);

        const allNodes = Object.values(nodes);

        function triggerChange(node) {
            node.setProperty('value', Math.random());
            setTimeout(() => {
                node.triggerChangeEvent();
            }, 200);
        }
        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
        animate();
        setInterval(() => {
            if (Math.random() < 0.1) {
              triggerChange(allNodes[0]);
            } else if (Math.random() < 0.25) {
              triggerChange(allNodes[Math.floor(Math.random() * allNodes.length / 2)]);
            } else {
              triggerChange(allNodes[Math.floor(Math.random() * allNodes.length)]);
            }
        }, 2000);
    </script>
</body>
</html>